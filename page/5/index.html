<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数论相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<p>本文除特殊说明,所涉及数均为整数.</p>
<h3><span id="整除性及相关">整除性及相关</span></h3>
<p>如果<span class="math inline">\(m &gt; 0\)</span>且<span class="math inline">\(\cfrac{ n }{ m }\)</span>是一个整数,我们就说<span class="math inline">\(m\)</span>整除<span class="math inline">\(n\)</span>,记作<span class="math inline">\(m |
n\)</span>.</p>
<p>能同时整除两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的数称为<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子,所有公因子中最大的那个称为最大公因子,记作<span class="math inline">\(\gcd ( n , m )\)</span>.而最小的能同时被<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>整除的非零数被称为他们的最小公倍数,记作<span class="math inline">\(lcm ( n , m )\)</span>.不难发现<span class="math inline">\(lcm ( n , m ) \gcd ( n , m ) = nm\)</span>.</p>
<h4><span id="欧几里得算法">欧几里得算法</span></h4>
<p>欧几里得算法基于以下定理:</p>
<p><span class="math inline">\(\gcd ( 0 , n ) = n\)</span>且<span class="math inline">\(\gcd ( n , m ) = \gcd ( n \mod m , m ) , m &gt;
0\)</span>.</p>
<p>考虑证明,首先,<span class="math inline">\(\forall k \in \mathbb{ Z
}\)</span>,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(n\)</span>和<span class="math inline">\(m +
kn\)</span>的公因子,这是显然的.因此,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(m\)</span>和<span class="math inline">\(n - m
\lfloor \cfrac{ n }{ m } \rfloor\)</span>的公因子,而反之亦然.</p>
<p>另外有如下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\gcd ( kn , km ) = k \gcd ( n , m
)\)</span>以及<span class="math inline">\(lcm ( kn , km ) = k \ lcm ( n
, m )\)</span>.</p></li>
<li><p>若<span class="math inline">\(a \bot b\)</span>,则<span class="math inline">\(\gcd ( a^m - b^m , a^n - b^n ) = a^{ \gcd ( n , m
) } - b^{ \gcd ( n , m ) }\)</span>.</p></li>
<li><p>如果<span class="math inline">\(n^a \equiv 1 \pmod{ m } \land n^b
\equiv 1 \pmod{ m }\)</span>,则<span class="math inline">\(n^{ \gcd ( a
, b ) } \equiv 1 \pmod{ m }\)</span>.</p></li>
</ol>
<p>(1)的证明较为显然,我们考虑(2)的证明.</p>
<p>不妨假设<span class="math inline">\(n \leq m\)</span>,当<span class="math inline">\(n = m\)</span>时显然成立.</p>
<p>当<span class="math inline">\(n &lt; m\)</span>时:</p>
<p>假设<span class="math inline">\(a &gt; b\)</span>,考虑<span class="math inline">\(\gcd ( a^m - b^m , a^n - b^n ) = \gcd ( a^m - b^m
- k ( a^n - b^n ) , a^n - b^n )\)</span>.</p>
<p>取<span class="math inline">\(k = b^{ m - n }\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
\gcd ( a^m - b^m , a^n - b^n ) &amp; = \gcd ( a^m - b^{ m - n } a^n ,
a^n - b^n ) \\
&amp; = \gcd ( a^n ( a^{ m - n } - b^{ m - n } ) , a^n - b^n )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(a \bot b\)</span>,所以显然<span class="math inline">\(a^n - b^n \bot a^n\)</span>,于是:</p>
<p><span class="math display">\[
\gcd ( a^m - b^m , a^n - b^n ) = \gcd ( a^{ m - n } - b^{ m - n } , a^n
- b^n )
\]</span></p>
<p>自然得证.</p>
<p>接下来考虑(3)的证明:</p>
<p>如果<span class="math inline">\(a =
b\)</span>,显然得证.不然,不妨设<span class="math inline">\(a &gt;
b\)</span>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n^a &amp; \equiv 1 \pmod{ m } \\
n^a - n^{ a - b } n^b &amp; \equiv 1 - n^{ a - b } \pmod{ m } \\
n^{ a - b } &amp; \equiv 1 \pmod{ m }
\end{aligned}
\]</span></p>
<p>自然得证.</p>
<h4><span id="一些性质">一些性质</span></h4>
<p>令<span class="math inline">\(n , m \in \mathbb{ N_+ }\)</span>.</p>
<ol type="1">
<li><p><span class="math inline">\(k | n \land k | m \Leftrightarrow k |
\gcd ( n , m )\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ m | n } a_m = \sum_{ m | n }
a_{ \frac{ n }{ m } }\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ m | n } \sum_{ k | m } a_{ k ,
m } = \sum_{ k | n } \sum_{ l | ( \frac{ n }{ k } ) } a_{ k , kl
}\)</span>.</p></li>
</ol>
<p>另外,<span class="math inline">\(\gcd\)</span>有一个很著名的性质:对于数字<span class="math inline">\(n , m\)</span>,找到最小的正整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(\exists
y \in \mathbb{ N }\)</span>,<span class="math inline">\(xn =
ym\)</span>.</p>
<p>首先令<span class="math inline">\(g = \gcd ( n , m
)\)</span>,我们自然有<span class="math inline">\(x \frac{ n }{ g } = y
\frac{ m }{ g }\)</span>,也就相当于<span class="math inline">\(x \frac{
n }{ g } \equiv 0 \pmod{ \frac{ m }{ g } }\)</span>,由于<span class="math inline">\(\gcd ( \frac{ n }{ g } , \frac{ m }{ g } ) =
1\)</span>,所以左边的<span class="math inline">\(\frac{ n }{ g
}\)</span>可以用逆元消掉,显然最小正整数解为<span class="math inline">\(x
= \frac{ m }{ g }\)</span>.</p>
<h5><span id="example1cf1656hequal-lcmsubsets">Example1([CF1656H]Equal LCM
Subsets)</span></h5>
<p>注意到插入可能有点小困难,我们考虑从全集中删除:注意到如果对于一个数字的某一个质因子,如果它的指数大于了对方集合中相同质因子的最大指数,那这个数一定不可能存在,直接删掉.不难发现删完后就是合法的了.</p>
<p>首先,数据范围不允许我们判断质因子,那么怎么做呢?</p>
<p>显然合法的条件等价于<span class="math inline">\(a_i | lcm ( b ) ,
\forall 1 \leq i \leq
n\)</span>(当然这个还要反过来再写一遍,两个式子一起才是充要条件,这里为了方便只写一个),这个条件等价于<span class="math inline">\(\gcd_{ j = 1 }^n ( \frac{ a_i }{ \gcd ( b_j , a_i
) } ) = 1\)</span>.后者是方便做的.</p>
<p>然后上线段树处理一下,好像先random_shuffle一下再暴力删除也是对的.</p>
<h4><span id="基于值域预处理的快速-gcd">基于值域预处理的快速 GCD</span></h4>
<p>存在一种<span class="math inline">\(O ( n )\)</span>预处理,<span class="math inline">\(O ( 1 )\)</span>求任意两个小于等于<span class="math inline">\(n\)</span>的数的<span class="math inline">\(\gcd\)</span>的方法:</p>
<p>引理:</p>
<p>对于任意整数<span class="math inline">\(n\)</span>,存在一种划分方式<span class="math inline">\(n = abc\)</span>,<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>,<span class="math inline">\(c\)</span>三个数要么是质数,要么<span class="math inline">\(\leq \sqrt{ n }\)</span>.</p>
<p>证明:</p>
<p>如果<span class="math inline">\(n\)</span>存在一个大于等于<span class="math inline">\(\sqrt{ n }\)</span>的质因子,显然成立.</p>
<p>否则,使用数学归纳,我们考虑<span class="math inline">\(n\)</span>的最小质因子为<span class="math inline">\(p\)</span>,设<span class="math inline">\(\frac{ n
}{ p } = xyz\)</span>,不妨设<span class="math inline">\(x \leq y \leq
z\)</span>.</p>
<p>如果<span class="math inline">\(x = 1\)</span>,显然成立.</p>
<p>不然有<span class="math inline">\(p \leq x \leq y \leq
z\)</span>,而<span class="math inline">\(pxyz = n\)</span>,那么<span class="math inline">\(p^4 \leq n\)</span>,<span class="math inline">\(p
\leq n^{ \frac{ 1 }{ 4 } }\)</span>.</p>
<p>现在我们想要证明不存在<span class="math inline">\(xp &gt; \sqrt{ n
}\)</span>,<span class="math inline">\(yp &gt; \sqrt{ n }\)</span>,<span class="math inline">\(zp &gt; \sqrt{ n }\)</span>.</p>
<p>如果存在,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
xyzp^3 &amp; &gt; n^{ \frac{ 3 }{ 2 } } \\
np^2 &amp; &gt; n^{ \frac{ 3 }{ 2 } } \\
p^2 &amp; &gt; \sqrt{ n } \\
p &amp; &gt; n^{ \frac{ 1 }{ 4 } }
\end{aligned}
\]</span></p>
<p>与我们前面的结论不符合.</p>
<p>因而该引理成立,并且给出了<span class="math inline">\(O ( n
)\)</span>预处理所有数<span class="math inline">\(abc\)</span>的方法.</p>
<p>接下来，设<span class="math inline">\(m = \sqrt{ n
}\)</span>,考虑使用<span class="math inline">\(O ( n
)\)</span>的时间求出每个小于等于<span class="math inline">\(m\)</span>的数对的<span class="math inline">\(\gcd\)</span>,如果我们要求<span class="math inline">\(\gcd ( x , y )\)</span>,设<span class="math inline">\(x = abc\)</span>,显然<span class="math inline">\(\gcd ( x , y ) = \gcd ( a , y ) \times \gcd ( b ,
\frac{ y }{ \gcd ( a , y ) } ) \times \gcd ( c , \frac{ y }{ \gcd ( ab ,
y ) } )\)</span>.</p>
<p>如果<span class="math inline">\(a\)</span>是质数，只需要判断<span class="math inline">\(a\)</span>是否整除<span class="math inline">\(y\)</span>.</p>
<p>否则<span class="math inline">\(\gcd ( a , y ) = \gcd ( y \mod a , a
)\)</span>,因为<span class="math inline">\(a \leq \sqrt{ n
}\)</span>,因而可以直接查表.</p>
<h4><span id="裴蜀定理">裴蜀定理</span></h4>
<p><span class="math inline">\(\forall a , b , m \in \mathbb{ Z
}\)</span>,则<span class="math inline">\(\exists x , y \in \mathbb{ Z
}\)</span>满足<span class="math inline">\(ax + by =
m\)</span>,当且仅当<span class="math inline">\(\gcd ( a , b ) |
m\)</span>.</p>
<p>证明如下:</p>
<p>若<span class="math inline">\(a = 0\)</span>或<span class="math inline">\(b = 0\)</span>,显然成立.</p>
<p>不然,设集合<span class="math inline">\(A = \{ xa + yb | x , y \in
\mathbb{ Z } \}\)</span>中的最小正元素<span class="math inline">\(d_0 =
x_0 a + y_0 b\)</span>,该集合中显然一定有正元素.</p>
<p>考虑取该集合中另一个正整数<span class="math inline">\(d_1 = x_1 a +
y_1 b &gt; d_0\)</span>,注意到<span class="math inline">\(d_1 - d_0 = (
x_1 - x_0 ) a + ( y_1 - y_0 ) b \in A\)</span>,所以<span class="math inline">\(\gcd ( d_1 , d_0 ) \in A\)</span>,如果<span class="math inline">\(d_0 \nmid d_1\)</span>,那么<span class="math inline">\(0 &lt; \gcd ( d_1 , d_0 ) &lt;
d_0\)</span>,与假设不符.所以这个集合里的所有数一定都是<span class="math inline">\(d_0\)</span>的倍数.</p>
<p>事实上还有另一种证明方式:</p>
<p>如果我们定义一个非空集合<span class="math inline">\(I \subseteq
\mathbb{ Z }\)</span>,满足其对加法和数乘(<span class="math inline">\(\forall a \in \mathbb{ Z } , x \in I , ax \in
I\)</span>)均封闭,那么我们可以证明其中存在一个唯一的数字<span class="math inline">\(g\)</span>满足所有数都是<span class="math inline">\(g\)</span>的倍数.</p>
<p>如果<span class="math inline">\(I = \{ 0 \}\)</span>,可以取<span class="math inline">\(g = 0\)</span>.</p>
<p>反之,显然其中有正有负(因为可以取<span class="math inline">\(a = -
1\)</span>),我们设<span class="math inline">\(I_+ = \{ k \in I | k \geq
1 \}\)</span>取<span class="math inline">\(g = \min I_+\)</span>.<span class="math inline">\(\forall a \in I\)</span>,不妨设<span class="math inline">\(a = gq + r , r \in [ 0 , g )\)</span>,那么<span class="math inline">\(r = a + ( - q ) g \in I\)</span>,由于<span class="math inline">\(r &lt; g\)</span>,所以<span class="math inline">\(r \notin I_+\)</span>,所以<span class="math inline">\(r = 0\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(g\)</span>的倍数,且显然<span class="math inline">\(g\)</span>唯一.</p>
<h4><span id="扩展欧几里得算法">扩展欧几里得算法</span></h4>
<p>考虑求方程<span class="math inline">\(ax + by = \gcd ( a , b
)\)</span>的一组解.</p>
<p>首先,如果<span class="math inline">\(b =
0\)</span>,那这组解显然就是<span class="math inline">\(\begin{cases}x =
1 \\ y = 0\end{cases}\)</span>.</p>
<p>反之,我们令<span class="math inline">\(c = a \mod
b\)</span>,考虑求方程<span class="math inline">\(cz + bw = \gcd ( c , b
)\)</span>的一组解.</p>
<p>接下来呢,考虑带入<span class="math inline">\(c\)</span>,则我们求出来的即方程<span class="math inline">\(( a - b \lfloor \cfrac{ a }{ b } \rfloor ) z + bw
= \gcd ( a , b )\)</span>的一组解.不难发现这也就是方程<span class="math inline">\(az + ( w - \lfloor \cfrac{ a }{ b } \rfloor z ) b
= \gcd ( a , b )\)</span>的一组解,所以原本的方程的解也就是<span class="math inline">\(\begin{cases}x = z \\ y = ( w - \lfloor \cfrac{ a
}{ b } \rfloor z )\end{cases}\)</span>.</p>
<p>另外,这个算法也可以使用矩阵形式:</p>
<p>首先有</p>
<p>a\</p>
<p>b</p>
<p>\end{matrix}]</p>
<p>=<span class="math inline">\(, 令\)</span>q=a b<span class="math inline">\(, 那 么 我 们 有\)</span></p>
<p>=</p>
<p>同样我们可以得到:</p>
<p>x_1&amp;y_1\</p>
<p>x_2&amp;y_2</p>
<p>\end{matrix}]</p>
<p>=</p>
<p><span class="math inline">\(, 即\)</span>ax_1+by_1=(a,b)<span class="math inline">\(,\)</span>(x_1,y_1)</p>
<h5><span id="example1xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</span></h5>
<p>题意:<span class="math inline">\(h \times w ( h , w \leq 10^6
)\)</span>的格子图,只能往下往右走,走到边界会循环,问从<span class="math inline">\(( 0 , 0
)\)</span>开始走遍历走一个哈密顿回路的方案数.</p>
<p>这题最重要的地方其实在于观察到,由于每个点只会被走到一次(除了<span class="math inline">\(( 0 , 0
)\)</span>,它会被走到两次,但只会由其它格子走来一次),因此如果抽象成图,每个格子只会有一个出边和一个入边.这意味着每个格子上面的和左边的格子必定只有一个指向它,进一步地,这意味着这两个格子的状态必然相同.</p>
<p>由此我们发现,每条副对角线(取膜意义下)的状态必然相同,而取膜意义下的副对角线有多少条呢?不难注意到是<span class="math inline">\(d = \frac{ hw }{ \text{ lcm } ( h , w ) } = \gcd (
h , w )\)</span>条.也就是说,我们只需要确定这<span class="math inline">\(d\)</span>条对角线的值,就可以确定整个矩阵的答案.假设<span class="math inline">\(R\)</span>表示向右走,<span class="math inline">\(D\)</span>表示向下走,<span class="math inline">\(a_i\)</span>表示第<span class="math inline">\(i\)</span>条副对角线的状态,最后的操作序列自然是<span class="math inline">\(a_0 a_1 . . . a_{ d - 1 } a_0 a_1 . .
.\)</span>.</p>
<p>那么我们接下来要做的就是给这<span class="math inline">\(d\)</span>条副对角线定向,并判断一个方案是否合法.注意到一个方案不合法当且仅当出现了多于<span class="math inline">\(1\)</span>个环.那这又意味着什么呢?意味着存在一个点,它可以通过少于<span class="math inline">\(hw\)</span>次走动走回自己.这显然是不被我们允许的.另一件不难发现的事是,第一个走回自己的点一定是<span class="math inline">\(( 0 , 0
)\)</span>.再不难发现的是,走回自己的时候一定是经过了若干个周期:<span class="math inline">\(a_0 a_1 . . . a_{ d - 1 } a_0 . . . a_{ d - 1
}\)</span>,因为每次向下或者向右走都会走到下一条副对角线,而且最后要回到自己.这就注意到每一个循环<span class="math inline">\(a_0 a_1 . . . a_{ d - 1
}\)</span>内部具体什么情况是不在乎的,只在乎经历过这个过程之后会发生什么样的变化.</p>
<p>我们不妨假设序列<span class="math inline">\(\{ a \}\)</span>中有<span class="math inline">\(k\)</span>个<span class="math inline">\(R\)</span>,<span class="math inline">\(d -
k\)</span>个<span class="math inline">\(D\)</span>,那会产生这种情况当且仅当<span class="math inline">\(\exists x \in \mathbb{ N_+ } , x &lt; \frac{ hw }{
d }\)</span>,<span class="math inline">\(\begin{cases}h | x ( d - k ) \\
w | xk\end{cases}\)</span>.注意到这等价于寻找最小的<span class="math inline">\(x\)</span>,判断其是否小于<span class="math inline">\(\frac{ hw }{ d
}\)</span>,于是条件等价于自然有<span class="math inline">\(x = lcm (
\frac{ h }{ \gcd ( d - k , h ) } , \frac{ w }{ \gcd ( w , k ) }
)\)</span>,枚举<span class="math inline">\(k\)</span>并判断即可.</p>
<h3><span id="素数及相关">素数及相关</span></h3>
<h4><span id="定义">定义</span></h4>
<p>可以利用裴蜀定理证明素数的定义等价于<span class="math inline">\(\forall a , b , p | ab \Rightarrow p | a \lor p |
b\)</span>.</p>
<p>考虑先用最基础的定义得到这个命题,考虑<span class="math inline">\(p |
ab , p \nmid a\)</span>,则<span class="math inline">\(1 = px +
ay\)</span>有解,则<span class="math inline">\(b = pxb + ( ab )
y\)</span>,右边都是<span class="math inline">\(p\)</span>的倍数,所以<span class="math inline">\(p
| b\)</span>.</p>
<p>这个命题反推的话,考虑设<span class="math inline">\(p = ab , a , b \ne
1\)</span>,则<span class="math inline">\(p | ab\)</span>且<span class="math inline">\(p \nmid a , p \nmid b\)</span>,不符.</p>
<h5><span id="example1具体数学422">Example1(《具体数学》4.22)</span></h5>
<p>证明:在<span class="math inline">\(n\)</span>进制下,若<span class="math inline">\(( 11 . . . 1 )_n\)</span>的<span class="math inline">\(1\)</span>的个数不是质数则其一定不是质数..</p>
<p>设<span class="math inline">\(1\)</span>的个数为<span class="math inline">\(m\)</span>,则<span class="math inline">\(( 11 . .
. 1 )_n = \sum_{ i = 0 }^{ m - 1 } n^i\)</span>.</p>
<p>如果<span class="math inline">\(m \notin \mathrm{ prime
}\)</span>,不妨设则<span class="math inline">\(m = cd , c \ne 1 \land d
\ne 1\)</span>.</p>
<p>则</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ m - 1 } n^i &amp; = \sum_{ i = 0 }^{ c - 1 } n^{ di }
\sum_{ j = 0 }^{ d - 1 } n^{ j } \\
&amp; = ( \sum_{ i = 0 }^{ c - 1 } n^{ di } ) ( \sum_{ j = 0 }^{ d - 1 }
n^j )
\end{aligned}
\]</span></p>
<p>显然不是质数.</p>
<h4><span id="唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</span></h4>
<p>任何正整数都只有一种方式以素数非减的次序写成素数的乘积.</p>
<p>证明:</p>
<p>考虑数学归纳法,设小于<span class="math inline">\(n\)</span>的数全部满足.</p>
<p>则对于<span class="math inline">\(n\)</span>,如果它不满足条件,一定存在两种分解方式<span class="math inline">\(n = \prod_{ i = 1 }^m p_i = \prod_{ i = 1 }^k
q_i\)</span>.</p>
<p>首先,如果<span class="math inline">\(p_1 =
q_1\)</span>,根据归纳假设,显然不成立.</p>
<p>不失一般性,设<span class="math inline">\(p_1 &lt;
q_1\)</span>.则<span class="math inline">\(q_1 | p_1 \prod_{ i = 2 }^m
p_i\)</span>,显然<span class="math inline">\(q_1 \nmid
p_1\)</span>,所以<span class="math inline">\(q_1 | \prod_{ i = 2 }^m
p_i\)</span>,设<span class="math inline">\(s = \prod_{ i = 2 }^m
p_i\)</span>,但这是不可能的,因为<span class="math inline">\(s &lt;
n\)</span>,根据归纳假设,它只有一种分解方式,这种方式中显然不可能存在<span class="math inline">\(p_1\)</span>.</p>
<p>那么根据上述证明,我们可以将一个数表示为以下形式:<span class="math inline">\(n = \prod_p p^{ n_p } , n_p \geq 0\)</span>.</p>
<p>另外不难证明的一点是,假设<span class="math inline">\(\sum n_p =
k\)</span>,那么最小质因子一定不大于<span class="math inline">\(\sqrt[k]{
n }\)</span>.</p>
<h5><span id="example1cf986foppafuncan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</span></h5>
<p>首先对<span class="math inline">\(k\)</span>做pollard-Rho算法.注意到我们可以默认<span class="math inline">\(q_i\)</span>是质因子,这显然不会影响答案.</p>
<p>然后,如果只有一个质因子,显然直接判断.</p>
<p>如果有两个质因子,是经典的二元不定方程.</p>
<p>如果有三个质因子,此时最小质因子的大小就不大于<span class="math inline">\(\sqrt[3]{ k }\)</span>,做同余最短路即可.</p>
<h4><span id="素数的个数">素数的个数</span></h4>
<p>首先,欧几里得证明了素数有无穷多个:</p>
<p>假设素数有有限个,分别为<span class="math inline">\(p_1 , p_2 , . . .
p_m\)</span>,则<span class="math inline">\(\prod_{ i = 1 }^m p_i +
1\)</span>无法被其中任何素数整除,则假设不成立.</p>
<p>在此基础上,我们可以定义欧几里得数:</p>
<p><span class="math inline">\(e_1 = 2 , e_n = 1 + \prod_{ i = 1 }^{ n -
1 } e_i\)</span>.</p>
<p>令<span class="math inline">\(\pi ( n )\)</span>表示小于等于<span class="math inline">\(n\)</span>的素数个数,有<span class="math inline">\({ \lim_{ n \rightarrow + \infty } \cfrac{ \pi ( n
) \times \ln n }{ n } } = 1\)</span>.</p>
<p>有切比雪夫定理(又称贝特朗假设):若<span class="math inline">\(n &gt; 1
, \exists p \in \mathrm{ prime } , p \in ( n , 2 n )\)</span>.</p>
<p>又有狄利克雷定理:若<span class="math inline">\(\gcd ( a , b ) = 1 ,
\{ an + b \}\)</span>中包含了无穷个素数.</p>
<p>(顺便一提,当<span class="math inline">\(a = 4\)</span>或者<span class="math inline">\(a = 6\)</span>,<span class="math inline">\(b = -
1\)</span>的时候是好证明的,由于素数要么形如<span class="math inline">\(6
n - 1\)</span>要么形如<span class="math inline">\(6 n +
1\)</span>,或者要么形如<span class="math inline">\(4 n -
1\)</span>要么形如<span class="math inline">\(4 n +
1\)</span>,只需要类似证明素数无限那样乘一乘)</p>
<p>同时,我们还有以下结论:<span class="math inline">\(\sum_{ 1 \leq p
\leq n \land p \in \mathrm{ prime } } \cfrac{ 1 }{ p } \approx \log \log
n\)</span>.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq p \leq n \land p \in \mathrm{ prime } } \cfrac{ 1 }{ p }
&amp; = \sum^n_{ k = 1 } \cfrac{ \pi ( k ) - \pi ( k - 1 ) }{ k } =
\sum^n_{ k = 1 } \cfrac{ \pi ( k ) }{ k } - \sum^n_{ k = 1 } \cfrac{ \pi
( k - 1 ) }{ k } \\
&amp; = \sum^n_{ k = 1 } \cfrac{ \pi ( k ) }{ k } - \sum^{ n - 1 }_{ k =
0 } \cfrac{ \pi ( k ) }{ k + 1 } \\
&amp; = \sum^{ n - 1 }_{ k = 1 } \cfrac{ \pi ( k ) }{ k } + \cfrac{ \pi
( n ) }{ n } - \sum^{ n - 1 }_{ k = 1 } \cfrac{ \pi ( k ) }{ k + 1 } -
\cfrac{ \pi ( 0 ) }{ 1 } \\
&amp; = \sum^{ n - 1 }_{ k = 1 } \cfrac{ \pi ( k ) }{ k ( k + 1 ) } +
\cfrac{ \pi ( n ) }{ n } \\
&amp; = \sum^{ n - 1 }_{ k = 1 }{ ( \cfrac{ 1 }{ k \log k } ) } + O (
\frac{ 1 }{ \log n } ) = O ( \log \log n ) + O ( \frac{ 1 }{ \log n } )
\end{aligned}
\]</span></p>
<h5><span id="example1具体数学420">Example1(《具体数学》4.20)</span></h5>
<p>证明:存在一个常数<span class="math inline">\(b\)</span>满足<span class="math inline">\(\lfloor 2^b \rfloor , \lfloor 2^{ 2^b } \rfloor ,
\lfloor 2^{ 2^{ 2^b } } \rfloor . , . .\)</span>都是质数.</p>
<p>如此构造数列:设<span class="math inline">\(p_1 = 2\)</span>,且<span class="math inline">\(p_n\)</span>为满足<span class="math inline">\(2^{
p_{ n - 1 } } &lt; p_n &lt; 2^{ p_{ n - 1 } + 1
}\)</span>的最小质数.</p>
<p>通过构造不难发现:<span class="math inline">\(p_{ n - 1 } = \lfloor
\log_2 p_n \rfloor\)</span>.</p>
<p>根据整值函数的性质,我们有<span class="math inline">\(\lfloor \log_2 x
\rfloor = \lfloor \log_2 \lfloor x \rfloor
\rfloor\)</span>.考虑反向数学归纳,考虑当<span class="math inline">\(n
\rightarrow + \infty\)</span>时构造满足题目条件,那么<span class="math inline">\(p^{ n - 1 } = \lfloor \log_2 \lfloor 2^{ 2^{ 2^{ .
. .^{ b } } } } \rfloor \rfloor = \lfloor 2^{ 2^{ . . .^{ b } } }
\rfloor\)</span>,自然也满足条件.所以如果设<span class="math inline">\(\log_2^{ ( n ) } x\)</span>为不断对<span class="math inline">\(x\)</span>迭代求<span class="math inline">\(\log_2\)</span>做<span class="math inline">\(n\)</span>次后的答案,只需构造<span class="math inline">\(b = \lim_{ n \rightarrow + \infty } \log_2^{ ( n )
} p_n\)</span>即可.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:</p>
<p><span class="math display">\[
\mu ( \gcd ( a , b ) ) = 0 \Leftrightarrow \forall n &gt; 0 , \mu ( an +
b ) = 0
\]</span></p>
<p>左推右是简单的.接下来考虑右推左.</p>
<p>考虑狄利克雷定理,数列<span class="math inline">\(\{ \frac{ an + b }{
\gcd ( a , b ) } \}\)</span>.不妨反证,假设<span class="math inline">\(\mu ( \gcd ( a , b ) ) \ne 0\)</span>,不妨设<span class="math inline">\(p = \frac{ an + b }{ \gcd ( a , b )
}\)</span>,<span class="math inline">\(p \gcd ( a , b ) = ax +
b\)</span>,也就是<span class="math inline">\(\mu ( p \gcd ( a , b ) ) =
0\)</span>,注意到<span class="math inline">\(\mu ( \gcd ( a , b ) ) \ne
0\)</span>,此时必有<span class="math inline">\(p | \gcd ( a , b
)\)</span>,而<span class="math inline">\(p\)</span>无限,<span class="math inline">\(\gcd ( a , b
)\)</span>的素因子有限,这就导出了矛盾.</p>
<h4><span id="欧几里得数">欧几里得数</span></h4>
<p>定义欧几里得数:<span class="math inline">\(e_1 = 2 , e_n = 1 +
\prod_{ i = 1 }^{ n - 1 } e_i\)</span>.不难发现<span class="math inline">\(e_n = e_{ n - 1 } ( e_{ n - 1 } - 1
)\)</span>.</p>
<h4><span id="费马数">费马数</span></h4>
<p>定义费马数<span class="math inline">\(f_n = 2^{ 2^n } +
1\)</span>.不难发现<span class="math inline">\(f_n = ( f_{ n - 1 } - 1
)^2 + 1\)</span>.</p>
<p>另外,费马数还满足<span class="math inline">\(f_n = \prod_{ i = 0 }^{
n - 1 } f_i +
2\)</span>,我们考虑这个式子的证明:显然后面那一个连乘会得到若干项<span class="math inline">\(2\)</span>的次幂,并且这些项两两不同,根据几何级数,我们有<span class="math inline">\(\prod_{ i = 0 }^{ n - 1 } f_i + 1\)</span>=<span class="math inline">\(2^{ 2^{ n } }\)</span>,于是显然得证.</p>
<h5><span id="example1具体数学417">Example1(《具体数学》4.17)</span></h5>
<p>求证:如果<span class="math inline">\(m \ne n\)</span>,则<span class="math inline">\(f_m \bot f_n\)</span>.</p>
<p>不妨假设<span class="math inline">\(m &lt; n\)</span>,有:<span class="math inline">\(\gcd ( f_m , f_n ) = \gcd ( f_m , 2 ) =
1\)</span>.</p>
<h5><span id="example2具体数学418">Example2(《具体数学》4.18)</span></h5>
<p>求证:若<span class="math inline">\(2^n + 1\)</span>是质数,则<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的整数幂.</p>
<p>如果<span class="math inline">\(n = qm\)</span>且<span class="math inline">\(q\)</span>是奇数,我们有:<span class="math inline">\(2^n + 1 = ( 2^m + 1 ) ( 2^{ n - m } - 2^{ n - 2 m
} + 2^{ n - 3 m } . . . - 2^m + 1 )\)</span>.</p>
<h4><span id="miller-rabin算法">Miller-Rabin算法</span></h4>
<p>如果判断<span class="math inline">\(n\)</span>是否是质数,取<span class="math inline">\(a &lt; n\)</span>,设<span class="math inline">\(n
- 1 = d \times 2^r\)</span>.</p>
<p>则要么<span class="math inline">\(a^d \equiv 1 ( \mod n
)\)</span>.</p>
<p>要么<span class="math inline">\(\exists i\)</span>,使得<span class="math inline">\(0 \leq i &lt; r\)</span>,<span class="math inline">\(a^{ d \times 2^i } \equiv - 1 ( \mod n
)\)</span>.</p>
<p>若一个都不满足,则n一定不是质数,不然可能是质数.</p>
<p>但是若取足够多的不同的<span class="math inline">\(a\)</span>(如果选<span class="math inline">\(m\)</span>个),那么<span class="math inline">\(n\)</span>是质数的可能性更大.</p>
<p>此为Miller-Rabin算法,复杂度<span class="math inline">\(O ( m \times
log_2 n )\)</span>.不保证正确性.</p>
<p>其中a通常取质数,原因不详.（事实上，如果a取前八个小质数，在<span class="math inline">\(2^{ 64 }\)</span>内是不会出错的）</p>
<h4><span id="pollard-rho算法">Pollard-Rho算法</span></h4>
<p>对<span class="math inline">\(n\)</span>做质因数分解,若能找到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a |
n\)</span>,则考虑对<span class="math inline">\(\cfrac{ n }{ a
}\)</span>和<span class="math inline">\(a\)</span>分别进行质因数分解.</p>
<p>考虑随机<span class="math inline">\(a\)</span>,若<span class="math inline">\(n\)</span>有<span class="math inline">\(m\)</span>个因数,那么显然随机到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a |
n\)</span>的概率为<span class="math inline">\(\cfrac{ m }{ n
}\)</span>,显然不太优秀.</p>
<p>考虑改变随机策略,我们考虑随机一个<span class="math inline">\(a\)</span>使得<span class="math inline">\(\gcd ( a
, n ) \ne 1\)</span>,那么<span class="math inline">\(\gcd ( a , n
)\)</span>就是<span class="math inline">\(n\)</span>的一个因子.</p>
<p>这种情况下,随机的概率是<span class="math inline">\(\cfrac{ \varphi (
n ) }{ n }\)</span>,仍然很不优秀.</p>
<p>考虑使用生日悖论优化,随机<span class="math inline">\(k\)</span>个数<span class="math inline">\(a\)</span>.两两匹配得到<span class="math inline">\(k^2\)</span>个值,这些值全都不整除<span class="math inline">\(n\)</span>的概率可以用生日悖论来计算.</p>
<p>当<span class="math inline">\(k = 10 \sqrt{ n
}\)</span>时,错误的概率会很小,但是复杂度仍然很高,无法接受.</p>
<p>考虑构造<span class="math inline">\(a_i = [ ( a_{ i - 1 } )^2 + b ]
\mod n\)</span>.</p>
<p>考虑该数列的性质,当<span class="math inline">\(b\)</span>确定时,<span class="math inline">\(a\)</span>一定有循环节.</p>
<p>显然当<span class="math inline">\(x | ( a_i - a_j )\)</span>,则<span class="math inline">\(x | [ ( a_i - a_j ) \times ( a_i + a_j ) - b + b
]\)</span>,<span class="math inline">\(x | ( a_{ i + 1 } - a_{ j + 1 }
)\)</span>.</p>
<p>因此,我们可以利用floyd判环法(双指针法)找出循环节.</p>
<p>并且在这个过程中,我们可以预处理出大量的<span class="math inline">\(a_{ i + len } - a_i\)</span>.</p>
<p>复杂度极其玄学,但是实际应用中不差.</p>
<h4><span id="狄利克雷前缀和">狄利克雷前缀和</span></h4>
<p>已知数列<span class="math inline">\(a\)</span>,求数列<span class="math inline">\(b\)</span>满足<span class="math inline">\(b_n =
\sum_{ d | n } a_d\)</span>.</p>
<p>我们将一个数的质因数分解看作它的向量表示.更直接地,如果<span class="math inline">\(n = \prod_{ i = 1 }^k p_i^{ q_i
}\)</span>,其中<span class="math inline">\(p_i\)</span>是第<span class="math inline">\(i\)</span>大的质数.我们将其写作向量<span class="math inline">\(( q_1 , q_2 , . . . , q_k
)\)</span>的形式,并做高位前缀和.</p>
<p>可以用<span class="math inline">\(O ( n \log \log n
)\)</span>的时间复杂度解决问题.</p>
<h3><span id="阶乘">阶乘</span></h3>
<p>我们定义<span class="math inline">\(n ! = \prod_{ i = 1 }^n
i\)</span>,特别地,<span class="math inline">\(0 ! = 1\)</span>.</p>
<p>考虑估计<span class="math inline">\(n !\)</span>的大小,不难发现<span class="math inline">\(( n ! )^2 = \prod_{ i = 1 }^n i ( n + 1 - i
)\)</span>.</p>
<p>而函数<span class="math inline">\(y = i ( n + 1 - i ) , i \in [ 1 , n
]\)</span>显然在<span class="math inline">\(i = 1\)</span>和<span class="math inline">\(i = n\)</span>时取最小值,而在<span class="math inline">\(i = \cfrac{ n + 1 }{ 2 }\)</span>时取最大值.</p>
<p>那么我们有<span class="math inline">\(\prod_{ i = 1 }^n n \leq ( n !
)^2 \leq \prod_{ i = 1 }^n \cfrac{ ( n + 1 )^2 }{ 4 }\)</span>.</p>
<p>于是<span class="math inline">\(n^{ \frac{ n }{ 2 } } \leq n ! \leq
\cfrac{ ( n + 1 )^n }{ 2^n }\)</span>.</p>
<p>还有一种估计方式是考虑<span class="math inline">\(\lim_{ n
\rightarrow \infty } \frac{ n }{ \sqrt[n]{ n } !
}\)</span>,由Stolz定理及其推论,我们知道若<span class="math inline">\(a_n
&gt; 0 , \frac{ a_{ n + 1 } }{ a_n } = a\)</span>,那么<span class="math inline">\(\lim_{ n \rightarrow \infty } \sqrt[n]{ a_n } =
a\)</span>.而我们令<span class="math inline">\(a_n = \frac{ n^n }{ n !
}\)</span>,<span class="math inline">\(\frac{ a_{ n + 1 } }{ a_n } = ( 1
+ \frac{ 1 }{ n } )^n\)</span>,所以<span class="math inline">\(\lim_{ n
\rightarrow \infty } \frac{ n }{ \sqrt[n]{ n ! } } =
e\)</span>,于是我们可以估计<span class="math inline">\(n ! \sim ( \frac{
n }{ e } )^n\)</span>.</p>
<p>事实上有一种更准确的估计方法:<span class="math inline">\(n ! \sim
\sqrt{ 2 \pi n } ( \cfrac{ n }{ e } )^n\)</span>.</p>
<p>考虑设<span class="math inline">\(\varepsilon_p ( n !
)\)</span>为<span class="math inline">\(n !\)</span>中质因子<span class="math inline">\(p\)</span>的个数,我们分析一下这个函数:</p>
<p>首先显然有:<span class="math inline">\(\varepsilon_p ( n ! ) = \sum_{
k \geq 1 } \lfloor \cfrac{ n }{ p^k } \rfloor \leq \frac{ n }{ p - 1
}\)</span>.</p>
<p>我们考虑以<span class="math inline">\(v_p ( n )\)</span>表示<span class="math inline">\(n\)</span>在<span class="math inline">\(p\)</span>进制下各位数字之和,不妨设第<span class="math inline">\(k\)</span>位数字为<span class="math inline">\(w\)</span>.那么这个数字对于最后的答案的贡献为<span class="math inline">\(w ( p^{ k - 1 } + p^{ k - 2 } + . . . + 1 ) = w
\cfrac{ p^k - 1 }{ p - 1 } = \cfrac{ wp^k - w }{ p - 1
}\)</span>.求和得到<span class="math inline">\(\varepsilon_p ( n ! ) =
\cfrac{ n - v_p ( n ) }{ p - 1 }\)</span>.</p>
<h5><span id="example具体数学455">Example(《具体数学》4.55)</span></h5>
<p>令<span class="math inline">\(P_n = \prod_{ i = 1 }^n i
!\)</span>,求证:<span class="math inline">\(P_n^4 ( n + 1 ) \mid P_{ 2 n
}\)</span>.</p>
<p>考虑对于每个质因子,分开考虑它在前者和后者内出现的次数.</p>
<p>我们不妨将<span class="math inline">\(p\)</span>和<span class="math inline">\(p^k\)</span>分开考虑,于是显然下面的式子是上面的式子成立的充分条件:</p>
<p><span class="math display">\[
\sum_{ m \geq 1 } \sum_{ i = 1 }^{ 2 n } \lfloor \cfrac{ i }{ p^m }
\rfloor \geq 4 \sum_{ m \geq 1 } \sum_{ i = 1 }^n \lfloor \cfrac{ i }{
p^m } \rfloor + [ p^m \mid ( n + 1 ) ]
\]</span></p>
<p>我们不妨对上面这个式子使用数学归纳,也就是说它的充分条件是:</p>
<p><span class="math display">\[
\lfloor \cfrac{ 2 n - 1 }{ p^m } \rfloor + \lfloor \cfrac{ 2 n }{ p^m }
\rfloor \geq 4 \lfloor \cfrac{ n }{ p^m } \rfloor + [ n \equiv - 1
\pmod{ p^m } ] - [ n \equiv 0 \pmod{ p^m } ]
\]</span></p>
<p>这个式子,当<span class="math inline">\(1 \leq n \leq
p^m\)</span>时显然成立.而当<span class="math inline">\(n\)</span>每增大<span class="math inline">\(p^m\)</span>的时候,左右两边同时增大<span class="math inline">\(4\)</span>,于是也是成立的,由此可以数学归纳.</p>
<h3><span id="互素">互素</span></h3>
<p>如果两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>满足<span class="math inline">\(\gcd ( n
, m ) = 1\)</span>,我们称他们互素,记作<span class="math inline">\(n \bot
m\)</span>.</p>
<p>我们显然有这样两条性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\cfrac{ n }{ \gcd ( n , m ) } \bot
\cfrac{ m }{ \gcd ( n , m ) }\)</span>.</p></li>
<li><p><span class="math inline">\(k \bot n \land k \bot m
\Leftrightarrow k \bot nm\)</span>.</p></li>
</ol>
<h5><span id="example1具体数学442">Example1(《具体数学》4.42)</span></h5>
<p>证明:如果两个分数<span class="math inline">\(\cfrac{ m }{ n
}\)</span>和<span class="math inline">\(\cfrac{ m &#39; }{ n &#39;
}\)</span>满足<span class="math inline">\(n \bot m\)</span>且<span class="math inline">\(n &#39; \bot m &#39;\)</span>,则<span class="math inline">\(( mn &#39; + m &#39; n ) \bot ( nn &#39;
)\)</span>的充分必要条件是<span class="math inline">\(n \bot n
&#39;\)</span>.</p>
<p>首先,如果<span class="math inline">\(\gcd ( n , n &#39; ) \ne
1\)</span>,显然不可能满足条件,必要性得证.</p>
<p>考虑充分性,如果<span class="math inline">\(n \bot n
&#39;\)</span>,则只需证明<span class="math inline">\(n \bot ( mn &#39; +
m &#39; n ) \land n &#39; \bot ( mn &#39; + m &#39; n
)\)</span>即可.</p>
<p>而<span class="math inline">\(\gcd ( n , mn &#39; + m &#39; n ) =
\gcd ( n , mn &#39; ) = 1\)</span>,另一个式子同理,于是得证.</p>
<h5><span id="example2">Example2</span></h5>
<p>证明:<span class="math inline">\(\sum_{ 0 \leq k &lt; m } f ( k ) =
\sum_{ d | m } \sum_{ 0 \leq k &lt; d } f ( \frac{ km }{ d } ) [ k \bot
d ] \\\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 0 \leq k &lt; m } f ( k ) &amp; = \sum_{ d | m } \sum_{ 0 \leq k
&lt; m , d | k } f ( k ) [ \gcd ( k , m ) = d ] \\
&amp; = \sum_{ d | m } \sum_{ 0 \leq k &lt; m , d | k } f ( k ) [ \frac{
k }{ d } \bot \frac{ m }{ d } ] \\
&amp; = \sum_{ d | m } \sum_{ 0 \leq k &lt; \frac{ m }{ d } } f ( kd ) [
k \bot \frac{ m }{ d } ] \\
&amp; = \sum_{ d | m } \sum_{ 0 \leq k &lt; d } f ( \frac{ km }{ d } ) [
k \bot d ]
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学463">Example3(《具体数学》4.63)</span></h5>
<p>证明:满足<span class="math inline">\(a^n + b^n = c^n ( n \in \mathbb{
N_+ } , n &gt; 2 )\)</span>的最小的(<span class="math inline">\(n\)</span>为第一关键字,<span class="math inline">\(c\)</span>为第二关键字)一组正整数解(即费马大定理最小的反例)一定满足以下性质:(另外,<span class="math inline">\(n = 4\)</span>的情况早被证明了无解)</p>
<ol type="1">
<li><p><span class="math inline">\(n \in \mathrm{ prime
}\)</span>.</p></li>
<li><p><span class="math inline">\(\exists m \in \mathbb{ N_+ } , a + b
= \begin{cases}m^n &amp; n \nmid c \\ n^{ n - 1 } m^n &amp; n \mid
c\end{cases}\)</span>.</p></li>
</ol>
<p>首先证明(1),如果<span class="math inline">\(n\)</span>是最小的满足条件的数但并不是质数,我们不妨设<span class="math inline">\(n = xy , x &gt; 2\)</span>,则<span class="math inline">\(( a^y )^x + ( b^y )^x = ( c^y
)^x\)</span>,显然这是更小的一组反例,于是(1)得证.</p>
<p>接下来考虑性质(2),注意到<span class="math inline">\(a , b ,
c\)</span>必然两两互质,不然可以两边同时除以一个数构造出更小的解,又注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\gcd ( a + b , \cfrac{ a^n + b^n }{ a + b } ) &amp; = \gcd ( a + b , (
a^{ n - 1 } - a^{ n - 2 } b + . . . + b^{ n - 1 } ) ) \\
\gcd ( a + b , \cfrac{ c^n }{ a + b } ) &amp; = \gcd ( a + b , na^{ n -
1 } ) \\
\gcd ( a + b , \cfrac{ c^n }{ a + b } ) &amp; = \gcd ( a + b , n )
\end{aligned}
\]</span></p>
<p>如果<span class="math inline">\(\gcd ( a + b , n ) =
1\)</span>,那么我们有<span class="math inline">\(( a + b ) \bot \cfrac{
c^n }{ a + b }\)</span>.接下来考虑每一个质因子<span class="math inline">\(p\)</span>,如果<span class="math inline">\(( a + b
)\)</span>中有<span class="math inline">\(x\)</span>个<span class="math inline">\(p\)</span>,<span class="math inline">\(c\)</span>中有<span class="math inline">\(y\)</span>个<span class="math inline">\(p\)</span>,于是<span class="math inline">\(c^n\)</span>中有<span class="math inline">\(ny\)</span>个<span class="math inline">\(p\)</span>,我们自然有:<span class="math inline">\(x = ny\)</span>,于是<span class="math inline">\(\exists m \in \mathbb{ N_+ }\)</span>满足<span class="math inline">\(a + b = m^n\)</span>.</p>
<p>如果<span class="math inline">\(n \mid ( a + b
)\)</span>,我们就有:<span class="math inline">\(\gcd ( a + b , \cfrac{
c^n }{ a + b } ) = n\)</span>,此时必有<span class="math inline">\(n \mid
c\)</span>,<span class="math inline">\(n^n \mid
c^n\)</span>,并且不难发现:<span class="math inline">\(n^k \mid \cfrac{
c^n }{ a + b } \Leftrightarrow n^{ n - k } \mid ( a + b
)\)</span>,由于上面提到的<span class="math inline">\(\gcd\)</span>的原因,<span class="math inline">\(\min \{ k , n - k \} = 1\)</span>,显然<span class="math inline">\(k = 1\)</span>或者<span class="math inline">\(k =
n - 1\)</span>.下面只需要证明<span class="math inline">\(k \ne n -
1\)</span>.</p>
<p>冷静一下,如果<span class="math inline">\(n | ( a + b ) , n^2 \nmid (
a + b )\)</span>,令<span class="math inline">\(m = a +
b\)</span>,此时必有:</p>
<p><span class="math display">\[
\begin{aligned}
c^n &amp; = a^n + ( m - a )^n \\
&amp; = a^n + ( - a )^n + nm ( - a )^{ n - 1 } + \frac{ n ( n - 1 ) }{ 2
} m^2 ( - a )^{ n - 2 } + \cdots
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(n\)</span>是奇数,<span class="math inline">\(a^n + ( - a )^n = 0\)</span>,而<span class="math inline">\(n^n | c^n \Rightarrow n^3 |
c^n\)</span>,又注意到<span class="math inline">\(n^3 |
nm^2\)</span>,我们把两边对<span class="math inline">\(n^3\)</span>取模:</p>
<p><span class="math display">\[
0 \equiv nx ( - a )^{ n - 1 } \pmod{ n^3 }
\]</span></p>
<p>注意到若<span class="math inline">\(n^2 \nmid
m\)</span>,则该式子必不成立.</p>
<h4><span id="stern-brocot-树">Stern-Brocot 树</span></h4>
<p>Stern-Brocot树是一种可以不重不漏列举有理数的方式,它的构造如下:</p>
<p>一开始,序列中有两个分数:<span class="math inline">\(\cfrac{ 0 }{ 1
}\)</span>和<span class="math inline">\(\cfrac{ 1 }{ 0
}\)</span>,这里使用了<span class="math inline">\(0\)</span>作分母,但我们暂且认为它是正确的,因为这样会出现很多方便的性质.</p>
<p>接下来,不断地对这个序列进行以下操作:在两个相邻的分数<span class="math inline">\(\cfrac{ m }{ n }\)</span>和<span class="math inline">\(\cfrac{ m &#39; }{ n &#39;
}\)</span>之间插入一个新分数<span class="math inline">\(\cfrac{ m + m
&#39; }{ n + n &#39; }\)</span>.</p>
<p>这么无限构造下去得到的序列满足两个性质:</p>
<ol type="1">
<li><p>所得到的分数全都是最简分数.</p></li>
<li><p>所得到的分数不重不漏,换句话说,任意非负有理数都在这个序列中出现恰好一次.</p></li>
</ol>
<p>我们不妨认为<span class="math inline">\(\cfrac{ 1 }{ 0 } = +
\infty\)</span>,那么不难发现这么构造序列,所得到的序列一定是单调递增的.</p>
<p>这是因为如果我们有<span class="math inline">\(\cfrac{ m }{ n } &lt;
\cfrac{ m &#39; }{ n &#39; }\)</span>,那么我们一定有:<span class="math inline">\(\cfrac{ m }{ n } &lt; \cfrac{ m + m &#39; }{ n + n
&#39; } &lt; \cfrac{ m &#39; }{ n &#39; }\)</span>,其中<span class="math inline">\(n , n &#39; , m , m &#39; \geq
0\)</span>,这一点不难验证.</p>
<p>而正因为如此,我们可以证明所得到的所有分数不重.</p>
<p>然后,如果当前所得到的序列中有两个数<span class="math inline">\(\cfrac{ m }{ n }\)</span>和<span class="math inline">\(\cfrac{ m &#39; }{ n &#39; }\)</span>相邻,则<span class="math inline">\(m &#39; n - mn &#39; =
1\)</span>,这一点不难通过数学归纳证明.而根据裴蜀定理,显然<span class="math inline">\(m \bot n\)</span>且<span class="math inline">\(m
&#39; \bot n &#39;\)</span>.</p>
<p>我们最后需要证明任意非负有理数都可以通过这个序列构造出来,考虑类似二分的方法构造.换句话说,我们有两个序列中的分数<span class="math inline">\(\cfrac{ m }{ n }\)</span>和<span class="math inline">\(\cfrac{ m &#39; }{ n &#39;
}\)</span>,要构造的有理数为<span class="math inline">\(\cfrac{ a }{ b
}\)</span>且满足<span class="math inline">\(\cfrac{ m }{ n } &lt;
\cfrac{ a }{ b } &lt; \cfrac{ m &#39; }{ n &#39; }\)</span>.</p>
<p>我们考虑判断<span class="math inline">\(\cfrac{ m + m &#39; }{ n + n
&#39; }\)</span>与<span class="math inline">\(\cfrac{ a }{ b
}\)</span>的大小关系,这样就可以类似二分的方法一直往下找下去.</p>
<p>问题在于为什么我们最后一定可以找到这个数呢?如果我们一直找不到这个数,意味着无论我们怎么做,都有<span class="math inline">\(\cfrac{ m }{ n } &lt; \cfrac{ a }{ b } &lt;
\cfrac{ m &#39; }{ n &#39; }\)</span>成立,而这也就意味着<span class="math inline">\(an - bm \geq 1 \land bm &#39; - an &#39; \geq
1\)</span>,处理一下不等式并合并,我们有<span class="math inline">\(( m
&#39; + n &#39; ) ( an - bm ) + ( n + m ) ( bm &#39; - an &#39; ) \geq n
+ m + n &#39; + m &#39;\)</span>.</p>
<p>化简这个式子得到<span class="math inline">\(a + b \geq m &#39; + n
&#39; + m + n\)</span>,而我们在操作过程中<span class="math inline">\(m ,
n , m &#39; , n
&#39;\)</span>显然会有两个数不变,另外两个数变大,因此迟早会大于<span class="math inline">\(a + b\)</span>,也就意味着这个数迟早会被找到.</p>
<p>之所以称其为”树”,则是因为我们如果每次都在任意两个数之间插入一个数,然后将进行若干次操作得到的序列放到二叉搜索树上,会得到一些很好的性质,譬如一个数是由它所有祖先中最大的小于它的数和最小的大于它的数生成的,以及关于根中心对称的两点互为倒数.</p>
<p>另外,如果我们定义法里级数<span class="math inline">\(\mathcal{ F
}_n\)</span>表示所有在<span class="math inline">\([ 0 , 1
]\)</span>范围内且分母小于等于<span class="math inline">\(n\)</span>的最简分数的集合.不难发现,<span class="math inline">\(\mathcal{ F
}_n\)</span>对应着整棵树的一棵子树的一部分.而<span class="math inline">\(\mathcal{ F }_n\)</span>可以由<span class="math inline">\(\mathcal{ F }_{ n - 1
}\)</span>得到,只需要判断<span class="math inline">\(\mathcal{ F }_{ n -
1 }\)</span>中每两个相邻数能否生成一个满足条件的数即可.</p>
<p>我们回到它的树形态上,如果我们定义<span class="math inline">\(\cfrac{
1 }{ 1
}\)</span>为这棵二叉搜索树的根,那么每个有理数显然都可以表示为从根到它的一个<span class="math inline">\(LR\)</span>序列,表示从根向下搜索时每一步向左走还是向右走.特别地,我们定义根的序列为<span class="math inline">\(I\)</span>.</p>
<p>不难发现,通过这样的操作,我们将每一个非负有理数都对应到了一个<span class="math inline">\(LR\)</span>序列.</p>
<p>那么我们来考虑第一个问题:已知<span class="math inline">\(LR\)</span>序列如何求这个数.</p>
<p>我们可以设当前点是<span class="math inline">\(x\)</span>,且它由<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>生成,其中<span class="math inline">\(y
&lt; x &lt; z\)</span>,那么不难发现它的右儿子由<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>生成,左儿子由<span class="math inline">\(y\)</span>和<span class="math inline">\(x\)</span>生成.</p>
<p>那么我们显然可以使用记录<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>的方式,反复迭代求得答案.注意<span class="math inline">\(x\)</span>是可以通过<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>求得的,因此没有必要存储.</p>
<p>而这一过程可以简化为矩阵运算:</p>
<p>我们令<span class="math inline">\(y = \cfrac{ m }{ n }\)</span>,<span class="math inline">\(z = \cfrac{ m &#39; }{ n &#39; }\)</span>,<span class="math inline">\(S = \begin{bmatrix}n &amp; n &#39; \\ m &amp; m
&#39;\end{bmatrix}\)</span>,<span class="math inline">\(f ( S ) =
\cfrac{ m + m &#39; }{ n + n &#39; }\)</span>.</p>
<p>那么不难发现它的每一次操作只需右乘一个变换矩阵即可.</p>
<p>其中:<span class="math inline">\(L = \begin{bmatrix}1 &amp; 1 \\ 0
&amp; 1\end{bmatrix} , R = \begin{bmatrix}1 &amp; 0 \\ 1 &amp;
1\end{bmatrix}\)</span>.</p>
<p>使用数学归纳不难证明:</p>
<p><span class="math inline">\(L^k = \begin{bmatrix}1 &amp; k \\ 0 &amp;
1\end{bmatrix} , R^k = \begin{bmatrix}1 &amp; 0 \\ k &amp;
1\end{bmatrix}\)</span>.</p>
<p>至于已知数字求它的序列表示,首先可以直接在树上搜索.</p>
<p>而如果要脱离树,我们仍然可以回到矩阵上,意识到<span class="math inline">\(f ( RS ) = f ( S ) +
1\)</span>,再加上关于根中心对称两点互为倒数的性质,我们可以推导出以下法则:</p>
<p>如果<span class="math inline">\(m &gt; n\)</span>,那么<span class="math inline">\(f ( RS ) = \cfrac{ m }{ n } \Leftrightarrow f ( S
) = \cfrac{ m - n }{ n }\)</span>.</p>
<p>如果<span class="math inline">\(m &lt; n\)</span>,那么<span class="math inline">\(f ( LS ) = \cfrac{ m }{ n } \Leftrightarrow f ( S
) = \cfrac{ m }{ n - m }\)</span>.</p>
<p>借助这一点,我们就可以求一个数的<span class="math inline">\(LR\)</span>序列表示了.</p>
<p>在某些情形下,这种表示可以解决二进制下某些分数无法精确表示的问题.</p>
<h4><span id="升幂引理">升幂引理</span></h4>
<h5><span id="形式一">形式一</span></h5>
<p>对于素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p \nmid x , p \nmid y\)</span>,对于满足<span class="math inline">\(\gcd ( n , p ) = 1\)</span>的<span class="math inline">\(n\)</span>:</p>
<ol type="1">
<li><p>若<span class="math inline">\(p | ( x - y )\)</span>,则<span class="math inline">\(v_p ( x^n - y^n ) = v_p ( x - y
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(p | ( x + y )\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p
( x^n + y^n ) = v_p ( x + y )\)</span>.</p></li>
</ol>
<p>考虑(1)的证明,由于<span class="math inline">\(p | ( x - y ) , x
\equiv y \pmod{ p }\)</span>,因此<span class="math inline">\(\sum_{ k =
0 }^{ n - 1 } x^k y^{ n - 1 - k } \equiv nx^{ n - 1 } \ne 0 \pmod{ p
}\)</span>.有次方差公式,显然.</p>
<p>(2)类似.</p>
<h5><span id="形式二">形式二</span></h5>
<p>对于奇素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p \nmid x , p \nmid y\)</span>:</p>
<ol type="1">
<li><p>若<span class="math inline">\(p | ( x - y )\)</span>,则<span class="math inline">\(v_p ( x^n - y^n ) = v_p ( x - y ) + v_p ( n
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(p | ( x + y )\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p
( x^n + y^n ) = v_p ( x + y ) + v_p ( n )\)</span>.</p></li>
</ol>
<p>和形式一的证明完全类似.</p>
<h3><span id="同余">同余</span></h3>
<p>如果<span class="math inline">\(a \mod m = b \mod
m\)</span>,我们称<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>关于模<span class="math inline">\(m\)</span>同余,记作<span class="math inline">\(a
\equiv b ( \mod m )\)</span>.</p>
<p>根据同余的定义,若<span class="math inline">\(a , b , c , d , k \in
\mathbb{ Z }\)</span>,<span class="math inline">\(n , m \in \mathbb{ N_+
}\)</span>,我们有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(a \equiv b \pmod{ m } \Leftrightarrow
a - b = km\)</span>.</p></li>
<li><p><span class="math inline">\(a \equiv b \pmod{ m } \land c \equiv
d \pmod{ m } \Rightarrow a + c \equiv b + d \pmod{ m
}\)</span>.</p></li>
<li><p><span class="math inline">\(a \equiv b \pmod{ m } \land c \equiv
d \pmod{ m } \Rightarrow ac \equiv bd \pmod{ m }\)</span>.</p></li>
<li><p><span class="math inline">\(a \equiv b \pmod{ m } \Rightarrow a^k
\equiv b^k \pmod{ m }\)</span>.</p></li>
<li><p><span class="math inline">\(ad \equiv bd \pmod{ m }
\Leftrightarrow a \equiv b \pmod{ m } , m \bot d\)</span>.</p></li>
<li><p><span class="math inline">\(ad \equiv bd \pmod{ md }
\Leftrightarrow a \equiv b \pmod{ m } , d \ne 0\)</span>.</p></li>
<li><p><span class="math inline">\(ad \equiv bd \pmod{ m }
\Leftrightarrow a \equiv b \pmod{ \cfrac{ m }{ \gcd ( m , d ) }
}\)</span>.</p></li>
<li><p><span class="math inline">\(a \equiv b \pmod{ md } \Rightarrow a
\equiv b \pmod{ m } , d \ne 0\)</span>.</p></li>
<li><p><span class="math inline">\(a \equiv b \pmod{ m } \land a \equiv
b \pmod{ n } \Leftrightarrow a \equiv b \pmod{ lcm ( n , m )
}\)</span>.</p></li>
</ol>
<p>我们考虑第五条的证明:由于<span class="math inline">\(m \bot
d\)</span>,则根据扩展欧几里得算法,可以求得一个数<span class="math inline">\(d &#39;\)</span>满足<span class="math inline">\(dd
&#39; + mm &#39; = 1\)</span>,也就是<span class="math inline">\(dd &#39;
\equiv 1 ( \mod m )\)</span>,那么如果我们有<span class="math inline">\(ad \equiv bd ( \mod m
)\)</span>,只需要两边同时乘以<span class="math inline">\(d
&#39;\)</span>就可以得到右边.值得一提的是,我们通常称<span class="math inline">\(d &#39;\)</span>是<span class="math inline">\(d\)</span>在模<span class="math inline">\(m\)</span>意义下的逆元,记作<span class="math inline">\(inv ( d , m )\)</span>或<span class="math inline">\(d^{ - 1 }\)</span>.</p>
<p>逆元有一种线性预处理的求法:</p>
<p>考虑<span class="math inline">\(1 \leq i \leq n\)</span>,设<span class="math inline">\(p = ki + r\)</span>,则有<span class="math inline">\(ki + r \equiv 0 ( \mod p )\)</span>,则有<span class="math inline">\(kr^{ - 1 } + i^{ - 1 } \equiv 0 ( \mod p
)\)</span>.</p>
<p>于是有<span class="math inline">\(i^{ - 1 } \equiv - kr^{ - 1 } (
\mod p )\)</span>,即<span class="math inline">\(i^{ - 1 } \equiv -
\lfloor \cfrac{ p }{ i } \rfloor \times r^{ - 1 } ( \mod p
)\)</span>.</p>
<p>现在,我们给出一个结论:数列<span class="math inline">\(0 \mod m , n
\mod m , 2 n \mod m , . . . , ( m - 1 ) n \mod
m\)</span>在排序去重后恰好为数列<span class="math inline">\(0 , d , 2 d
, . . . , m - d\)</span>,<span class="math inline">\(d = \gcd ( n , m
)\)</span>,而且其中每个数字在原数列中恰好出现了<span class="math inline">\(d\)</span>次.</p>
<p>恰好出现<span class="math inline">\(d\)</span>次是好证明的:考虑<span class="math inline">\(jn \equiv kn ( \mod m )\)</span>可以推导出<span class="math inline">\(j \equiv k ( \mod \cfrac{ m }{ d } ) , d = \gcd (
n , m )\)</span>,则显然这些数是一个序列复制<span class="math inline">\(d\)</span>次得到的.</p>
<p>由上,我们要证明<span class="math inline">\(kn \mod
m\)</span>一定是<span class="math inline">\(d\)</span>的倍数.不难发现<span class="math inline">\(kn \mod m = dk \cfrac{ n }{ d } ( \mod \cfrac{ m
}{ d } d ) = d ( \cfrac{ kn }{ d } \mod \cfrac{ m }{ d } )\)</span>.</p>
<p>接下来,不妨假设<span class="math inline">\(n \bot
m\)</span>,并在此条件下证明<span class="math inline">\(0 \mod m , n \mod
m , 2 n \mod m , . . . , ( m - 1 ) n \mod
m\)</span>两两不同即可.而由于<span class="math inline">\(n \bot
m\)</span>,则<span class="math inline">\(kn \equiv jn ( \mod m
)\)</span>的充分必要条件是<span class="math inline">\(k \equiv j ( \mod
m )\)</span>,因此它们显然两两不同.</p>
<h5><span id="example具体数学431">Example(《具体数学》4.31)</span></h5>
<p><span class="math inline">\(n\)</span>进制下,各位数字之和是<span class="math inline">\(m\)</span>的倍数,则这个数是<span class="math inline">\(m\)</span>的倍数的充分必要条件是?</p>
<p>令<span class="math inline">\(a_i\)</span>表示这个数字在<span class="math inline">\(n\)</span>进制下的第<span class="math inline">\(i\)</span>位,则这条性质也就是:</p>
<p><span class="math display">\[
\sum_{ i = 0 } a_i n^i \equiv 0 \pmod{ m } \Leftrightarrow \sum_{ i = 0
} a_i \equiv 0 \pmod{ m }
\]</span></p>
<p>不难发现,当<span class="math inline">\(n \equiv 1 \pmod{ m
}\)</span>时,满足该性质.</p>
<h4><span id="威尔逊定理">威尔逊定理</span></h4>
<p>-1(p)&amp;pprime\</p>
<p>2(p)&amp;p=4\</p>
<p>0(p)&amp;other</p>
<p>\end{cases}</p>
<p>证明:</p>
<p>当<span class="math inline">\(p\)</span>为质数时，考虑对于<span class="math inline">\(a\)</span>和<span class="math inline">\(b = a^{ -
1 } ( \mod p )\)</span>,若<span class="math inline">\(a =
b\)</span>,此时可证明<span class="math inline">\(a = 1\)</span>或<span class="math inline">\(a = p - 1\)</span>(需要用到下面独立剩余知识).</p>
<p>如果<span class="math inline">\(a \ne b\)</span>那么一定可以在<span class="math inline">\([ 1 , p - 1 ]\)</span>找到一对数,它们相乘为<span class="math inline">\(1\)</span>.原因是若<span class="math inline">\(a_1
\ne a_2\)</span>,那么<span class="math inline">\(a_1^{ - 1 } \ne a_2^{ -
1 }\)</span>.</p>
<p>若<span class="math inline">\(p\)</span>不是质数,则设<span class="math inline">\(p = ab\)</span>,当<span class="math inline">\(a
\ne b\)</span>时,由于<span class="math inline">\(a , b \leq
p\)</span>,因此<span class="math inline">\(( p - 1 )
!\)</span>一定是<span class="math inline">\(p\)</span>的倍数.</p>
<p>若<span class="math inline">\(a = b\)</span>,除非<span class="math inline">\(p = 4\)</span>,不然一定能在<span class="math inline">\([ 1 , p - 1 ]\)</span>里找到<span class="math inline">\(a\)</span>和<span class="math inline">\(2
a\)</span>,此时<span class="math inline">\(( p - 1 ) !\)</span>也是<span class="math inline">\(p\)</span>的倍数.</p>
<p>另外,当<span class="math inline">\(p\)</span>是奇质数的时候,威尔逊定理可以写成如下形式:</p>
<p><span class="math display">\[
\begin{aligned}
\prod_{ k = 1 }^{ \frac{ p - 1 }{ 2 } } k ( p - k ) &amp; \equiv - 1
\pmod{ p } \\
\prod_{ k = 1 }^{ \frac{ p - 1 }{ 2 } } - k^2 &amp; \equiv - 1 \pmod{ p
} \\
( - 1 )^{ \frac{ p - 1 }{ 2 } } ( ( \cfrac{ p - 1 }{ 2 } ) ! )^2 &amp;
\equiv - 1 \pmod{ p }
\end{aligned}
\]</span></p>
<p>另外,通过以上推导过程,不难发现威尔逊定理还可以写成:</p>
<p><span class="math display">\[
( p - 2 ) ! \equiv \begin{cases}
1 ( \mod p ) &amp; p \in \mathrm{ prime } \\
2 ( \mod p ) &amp; p = 4 \\
0 ( \mod p ) &amp; other
\end{cases}
\]</span></p>
<h5><span id="example1具体数学448">Example1(《具体数学》4.48)</span></h5>
<p>求<span class="math inline">\(\prod_{ 1 \leq n &lt; m , n \bot m } n
\pmod{ m } \\\)</span>.</p>
<p>首先,类似威尔逊定理的推导,不难注意到这个式子也就等价于:</p>
<p><span class="math display">\[
\prod_{ 1 \leq n &lt; m , n^2 \equiv 1 \pmod{ m } } n \pmod{ m }
\]</span></p>
<p>首先考虑满足<span class="math inline">\(n^2 \equiv 1 \pmod{ m
}\)</span>的<span class="math inline">\(n\)</span>满足什么性质,根据我们在二次剩余的推导,先考虑<span class="math inline">\(2 \nmid m\)</span>的情况,此时我们将<span class="math inline">\(m\)</span>分解为了若干个形如<span class="math inline">\(p^k\)</span>的质因数的乘积,对于每个<span class="math inline">\(p^k\)</span>作为模数时,<span class="math inline">\(n\)</span>有两个解:<span class="math inline">\(1\)</span>和<span class="math inline">\(p^k -
1\)</span>.</p>
<p>当<span class="math inline">\(m =
p^k\)</span>的时候,显然答案就是<span class="math inline">\(-
1\)</span>.</p>
<p>不然,由于此时有很多解,我们考虑设答案为<span class="math inline">\(ans\)</span>并对于每个<span class="math inline">\(p^k\)</span>求出<span class="math inline">\(ans
\pmod{ p^k }\)</span>的答案,再使用中国剩余定理合并.不难发现只要<span class="math inline">\(m\)</span>有多个不同的质因子,那么中国剩余定理合并的时候,一定会有偶数个<span class="math inline">\(n\)</span>(事实上,假设<span class="math inline">\(m\)</span>有<span class="math inline">\(a\)</span>个质因子,那么有<span class="math inline">\(2^{ a - 1 }\)</span>个这样的<span class="math inline">\(n\)</span>)满足<span class="math inline">\(n
\equiv - 1 \pmod{ p^k }\)</span>,也有同样数目的<span class="math inline">\(n\)</span>满足<span class="math inline">\(n \equiv
1 \pmod{ p^k }\)</span>.那么此时的<span class="math inline">\(ans \equiv
1 \pmod{ p^k }\)</span>.多次合并后的<span class="math inline">\(ans\)</span>显然还是<span class="math inline">\(1\)</span>.</p>
<p>至于<span class="math inline">\(2 \mid
m\)</span>的情况并没有麻烦很多,当<span class="math inline">\(2 \mid m
\land 4 \nmid m\)</span>,显然有没有这个<span class="math inline">\(2\)</span>作为质因子都一样.当<span class="math inline">\(4 \mid m \land 8 \nmid
m\)</span>,这个质因子和其它质因子并没有多少区别.</p>
<p>于是我们最后得到结论:</p>
$$ _{ 1 n &lt; m , n m } n
<span class="math display">\[\begin{cases}
- 1 \pmod{ m } &amp; m = p^k \lor m = 2 p^k \lor m = 4 , p \in \mathrm{
prime } \land p \ne 2 \\
1 \pmod{ m } &amp; other \\

\end{cases}\]</span>
<p>$$</p>
<h5><span id="example2具体数学440">Example2(《具体数学》4.40)</span></h5>
<p>如果我们设<span class="math inline">\(n = \sum_{ k \geq 0 } a_k
p^k\)</span>,求证:<span class="math inline">\(\cfrac{ n ! }{ p^{
\varepsilon_p ( n ! ) } } = ( - 1 )^{ \varepsilon_p ( n ! ) } \prod_{ k
\geq 0 } a_k ! \pmod{ p }\)</span>.</p>
<p>证明考虑数学归纳:如果<span class="math inline">\(n \rightarrow n +
1\)</span>的过程中没有发生进位,那么该公式显然成立.</p>
<p>如果发生进位了,假设进到了第<span class="math inline">\(k\)</span>位,第<span class="math inline">\(k\)</span>位原本是<span class="math inline">\(w\)</span>,现在是<span class="math inline">\(w +
1\)</span>,那么要证其对于<span class="math inline">\(n +
1\)</span>成立,即证明下式成立:</p>
<p><span class="math display">\[
\cfrac{ n ! ( n + 1 ) }{ p^{ \varepsilon_p ( n ! ) + k } } = ( - 1 )^{
\varepsilon_p ( n ! ) + k } ( w + 1 ) ! \prod_{ i \geq k + 1 } a_i !
\pmod{ p }
\]</span></p>
<p>考虑<span class="math inline">\(( p - 1 ) \equiv - 1 \pmod{ p
}\)</span>,于是上式也即:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ n ! ( n + 1 ) }{ p^{ \varepsilon_p ( n ! ) + k } } &amp; = ( - 1
)^{ \varepsilon_p ( n ! ) } ( w + 1 ) \prod_{ i \geq 0 } a_i ! \pmod{ p
} \\
\cfrac{ n ! }{ p^{ \varepsilon_p ( n ! ) } } \cfrac{ n + 1 }{ p^k }
&amp; = ( - 1 )^{ \varepsilon_p ( n ! ) } ( w + 1 ) \prod_{ i \geq 0 }
a_i ! \pmod{ p } \\
\cfrac{ n ! }{ p^{ \varepsilon_p ( n ! ) } } ( w + 1 ) &amp; = ( - 1 )^{
\varepsilon_p ( n ! ) } ( w + 1 ) \prod_{ i \geq 0 } a_i ! \pmod{ p }
\end{aligned}
\]</span></p>
<p>于是化到<span class="math inline">\(n\)</span>的情况,于是<span class="math inline">\(n + 1\)</span>时该式子成立.</p>
<h5><span id="example3具体数学453">Example3(《具体数学》4.53)</span></h5>
<p>求所有满足<span class="math inline">\(n | \lceil \cfrac{ ( n - 1 ) !
}{ n + 1 } \rceil\)</span>的整数<span class="math inline">\(n\)</span>.</p>
<p>首先这个形式看上去就是威尔逊定理的形式,所以第一步我们先暴力验证<span class="math inline">\(n \in [ 1 , 4
]\)</span>的答案,注意到此时当且仅当<span class="math inline">\(n =
1\)</span>时成立.接下来我们尝试找到<span class="math inline">\(n \geq
5\)</span>时的解.</p>
<p>考虑当<span class="math inline">\(n + 1 \in \mathrm{ prime
}\)</span>时,根据威尔逊定理,要求化为:<span class="math inline">\(n \mid
\cfrac{ ( n - 1 ) ! + n }{ n + 1 }\)</span>.注意到此时<span class="math inline">\(n\)</span>一定不是质数,又因为<span class="math inline">\(n \bot ( n + 1 )\)</span>,于是要求化为<span class="math inline">\(n \mid{ ( n - 1 ) ! + n }\)</span>,显然成立.</p>
<p>当<span class="math inline">\(n + 1 \notin \mathrm{ prime
}\)</span>时,要求则化为<span class="math inline">\(n \mid \cfrac{ ( n -
1 ) ! }{ n + 1 }\)</span>.当<span class="math inline">\(n \in \mathrm{
prime }\)</span>时,显然不成立.反之显然成立.</p>
<p>于是要么<span class="math inline">\(n = 1\)</span>,要么<span class="math inline">\(n \geq 5 \land n \notin \mathrm{ prime
}\)</span>.</p>
<h4><span id="费马小定理">费马小定理</span></h4>
<p><span class="math inline">\(n^{ p - 1 } \equiv 1 ( \mod p ) , n \bot
p , p \in \mathrm{ prime }\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\prod_{ k = 1 }^{ p - 1 } kn &amp; \equiv \prod_{ k = 1 }^{ p - 1 } ( kn
\mod p ) ( \mod p ) \\
n^{ p - 1 } ( p - 1 ) ! &amp; \equiv ( p - 1 ) ! ( \mod p )
\end{aligned}
\]</span></p>
<p>根据威尔逊定理,显然可以推得费马小定理.</p>
<p>根据费马小定理,我们可以考虑证明一个结论:<span class="math inline">\(n^{ p^k } \equiv n^{ p^{ k - 1 } } ( \mod p^k
)\)</span>.</p>
<p>由于<span class="math inline">\(n^{ p - 1 } \equiv 1 ( \mod p
)\)</span>,那么我们有<span class="math inline">\(n^p \equiv n ( \mod p
)\)</span>,也即<span class="math inline">\(\exists q \in \mathbb{ Z
}\)</span>满足<span class="math inline">\(n^p = n +
pq\)</span>,不断两边取<span class="math inline">\(p\)</span>次方即可得到上述结论.</p>
<p>另外,费马小定理还可以如下证明:</p>
<p>考虑证明<span class="math inline">\(n^p \equiv n \pmod{ p
}\)</span>,也就是要证明<span class="math inline">\(( \sum_{ i = 1 }^n 1
)^p \equiv n \pmod{ p }\)</span>.</p>
<p>注意到根据多项式定理,<span class="math inline">\(( \sum_{ i = 1 }^n 1
)^p = \sum_{ \sum a = p } \cfrac{ p ! }{ a_1 ! . . . a_n !
}\)</span>.而如果<span class="math inline">\(\max \{ a \} \ne
p\)</span>,则后面的式子在<span class="math inline">\(\mod
p\)</span>意义下显然为<span class="math inline">\(0\)</span>,不然,考虑<span class="math inline">\(\max \{ a \} = p\)</span>的序列一共会出现<span class="math inline">\(n\)</span>次且每次对答案的贡献都是<span class="math inline">\(1\)</span>,自然有<span class="math inline">\(n^p
\equiv n ( \mod p )\)</span>.</p>
<h5><span id="example1具体数学441">Example1(《具体数学》4.41)</span></h5>
<p>求证:如果质数<span class="math inline">\(p\)</span>满足<span class="math inline">\(p \equiv 3 \pmod{ 4 }\)</span>,则不存在整数<span class="math inline">\(n\)</span>满足<span class="math inline">\(p | (
n^2 + 1 )\)</span>;如果其满足<span class="math inline">\(p \equiv 1
\pmod{ 4 }\)</span>,则一定存在一个整数<span class="math inline">\(n\)</span>满足条件.</p>
<p>先考虑证明前半部分,如果存在这样一个整数<span class="math inline">\(n\)</span>,考虑<span class="math inline">\(p | (
n^2 + 1 )\)</span>也就等价于<span class="math inline">\(n^2 \equiv - 1
\pmod{ p }\)</span>,则<span class="math inline">\(n^4 \equiv 1 \pmod{ p
}\)</span>.显然<span class="math inline">\(p \bot
n\)</span>,根据费马小定理,我们有<span class="math inline">\(n^{ p - 1 }
\equiv 1 \pmod{ p }\)</span>,也就有<span class="math inline">\(n^{ p + 1
} \equiv - 1 \pmod{ p }\)</span>.</p>
<p>而由于<span class="math inline">\(p \equiv 3 \pmod{ 4
}\)</span>,所以<span class="math inline">\(4 | ( p + 1
)\)</span>,所以<span class="math inline">\(n^{ p + 1 } \equiv 1 \pmod{ p
}\)</span>,不符,因此一定不存在.</p>
<p>反之,考虑威尔逊定理的变形<span class="math inline">\(\prod_{ k = 1
}^{ \frac{ p - 1 }{ 2 } } - k^2 \equiv - 1 \pmod{ p }
\\\)</span>.由于<span class="math inline">\(p - 1 \equiv 0 \pmod{ 4
}\)</span>,所以这个式子也就等价于<span class="math inline">\(\prod_{ k =
1 }^{ \frac{ p - 1 }{ 2 } } k^2 \equiv - 1 \pmod{ p
}\)</span>,也就是<span class="math inline">\(( ( \cfrac{ p - 1 }{ 2 } )
! )^2 \equiv - 1 \pmod{ p }\)</span>,这就是一个解.</p>
<h5><span id="example2具体数学446">Example2(《具体数学》4.46)</span></h5>
<p>求证:如果<span class="math inline">\(n &gt; 1\)</span>,则<span class="math inline">\(2^n \ne 1 \pmod{ n }\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>是质数,根据费马小定理,显然得证.</p>
<p>不然,设<span class="math inline">\(n = pq\)</span>,且<span class="math inline">\(p\)</span>是<span class="math inline">\(n\)</span>的最小质因子,若<span class="math inline">\(2^{ n } \equiv 1 \pmod{ n }\)</span>,则<span class="math inline">\(2^n \equiv 1 \pmod{ p }\)</span>.</p>
<p>若<span class="math inline">\(p = 2\)</span>,显然不成立.不然,有<span class="math inline">\(2^{ p - 1 } \equiv 1 \pmod{ p }\)</span>,由于<span class="math inline">\(( p - 1 ) \bot n\)</span>,则<span class="math inline">\(2^{ \gcd ( p - 1 , n ) } \equiv 2 \equiv 1 \pmod{
p }\)</span>,显然不成立.</p>
<p>另外,上面的过程显然可以推广为:</p>
<p>如果<span class="math inline">\(n &gt; 1\)</span>,则对于任意质数<span class="math inline">\(p\)</span>,<span class="math inline">\(p^n \ne 1
\pmod{ n }\)</span>.</p>
<h4><span id="中国剩余定理crt">中国剩余定理(crt)</span></h4>
<p>对于方程组<span class="math inline">\(x \equiv a_i ( \mod m_i
)\)</span>,其中<span class="math inline">\(m_i\)</span>两两互质,求<span class="math inline">\(x\)</span>.</p>
<p>令<span class="math inline">\(m = \prod^k_{ i = 1 }
m_i\)</span>,设<span class="math inline">\(M_i = \cfrac{ m }{ m_i
}\)</span>,<span class="math inline">\(N_i\)</span>是<span class="math inline">\(M_i\)</span>在<span class="math inline">\(\mod
m_i\)</span>意义下逆元.</p>
<p>则<span class="math inline">\(x \equiv \sum^k_{ i = 1 } M_i N_i a_i (
\mod m )\)</span>.</p>
<p>中国剩余定理的证明类似拉格朗日插值:</p>
<p>由于<span class="math inline">\(x\)</span>在<span class="math inline">\(\mod m_i\)</span>意义下,<span class="math inline">\(\sum\)</span>中枚举的所有不等于<span class="math inline">\(i\)</span>的项都会成<span class="math inline">\(0\)</span>，等于<span class="math inline">\(i\)</span>的项会成<span class="math inline">\(a_i\)</span>.</p>
<p>考虑每次合并两项，显然有:<span class="math inline">\(a = a_1 + ( a_2
- a_1 ) \times m_1 \times inv ( m_1 , m_2 )\)</span>,<span class="math inline">\(m = m_1 m_2\)</span>.</p>
<p>中国剩余定理的本质是一个环同构<span class="math inline">\(\varphi :
\mathbb{ Z } / m_1 m_2 \mathbb{ Z } \rightarrow ( \mathbb{ Z } / m_1
\mathbb{ Z } ) \times ( \mathbb{ Z } / m_2 \mathbb{ Z }
)\)</span>,当<span class="math inline">\(m_1 \bot m_2\)</span>.</p>
<p>由于映射两边都是大小相同的有限环,所以只需证明它是单射就行.而容易发现<span class="math inline">\(\ker \varphi = \{ [ 1 ] \}\)</span>.</p>
<p>下面的扩展中国剩余定理亦然同理,用一下裴蜀定理证明映射两边的有限环大小相等,再注意到<span class="math inline">\(| \ker \varphi | = 1\)</span>.</p>
<h4><span id="扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</span></h4>
<p>对于方程组<span class="math inline">\(x \equiv a_i ( \mod m_i
)\)</span>,若<span class="math inline">\(m_i\)</span>两两不互质.</p>
<p>我们考虑每次合并两个方程:</p>
<p>xa_1(m_1)\</p>
<p>xa_2(m_2)</p>
<p>\end{cases}</p>
<p>那这个方程组等价于:</p>
<p>x=k_1m_1+a_1\</p>
<p>x=k_2m_2+a_2</p>
<p>\end{cases}</p>
<p>合并上下方程,有:</p>
<p><span class="math display">\[
\begin{aligned}
k_1 m_1 + a_1 &amp; = k_2 m_2 + a_2 \\
a_2 - a_1 &amp; = k_1 m_1 - k_2 m_2
\end{aligned}
\]</span></p>
<p>设<span class="math inline">\(g = \gcd ( m_1 , m_2
)\)</span>,显然若<span class="math inline">\(g \nmid ( a_2 - a_1
)\)</span>,方程无解.</p>
<p>不然,有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ a_2 - a_1 }{ g } &amp; = k_1 \frac{ m_1 }{ g } - k_2 \frac{ m_2
}{ g } \\
k_1 \frac{ m_1 }{ g } &amp; = k_2 \frac{ m_2 }{ g } + \frac{ a_2 - a_1
}{ g } \\
k_1 \frac{ m_1 }{ g } &amp; \equiv \frac{ a_2 - a_1 }{ g } ( \mod \frac{
m_2 }{ g } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(inv ( a , p )\)</span>表示<span class="math inline">\(a\)</span>在<span class="math inline">\(\mod
p\)</span>意义下的逆元,有:</p>
$$
<span class="math display">\[\begin{aligned}
k_1 &amp; \equiv inv ( \frac{ m_1 }{ g } , \frac{ m_2 }{ g } ) \frac{
a_2 - a_1 }{ g } ( \mod \frac{ m_2 }{ g } ) \\
k_1 &amp; = inv ( \frac{ m_1 }{ g } , \frac{ m_2 }{ g } ) \frac{ a_2 -
a_1 }{ g } + k_3 \frac{ m_2 }{ g } \\

\end{aligned}\]</span>
<p>$$</p>
<p>带回第一个方程:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = m_1 ( inv ( \frac{ m_1 }{ g } , \frac{ m_2 }{ g } ) \frac{ a_2
- a_1 }{ g } + k_3 \frac{ m_2 }{ g } ) + a_1 \\
x &amp; \equiv m_1 inv ( \frac{ m_1 }{ g } , \frac{ m_2 }{ g } ) \frac{
a_2 - a_1 }{ g } + a_1 ( \mod \frac{ m_1 m_2 }{ g } )
\end{aligned}
\]</span></p>
<h5><span id="example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</span></h5>
<p>考虑拿个set之类的维护,然后问题转化为求:</p>
<p><span class="math display">\[
\begin{cases}
b_1 x \equiv a_1 ( \mod m_1 ) \\
b_2 x \equiv a_2 ( \mod m_2 ) \\
. . . \\
b_n x \equiv a_n ( \mod m_n )
\end{cases}
\]</span></p>
<p>的一个<span class="math inline">\(x\)</span>的最小解.</p>
<p>对于一个式子<span class="math inline">\(b_i x \equiv a_i \pmod{ m_i
}\)</span>,设<span class="math inline">\(g = \gcd ( b_i , m_i
)\)</span>,那么若<span class="math inline">\(g \nmid
a_i\)</span>,显然无解;不然,我们有:<span class="math inline">\(\cfrac{
b_i }{ g } x \equiv \cfrac{ a_i }{ g } \pmod{ \cfrac{ m_i }{ g }
}\)</span>,而<span class="math inline">\(\cfrac{ b_i }{ g } \bot \cfrac{
m_i }{ g }\)</span>,可以求逆元.</p>
<h5><span id="example2cf571egeometricprogressions">Example2([CF571E]Geometric
Progressions)</span></h5>
<p>首先分解质因子,这样问题转化为判断等差数列中是否出现.我们随便挑一个数列,假设这个数列中第<span class="math inline">\(x\)</span>个数字是答案,显然最小化<span class="math inline">\(x\)</span>即可.</p>
<p>但是直接对所有质因子做excrt复杂度不可接受.我们考虑如果对于质因子<span class="math inline">\(p\)</span>,<span class="math inline">\(\exists i ,
j \in [ 1 , n ] , i \ne j\)</span>有<span class="math inline">\(p | b_j
, p \nmid a_i , p \nmid b_i\)</span>,显然无解.如果有<span class="math inline">\(p | b_j , p | a_i , p \nmid
b_i\)</span>,显然要么无解,要么有唯一解,而且可以快速求出唯一解是谁,直接验证就行.</p>
<p>这样,我们就保证了所有需要做excrt的质因子必然全部出现,容易发现这样的质因子数量很少.</p>
<h4><span id="二次剩余">二次剩余</span></h4>
<p>求方程<span class="math inline">\(x^2 = k ( \mod m
)\)</span>的解.</p>
<p>我们先考虑一个特殊情况:<span class="math inline">\(k =
1\)</span>,<span class="math inline">\(m = p^k , p \in \mathrm{ prime
}\)</span>.</p>
<p>那么也就相当于求方程<span class="math inline">\(( x - 1 ) ( x + 1 )
\equiv 0 ( \mod p^k )\)</span>.</p>
<p>如果<span class="math inline">\(p &gt; 2\)</span>,那么显然<span class="math inline">\(x - 1\)</span>和<span class="math inline">\(x +
1\)</span>只有一个能被<span class="math inline">\(p^k\)</span>整除,所以有<span class="math inline">\(x = \pm 1\)</span>.</p>
<p>如果<span class="math inline">\(p = 2\)</span>,那么显然<span class="math inline">\(x - 1\)</span>和<span class="math inline">\(x +
1\)</span>有一个能被<span class="math inline">\(2\)</span>整除但不能被<span class="math inline">\(4\)</span>整除,另一个能被<span class="math inline">\(2^{ k - 1 }\)</span>整除,如果<span class="math inline">\(k = 1\)</span>时,显然只有一个解.当<span class="math inline">\(k = 2\)</span>时,同上.反之,有<span class="math inline">\(x = \pm 1\)</span>或<span class="math inline">\(x
= 2^{ k - 1 } \pm 1\)</span>.考虑一个性质:<span class="math inline">\((
2 k + 1 )^2 \equiv 1 ( \mod 8 )\)</span>.</p>
<p>那么如果:<span class="math inline">\(k = 1 , m \in \mathbb{ N_+
}\)</span>,也是一样的.先把<span class="math inline">\(m\)</span>作质因数分解,然后再用中国剩余定理合并,那么显然不同质数的解会累乘到总的解上,若<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同大于<span class="math inline">\(2\)</span>的质因子,总的解的个数是<span class="math inline">\(2^r\)</span>.而如果考虑<span class="math inline">\(p = 2\)</span>的情况,<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同的质因子,则解的个数为<span class="math inline">\(2^{ r + [ 8 | m ] + [ 4 | m ] - [ 2 | m ]
}\)</span>.</p>
<p>下面开始讲正经的二次剩余.</p>
<p>我们称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的二次剩余,当且仅当<span class="math inline">\(\exists b , b^2 \equiv a \pmod{ p
}\)</span>并且<span class="math inline">\(a \ne 0 \pmod{ p
}\)</span>,这里的<span class="math inline">\(p\)</span>是奇素数,如果<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的倍数且<span class="math inline">\(\nexists b , b^2 \equiv a \pmod{ p
}\)</span>,则称为二次非剩余.我们引入勒让德符号来表示这个东西:</p>
<p><span class="math display">\[
\left ( \frac{ a }{ p } \right ) = \begin{cases}
1 &amp; a 是 二 次 剩 余 \\
0 &amp; a \equiv 0 \pmod{ p } \\
- 1 &amp; a 为 二 次 非 剩 余
\end{cases}
\]</span></p>
<p>那么这玩意怎么求呢?我们有欧拉判别准则:</p>
<p><span class="math display">\[
\left ( \frac{ a }{ p } \right ) \equiv a^{ \frac{ p - 1 }{ 2 } } \pmod{
p }
\]</span></p>
<p>先证明个引理:若<span class="math inline">\(g\)</span>为<span class="math inline">\(\bmod p\)</span>意义下的原根,且<span class="math inline">\(a \equiv g^k\)</span>,那么<span class="math inline">\(x^2 \equiv a \pmod{ p
}\)</span>有解的充要条件是<span class="math inline">\(k\)</span>是偶数.</p>
<p>充分性显然,而必要性,我们考虑费马小定理:<span class="math inline">\(g^{ p - 1 } \equiv 1 \pmod{ p }\)</span>,而<span class="math inline">\(p -
1\)</span>是偶数,因此无论如何奇偶性都不会变.</p>
<p>接下来证明欧拉判别准则:</p>
<p><span class="math display">\[
\begin{aligned}
g^{ p - 1 } &amp; \equiv 1 \pmod{ p } \\
g^{ p - 1 } - 1 &amp; \equiv 0 \pmod{ p } \\
( g^{ \frac{ p - 1 }{ 2 } } + 1 ) ( g^{ \frac{ p - 1 }{ 2 } } - 1 )
&amp; \equiv 0 \pmod{ p } \\
g^{ \frac{ p - 1 }{ 2 } } &amp; \equiv - 1 \pmod{ p } \\
a^{ \frac{ p - 1 }{ 2 } } &amp; = ( g^k )^{ \frac{ p - 1 }{ 2 } } = (
g^{ p - 1 } )^{ \frac{ k }{ 2 } }
\end{aligned}
\]</span></p>
<p>于是得证.另外通过这个证明过程,我们可以发现<span class="math inline">\([ 1 , p - 1
]\)</span>中有正好一半的数是二次剩余,我们还能得知<span class="math inline">\(x^2 \equiv a \pmod{ p }\)</span>的解的数量是<span class="math inline">\(\left ( \frac{ a }{ p } \right ) + 1
\\\)</span>.</p>
<h5><span id="example1cf1091gnewyear-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</span></h5>
<p>考虑随机一个<span class="math inline">\(x\)</span>,令<span class="math inline">\(x &#39; = \sqrt{ x^2 } \pmod{ n
}\)</span>,如果<span class="math inline">\(x &#39; =
x\)</span>则放弃这次询问,不然自然有<span class="math inline">\(( x &#39;
- x ) ( x &#39; + x ) \equiv 0 \pmod{ n }\)</span>.</p>
<p><span class="math inline">\(\forall p | n , p \in \mathrm{ prime
}\)</span>,注意到一定满足<span class="math inline">\(p | ( x &#39; - x
)\)</span>或<span class="math inline">\(p | ( x &#39; + x
)\)</span>,我们可以多做几次,可以理解为这样将<span class="math inline">\(n\)</span>随机分割了.</p>
<h5><span id="example2qoj5021">Example2(qoj5021)</span></h5>
<p>整个题就强调一个字:双射!</p>
<p>先把模数质因数分解.</p>
<p>从头开始看,这种多元组计数肯定要一点一点确定,我们考虑固定<span class="math inline">\(( a , a &#39; )\)</span>求解<span class="math inline">\(( b , b &#39; )\)</span>,这个时候发现只要<span class="math inline">\(( a , a &#39; )\)</span>不全为<span class="math inline">\(0\)</span>,那么就有<span class="math inline">\(p\)</span>组<span class="math inline">\(( b , b
&#39; )\)</span>满足条件,这个可以通过移项求逆元发现.发现这个全为<span class="math inline">\(0\)</span>的条件很烦,我们先把它处理掉.</p>
<p>显然只有<span class="math inline">\(r =
0\)</span>会出现这种情况,讨论一下<span class="math inline">\(( a , a
&#39; )\)</span>全为<span class="math inline">\(0\)</span>或<span class="math inline">\(( b , b &#39; )\)</span>全为<span class="math inline">\(0\)</span>的情况,简单分类讨论可以得到共有<span class="math inline">\(2 p^3 + p^2 - 2 p\)</span>种方案.</p>
<p>好了,困难的部分被我们解决了,不过这样我们需要多讨论一下<span class="math inline">\(r\)</span>是否等于<span class="math inline">\(0\)</span>,不过问题不大.</p>
<p>先考虑<span class="math inline">\(r = 0\)</span>的情况:</p>
<p>注意到此时固定<span class="math inline">\(( a , a &#39;
)\)</span>会有<span class="math inline">\(p - 1\)</span>组(有一组全<span class="math inline">\(0\)</span>)<span class="math inline">\(( b , b
&#39; )\)</span>满足条件,此时有方程<span class="math inline">\(\begin{cases}ac + a &#39; c &#39; \equiv 0 \pmod{
p } \\ bc + b &#39; c &#39; \equiv 0 \pmod{ p
}\end{cases}\)</span>.显然若<span class="math inline">\(( b , b &#39; )
\equiv k ( a , a &#39; )\)</span>,那么该方程有<span class="math inline">\(p\)</span>组解,不然只有一组解.而前者相当于<span class="math inline">\(( a , a &#39; )\)</span>满足<span class="math inline">\(ka^2 + ka &#39;^2 \equiv 0\)</span>,我们设<span class="math inline">\(C_k\)</span>是方程<span class="math inline">\(a^2
+ a &#39;^2 \equiv k \pmod{ p
}\)</span>的解的数量,把上面的全部加起来,答案是:</p>
<p><span class="math display">\[
( C_0 - 1 ) ( p - 1 ) p + ( ( p^2 - 1 ) ( p - 1 ) - ( C_0 - 1 ) ( p - 1
) )
\]</span></p>
<p>化简一下得到:<span class="math inline">\(( C_0 - 1 ) ( p - 1 )^2 +
p^3 - p^2 - p + 1\)</span>.</p>
<p>再考虑<span class="math inline">\(r \ne 0\)</span>的情况:</p>
<p>注意到此时不可能有全为<span class="math inline">\(0\)</span>的二元组了.所以固定<span class="math inline">\(( a , a &#39; )\)</span>的话,<span class="math inline">\(( b , b &#39; )\)</span>共有<span class="math inline">\(p\)</span>组解,此时有方程<span class="math inline">\(\begin{cases}ac + a &#39; c &#39; \equiv r \pmod{
p } \\ bc + b &#39; c &#39; \equiv r \pmod{ p }\end{cases}\)</span>.</p>
<p>若<span class="math inline">\(( b , b &#39; ) \equiv k ( a , a &#39;
)\)</span>,显然当<span class="math inline">\(k = 1\)</span>时有<span class="math inline">\(p\)</span>组解,否则无解,此时<span class="math inline">\(a^2 + a &#39;^2 \equiv r \pmod{ p }\)</span>.</p>
<p>不然有唯一解.</p>
<p>而<span class="math inline">\(( b , b &#39; ) = k ( a , a &#39;
)\)</span>的方案有多少呢,显然是<span class="math inline">\(\sum_{ k = 1
}^{ p - 1 } C_{ \frac{ r }{ k } } = \sum_{ k = 1 }^{ p - 1 } C_k = p^2 -
C_0\)</span>,这里用到了这篇题解的第一个双射,<span class="math inline">\([ 1 , p - 1 ] / k \mapsto [ 1 , p - 1
]\)</span>.</p>
<p>于是这里的答案就是:</p>
<p><span class="math display">\[
C_r p + ( ( p^2 - 1 ) p - ( p^2 - C_0 ) )
\]</span></p>
<p>化简一下得到<span class="math inline">\(p^3 - p^2 - p + C_0 + C_r
p\)</span>.</p>
<p>现在的问题是如何求<span class="math inline">\(C_0 , C_r\)</span>.</p>
<p>先来技术总结一下,这种多元组计数通常要确定一些数字,然后对另一些数字进行计数,如果确定的那些数字不能进行枚举,那就得进行一些别的操作来在不同的情况下判断数量.</p>
<p>那么<span class="math inline">\(C_r\)</span>怎么求呢?考虑<span class="math inline">\(x^2 \equiv a \pmod{ p }\)</span>的解数为<span class="math inline">\(\left ( \frac{ a }{ p } \right ) +
1\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
C_r &amp; = \sum_{ i = 0 }^{ p - 1 } ( \left ( \frac{ i }{ p } \right )
+ 1 ) ( \left ( \frac{ r - i }{ p } \right ) + 1 ) \\
&amp; = \sum_{ i = 0 }^{ p - 1 } \left ( \frac{ i ( r - i ) }{ p }
\right ) + 2 \sum_{ i = 0 }^{ p - 1 } \left ( \frac{ i }{ p } \right ) +
p \\
&amp; = \sum_{ i = 1 }^{ p - 1 } \left ( \frac{ \frac{ r }{ i } - 1 }{ p
} \right ) + p
\end{aligned}
\]</span></p>
<p><del>(这是干啥啊)</del></p>
<p>我们来一步一步分析这个式子是怎么得到的:</p>
<p>首先,第一步仍然是枚举其中一个,然后求另一个.然后将整个式子乘开,做一个双射<span class="math inline">\(r - [ 0 , p - 1 ] \mapsto [ 0 , p - 1
]\)</span>就可以合并其中两项,而至于前两项则是根据欧拉判别准则直接将上指标乘起来合并.然后我们发现<span class="math inline">\(\sum_{ i = 0 }^{ p - 1 } \left ( \frac{ i }{ p }
\right ) = 0\)</span>,因为<span class="math inline">\([ 0 , p - 1
]\)</span>中一半是<span class="math inline">\(1\)</span>一半是<span class="math inline">\(- 1\)</span>,又可以发现<span class="math inline">\(i = 0\)</span>时显然为<span class="math inline">\(0\)</span>,<span class="math inline">\(x^2 = i ( r
- i ) \Leftrightarrow ( \frac{ x }{ i } )^2 = \frac{ r }{ i } -
1\)</span>,做双射<span class="math inline">\([ 1 , p - 1 ] \times i^{ -
1 } \mapsto [ 1 , p - 1 ]\)</span>.</p>
<p>做到这一步,自然有<span class="math inline">\(C_0 = ( p - 1 ) \left (
\frac{ - 1 }{ p } \right ) + p\)</span>.</p>
<p>而对于<span class="math inline">\(r \ne
0\)</span>的时候,我们再做双射<span class="math inline">\(r / [ 1 , p - 1
] \mapsto [ 1 , p - 1 ]\)</span>,于是<span class="math inline">\(C_r =
\sum_{ i = 0 }^{ p - 2 } \left ( \frac{ i }{ p } \right ) + p = p -
\left ( \frac{ - 1 }{ p } \right )\)</span>.</p>
<p>只能说模质数意义下的加法乘法减法以及不含<span class="math inline">\(0\)</span>的乘法都是群,而且所有运算都是双射,很牛逼,计数题直接起飞.</p>
<p>不过这题需要特别判断一下<span class="math inline">\(p =
2\)</span>的情况,也容易,暴力就行.</p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(2^a = 3^b + 1\)</span>和<span class="math inline">\(3^a = 2^b + 1\)</span>的所有解.</p>
<p>先看<span class="math inline">\(2^a = 3^b + 1\)</span>,显然<span class="math inline">\(( 2 , 1 )\)</span>是一组解.当<span class="math inline">\(y \geq 3\)</span>的时候,显然有<span class="math inline">\(3^a + 1 \equiv 0 \pmod{ 8 }\)</span>,而考虑<span class="math inline">\(3^{ 2 k } \equiv 1 \pmod{ 8
}\)</span>,这自然不可能.</p>
<p>再看<span class="math inline">\(3^a = 2^b + 1\)</span>.显然<span class="math inline">\(( 1 , 1 )\)</span>和<span class="math inline">\((
2 , 3 )\)</span>是两组解.当<span class="math inline">\(b \geq
2\)</span>的时候<span class="math inline">\(3^a \equiv 1 \pmod{ 4
}\)</span>,根据欧拉定理知道<span class="math inline">\(a \in \text{ even
}\)</span>,令<span class="math inline">\(a = 2 k\)</span>.自然有<span class="math inline">\(( 3^k - 1 ) ( 3^k + 1 ) =
2^b\)</span>,这是形如<span class="math inline">\(t ( t + 2 ) =
2^b\)</span>的形式,只有<span class="math inline">\(t =
2\)</span>是一个解.</p>
<h4><span id="bsgs">BSGS</span></h4>
<p>求<span class="math inline">\(a^x \equiv b ( \mod p
)\)</span>的一组解,其中<span class="math inline">\(p \in \mathrm{ prime
}\)</span>且<span class="math inline">\(1 \leq p \leq 10^9\)</span>.</p>
<p>直接枚举显然是<span class="math inline">\(O ( p
)\)</span>的,非常不合理,考虑如何优化.</p>
<p>求出<span class="math inline">\(s = \lfloor \sqrt{ p }
\rfloor\)</span>,并求出所有<span class="math inline">\(a^i\)</span>,其中<span class="math inline">\(i \in
[ 0 , s - 1 ]\)</span>.</p>
<p>若<span class="math inline">\(x \leq s -
1\)</span>.则可以直接判断是否被求出来过.</p>
<p>否则,则将<span class="math inline">\(x = x \mod ( s - 1
)\)</span>,一直操作直到<span class="math inline">\(x \leq s -
1\)</span>.</p>
<h4><span id="exbsgs">exBSGS</span></h4>
<p>求<span class="math inline">\(a^x \equiv b ( \mod p
)\)</span>的一组解,其中<span class="math inline">\(1 \leq p \leq
10^9\)</span>.</p>
<p>设<span class="math inline">\(g = \gcd ( a , p
)\)</span>,那么根据膜的性质,原方程即<span class="math inline">\(\frac{
a^x }{ g } \equiv \frac{ b }{ g } ( \mod \frac{ p }{ g } )\)</span>.</p>
<p>显然若<span class="math inline">\(g \nmid b\)</span>并且<span class="math inline">\(b \ne 1\)</span>,方程定无解.(若<span class="math inline">\(b = 1\)</span>,那么<span class="math inline">\(x =
0\)</span>就是一个解)</p>
<p>那么现在的方程就是<span class="math inline">\(a^{ x - 1 } \frac{ a }{
g } \equiv \frac{ b }{ g } ( \mod \frac{ p }{ g } )\)</span>.</p>
<p>继续进行这个过程,不断求<span class="math inline">\(a\)</span>和当前模数的<span class="math inline">\(\gcd\)</span>.并将当前模数除以该<span class="math inline">\(\gcd\)</span>,这样最后我们得到了方程:</p>
<p><span class="math inline">\(a^{ x - k } \prod_{ i = 1 }^k \frac{ a }{
g_i } \equiv \frac{ b }{ \prod_{ i = 1 }^k g_i } ( \mod \frac{ p }{
\prod_{ i = 1 }^k g_i } ) \\\)</span></p>
<p>不妨设<span class="math inline">\(A = \prod_{ i = 1 }^k \frac{ a }{
g_i } , B = \frac{ b }{ \prod_{ i = 1 }^k g_i } , P = \frac{ p }{
\prod_{ i = 1 }^k g_i } \\\)</span></p>
<p>那么现在方程就是<span class="math inline">\(a^{ x - k } \equiv \frac{
B }{ A } \pmod{ P }\)</span>,可以使用BSGS求解.</p>
<p>ps：<span class="math inline">\(p = 1\)</span>的时候要特判.</p>
<h4><span id="原根和阶">原根和阶</span></h4>
<p>阶:找到一个最小的<span class="math inline">\(k\)</span>使得<span class="math inline">\(a^k \equiv 1 ( \mod p )\)</span>,则称<span class="math inline">\(k\)</span>是<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶.</p>
<p>原根:如果<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶是<span class="math inline">\(\varphi ( p )\)</span>且<span class="math inline">\(a &lt; p\)</span>,则称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的一个原根.</p>
<p>若<span class="math inline">\(m\)</span>有原根,则<span class="math inline">\(m\)</span>一定是<span class="math inline">\(2\)</span>,<span class="math inline">\(4\)</span>或是<span class="math inline">\(p^a , 2
p^a\)</span>,其中<span class="math inline">\(p \in \mathrm{ prime
}\)</span>且<span class="math inline">\(2 \nmid p\)</span>.</p>
<p>由于对于大部分<span class="math inline">\(m\)</span>来说,都存在一个很小的原根,所以在实际应用中只需要暴力找就可以了.</p>
<p>根据阶的定义,我们如果要判断一个<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的原根,只需判断是否<span class="math inline">\(\exists i\)</span>使得<span class="math inline">\(a^i \equiv 1 ( \mod p )\)</span>.</p>
<p>而由于<span class="math inline">\(a^{ \varphi ( p ) } \equiv 1 ( \mod
p )\)</span>,因此一定有<span class="math inline">\(i | \varphi ( p
)\)</span>,因此只需判断<span class="math inline">\(\varphi ( p
)\)</span>的所有因数,复杂度<span class="math inline">\(O ( \sqrt{
\varphi ( p ) } )\)</span>.</p>
<p>事实上,只需要判断对于<span class="math inline">\(\varphi ( p
)\)</span>的所有质因子<span class="math inline">\(w\)</span>,是否有<span class="math inline">\(a^{ \frac{ \varphi ( p ) }{ w } } \equiv 1 ( \mod
p )\)</span>即可,复杂度<span class="math inline">\(O ( \omega ( p )
)\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定<span class="math inline">\(k\)</span>,<span class="math inline">\(p\)</span>,<span class="math inline">\(a\)</span>,求<span class="math inline">\(x^k
\equiv a ( \mod p )\)</span>的所有解,其中<span class="math inline">\(p
\in \mathrm{ prime }\)</span>,<span class="math inline">\(1 \leq k \leq
10^5\)</span>.</p>
<p>考虑求出<span class="math inline">\(p\)</span>的原根<span class="math inline">\(g\)</span>,得到<span class="math inline">\(g^r
\equiv a ( \mod p )\)</span>,同时由于<span class="math inline">\(x
\equiv g^y ( \mod p )\)</span>,因此原方程变为:<span class="math inline">\(g^{ yk } \equiv g^r ( \mod p )\)</span>.</p>
<p>于是有:<span class="math inline">\(yk \equiv r ( \mod p - 1
)\)</span>,即可求解.</p>
<h5><span id="example2具体数学447">Example2(《具体数学》4.47)</span></h5>
<p>证明:如果<span class="math inline">\(\exists n , n^{ m - 1 } \equiv 1
\pmod{ m }\)</span>,且对于所有满足<span class="math inline">\(p | ( m -
1 )\)</span>的<span class="math inline">\(p\)</span>都满足<span class="math inline">\(n^{ \frac{ m - 1 }{ p } } \ne 1 \pmod{ m
}\)</span>,那么<span class="math inline">\(m\)</span>是素数.</p>
<p>首先不难发现,<span class="math inline">\(m \in \ \mathrm{ prime }
\Leftrightarrow \varphi ( m ) = m - 1\)</span>.</p>
<p>考虑上面的过程中,不可能存在一个数<span class="math inline">\(k\)</span>满足<span class="math inline">\(0 \leq k
&lt; m - 1 , n^k \equiv 1 \pmod{ m }\)</span>.因此<span class="math inline">\(\nexists 0 \leq i , j &lt; m , i \ne j , n^i
\equiv n^j \pmod{ m }\)</span>.</p>
<p>根据欧拉定理,<span class="math inline">\(m - 1 = \varphi ( m
)\)</span>,因此得证.</p>
<h3><span id="积性函数">积性函数</span></h3>
<p>若函数<span class="math inline">\(f ( x )\)</span>满足<span class="math inline">\(\forall n , m \in \mathbb{ N_+ } , n \bot
m\)</span>,有<span class="math inline">\(f ( 1 ) = 1 , f ( nm ) = f ( n
) f ( m )\)</span>,则称其为积性函数.若<span class="math inline">\(\forall n , m \in \mathbb{ N_+ }\)</span>,有<span class="math inline">\(f ( 1 ) = 1 , f ( nm ) = f ( n ) f ( m
)\)</span>,则称其为完全积性函数.</p>
<p>若函数<span class="math inline">\(g ( x
)\)</span>是积性函数并且有<span class="math inline">\(g ( m ) = \sum_{ d
| m } f ( d )\)</span>,则<span class="math inline">\(f ( x
)\)</span>也是积性函数,证明如下:</p>
<p>不妨考虑数学归纳,首先<span class="math inline">\(g ( 1 ) = f ( 1 ) =
1\)</span>.</p>
<p>令<span class="math inline">\(m = m_1 m_2 , m_1 \bot
m_2\)</span>,则<span class="math inline">\(g ( m ) = \sum_{ d | m } f (
d ) = \sum_{ d_1 | m_1 } \sum_{ d_2 | m_2 } f ( d_1 d_2
)\)</span>.由于归纳假设,此时只有<span class="math inline">\(d_1 = m_1
\land d_2 = m_2\)</span>的时候,<span class="math inline">\(f ( d_1 d_2
)\)</span>可能不等于<span class="math inline">\(f ( d_1 ) f ( d_2
)\)</span>.</p>
<p>于是有</p>
<p><span class="math display">\[
\begin{aligned}
g ( m ) &amp; = \sum_{ d_1 | m_1 } \sum_{ d_2 | m_2 } f ( d_1 ) f ( d_2
) - f ( m_1 ) f ( m_2 ) + f ( m_1 m_2 ) \\
&amp; = g ( m_1 m_2 ) - f ( m_1 ) f ( m_2 ) + f ( m_1 m_2 )
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(f ( m_1 ) f ( m_2 ) = f ( m_1 m_2
)\)</span>.</p>
<p>该命题的逆命题也是同样成立的.有一些常见的积性函数,比如:<span class="math inline">\(id ( x ) = x\)</span>,<span class="math inline">\(I ( x ) = 1\)</span>,<span class="math inline">\(\varepsilon ( x ) = [ x = 1 ]\)</span>.</p>
<h5><span id="example具体数学458">Example(《具体数学》4.58)</span></h5>
<p>求:<span class="math inline">\(f ( m ) = \sum_{ d | m }
d\)</span>是<span class="math inline">\(2\)</span>的整数次幂的充分必要条件.</p>
<p>不难发现<span class="math inline">\(f\)</span>是一个积性函数,于是考虑<span class="math inline">\(f ( p^k ) = 1 + p + p^2 + . . . +
p^k\)</span>.</p>
<p>当<span class="math inline">\(p =
2\)</span>的时候,显然不满足条件.</p>
<p>不然,只有<span class="math inline">\(k\)</span>是奇数的时候,<span class="math inline">\(f ( p^k )\)</span>才是一个偶数.</p>
<p>而此时<span class="math inline">\(f ( p^k ) = ( 1 + p ) ( 1 + p^2 +
p^4 + . . . + p^{ k - 1 } ) = ( 1 + p ) ( 1 + p^2 ) ( 1 + p^4 + . . . +
p^{ k - 3 } )\)</span>.其是<span class="math inline">\(2\)</span>的整数次幂的一个必要条件是<span class="math inline">\(p\)</span>是一个梅森素数,而且不难发现只有当<span class="math inline">\(k = 1\)</span>的时候才满足条件.</p>
<p>于是充分必要条件是:<span class="math inline">\(m\)</span>是若干个不同的梅森素数的乘积.</p>
<h4><span id="狄利克雷卷积">狄利克雷卷积</span></h4>
<p><span class="math inline">\(f * g = \sum_{ d | n }{ f ( d ) g (
\cfrac{ n }{ d } ) }\)</span>.</p>
<p>不难证明狄利克雷卷积满足:</p>
<ol type="1">
<li><p>交换律:<span class="math inline">\(f * g = g *
f\)</span>.</p></li>
<li><p>结合律:<span class="math inline">\(f * ( g * h ) = ( f * g ) *
h\)</span>.</p></li>
<li><p>分配律:<span class="math inline">\(f * ( g + h ) = f * g + f *
h\)</span>.</p></li>
<li><p>若<span class="math inline">\(f , g\)</span>是积性函数,则<span class="math inline">\(f * g\)</span>也是积性函数.</p></li>
</ol>
<p>考虑第四条的证明:</p>
<p><span class="math display">\[
\begin{aligned}
f * g ( nm ) &amp; = \sum_{ d | ( nm ) } f ( d ) g ( \cfrac{ n }{ d } )
\\
&amp; = \sum_{ c | n } \sum_{ d | m } f ( cd ) g ( \cfrac{ nm }{ cd } )
\\
&amp; = \sum_{ c | n } \sum_{ d | m } f ( c ) f ( d ) g ( \cfrac{ n }{ c
} ) g ( \cfrac{ m }{ d } ) \\
&amp; = ( f * g ( n ) ) \times ( f * g ( m ) )
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(\forall f , f ( 1 ) \ne 0\)</span>,<span class="math inline">\(\exists f^{ - 1 }\)</span>,<span class="math inline">\(f * f^{ - 1 } = \epsilon\)</span>.</li>
</ol>
<p>构造<span class="math inline">\(g ( x )\)</span>满足<span class="math inline">\(f ( 1 ) g ( x ) = \epsilon ( x ) - \sum_{ d | x ,
d \ne 1 } f ( d ) g ( \frac{ x }{ d } )\)</span>显然就是满足条件的.</p>
<ol start="6" type="1">
<li>积性函数的逆元也是积性函数.</li>
</ol>
<h4><span id="欧拉函数">欧拉函数</span></h4>
<p>定义欧拉函数<span class="math inline">\(\varphi ( m
)\)</span>为所有满足<span class="math inline">\(1 \leq n \leq m \land n
\perp m\)</span>的<span class="math inline">\(n\)</span>的个数.</p>
<p>令<span class="math inline">\(m = m_1 m_2\)</span>,其中<span class="math inline">\(m_1 \bot m_2\)</span>.由于若<span class="math inline">\(n \bot m_1 , n \bot m_2\)</span>,显然有<span class="math inline">\(( n \mod m_1 ) \bot m_1\)</span>且<span class="math inline">\(( n \mod m_2 ) \bot
m_2\)</span>,则根据中国剩余定理,不难有<span class="math inline">\(\varphi ( m ) = \varphi ( m_1 ) \varphi ( m_2
)\)</span>,也即<span class="math inline">\(\varphi ( x
)\)</span>是积性函数.</p>
<p>若<span class="math inline">\(n = \prod^{ k }_{ i = 1 } p_i^{ a_i
}\)</span>,则:</p>
<p><span class="math inline">\(\varphi ( n ) = \prod^k_{ i = 1 } \varphi
( p_i^{ a_i } ) = \prod^k_{ i = 1 }{ p_i^{ a_i } - p_i^{ a_i - 1 } } =
\prod^k_{ i = 1 }{ p^{ a_i - 1 } ( p_i - 1 ) }\)</span>.</p>
<p>考虑改变枚举方式,因为<span class="math inline">\(n = \prod_{ p | n }
p^{ a_p }\)</span>,则:<span class="math inline">\(\varphi ( n ) =
\prod_{ p | n }{ p^{ a_p - 1 } ( p - 1 ) } = \prod_{ p | n }{ ( p^{ a_p
} \times \cfrac{ p - 1 }{ p } ) } = n \times \prod_{ p | n } \cfrac{ p -
1 }{ p }\)</span>.</p>
<p>我们考虑一个事实:现在有<span class="math inline">\(m\)</span>个不同的分数<span class="math inline">\(\cfrac{ k }{ m } , k \in [ 1 , m
]\)</span>,这些分数进行约分后,它们的分母即<span class="math inline">\(m\)</span>的若干因数,而它们的分子就是与这些因数互质的数,同时这些数的个数总共是<span class="math inline">\(m\)</span>个,我们可以得到:<span class="math inline">\(\sum_{ d | m } \varphi ( d ) = m\)</span>.</p>
<p>上面这个结论还有另一种证明方法:</p>
<p>由于<span class="math inline">\(\varphi\)</span>是积性函数,若<span class="math inline">\(n \ne 1\)</span>,设<span class="math inline">\(n =
\prod_{ i = 1 }^k p_i^{ q_i }\)</span>,则<span class="math inline">\(\varphi ( n ) = \prod_{ i = 1 }^k \varphi ( p_i^{
q_i } )\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ d | n } \varphi ( d ) &amp; = \sum_{ w_1 = 0 }^{ q_1 } \sum_{ w_2
= 0 }^{ q_2 } . . . . . . \sum_{ w_k = 0 }^{ q_k }{ \varphi ( p_1^{ w_1
} ) \varphi ( p_2^{ w_2 } ) . . . . . . \varphi ( p_k^{ w_k } ) } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而<span class="math inline">\(\varphi ( p^q ) = p^q - p^{ q - 1
}\)</span>,于是有<span class="math inline">\(\sum_{ i = 1 }^{ q_i }{ (
p_x^i - p_x^{ i - 1 } ) } = ( p_x^{ q_x } - 1 )\)</span>,则有<span class="math inline">\(\sum_{ i = 0 }^{ q_x } \varphi ( p_x^{ i } ) =
p_x^{ q_x }\)</span>.</p>
<p>则原式等于<span class="math inline">\(\prod_{ i = 1 }^k p_i^{ q_i } =
n\)</span>.</p>
<h5><span id="和法里级数的关系">和法里级数的关系</span></h5>
<p>我们考虑之前提到的法里级数<span class="math inline">\(\mathcal{ F
}_n\)</span>,令<span class="math inline">\(\Phi ( x ) = \sum_{ 1 \leq k
\leq x } \varphi ( k )\)</span>,那么<span class="math inline">\(\mathcal{ F }_n\)</span>的个数显然是<span class="math inline">\(\Phi ( x ) + 1\)</span>.</p>
<p>接下来我们思考如何计算<span class="math inline">\(\Phi ( x
)\)</span>.事实上,我们有<span class="math inline">\(\sum_{ d = 1 }^n
\Phi ( \lfloor \cfrac{ n }{ d } \rfloor ) = \cfrac{ 1 }{ 2 } ( n + 1 )
n\)</span>.这里的证明是:考虑满足<span class="math inline">\(0 \leq a
&lt; b \leq n\)</span>的分数<span class="math inline">\(\cfrac{ a }{ b
}\)</span>共有<span class="math inline">\(\cfrac{ 1 }{ 2 } n ( n + 1
)\)</span>个,而如果我们枚举<span class="math inline">\(d = \gcd ( a , b
)\)</span>,那么显然右边也等于这些分数个数,于是得证.</p>
<p>而事实上,如果我们用<span class="math inline">\(n = \lfloor x
\rfloor\)</span>来带入上面的式子,可以得到<span class="math inline">\(\sum_{ d = 1 } \Phi ( \cfrac{ x }{ d } ) = \cfrac{
1 }{ 2 } \lfloor x \rfloor \lfloor 1 + x \rfloor\)</span>.</p>
<p>根据第三种莫比乌斯反演的形式,我们有:<span class="math inline">\(\Phi
( x ) = \cfrac{ 1 }{ 2 } \sum_{ 1 \leq d } \mu ( d ) \lfloor \cfrac{ x
}{ d } \rfloor \lfloor \cfrac{ x }{ d } + 1 \rfloor\)</span>.</p>
<h5><span id="麦克马洪和式">麦克马洪和式</span></h5>
<p>考虑这个问题:我们现在有<span class="math inline">\(m\)</span>种颜色,要对一个长度为<span class="math inline">\(n\)</span>的圆环进行染色,旋转后相同算一种方案,求方案数.</p>
<p>我们先设答案为<span class="math inline">\(N ( n , m
)\)</span>,并将这些答案全部列举出来,然后将它们进行旋转,进行<span class="math inline">\(n - 1\)</span>次.这样我们就得到了<span class="math inline">\(nN ( n , m
)\)</span>个圆环,但是这些圆环是有重复的.</p>
<p>那么我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
nN ( n , m ) &amp; = \sum_{ a_0 a_1 . . . a_{ n - 1 } } \sum_{ 0 \leq k
&lt; n } [ a_0 a_1 . . . a_{ n - 1 } = a_k . . . a_{ n - 1 } a_0 . . .
a_{ k - 1 } ] \\
&amp; = \sum_{ 0 \leq k &lt; n } \sum_{ a_0 a_1 . . . a_{ n - 1 } } [
a_0 a_1 . . . a_{ n - 1 } = a_k . . . a_{ n - 1 } a_0 . . . a_{ k - 1 }
]
\end{aligned}
\]</span></p>
<p>接下来我们只需要知道,当已知<span class="math inline">\(k\)</span>的时候,右边和式的贡献是多少.显然此时有<span class="math inline">\(a_i = a_{ ( i + k ) \mod n }\)</span>,也就是<span class="math inline">\(a_i = a_{ ( i + kl ) \mod n
}\)</span>,此时答案为<span class="math inline">\(m^{ \gcd ({ n , k } )
}\)</span>.</p>
<p>为啥答案为<span class="math inline">\(m^{ \gcd ( n , k )
}\)</span>呢?我们考虑这一定会不断在<span class="math inline">\(a\)</span>中取数,那么会取多少数呢?显然会取<span class="math inline">\(x - 1\)</span>个数,其中<span class="math inline">\(i + xk = i + yn\)</span>,不难解得此时<span class="math inline">\(x = \frac{ n }{ \gcd ( k , n )
}\)</span>,因此一共有<span class="math inline">\(\gcd ( n , k
)\)</span>个轨道.</p>
<p>也就是说:<span class="math inline">\(nN ( n , m ) = \sum_{ 0 \leq k
&lt; n } m^{ \gcd ( n , k ) } , N ( n , m ) = \cfrac{ 1 }{ n } \sum_{ 0
\leq k &lt; n } m^{ \gcd ( n , k ) } \\\)</span>.</p>
<p>如果我们对这个式子进行化简:</p>
<p><span class="math display">\[
\begin{aligned}
N ( n , m ) &amp; = \cfrac{ 1 }{ n } \sum_{ d | n } m^d \sum_{ 0 \leq k
&lt; n } [ d = \gcd ( n , k ) ] \\
&amp; = \cfrac{ 1 }{ n } \sum_{ d | n } m^d \sum_{ d | k , k &lt; n } [
\cfrac{ k }{ d } \bot \cfrac{ n }{ d } ] \\
&amp; = \cfrac{ 1 }{ n } \sum_{ d | n } m^d \sum_{ 0 \leq k &lt; \frac{
n }{ d } } [ k \bot \cfrac{ n }{ d } ] \\
&amp; = \cfrac{ 1 }{ n } \sum_{ d | n } \varphi ( d ) m^{ \frac{ n }{ d
} } .
\end{aligned}
\]</span></p>
<p>这个式子被称为麦克马洪公式.</p>
<p>另外,如果我们考虑<span class="math inline">\(n | ( \sum_{ d | n }
\varphi ( d ) n^{ \frac{ n }{ d } } )\)</span>这件事的证明,考虑如果<span class="math inline">\(n =
p^k\)</span>,那么根据费马小定理,显然可证明.</p>
<p>而由于<span class="math inline">\(\varphi ( x
)\)</span>是积性函数,令<span class="math inline">\(n = n_1 n_2 , n_1
\bot n_2\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ d | n } \varphi ( d ) n^{ \frac{ n }{ d } } &amp; = \sum_{ d_1 |
n_1 , d_2 | n_2 } \varphi ( d_1 d_2 ) n^{ \frac{ n_1 n_2 }{ d_1 d_2 } }
\\
&amp; = \sum_{ d_1 | n_1 } \varphi ( d_1 ) ( \sum_{ d_2 | n_2 } \varphi
( d_2 ) ( n^{ \frac{ n_1 }{ d_1 } } )^{ \frac{ n_2 }{ d_2 } } )
\end{aligned}
\]</span></p>
<p>我们可以通过数学归纳来证明.</p>
<h5><span id="burnside定理">Burnside定理</span></h5>
<p>现在让我们来进行一些抽象代数的计算.</p>
<p>置换群:运算<span class="math inline">\(( a_1 , a_2 , . . . , a_k
)\)</span>表示将<span class="math inline">\(a_1\)</span>放到<span class="math inline">\(a_2\)</span>位置…把<span class="math inline">\(a_i\)</span>放到<span class="math inline">\(a_{ i
+ 1 }\)</span>的位置…把<span class="math inline">\(a_k\)</span>放到<span class="math inline">\(a_1\)</span>的位置,而幺元<span class="math inline">\(e = ( 1 ) ( 2 ) ( 3 ) . . . ( n )\)</span>.</p>
<p>由麦克马洪和式的证明,我们不难推导出Polya定理:设要对<span class="math inline">\(n\)</span>个元素用<span class="math inline">\(m\)</span>种颜色染色,若通过某种旋转得到的染色方案算同一种,考虑旋转一定是一种置换,则本质不同的染色方案数<span class="math inline">\(= \cfrac{ \sum_{ s \in S } m^{ \eta ( s ) } }{ | S
| }\)</span>,其中<span class="math inline">\(\eta ( s
)\)</span>表示<span class="math inline">\(s\)</span>的轨道数,即有多少组置换.</p>
<h6><span id="example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</span></h6>
<p>首先看到循环同构,第一反应就是Burnside定理.考虑将每条边的状态设为两种:选或不选,那么我们就对点的编号进行置换,然后找到不动边的数量.</p>
<p>我们先考虑对于一个置换,该如何求得它的不动边的数量.考虑置换是一个排列,对它做置换环分解.</p>
<p>现在问题在于置换环内和置换环间要分别求不动点的数量.</p>
<p>先来考虑置换环内:由于是一个置换环,我们假设它的大小是<span class="math inline">\(b\)</span>,将这<span class="math inline">\(b\)</span>个点排成一个正<span class="math inline">\(b\)</span>边形(<span class="math inline">\(b\)</span>个点的完全图),考虑一个一条边转多少次才能转回来,如果不是<span class="math inline">\(b\)</span>是偶数并且这条边正好平分整个多边形的话,显然需要转<span class="math inline">\(n\)</span>次,简单判掉特殊情况,发现轨道数量<span class="math inline">\(\lfloor \frac{ b }{ 2 } \rfloor\)</span>.</p>
<p>接下来考虑置换环外:对于两个置换环间,对于一条边,我们考虑不断做置换,做多少次才能使这条边回归原位置.注意到需要做<span class="math inline">\(lcm ( b_1 , b_2 )\)</span>次.而总共有<span class="math inline">\(b_1 b_2\)</span>条边,于是轨道数量<span class="math inline">\(\frac{ b_1 b_2 }{ lcm ( b_1 , b_2 ) } = \gcd ( b_1
, b_2 )\)</span>.</p>
<p>这样对于一个<span class="math inline">\(k\)</span>个环的置换,它的答案就是<span class="math inline">\(\sum_{ i = 1 }^k \lfloor \frac{ b_i }{ 2 } \rfloor
+ \sum_{ i = 1 }^k \sum_{ j = i + 1 }^k \gcd ( b_i , b_j )\)</span>.</p>
<p>接下来发现本质不同的置换不多,搜出来每个置换环的大小,暴力判断.</p>
<h5><span id="欧拉定理">欧拉定理</span></h5>
<p>当<span class="math inline">\(a \perp m\)</span>时,<span class="math inline">\(a^{ \varphi ( m ) } \equiv 1 ( \mod m
)\)</span>.</p>
<p>证明考虑取出<span class="math inline">\([ 1 , m
]\)</span>中所有和<span class="math inline">\(m\)</span>互质的数,设它们为<span class="math inline">\(b_1 , b_2 , \cdots , b_{ \varphi ( m )
}\)</span>.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\prod_{ k = 1 }^{ \varphi ( m ) } ab_k &amp; \equiv \prod_{ k = 1 }^{
\varphi ( m ) } ( ab_k \bmod p ) ( \mod p ) \\
a^{ \varphi ( m ) } \prod_{ k = 1 }^{ \varphi ( m ) } b_k &amp; \equiv
\prod_{ k = 1 }^{ \varphi ( m ) } b_k ( \mod p )
\end{aligned}
\]</span></p>
<p>欧拉定理可以用来求逆元:<span class="math inline">\(a^{ \varphi ( p )
} \equiv 1 ( \mod p )\)</span>,则有<span class="math inline">\(a^{ - 1 }
\equiv a^{ \varphi ( p ) - 1 } ( \mod p )\)</span>.</p>
<h5><span id="扩展欧拉定理">扩展欧拉定理</span></h5>
<p><span class="math inline">\(a^b \equiv a^c ( \mod m
)\)</span>,其中</p>
<span class="math display">\[\begin{cases}

b\bmod \varphi(m) &amp;a\perp m\\

b &amp;b&lt;\varphi(m)\\

(b\bmod \varphi(m))+\varphi(m) &amp;other

\end{cases}\]</span>
<p>证明如下:</p>
<p>设<span class="math inline">\(m = \prod^k_{ i = 1 } p_i^{ e_i
}\)</span>,则要证<span class="math inline">\(a^b \equiv a^{ ( b \mod
\varphi ( m ) ) + \varphi ( m ) } ( \mod m )\)</span>,即证<span class="math inline">\(\forall i\)</span>都有<span class="math inline">\(a^b \equiv a^{ ( b \mod \varphi ( m ) ) + \varphi
( m ) } ( \mod p_i^{ e_i } )\)</span>.</p>
<p>分情况讨论:</p>
<p>若<span class="math inline">\(p_i^{ e_i } \perp
a\)</span>,则为普通欧拉定理情况,即证明<span class="math inline">\(\varphi ( p_i^{ e_i } )\)</span>是<span class="math inline">\(b - c\)</span>的因数.由于<span class="math inline">\(\varphi ( p_i^{ e_i } )\)</span>是<span class="math inline">\(\varphi ( m )\)</span>的因数,而<span class="math inline">\(\varphi ( m )\)</span>是<span class="math inline">\(b - c\)</span>的因数,显然得证.</p>
<p>不然,发现<span class="math inline">\(e_i \leq \varphi ( p_i^{ e_i } )
\leq \varphi ( m ) \leq b\)</span>且<span class="math inline">\(\varphi
( m ) \leq c\)</span>,又发现<span class="math inline">\(p_i^{ e_i } |
a^{ e_i }\)</span>,所以<span class="math inline">\(p_i^{ e_i } |
a^b\)</span>,<span class="math inline">\(p_i^{ e_i } |
a^c\)</span>,左右两边均为<span class="math inline">\(0\)</span>,得证.</p>
<h6><span id="example1cf906d-power-tower">Example1(CF906D Power Tower)</span></h6>
<p>考虑每次暴力做扩展欧拉定理,注意到每次会把<span class="math inline">\(p\)</span>变成<span class="math inline">\(\varphi
( p )\)</span>,如果<span class="math inline">\(p\)</span>是奇数,那它下一步会变为偶数,如果<span class="math inline">\(p\)</span>是偶数,则下一步至少减半,于是迭代次数是<span class="math inline">\(\log n\)</span>级别的.</p>
<h6><span id="example2六省联考-2017相逢是问候">Example2([六省联考 2017]
相逢是问候)</span></h6>
<p>同上.</p>
<h6><span id="example3具体数学454">Example3(《具体数学》4.54)</span></h6>
<p>求<span class="math inline">\(1000 ! \pmod{ 10^{ 250 }
}\)</span>.</p>
<p>首先,根据前面的例题,不难发现<span class="math inline">\(5^{ 249 }
\times 2^{ 994 } \mid ( 1000 ! )\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
1000 ! &amp; \equiv ans \pmod{ 10^{ 250 } } \\
\cfrac{ 1000 ! }{ 10^{ 249 } } &amp; \equiv \cfrac{ ans }{ 10^{ 249 } }
\pmod{ 10 }
\end{aligned}
\]</span></p>
<p>由于模数现在变成了<span class="math inline">\(10\)</span>,考虑<span class="math inline">\(1 \times 3 \times 3 \times 7 \times 9 \mod{ 10 } =
7\)</span>,于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\cfrac{ ans }{ 10^{ 249 } } &amp; \equiv 2^{ 745 } \times 7^{ 100 }
\pmod{ 10 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而<span class="math inline">\(\varphi ( 10 ) =
4\)</span>,根据扩展欧拉定理:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ ans }{ 10^{ 249 } } &amp; \equiv 2^{ 5 } \pmod{ 10 } \\
ans &amp; \equiv 2 \times 10^{ 249 } \pmod{ 10^{ 250 } }
\end{aligned}
\]</span></p>
<h5><span id="example1具体数学457">Example1(《具体数学》4.57)</span></h5>
<p>求证:<span class="math inline">\(\sum_{ 1 \leq k \leq n + m } \varphi
( k ) [ ( m \mod k ) + ( n \mod k ) \geq k ] = nm \\\)</span>.</p>
<p>先考虑将条件改为一个更好处理的式子,不难发现:</p>
<p><span class="math display">\[
[ m \bmod k + n \bmod k \geq k ] = \lfloor \cfrac{ n + m }{ k } \rfloor
- \lfloor \cfrac{ n }{ k } \rfloor - \lfloor \cfrac{ m }{ k } \rfloor
\]</span></p>
<p>于是接下来我们要处理的式子形如<span class="math inline">\(\sum_{ 1
\leq k \leq n } \varphi ( k ) \lfloor \cfrac{ n }{ k } \rfloor
\\\)</span>.</p>
<p>对其增加枚举量:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq k \leq n } \varphi ( k ) \lfloor \cfrac{ n }{ k } \rfloor
&amp; = \sum_{ 1 \leq k \leq n } \varphi ( k ) \sum_{ d = 1 }^{ \lfloor
\frac{ n }{ k } \rfloor } 1 \\
&amp; = \sum_{ k = 1 }^n \sum_{ d | k } \varphi ( d ) \\
&amp; = \sum_{ k = 1 }^n k = \cfrac{ ( n + 1 ) n }{ 2 }
\end{aligned}
\]</span></p>
<p>带入即可证明.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{ 1 \leq a , b \leq p ( p - 1 ) }
[ a^b \equiv b^a ( \mod p ) ] , p \in \mathrm{ prime }\)</span>.</p>
<p>考虑<span class="math inline">\(p \bot ( p - 1
)\)</span>,使用中国剩余定理,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq a , b \leq p ( p - 1 ) } [ a^b &amp; \equiv b^a ( \mod p )
] \\
&amp; = \sum_{ 0 \leq a , b &lt; p } \sum_{ 0 \leq c , d &lt; p - 1 } [
a^c \equiv b^d ( \mod p ) ] \\
&amp; = ( p - 1 )^2 + \sum_{ 1 \leq a , b &lt; p } \sum_{ 0 \leq c , d
&lt; p - 1 } [ a^c \equiv b^d ( \mod p ) ]
\end{aligned}
\]</span></p>
<p>后面那部分的答案是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq a , b &lt; p } \sum_{ 0 \leq c , d &lt; p - 1 } [ a^c
&amp; \equiv b^d ( \mod p ) ] \\
&amp; = \sum_{ 1 \leq x &lt; p } \sum_{ 0 \leq a , b &lt; p } \sum_{ 1
\leq c , d &lt; p - 1 } [ a^c \equiv x ( \mod p ) ] [ b^d \equiv x (
\mod p ) ] \\
&amp; = \sum_{ 1 \leq x &lt; p } ( \sum_{ 1 \leq a &lt; p , 0 \leq c
&lt; p - 1 } [ a^c \equiv x ( \mod p ) ] )^2
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(g\)</span>为<span class="math inline">\(p\)</span>的原根,令<span class="math inline">\(a =
g^b\)</span>,<span class="math inline">\(x = g^{ x &#39;
}\)</span>有:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 1 \leq x &lt; p } ( \sum_{ 1 \leq a &lt; p , 0 \leq c &lt; p - 1
} [ a^c &amp; \equiv x ( \mod p ) ] )^2 \\
&amp; = \sum_{ 0 \leq x &#39; &lt; p - 1 } ( \sum_{ 0 \leq b &lt; p - 1
, 0 \leq c &lt; p - 1 } [ bc \equiv x &#39; ( \mod p - 1 ) ] )^2 \\
&amp; = \sum_{ 0 \leq x &lt; p - 1 } ( \sum_{ 0 \leq a , b &lt; p - 1 }
[ ab \equiv x ( \mod p - 1 ) ] )^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑前面那个式子,如果我们令<span class="math inline">\(x = x_0 x_1 ,
x_0 \bot x_1\)</span>,<span class="math inline">\(p - 1 = p_0 p_1 , p_0
\bot p_1\)</span>,其中<span class="math inline">\(0 \leq x_0 &lt; p_0 ,
0 \leq x_1 &lt; p_1\)</span>,后面那个式子为<span class="math inline">\(f
( p - 1 , x )\)</span>,由于中国剩余定理,有<span class="math inline">\(f
( p - 1 , x ) = f ( p_0 , x_0 ) f ( p_1 , x_1 )\)</span>.</p>
<p>于是令<span class="math inline">\(p - 1 = \prod_{ i = 1 }^k p_i^{ q_i
}\)</span>上面的式子可以改为:</p>
<p><span class="math display">\[
\prod_{ i = 1 }^k ( \sum_{ 0 \leq x_i &lt; p_i^{ q_i } } ( \sum_{ 0 \leq
a , b &lt; p_i^{ q_i } } [ ab \equiv x_i ( \mod p_i^{ q_i } ) ] )^2 )
\]</span></p>
<p>我们只考虑其中一项,形如:</p>
<p><span class="math display">\[
\sum_{ 0 \leq x &lt; p^{ q } } ( \sum_{ 0 \leq a , b &lt; p^q } [ ab
\equiv x ( \mod p^{ q } ) ] )^2
\]</span></p>
<p>我们不妨用<span class="math inline">\(ap^{ \alpha }\)</span>代替<span class="math inline">\(a\)</span>,<span class="math inline">\(bp^\beta\)</span>代替<span class="math inline">\(b\)</span>,<span class="math inline">\(xp^t\)</span>代替<span class="math inline">\(x\)</span>,其中<span class="math inline">\(a , b ,
x \bot p\)</span>那么有:</p>
<p><span class="math display">\[
\sum_{ 0 \leq x &lt; p^{ q - t } } ( \sum_{ 0 \leq a &lt; p^{ q - \alpha
} , 0 \leq b &lt; p^{ q - \beta } } [ abp^{ \alpha + \beta } \equiv xp^t
( \mod p^{ q } ) ] )^2
\]</span></p>
<p>则我们要做的即对四元组<span class="math inline">\(( a , b , \alpha ,
\beta )\)</span>计数.由于<span class="math inline">\(a , b , x \bot
p\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha + \beta &amp; = t , \alpha , \beta \in \mathbb{ N } \\
ab &amp; \equiv x \pmod{ p^{ q - t } } , 0 \leq a &lt; p^{ q - \alpha }
, 0 \leq b &lt; p^{ q - \beta }
\end{aligned}
\]</span></p>
<p>第一个式子对四元组的贡献显然是<span class="math inline">\(t +
1\)</span>,而第二个式子,由于<span class="math inline">\([ 1 , p^{ q - t
} ) \in [ 1 , p^{ q - \alpha } )\)</span>,所以我们可以先求出<span class="math inline">\(1 \leq a &lt; p^{ q - t
}\)</span>的答案,然后乘以<span class="math inline">\(p^{ t - \alpha
}\)</span>得到答案,<span class="math inline">\(b\)</span>是类似的,于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ 1 \leq x &lt; p^{ q - t } } ( ( t + 1 ) p^{ t -
\alpha } p^{ t - \beta } \sum_{ 1 \leq a , b &lt; p^{ q - t } } [ ab
\equiv x \pmod{ p^{ q - t } } ] )^2 + ( \sum_{ 1 \leq a , b \leq p^q } [
ab \equiv 0 \pmod{ p^{ q } } ] )^2 \\
&amp; = \sum_{ 1 \leq x &lt; p^{ q - t } } ( ( t + 1 ) p^{ t - \alpha }
p^{ t - \beta } \sum_{ 1 \leq a , b &lt; p^{ q - t } } [ ab \equiv x
\pmod{ p^{ q - t } } ] )^2 + q ( p - 1 ) p^{ q - 1 } + p^q
\end{aligned}
\]</span></p>
<p>后面,由于<span class="math inline">\(a \bot p\)</span>,显然一个<span class="math inline">\(a\)</span>唯一对应一个<span class="math inline">\(b\)</span>.于是我们得到了答案为:</p>
<p><span class="math display">\[
\sum_{ 1 \leq x &lt; p^{ q - t } } ( ( t + 1 ) p^{ t } \varphi ( p^{ q -
t } ) )^2
\]</span></p>
<p>而后面的式子显然跟<span class="math inline">\(x\)</span>无关,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ 0 &lt; x &lt; p^{ q - t } } ( ( t + 1 ) p^{ t } \varphi (
p^{ q - t } ) )^2 \\
= &amp; \sum_{ 0 \leq t &lt; q } ( \varphi ( p^{ q - t } ) ) ( ( t + 1 )
p^{ t } \varphi ( p^{ q - t } ) )^2 \\
= &amp; \sum_{ 0 \leq t &lt; q } ( t + 1 )^2 p^{ 2 t } ( p - 1 )^3 p^{ 3
q - 3 t - 3 } \\
= &amp; \sum_{ 0 \leq t &lt; q } ( t + 1 )^2 ( p - 1 )^3 p^{ 3 q - t - 3
}
\end{aligned}
\]</span></p>
<p>其实到这一步,由于<span class="math inline">\(\sum t\)</span>是<span class="math inline">\(O ( \log n )\)</span>级别的,这题已经可以做了.</p>
<h4><span id="莫比乌斯函数">莫比乌斯函数</span></h4>
<p>莫比乌斯函数<span class="math inline">\(\mu ( x
)\)</span>是一个满足<span class="math inline">\(\sum_{ d | n } \mu ( n )
=
1\)</span>的函数,根据定义其显然是积性函数.根据定义可以求出它的封闭形式:</p>
<p><span class="math inline">\(\mu ( m ) = \begin{cases}0 &amp; \exists
m_i \geq 2 \\ ( - 1 )^k &amp; \forall m_i \leq 1\end{cases} , m =
\prod_{ i = 1 }^k p_i^{ m_i }\)</span>.</p>
<h5><span id="莫比乌斯反演">莫比乌斯反演</span></h5>
<p>见”反演.md”.</p>
<p>另外,值得一提的是,根据莫比乌斯反演,我们可以发现<span class="math inline">\(\mu * id = \varphi\)</span>.</p>
<p>有公式:<span class="math inline">\(\mu^2 ( x ) = \sum_{ i^2 | x } \mu
( i )\)</span>.原因很简单,我们设<span class="math inline">\(x
&#39;\)</span>为<span class="math inline">\(x\)</span>中所有的质因子的幂先除二下取整再乘二后变成的答案,显然<span class="math inline">\(\mu^2 ( x ) = \mu^2 ( x &#39;
)\)</span>,我们有<span class="math inline">\(\sum_{ i | \sqrt{ x &#39; }
} \mu ( y ) = [ \sqrt{ x &#39; } = 1 ] , \sum_{ i^2 | x &#39; } \mu ( y
) = [ x &#39; = 1 ]\)</span>.</p>
<h4><span id="min25筛">min25筛</span></h4>
<p>如果我们考虑积性函数的值,理论上来说,设<span class="math inline">\(S (
n , k )\)</span>表示最小质因子大于等于<span class="math inline">\(p_k\)</span>的所有<span class="math inline">\(f\)</span>的和加上<span class="math inline">\(f (
1 )\)</span>,其实我们自然有:</p>
<p><span class="math display">\[
S ( n , k ) = \sum_{ e \geq 0 } f ( p_k^e ) S ( \lfloor \frac{ n }{
p_k^e } \rfloor , k + 1 )
\]</span></p>
<p>问题在于这么做需要枚举<span class="math inline">\([ 1 , n
]\)</span>中的全部质数,这是根本无法接受的.</p>
<p>我们考虑一些很大的质数,换言之,最小质因子大于<span class="math inline">\(\sqrt{ n }\)</span>的数在<span class="math inline">\([ 1 , n ]\)</span>中只有可能是质数本身.</p>
<p>因此你会发现,这个过程只需要把质数单独拿出来做,复杂度就可以得到相当的飞跃.</p>
<p>考虑:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n f ( i ) = \sum_{ p \in \mathrm{ prime } } f ( p ) +
\sum_{ p \notin \mathrm{ prime } \land p \ne 1 } f ( p ) + f ( 1 )
\]</span></p>
<p>令<span class="math inline">\(g ( N , i ) = \sum_{ j = 1 }^N [ j \in
\mathrm{ prime } \lor \mathrm{ Min }_j &gt; p_i ] F ( j )
\\\)</span>,其中<span class="math inline">\(\mathrm{ Min
}_j\)</span>表示<span class="math inline">\(j\)</span>最小的质因数,<span class="math inline">\(p_i\)</span>表示第<span class="math inline">\(i\)</span>个质数.</p>
<p>注意到<span class="math inline">\(g ( N , i )\)</span>实际上就是<span class="math inline">\(N\)</span>以内的数在第<span class="math inline">\(i\)</span>轮埃氏筛后剩余的数的<span class="math inline">\(F\)</span>的和.</p>
<p><span class="math inline">\(F ( i
)\)</span>表示若干完全积性函数之和且当<span class="math inline">\(p \in
\mathrm{ prime }\)</span> 时,<span class="math inline">\(F ( p ) = f ( p
)\)</span>,下文为了方便书写,直接认为<span class="math inline">\(F\)</span>是完全积性函数.</p>
<p>而<span class="math inline">\(g ( N , \sqrt{ N }
)\)</span>实际上就是<span class="math inline">\(N\)</span>以内的质数的<span class="math inline">\(F\)</span>之和,那么有:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , 0 ) &amp; = \sum_{ i = 2 }^n F ( i ) \\
g ( i , j ) &amp; = g ( i , j - 1 ) - F ( p_j ) ( \ g ( \lfloor \frac{ i
}{ p_j } \rfloor , j - 1 ) - \sum_{ 2 \leq p \leq p_{ j - 1 } , p \in
\mathrm{ prime } } F ( p ) \ ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>ps1:</p>
<p>第<span class="math inline">\(j\)</span>个质数会比第<span class="math inline">\(j - 1\)</span>个多筛若干个数,即最小质因数是<span class="math inline">\(p_j\)</span>的数.这些数形如<span class="math inline">\(\{ p_j , 2 p_j , 3 p_j . . .
\}\)</span>,同时除以<span class="math inline">\(p_j\)</span>得到<span class="math inline">\(\{ 1 , 2 , 3 . . . \}\)</span>.</p>
<p>我们要的就是其中最小质因数大于等于<span class="math inline">\(p_j\)</span>的数,也就是最小质因数大于<span class="math inline">\(p_{ j - 1 }\)</span>的数,因而就是<span class="math inline">\(g ( \lfloor \frac{ i }{ p_j } \rfloor , j - 1
)\)</span>.</p>
<p>但还有一些质数会被重复计算,我们把他删掉就可以了.</p>
<p>考虑到<span class="math inline">\(g\)</span>后面的维度最多走到<span class="math inline">\(\sqrt{ n
}\)</span>,所以我们所枚举的最小质因子一定小于等于<span class="math inline">\(\sqrt{ n }\)</span>,所以一定有<span class="math inline">\(p_{ j - 1 } &lt; \lfloor \frac{ i }{ p_j }
\rfloor\)</span>,所以直接删去一定不会多删.</p>
<p>ps2:</p>
<p>注意到以下事实:<span class="math inline">\(\lfloor \frac{ \lfloor
\frac{ a }{ b } \rfloor }{ c } \rfloor = \lfloor \frac{ a }{ bc }
\rfloor \\\)</span>.</p>
<p>因而,如果我们有以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[n])<span class="keyword">return</span> f[n];</span><br><span class="line"><span class="keyword">else</span> f[n]=......;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">solve</span>(n/i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">solve</span>(n);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码复杂度为<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.原因在于,根据整数分块,<span class="math inline">\(\lfloor
\frac{ n }{ i } \rfloor\)</span>有<span class="math inline">\(\sqrt{ n
}\)</span>种取值.</p>
<p>而如果递归下去,继续枚举<span class="math inline">\(j\)</span>,并往下递归到<span class="math inline">\(\lfloor \frac{ \lfloor \frac{ n }{ i } \rfloor }{
j } \rfloor\)</span>,那他就相当于枚举<span class="math inline">\(k =
ij\)</span>,并递归到<span class="math inline">\(\lfloor \frac{ n }{ k }
\rfloor\)</span>,因而复杂度得到保证.</p>
<p>由此可知,求<span class="math inline">\(g\)</span>的复杂度为<span class="math inline">\(O ( \sqrt{ n } \times \sqrt{ \sqrt{ n } } ) = O (
n^{ \frac{ 3 }{ 4 } } )\)</span>.</p>
<p>令<span class="math inline">\(S ( n , m )\)</span>表示前<span class="math inline">\(n\)</span>个数中,最小质因数大于等于<span class="math inline">\(p_m\)</span>的数的<span class="math inline">\(f\)</span>之和,可知:</p>
$$
<span class="math display">\[\begin{aligned}
S ( n , m ) &amp; = g ( n , + \infty ) - \sum_{ k = 1 }^{ m - 1 } f (
p_k ) + \sum_{ k \geq m , e \geq 1 , p_k^{ e + 1 } \leq n } f ( p_k^e )
S ( \lfloor \frac{ n }{ p_k^e } \rfloor , k + 1 ) + \sum_{ k \geq m , e
= 2 , p_k^e \leq n } f ( p_k^e ) \\
&amp; = g ( n , + \infty ) - \sum_{ k = 1 }^{ m - 1 } f ( p_k ) + \sum_{
k \geq m , e \geq 1 , p_k^{ e + 1 } \leq n } [ f ( p_k^e ) S ( \lfloor
\frac{ n }{ p_k^e } \rfloor , k + 1 ) + f ( p_k^{ e + 1 } ) ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>ps1:</p>
<p>前半段求出质数部分的和,后半段开始枚举最小质因子.</p>
<p>由于<span class="math inline">\(p_k\)</span>是当前数的最小质因子,<span class="math inline">\(e\)</span>是他的幂.则这个数其他的质因子应该均大于<span class="math inline">\(p_k\)</span>,因而大于等于<span class="math inline">\(p_{ k + 1 }\)</span>.</p>
<p>注意到由于<span class="math inline">\(S\)</span>中不包含<span class="math inline">\(1\)</span>,所以应特殊处理只含有<span class="math inline">\(p_k\)</span>一个质因子的情况.</p>
<p>又注意到,如果<span class="math inline">\(p_k^e &lt; n &lt; p_k^{ e +
1 }\)</span>,那么此时<span class="math inline">\(\lfloor \frac{ n }{
p_k^e } \rfloor\)</span>一定小于<span class="math inline">\(p_k\)</span>,则不可能拥有比<span class="math inline">\(p_k\)</span>更大的质因子.</p>
<p>该形式与上面一致,因而复杂度同样为<span class="math inline">\(O ( n^{
\frac{ 3 }{ 4 } } )\)</span>.我们最终要求的答案即<span class="math inline">\(S ( n , 1 ) + f ( 1 )\)</span>.</p>
<p>一些后记:</p>
<ol type="1">
<li><p>事实上,复杂度的计算只是上限,实际上应该约为<span class="math inline">\(O ( \frac{ n^{ \frac{ 3 }{ 4 } } }{ \log_2 n }
)\)</span>.</p></li>
<li><p>如果使用map会导致复杂度较差,考虑如下事实:</p></li>
</ol>
<p>(1).<span class="math inline">\(\forall 1 \leq x \leq
n\)</span>,则要么<span class="math inline">\(x \leq \sqrt{ n
}\)</span>,要么<span class="math inline">\(\lfloor \frac{ n }{ x }
\rfloor \leq \sqrt{ n } \\\)</span>.</p>
<p>(2).<span class="math inline">\(\forall a\)</span>形如<span class="math inline">\(\lfloor \frac{ n }{ x } \rfloor\)</span>,则<span class="math inline">\(\lfloor \frac{ n }{ a } \rfloor\)</span>应为<span class="math inline">\(x_{ max }\)</span>,互不相同.</p>
<p>因而可以分别特判,从而做到比map或离散化都优秀的复杂度.</p>
<ol start="3" type="1">
<li><p>我们在代码中所求出的<span class="math inline">\(w\)</span>是倒序的,而我们转移的过程也是倒序的,因而枚举的时候可以直接正序枚举.</p></li>
<li><p>考虑做的时候由于进行了滚动数组,因而继承操作可以直接使用,为了方便可以直接判掉可以直接继承的情况.</p></li>
<li><p>求<span class="math inline">\(S\)</span>的过程可以使用递归,因为我们只关心一个<span class="math inline">\(S\)</span>的量.</p></li>
</ol>
<h5><span id="example1uoj188sanrd">Example1([uoj188]Sanrd)</span></h5>
<p>注意到这题显然可以写埃筛的暴力.考虑使用类似min15筛的方式,定义<span class="math inline">\(f ( n )\)</span>为<span class="math inline">\(n\)</span>的次大质因子(若<span class="math inline">\(n = 1 \lor n \in \mathrm{ prime }\)</span>则<span class="math inline">\(f ( n ) = 0\)</span>),<span class="math inline">\(S ( n , k ) = \sum_{ i = 1 }^n [ \mathrm{ Min }_i
\geq p_k ] f ( i )\)</span>.不难发现我们要求的就是<span class="math inline">\(S ( n , 1 )\)</span>,而显然<span class="math inline">\(S ( n , \sqrt{ n } ) = 0\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
S ( n , m ) = \sum_{ i \geq m , e \geq 1 , p_i^{ e + 1 } \leq n } S (
\lfloor \frac{ n }{ p_i^e } \rfloor , i + 1 ) + p_i \sum_{ i = p_i + 1
}^{ \lfloor \frac{ n }{ p_i^e } \rfloor } [ i \in \mathrm{ prime } ]
\]</span></p>
<p>区间素数个数可以拿min25筛的前半部分做.</p>
<h4><span id="杜教筛">杜教筛</span></h4>
<p>令<span class="math inline">\(F ( n ) = \sum_{ i = 1 }^n f ( i )
\\\)</span>,我们考虑构造两个函数<span class="math inline">\(g\)</span>和<span class="math inline">\(s\)</span>.使得<span class="math inline">\(f * g =
s\)</span>.</p>
<p>令<span class="math inline">\(G ( n ) = \sum_{ i = 1 }^n g ( i ) , S
( n ) = \sum_{ i = 1 }^n s ( i ) \\\)</span>.若<span class="math inline">\(G ( i )\)</span>和<span class="math inline">\(S (
i )\)</span>都很方便求,<span class="math inline">\(g ( 1 ) =
1\)</span>,我们就可以求出<span class="math inline">\(F ( n
)\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
f * g &amp; = s \\
\sum_{ j | i } f ( j ) g ( \frac{ i }{ j } ) &amp; = s ( i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由于<span class="math inline">\(g ( 1 ) = 1\)</span>,我们有<span class="math inline">\(f ( i ) = s ( i ) - \sum_{ j | i , j \ne i } f ( j
) g ( \frac{ i }{ j } ) \\\)</span>.</p>
<p>那么:</p>
$$
<span class="math display">\[\begin{aligned}
F ( n ) &amp; = \sum_{ i = 1 }^n f ( i ) \\
&amp; = \sum_{ i = 1 }^n ( s ( i ) - \sum_{ j | i , j \ne i } f ( j ) g
( \frac{ i }{ j } ) ) \\
&amp; = S ( n ) - \sum_{ j = 1 }^n \sum_{ k = 2 }^{ \lfloor \frac{ n }{
j } \rfloor } g ( k ) f ( j ) \\
&amp; = S ( n ) - \sum_{ k = 2 }^n g ( k ) \sum_{ j = 1 }^{ \lfloor
\frac{ n }{ k } \rfloor } f ( j ) \\
&amp; = S ( n ) - \sum_{ k = 2 }^n g ( k ) F ( \lfloor \frac{ n }{ k }
\rfloor ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>复杂度证明和min25筛是一样的,不同点在于我们可以预处理<span class="math inline">\(n^{ \frac{ 2 }{ 3 } }\)</span>以内的<span class="math inline">\(F\)</span>,这样复杂度可以降到<span class="math inline">\(O ( n^{ \frac{ 2 }{ 3 } } )\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^N \mu ( i )
\\\)</span>.</p>
<p>由于<span class="math inline">\(\mu * I =
\epsilon\)</span>,于是考虑<span class="math inline">\(g =
I\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^N \varphi ( i )
\\\)</span>.</p>
<p>由于<span class="math inline">\(\varphi * I =
id\)</span>,于是考虑<span class="math inline">\(g = I\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^N{ \varphi ( i ) \times
i } \\\)</span></p>
<p>由于<span class="math inline">\(\sum^N_{ i = 1 } ( f * g ) ( i ) =
\sum_{ d | N }{ f ( i ) \times g ( \cfrac{ n }{ d } ) } = \sum_{ d | N
}{ \varphi ( d ) \times d \times g ( \cfrac{ n }{ d } ) }
\\\)</span></p>
<p>由于中间过程中乘出来的<span class="math inline">\(d\)</span>很难处理,需要消掉它,于是考虑<span class="math inline">\(g = id\)</span>.</p>
<h5><span id="example4">Example4</span></h5>
<p><span class="math inline">\(\sum_{ i = 1 }^N{ \varphi ( i ) \times
i^2 } \\\)</span>.</p>
<p>由Example3,于是考虑<span class="math inline">\(g = id^2\)</span>.</p>
<h4><span id="powerful-number筛">Powerful Number筛</span></h4>
<p>定义Powerful Number为满足所有质因子的指数都<span class="math inline">\(&gt; 1\)</span>的数,不难证明这样的数在<span class="math inline">\([ 1 , n ]\)</span>中最多只有<span class="math inline">\(O ( \sqrt{ n }
)\)</span>个(使用积分).同时对于质因子的幂分奇偶讨论:奇数分成一个<span class="math inline">\(3\)</span>加上一个偶数,那么不难证明这个数一定有:<span class="math inline">\(a^2
b^3\)</span>的形式.找到这些数字可以直接dfs搜指数.</p>
<p>现在我们要求积性函数<span class="math inline">\(f ( n
)\)</span>的前缀和.假设<span class="math inline">\(f = h *
g\)</span>,其中<span class="math inline">\(h ( 1 ) = 1 , g ( p ) = f ( p
) , \forall p \in \mathrm{ prime }\)</span>且<span class="math inline">\(g ( n )\)</span>的前缀和容易计算.</p>
<p>接下来我们证明:<span class="math inline">\(h ( n ) \ne 0 \Rightarrow
n \ is \ Powerful \ Number\)</span>.</p>
<p><span class="math inline">\(\forall p \in \mathrm{ prime
}\)</span>,<span class="math inline">\(f ( p ) = g ( 1 ) h ( p ) + g ( p
) h ( 1 ) = h ( p ) + g ( p )\)</span>,于是<span class="math inline">\(h
( p ) = 0\)</span>.根据积性函数的性质有<span class="math inline">\(\forall x \notin \text{ PN } , h ( x ) =
0\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
F ( n ) &amp; = \sum_{ i = 1 }^n f ( i ) \\
&amp; = \sum_{ i = 1 }^n \sum_{ j | i } h ( j ) g ( \frac{ i }{ j } ) \\
&amp; = \sum_{ j = 1 }^n h ( j ) G ( \lfloor \frac{ n }{ j } \rfloor )
\end{aligned}
\]</span></p>
<p>于是可以快速求,复杂度<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.</p>
<h5><span id="example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</span></h5>
<p>首先我们需要构造<span class="math inline">\(g ( p ) = f ( p ) , p \in
\mathrm{ prime }\)</span>.注意到<span class="math inline">\(f ( p ) = d
( p^3 ) = 4\)</span>,我们构造<span class="math inline">\(g ( p ) = ( d *
d ) ( p )\)</span>.这样问题在于求<span class="math inline">\(G ( n
)\)</span>.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
G ( n ) &amp; = \sum_{ i = 1 }^n ( d * d ) ( i ) \\
&amp; = \sum_{ ij \leq n } d ( i ) d ( j ) \\
&amp; = \sum_{ i = 1 }^n d ( i ) D ( \lfloor \frac{ n }{ i } \rfloor )
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(D ( n ) = \sum_{ i = 1 }^n \lfloor
\frac{ n }{ i } \rfloor\)</span>,自然可以做.复杂度算一算是<span class="math inline">\(O ( n^{ \frac{ 2 }{ 3 } } )\)</span>.</p>
<p>感觉Powerful Number筛的关键在于构造.</p>
<h2><span id="整值函数">整值函数</span></h2>
<h3><span id="定义">定义</span></h3>
<p>若<span class="math inline">\(x \in \mathbb{ R }\)</span>,则:</p>
<p><span class="math inline">\(\lfloor x \rfloor
=\)</span>小于等于x的最大的整数.</p>
<p><span class="math inline">\(\lceil x \rceil
=\)</span>大于等于x的最小的整数.</p>
<p>我们有时称<span class="math inline">\(\lfloor x
\rfloor\)</span>为<span class="math inline">\(x\)</span>的整数部分,并定义<span class="math inline">\(x - \lfloor x
\rfloor\)</span>为分数部分,有时记作<span class="math inline">\(\{ x
\}\)</span>.</p>
<p>我们定义<span class="math inline">\(x \mod y = x - y \lfloor \cfrac{
x }{ y } \rfloor\)</span>,<span class="math inline">\(x \ mumble \ y = y
\lceil \cfrac{ x }{ y } \rceil - x\)</span>,其中<span class="math inline">\(x , y \in \mathbb{ N_+ }\)</span>.</p>
<p>当然,我们也可以使用上述定义将<span class="math inline">\(mod\)</span>和<span class="math inline">\(mumble\)</span>的定义扩展到实数域,不过<span class="math inline">\(y = 0\)</span>的时候需要特殊处理.</p>
<h3><span id="整值函数的基本性值">整值函数的基本性值</span></h3>
<p>若<span class="math inline">\(x \in \mathbb{ R } , n \in \mathbb{ Z
}\)</span>,则有:</p>
<ol type="1">
<li><p><span class="math inline">\(\lfloor x \rfloor = x \Leftrightarrow
\lceil x \rceil = x \Leftrightarrow x \in \mathbb{ Z
}\)</span>.</p></li>
<li><p><span class="math inline">\(\lceil x \rceil - \lfloor x \rfloor =
[ x \notin \mathbb{ Z } ]\)</span>.</p></li>
<li><p><span class="math inline">\(x - 1 &lt; \lfloor x \rfloor \leq x
\leq \lceil x \rceil &lt; x + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\lfloor - x \rfloor = - \lceil x
\rceil , \lceil - x \rceil = - \lfloor x \rfloor\)</span>.</p></li>
<li><p><span class="math inline">\(\lfloor x \rfloor = n \Leftrightarrow
n \leq x &lt; n + 1 \Leftrightarrow x - 1 &lt; n \leq
x\)</span>.</p></li>
<li><p><span class="math inline">\(\lceil x \rceil = n \Leftrightarrow n
- 1 &lt; x \leq n \Leftrightarrow x \leq n &lt; x + 1\)</span>.</p></li>
<li><p><span class="math inline">\(x &lt; n \Leftrightarrow \lfloor x
\rfloor &lt; n\)</span>.</p></li>
<li><p><span class="math inline">\(x \leq n \Leftrightarrow \lceil x
\rceil \leq n\)</span>.</p></li>
<li><p><span class="math inline">\(x &gt; n \Leftrightarrow \lceil x
\rceil &gt; n\)</span>.</p></li>
<li><p><span class="math inline">\(x \geq n \Leftrightarrow \lfloor x
\rfloor \geq n\)</span>.</p></li>
<li><p><span class="math inline">\(\lfloor x + n \rfloor = \lfloor x
\rfloor + n\)</span>.</p></li>
<li><p><span class="math inline">\(\lceil x + n \rceil = \lceil x \rceil
+ n\)</span>.</p></li>
<li><p><span class="math inline">\(\lfloor nx \rfloor = n \lfloor x
\rfloor \Leftrightarrow n = 0 \lor x - \lfloor x \rfloor &lt; \cfrac{ 1
}{ n }\)</span>.</p></li>
<li><p><span class="math inline">\(\lceil nx \rceil = n \lceil x \rceil
\Leftrightarrow n = 0 \lor x - \lceil x \rceil &lt; \cfrac{ 1 }{ n
}\)</span>.</p></li>
<li><p><span class="math inline">\(\lceil \cfrac{ n }{ m } \rceil =
\lfloor \cfrac{ n - 1 }{ m } \rfloor + 1 , m \in \mathbb{ N_+
}\)</span>.</p></li>
<li><p><span class="math inline">\(m \lceil x \rceil - \lceil m ( \lceil
x \rceil - x ) \rceil = \lfloor mx \rfloor\)</span>.</p></li>
<li><p><span class="math inline">\(( x \mod ny ) \mod y = x \mod y , n
\in \mathbb{ N_+ }\)</span>.</p></li>
<li><p>分配律:<span class="math inline">\(c ( x \mod y ) = ( cx ) \mod (
cy )\)</span>.</p></li>
</ol>
<h3><span id="整值函数的应用">整值函数的应用</span></h3>
<h4><span id="一类函数与整值函数">一类函数与整值函数</span></h4>
<p>设<span class="math inline">\(f ( x
)\)</span>是一个有以下性质且在一个实数区间连续的单调递增函数:</p>
<p><span class="math inline">\(f ( x ) \in \mathbb{ Z } \Rightarrow x
\in \mathbb{ Z }\)</span>.</p>
<p>那么,只要<span class="math inline">\(f ( x ) , f ( \lfloor x \rfloor
) , f ( \lceil x \rceil )\)</span>都有定义,我们有:</p>
<p><span class="math inline">\(\lfloor f ( x ) \rfloor = \lfloor f (
\lfloor x \rfloor ) \rfloor\)</span>和<span class="math inline">\(\lceil
f ( x ) \rceil = \lceil f ( \lceil x \rceil ) \rceil\)</span>.</p>
<p>由于底和顶是类似的,我们考虑先对顶进行证明,这样也可以类似证明底:</p>
<p>若<span class="math inline">\(x = \lceil x
\rceil\)</span>,显然得证;</p>
<p>不然,有<span class="math inline">\(x &lt; \lceil x
\rceil\)</span>,那么有<span class="math inline">\(f ( x ) &lt; f (
\lceil x \rceil )\)</span>,也就有<span class="math inline">\(\lceil f (
x ) \rceil \leq \lceil f ( \lceil x \rceil ) \rceil\)</span>.</p>
<p>考虑反证法,不妨令<span class="math inline">\(\lceil f ( x ) \rceil
&lt; \lceil f ( \lceil x \rceil )
\rceil\)</span>.则一定存在一个整数<span class="math inline">\(y\)</span>使得<span class="math inline">\(\lceil f
( x ) \rceil = y &lt; \lceil f ( \lceil x \rceil )
\rceil\)</span>,此时必有<span class="math inline">\(x \leq y &lt; \lceil
x \rceil\)</span>.由于<span class="math inline">\(f\)</span>的性值,显然有<span class="math inline">\(y\)</span>是整数,但根据整值函数的性值,不可能存在这样一个整数<span class="math inline">\(y\)</span>满足<span class="math inline">\(x \leq y
&lt; \lceil x \rceil\)</span>,因此得证.</p>
<p>另外,我们考虑函数<span class="math inline">\(f ( x ) = \cfrac{ x + m
}{ n
}\)</span>,显然这是一个满足条件的函数,因此显然满足上述的条件.再考虑<span class="math inline">\(m = 0\)</span>的特殊情况:<span class="math inline">\(\lfloor \cfrac{ \lfloor \cfrac{ x }{ n } \rfloor
}{ m } \rfloor = \lfloor \cfrac{ x }{ nm } \rfloor\)</span>.</p>
<p>而单调递减函数可以取相反数转化为单调递增函数.</p>
<h4><span id="迪利克雷抽屉原理">迪利克雷抽屉原理</span></h4>
<p><span class="math inline">\(n\)</span>个物体放进<span class="math inline">\(m\)</span>个盒子里,那么必定有一个盒子中放入了大于等于<span class="math inline">\(\lceil \cfrac{ n }{ m }
\rceil\)</span>个物品,有一个盒子放入了小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ m }
\rfloor\)</span>个物体.</p>
<h5><span id="example1">Example1</span></h5>
<p>求证:每个由<span class="math inline">\(n^2 +
1\)</span>个不同实数构成的序列都包含一个长为<span class="math inline">\(n +
1\)</span>的严格递增子序列或严格递减子序列.</p>
<p>设<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个实数,<span class="math inline">\(c_i\)</span>为以这个数为开头的最长的递增子序列,<span class="math inline">\(d_i\)</span>表示以这个数为开头的最长的递减子序列.考虑反证法,如果不成立,那么<span class="math inline">\(\forall 1 \leq i \leq n^2 + 1\)</span>,<span class="math inline">\(1 \leq c_i \leq n \land 1 \leq d_i \leq
n\)</span>.那么一共有<span class="math inline">\(n^2\)</span>种不同的有序对.</p>
<p>根据抽屉原理,一共有<span class="math inline">\(n^2 +
1\)</span>个有序对,所以一定有两个有序对相等.由于这些数字两两不同,所以一定可以把其中一个数字加到另一个数字的递增或递减子序列的后面,这样那个数字的<span class="math inline">\(c_i\)</span>或者<span class="math inline">\(d_i\)</span>就要<span class="math inline">\(+
1\)</span>,与我们的假设不符,因此该定理成立.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:若任意两个人间只有两种关系:朋友或敌人.那么对于六个人而言,一定有三个人两两都是朋友或者两两都是敌人.</p>
<p>令<span class="math inline">\(A\)</span>是这六个人中其中一个,根据抽屉原理,一定有大于等于<span class="math inline">\(3\)</span>个人都是<span class="math inline">\(A\)</span>的敌人或者都是<span class="math inline">\(A\)</span>的朋友,不妨假设这三个人都是<span class="math inline">\(A\)</span>的朋友.</p>
<p>如果这三个人中有两个人是朋友,那么它们和A就一起构成了一组人.不然,他们三个人就构成了一组人.</p>
<h4><span id="计算区间内整数个数">计算区间内整数个数</span></h4>
<p>整值函数的另一个应用是计算区间内整数个数:</p>
<p>考虑基本性值<span class="math inline">\(7 , 8 , 9 ,
10\)</span>,不难发现:</p>
<ol type="1">
<li><p><span class="math inline">\([ \alpha , \beta ]\)</span>包含<span class="math inline">\(\lfloor \beta \rfloor - \lceil \alpha \rceil +
1\)</span>个整数.</p></li>
<li><p><span class="math inline">\(( \alpha , \beta )\)</span>包含<span class="math inline">\(\lceil \beta \rceil - \lfloor \alpha \rfloor -
1\)</span>个整数.</p></li>
<li><p><span class="math inline">\(( \alpha , \beta ]\)</span>包含<span class="math inline">\(\lfloor \beta \rfloor - \lfloor \alpha
\rfloor\)</span>个整数.</p></li>
<li><p><span class="math inline">\([ \alpha , \beta )\)</span>包含<span class="math inline">\(\lceil \beta \rceil - \lceil \alpha
\rceil\)</span>个整数.</p></li>
</ol>
<h4><span id="谱">谱</span></h4>
<p>我们定义一个实数<span class="math inline">\(\alpha\)</span>的<strong>谱</strong>是以下集合:</p>
<p><span class="math inline">\(Spec ( \alpha ) = \{ \lfloor \alpha
\rfloor , \lfloor 2 \alpha \rfloor , \lfloor 3 \alpha \rfloor . . .
\}\)</span>.</p>
<p>不难发现,只要<span class="math inline">\(\alpha \ne
\beta\)</span>,则<span class="math inline">\(Spec ( \alpha ) \ne Spec (
\beta )\)</span>.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(Spec ( \sqrt{ 2 } ) \cup Spec ( 2 +
\sqrt{ 2 } ) = \mathbb{ N_+ }\)</span>且<span class="math inline">\(Spec
( \sqrt{ 2 } ) \cap Spec ( 2 + \sqrt{ 2 } ) =
\phi\)</span>,即这两个集合构成了正整数集的一个划分.</p>
<p>我们考虑这样一个事实:对于任意正整数<span class="math inline">\(n\)</span>,如果我们能求出来<span class="math inline">\(Spec ( \sqrt{ 2 } )\)</span>中有<span class="math inline">\(a\)</span>个元素<span class="math inline">\(\leq
n\)</span>,<span class="math inline">\(Spec ( 2 + \sqrt{ 2 }
)\)</span>中有<span class="math inline">\(b\)</span>个元素<span class="math inline">\(\leq n\)</span>,并且<span class="math inline">\(a
+ b = n\)</span>,则结论显然成立.</p>
<p>不妨令函数<span class="math inline">\(N ( \alpha , n
)\)</span>表示<span class="math inline">\(Spec ( \alpha
)\)</span>中有多少个元素<span class="math inline">\(\leq
n\)</span>,其中<span class="math inline">\(\alpha\)</span>是正数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N ( \alpha , n ) &amp; = \sum_{ k \in \mathbb{ N_+ } } [ \lfloor k
\alpha \rfloor \leq n ] \\
&amp; = \sum_{ k \in \mathbb{ N_+ } } [ \lfloor k \alpha \rfloor &lt; n
+ 1 ] \\
&amp; = \sum_{ k \in \mathbb{ N_+ } } [ k \alpha &lt; n + 1 ] \\
&amp; = \sum_k [ 0 &lt; k &lt; ( n + 1 ) / \alpha ] \\
&amp; = \lceil ( n + 1 ) / \alpha \rceil - 1
\end{aligned}
\]</span></p>
<p>则我们要证明的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\lceil \cfrac{ n + 1 }{ \sqrt{ 2 } } \rceil - 1 + \lceil \cfrac{ n + 1
}{ 2 + \sqrt{ 2 } } \rceil - 1 &amp; = n \\
\lfloor \cfrac{ n + 1 }{ \sqrt{ 2 } } \rfloor + \lfloor \cfrac{ n + 1 }{
2 + \sqrt{ 2 } } \rfloor &amp; = n \\
\cfrac{ n + 1 }{ \sqrt{ 2 } } - \{ \cfrac{ n + 1 }{ \sqrt{ 2 } } \} +
\cfrac{ n + 1 }{ 2 + \sqrt{ 2 } } - \{ \cfrac{ n + 1 }{ 2 + \sqrt{ 2 } }
\} &amp; = n
\end{aligned}
\]</span></p>
<p>而由于我们有恒等式:<span class="math inline">\(\cfrac{ 1 }{ \sqrt{ 2
} } + \cfrac{ 1 }{ 2 + \sqrt{ 2 } } =
1\)</span>,且两个相加为整数的数的分数部分相加显然为<span class="math inline">\(1\)</span>,原式得证.</p>
<p>事实上,如果两个集合<span class="math inline">\(Spec ( \alpha
)\)</span>和<span class="math inline">\(Spac ( \beta
)\)</span>构成正整数集一个划分,可以同上证明<span class="math inline">\(\cfrac{ 1 }{ \alpha } + \cfrac{ 1 }{ \beta } =
1\)</span>且<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>都是无理数.</p>
<h4><span id="整值函数的递归式">整值函数的递归式</span></h4>
<p>得到递归式的封闭形式的确很有用,它可以让我们在很快的时间内求出答案,但大部分时候是很麻烦的.</p>
<p>而如果我们对时间的要求没有那么紧,我们不妨考虑一种较慢但更容易的方法:</p>
<h5><span id="example">Example</span></h5>
<p>约瑟夫问题,但是每隔两个人处死一个人,求最后存活者的编号.</p>
<p>我们不妨这样考虑:我们每略过两个人,就将他们重新编号.</p>
<p>例如,我们杀掉了三号,就将一号和二号重新编号为<span class="math inline">\(n + 1\)</span>号和<span class="math inline">\(n +
2\)</span>号,杀掉了六号,就将四号和五号重新编号为<span class="math inline">\(n + 3\)</span>号和<span class="math inline">\(n +
4\)</span>号,这样,我们在做游戏的时候,场上人员的编号一定是连续的.</p>
<p>我们把最后存活者改为最后死亡者,这样它的最后编号就是<span class="math inline">\(3 n\)</span>.</p>
<p>并且不难发现,第<span class="math inline">\(k\)</span>个死亡的人的最后编号就是<span class="math inline">\(3 k\)</span>.</p>
<p>我们考虑已知新编号如何求旧编号,设新编号为<span class="math inline">\(N\)</span>:</p>
<p>如果<span class="math inline">\(N \leq n\)</span>,则<span class="math inline">\(N\)</span>是初始编号,反之,我们考虑在编号<span class="math inline">\(N\)</span>的时候被杀死的人的编号.</p>
<p>假设现在进行完了<span class="math inline">\(k + 1\)</span>轮,令<span class="math inline">\(N = n + 2 k + w\)</span>,其中<span class="math inline">\(w \in \{ 1 , 2 \}\)</span>,则编号<span class="math inline">\(N\)</span>的时候被杀死的即是<span class="math inline">\(3 ( k + 1 )\)</span>,那么<span class="math inline">\(N\)</span>之前的编号就是<span class="math inline">\(3 k + w = N - ( n - k ) = N - n + k\)</span>.</p>
<p>而<span class="math inline">\(k = \lfloor \cfrac{ ( N - n - 1 ) }{ 2
} \rfloor\)</span>,我们可以不断进行迭代.</p>
<p>如果我们令<span class="math inline">\(D = 3 n + 1 -
N\)</span>,换句话说即改变编号的顺序,我们可以有以下的赋值操作:</p>
<p><span class="math inline">\(3 n + 1 - D &#39; = 3 n + 1 - D - n +
\lfloor \cfrac{ ( 3 n + 1 - D - n - 1 ) }{ 2 } \rfloor\)</span>.</p>
<p>化简这个式子,我们有:<span class="math inline">\(D &#39; = D + n -
\lfloor \cfrac{ ( 2 n - D ) }{ 2 } \rfloor = D + \lceil \cfrac{ D }{ 2 }
\rceil = \lceil \cfrac{ 3 D }{ 2 } \rceil\)</span>.</p>
<p>事实上,我们可以证明:如果我们每隔<span class="math inline">\(q\)</span>个人就杀掉一个人的话,那么<span class="math inline">\(D &#39; = \lceil \cfrac{ ( q + 1 ) D }{ q }
\rceil\)</span>,一直迭代到<span class="math inline">\(D &#39; &gt;
qn\)</span>时.</p>
<p>而最后的答案就是<span class="math inline">\(( q + 1 ) n + 1 -
D\)</span>.</p>
<h4><span id="整值函数的恒等式">整值函数的恒等式</span></h4>
<p>考虑公式<span class="math inline">\(\lceil \cfrac{ n - k + 1 }{ m }
\rceil\)</span>,不难发现它在<span class="math inline">\(1 \leq k \leq n
\mod m\)</span>时的值为<span class="math inline">\(\lceil \cfrac{ n }{ m
} \rceil\)</span>,而在<span class="math inline">\(n \mod m &lt; k \leq
m\)</span>的值为<span class="math inline">\(\lfloor \cfrac{ n }{ m }
\rfloor\)</span>.</p>
<p>那么我们可以得到以下恒等式:</p>
<p><span class="math inline">\(n = \sum_{ k = 1 }^m \lceil \cfrac{ n - k
+ 1 }{ m } \rceil\)</span>.</p>
<p>类似地,有:</p>
<p><span class="math inline">\(n = \sum_{ k = 1 }^m \lfloor \cfrac{ n +
k - 1 }{ m } \rfloor\)</span>.</p>
<p>用<span class="math inline">\(\lfloor mx
\rfloor\)</span>替换上面的<span class="math inline">\(n\)</span>有<span class="math inline">\(\lfloor mx \rfloor = \sum_{ k = 1 }^m \lfloor x +
\cfrac{ k - 1 }{ m } \rfloor\)</span>.</p>
<p>同样的,有<span class="math inline">\(\lceil mx \rceil = \sum_{ k = 1
}^m \lceil x - \cfrac{ k - 1 }{ m } \rceil\)</span>.</p>
<h4><span id="整值函数的和式">整值函数的和式</span></h4>
<p>通常情况下,处理含整值函数的和式时,通过引入新变量进行代替以及通过转化为区间进行化简.</p>
<p>如果遇到难以处理的情况,我们不妨考虑直接处理其中一段的和,使得剩下部分求和更为简单.</p>
<p>处理整值函数的另一个方法是:考虑将整值函数内的东西移出,并且让里面的东西形如等差序列,这样我们就可以尝试使用恒等式来化简.</p>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ n - 1 } \lfloor \sqrt{
k } \rfloor\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^{ n - 1 } \lfloor \sqrt{ k } \rfloor &amp; = \sum_{ 0
\leq k , m } [ k &lt; n ] [ m = \lfloor \sqrt{ k } \rfloor ] m \\
&amp; = \sum_{ 0 \leq k , m } [ k &lt; n ] [ m^2 \leq k &lt; ( m + 1 )^2
] m \\
&amp; = \sum_{ 0 \leq k , m } m [ m^2 \leq k &lt; n &lt; ( m + 1 )^2 ] +
\sum_{ 0 \leq k , m } m [ m^2 \leq k &lt; ( m + 1 )^2 \leq n ]
\end{aligned}
\]</span></p>
<p>考虑<span class="math inline">\(n =
a^2\)</span>的特殊情况,则前面那一项显然是<span class="math inline">\(0\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ 0 \leq k , m } m [ m^2 \leq k &lt; ( m + 1 )^2 \leq n
] \\
&amp; = \sum_{ 0 \leq m } m ( 2 m + 1 ) [ m &lt; a ] \\
&amp; = \sum_{ m = 0 }^{ a - 1 } ( 2 m^2 + m ) \\
&amp; = \cfrac{ ( a - 1 ) a ( 2 a - 1 ) }{ 3 } + \cfrac{ a ( a - 1 ) }{
2 } \\
&amp; = \cfrac{ ( 4 a + 1 ) a ( a - 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<p>而如果<span class="math inline">\(n \ne a^2\)</span>,我们令<span class="math inline">\(a = \lfloor \sqrt{ n } \rfloor\)</span>,而当<span class="math inline">\(k \in [ a^2 , n )\)</span>的部分的贡献显然是<span class="math inline">\(a ( n - a^2 )\)</span>.</p>
<p>于是最后的结果就是:<span class="math inline">\(\cfrac{ ( 4 a + 1 ) a
( a - 1 ) }{ 6 } + a ( n - a^2 ) , a = \lfloor \sqrt{ n }
\rfloor\)</span>.</p>
<p>另一个做法是,我们考虑增加枚举量,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^{ n - 1 } \lfloor \sqrt{ k } \rfloor &amp; = \sum_{ j , k
} [ 1 \leq j \leq \sqrt{ k } ] [ 0 \leq k &lt; a^2 ] \\
&amp; = \sum_{ 1 \leq j &lt; a } \sum_{ k } [ j^2 \leq k &lt; a^2 ] \\
&amp; = \sum_{ 1 \leq j &lt; a } a^2 - j^2 = a^3 - \cfrac{ a ( 2 a + 1 )
( a + 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<h5><span id="example2类欧几里得算法">Example2(类欧几里得算法)</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ m - 1 } \lfloor
\cfrac{ nk + x }{ m } \rfloor , m \in \mathbb{ N_+ } , n \in \mathbb{ Z
}\)</span>.</p>
<p>由于<span class="math inline">\(kn - ( kn \mod m ) = m \lfloor
\cfrac{ kn }{ m } \rfloor\)</span>,我们有:</p>
<p><span class="math display">\[
\lfloor \cfrac{ x + kn }{ m } \rfloor = \lfloor \cfrac{ x + ( kn \mod m
) }{ m } \rfloor + \cfrac{ kn }{ m } - \cfrac{ kn \mod m }{ m }
\]</span></p>
<p>这样,我们将整个式子的求和分为了三部分,第二项显然是等差数列求和,而如果我们令<span class="math inline">\(g = \gcd ( n , m
)\)</span>,不难发现第三项的分子是一个等差数列<span class="math inline">\(0 , g , 2 g , . . . m - g\)</span>重复了<span class="math inline">\(g\)</span>次,而且正因为这,第一项里面的数也就自然组成了等差数列,由于我们有恒等式,那么这一项也就自然可以计算了.</p>
<p>分别求和后加起来,得到答案为<span class="math inline">\(g \lfloor
\cfrac{ x }{ g } \rfloor + \cfrac{ ( m - 1 ) n }{ 2 } + \cfrac{ g - m }{
2 }\)</span>.</p>
<p>另外,对这个式子进行化简,我们可以得到:<span class="math inline">\(g
\lfloor \cfrac{ x }{ g } \rfloor + \cfrac{ ( m - 1 ) ( n - 1 ) }{ 2 } +
\cfrac{ g - 1 }{ 2 }\)</span>,而这个式子关于<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>是对称的.</p>
<p>也就是说:<span class="math inline">\(\sum_{ k = 0 }^{ m - 1 } \lfloor
\cfrac{ nk + x }{ m } \rfloor = \sum_{ k = 0 }^{ n - 1 } \lfloor \cfrac{
mk + x }{ n } \rfloor , m , n \in \mathbb{ N_+ }\)</span>.</p>
<p>另外,如果要求<span class="math inline">\(\sum^n_{ i = 0 } \lfloor
\cfrac{ ai + b }{ c } \rfloor\)</span>,我们也有一种<span class="math inline">\(O ( \log n )\)</span>的做法(类欧几里得算法):</p>
<p>若<span class="math inline">\(c \leq a\)</span>,原式化为<span class="math inline">\(\sum^n_{ i = 0 }{ ( i \times \lfloor \frac{ a }{ c
} \rfloor + \lfloor \cfrac{ ( a \mod c ) i + b }{ c } \rfloor )
}\)</span>.</p>
<p>若<span class="math inline">\(c \leq b\)</span>,原式化为<span class="math inline">\(\sum^n_{ i = 0 }{ \lfloor \cfrac{ b }{ c } \rfloor
+ \lfloor \cfrac{ ai + ( b \mod c ) }{ c } \rfloor }\)</span>.</p>
<p>考虑<span class="math inline">\(a , b &lt; c\)</span>的情况,设<span class="math inline">\(m = \lfloor \cfrac{ an + b }{ c }
\rfloor\)</span>,原式化为</p>
<p><span class="math display">\[
\begin{aligned}
\sum^n_{ i = 0 } \sum^m_{ j = 1 } [ j &amp; \leq \lfloor \cfrac{ ai + b
}{ c } \rfloor ] \\
&amp; = \sum^n_{ i = 0 } \sum^m_{ j = 1 } [ cj \leq ai + b ] \\
&amp; = nm - \sum^n_{ i = 0 } \sum^m_{ j = 1 } [ ai \leq cj - b - 1 ] \\
&amp; = nm - \sum^m_{ i = 1 } \lfloor \cfrac{ ci - b - 1 }{ a } \rfloor
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{ n = 1 }^{ 1000 } [ \lfloor
\sqrt[3]{ n } \rfloor | n ]\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ n , k } [ k = \lfloor \sqrt[3]{ n } \rfloor ] [ k | n
] [ 1 \leq n \leq 1000 ] \\
&amp; = \sum_{ k , m , n } [ k^3 \leq n &lt; ( k + 1 )^3 ] [ n = km ] [
1 \leq n \leq 1000 ] \\
&amp; = 1 + \sum_{ k , m } [ k^3 \leq km &lt; ( k + 1 )^3 ] [ 1 \leq k
&lt; 10 ] \\
&amp; = 1 + \sum_{ k , m } [ k^2 \leq m &lt; \frac{ ( k + 1 )^3 }{ k } ]
[ 1 \leq k &lt; 10 ] \\
&amp; = 1 + \sum_{ k = 1 }^9 ( \lceil k^2 + 3 k + 3 + \frac{ 1 }{ k }
\rceil - \lceil k^2 \rceil ) \\
&amp; = 1 + \sum_{ k = 1 }^9 ( 3 k + 4 ) = 172
\end{aligned}
\]</span></p>
<p>上述推理过程将<span class="math inline">\(n =
1000\)</span>的情况特殊讨论了一下,不难发现,如果我们要求的式子是<span class="math inline">\(\sum_{ n = 1 }^{ N } [ \lfloor \sqrt[3]{ n }
\rfloor | n ]\)</span>,也仍然可以使用将<span class="math inline">\([ K^3
, N ] , K = \lfloor \sqrt[3]{ N }
\rfloor\)</span>中的数特殊处理的方式做掉,因为这些数的三次根下取整一定是<span class="math inline">\(K\)</span>,式子就不难化简了.</p>
<h5><span id="example4uoj42sum">Example4([uoj42]Sum)</span></h5>
<p>这题的重点在于将幂通过<span class="math inline">\(-
1\)</span>的性质拿下来.</p>
<p>我们有<span class="math inline">\(( - 1 )^a = 1 - 2 ( a \mod 2 ) = 1
- 2 ( a - 2 \lfloor \frac{ a }{ 2 } \rfloor )\)</span>.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ d = 1 }^n ( - 1 )^{ \lfloor d \sqrt{ r } \rfloor } \\
= &amp; n - 2 \sum_{ d = 1 }^n \lfloor d \sqrt{ r } \rfloor + 4 \sum_{ d
= 1 }^n \lfloor \frac{ \lfloor d \sqrt{ r } \rfloor }{ 2 } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(f ( x ) = \frac{ x }{ 2
}\)</span>,根据整值函数的性质,不难发现<span class="math inline">\(\lfloor \frac{ \lfloor d \sqrt{ r } \rfloor }{ 2 }
\rfloor = \lfloor \frac{ d \sqrt{ r } }{ 2 } \rfloor\)</span>.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
ans &amp; = n - 2 \sum_{ d = 1 }^n \lfloor d \sqrt{ r } \rfloor + 4
\sum_{ d = 1 }^n \lfloor \frac{ d \sqrt{ r } }{ 2 } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>记<span class="math inline">\(t = \sqrt{ r
}\)</span>,我们所要解决的问题是<span class="math inline">\(\sum_{ d = 1
}^n \lfloor d \frac{ Pt + R }{ Q } \rfloor\)</span>.如果<span class="math inline">\(\frac{ Pt + R }{ Q } \geq
1\)</span>,我们可以把整数部分取出来单独算.于是接下来我们只讨论<span class="math inline">\(0 \leq \frac{ Pt + R }{ Q } &lt;
1\)</span>的情况.相当于求一条斜率小于<span class="math inline">\(1\)</span>的直线下方的整点个数.我们可以反转坐标系,这样就变成了斜率大于<span class="math inline">\(1\)</span>的直线,继续做上面的操作.</p>
<p>这个问题引出万能欧几里得算法.</p>
<h5><span id="example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</span></h5>
<p>解决形如<span class="math inline">\(\sum_{ x = 1 }^{ L } A^x B^{
\lfloor \frac{ Px + R }{ Q } \rfloor }\)</span>的问题,其中<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是<span class="math inline">\(n \times
n\)</span>的矩阵.默认<span class="math inline">\(P , Q , R \geq
0\)</span>.</p>
<p>我们将问题抽象为下面的模型:</p>
<p>首先将坐标系中所有经过整数点的与坐标轴平行的直线全都标记出来.</p>
<p>考虑将问题转化为:有一条<span class="math inline">\(y = \frac{ Px + R
}{ Q }\)</span>的直线,我们从<span class="math inline">\(( 0 , \frac{ R
}{ Q }
)\)</span>(不包含这个点)处开始沿直线向右走.每遇到一条横线,就进行<span class="math inline">\(U_w\)</span>操作;每遇到一条竖线,就进行<span class="math inline">\(R_w\)</span>操作.如果遇到了整数格点,就先进行<span class="math inline">\(U_w\)</span>操作,再进行<span class="math inline">\(R_w\)</span>操作.</p>
<p>例如上面那个例子就是:现在有一个矩阵二元组<span class="math inline">\(( X , Y )\)</span>,初始为<span class="math inline">\(( A , B^{ \lfloor \frac{ R }{ Q } \rfloor }
)\)</span>,<span class="math inline">\(R_w\)</span>操作是:<span class="math inline">\(( X , Y ) \rightarrow ( AX , Y + X
)\)</span>,<span class="math inline">\(U_w\)</span>操作是:<span class="math inline">\(( X , Y ) \rightarrow ( XB , Y
)\)</span>.一直走到<span class="math inline">\(x =
L\)</span>的点为止,最后矩阵<span class="math inline">\(Y\)</span>就是答案.不过这个形式不好写成矩阵,我们可以记录<span class="math inline">\(( A^a , B^b , Y
)\)</span>.这样最后就可以带入操作,不难发现这个操作是个环.</p>
<p>操作要满足可合并性,也就是我可以将<span class="math inline">\(U_w
R_w\)</span>变成一个操作进行.</p>
<p>接下来我们分情况讨论一下:</p>
<p>当<span class="math inline">\(P \geq Q\)</span>时,注意到<span class="math inline">\(y = \frac{ Px + R }{ Q } = \lfloor \frac{ P }{ Q }
\rfloor x + \frac{ ( P \mod Q ) x + R }{ Q }\)</span>,此时任意一个<span class="math inline">\(R_w\)</span>操作前必然有至少<span class="math inline">\(\lfloor \frac{ P }{ Q } \rfloor\)</span>个<span class="math inline">\(U_w\)</span>,我们令<span class="math inline">\(R_w
&#39; = U_w^{ \lfloor \frac{ P }{ Q } \rfloor }
R_w\)</span>,不难发现:<span class="math inline">\(solve ( P , Q , R , L
, U_w , R_w ) = solve ( P \mod Q , Q , R , L , U_w , R_w &#39;
)\)</span>.</p>
<p>当<span class="math inline">\(P &lt; Q \land P \ne
0\)</span>时,我们想要让<span class="math inline">\(P\)</span>与<span class="math inline">\(Q\)</span>互换,假设第<span class="math inline">\(a\)</span>个<span class="math inline">\(R_w\)</span>在第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>之前,考虑这个<span class="math inline">\(R_w\)</span>前会有<span class="math inline">\(\lfloor \frac{ Pa + R }{ Q } \rfloor - \lfloor
\frac{ R }{ Q } \rfloor\)</span>个<span class="math inline">\(U_w\)</span>,而对于后者,变换坐标系得到<span class="math inline">\(x = \frac{ yQ - R }{ P
}\)</span>,由于遇到整点时,先<span class="math inline">\(U_w\)</span>再进行<span class="math inline">\(R_w\)</span>,也就是说,第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>前会有<span class="math inline">\(\lfloor \frac{ Qb - R - 1 }{ P }
\rfloor\)</span>个<span class="math inline">\(R_w\)</span>(这个并没有忽略初始位置).我们考虑如何让这个数和上面的<span class="math inline">\(\lfloor \frac{ Pa + R }{ Q }
\rfloor\)</span>的差分写成一样的形式.注意到<span class="math inline">\(b
= 1\)</span>需要特殊处理!</p>
<p>显然操作序列一共有<span class="math inline">\(cntU = \lfloor \frac{
PL + R }{ Q } \rfloor - \lfloor \frac{ R }{ Q }
\rfloor\)</span>,将二者对应一下,这里的答案就是<span class="math inline">\(solve ( Q , P , ( Q - R - 1 ) \bmod P , cntU - 1 ,
R_w , U_w )\)</span>.</p>
<p>然后是开头部分,开头部分一共有<span class="math inline">\(\lfloor
\frac{ Q - R - 1 }{ P } \rfloor\)</span>个<span class="math inline">\(R_w\)</span>和一个<span class="math inline">\(U_w\)</span>.</p>
<p>但是注意到末尾部分同样是不规整的,注意到末尾一共有<span class="math inline">\(L - \lfloor \frac{ QcntU - R - 1 }{ P }
\rfloor\)</span>个<span class="math inline">\(R_w\)</span>,拼到末尾即可.</p>
<p>最后<span class="math inline">\(P = 0\)</span>的时候直接返回<span class="math inline">\(R_w^{ L }\)</span>即可.</p>
<p>假设合并的复杂度是<span class="math inline">\(c\)</span>,注意到每层的复杂度是<span class="math inline">\(O ( c \log ( \frac{ Q }{ P } ) ) = O ( c ( \log Q
- \log P ) )\)</span>,但是每两层会抵消,因此复杂度<span class="math inline">\(O ( C \log ( P + Q ) )\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个<span class="math inline">\(B\)</span>维的点<span class="math inline">\(x\)</span>,满足<span class="math inline">\(\forall
1 \leq i \leq B , l_i \leq x_i \leq
r_i\)</span>,称所有这样的点组成的集合为一个<span class="math inline">\(B\)</span>维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果<span class="math inline">\(l ,
r\)</span>有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个<span class="math inline">\(B\)</span>维正交范围有<span class="math inline">\(k\)</span>个有用限制,称它为<span class="math inline">\(k - side\)</span>的.</p>
<p>例如,找到区间<span class="math inline">\([ l , r ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(3 - side\)</span>的.找到区间<span class="math inline">\([ 1 , l ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(2 -
side\)</span>的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做<span class="math inline">\(n \times
n\)</span>的矩阵乘法目前得到的最优秀复杂度也是<span class="math inline">\(O ( n^{ 2 . 373 } )\)</span>.</p>
<p>另外可以归约:<span class="math inline">\(01\)</span>矩阵和整数矩阵在去除<span class="math inline">\(\log n\)</span>后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有<span class="math inline">\(\sqrt{ n
}\)</span>个叉,每个叉上有<span class="math inline">\(\sqrt{ n
}\)</span>个点.我们将这些叉编号为<span class="math inline">\([ 1 ,
\sqrt{ n } ]\)</span>.然后我们考虑询问两个叉所组成的链的答案,设<span class="math inline">\(f_{ i , j }\)</span>表示数字<span class="math inline">\(j\)</span>是否在<span class="math inline">\(i\)</span>的叉上出现过,不难发现它们合并的时候要对<span class="math inline">\(f\)</span>做或运算,<span class="math inline">\(01\)</span>矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第<span class="math inline">\(L\)</span>到第<span class="math inline">\(R\)</span>个块的答案,设为<span class="math inline">\(f ( L , R )\)</span>,这两块间的答案设为<span class="math inline">\(g ( L , R )\)</span>,显然<span class="math inline">\(f ( L , R ) = f ( L + 1 , R ) + f ( L , R - 1 ) -
f ( L + 1 , R - 1 ) + g ( L , R )\)</span>,而由于对值域分块,<span class="math inline">\(g ( L , R ) = \sum a \times
b\)</span>的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于<span class="math inline">\(A\)</span>的点加上<span class="math inline">\(v\)</span>,或者查询纵坐标小于等于<span class="math inline">\(B\)</span>的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将<span class="math inline">\(a\)</span>分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的<span class="math inline">\(L\)</span>的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为<span class="math inline">\(B\)</span>,暴力处理散块的复杂度是<span class="math inline">\(O ( Bm )\)</span>,处理整块的复杂度是<span class="math inline">\(O ( \frac{ n }{ B } ( m + n \log n )
)\)</span>.取<span class="math inline">\(B^2 = \frac{ n }{ m } ( m + n
\log n ) = 500\)</span>最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了<span class="math inline">\(B =
2048\)</span>.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了<span class="math inline">\([ 1
, l - 1 ]\)</span>对<span class="math inline">\([ l , r
]\)</span>的贡献.</p>
<p>先序列分块.然后<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块对<span class="math inline">\([ l , r
]\)</span>的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块的树状数组进行一个<span class="math inline">\([ l , r
]\)</span>的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到<span class="math inline">\(O ( Bq \log n )\)</span>的时间复杂度和<span class="math inline">\(O ( Bn )\)</span>的空间复杂度.</p>
<p>问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块咋办.首先<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的散块的贡献是好处理的,因为总共就<span class="math inline">\(O ( \frac{ n }{ B }
)\)</span>个数字,直接全部存下来排序做归并就可以统计,时间复杂度<span class="math inline">\(O ( Bq \log n )\)</span>.</p>
<p>现在的问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的整块如何贡献.能不能把<span class="math inline">\([ l , r
]\)</span>的信息统计在<span class="math inline">\([ 1 , l - 1
]\)</span>的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有<span class="math inline">\(\frac{ n }{ B }\)</span>个,整块一共有<span class="math inline">\(B\)</span>个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为<span class="math inline">\(O ( n \sqrt{ n } \log n
)\)</span>,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度<span class="math inline">\(O ( nq )\)</span>.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果<span class="math inline">\(n =
2^k\)</span>,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的<span class="math inline">\(a\)</span>(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是<span class="math inline">\(n\)</span>不一定是<span class="math inline">\(2^k\)</span>,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是<span class="math inline">\([ 1 , n
]\)</span>,然后每次操作都会将整个块分为两部分:<span class="math inline">\([ 1 , x )\)</span>和<span class="math inline">\([
x , maxn ]\)</span>,讨论一下<span class="math inline">\(maxn\)</span>和<span class="math inline">\(2
x\)</span>的大小,就可以用<span class="math inline">\(\min ( x , maxn - x
)\)</span>的复杂度使得<span class="math inline">\(maxn\)</span>变成<span class="math inline">\(maxn - x\)</span>,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到<span class="math inline">\(O ( n \sqrt{ n } \log n )\)</span>.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为<span class="math inline">\([
l , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献实际上就是<span class="math inline">\([ 1 , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献减去<span class="math inline">\([
1 , l - 1 ]\)</span>对<span class="math inline">\(r\)</span>的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入<span class="math inline">\(O ( n )\)</span>次但是需要查询<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到<span class="math inline">\(O ( n )\)</span>.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的<span class="math inline">\(n \times
n\)</span>的平面,我们现在对其进行分块:</p>
<ol type="1">
<li><p>将平面分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{
\frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(A\)</span>块,以<span class="math inline">\(A\)</span>块为单位做二维前缀和.</p></li>
<li><p>每个<span class="math inline">\(A\)</span>块内部分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 } }\)</span>个<span class="math inline">\(n^{ \frac{ 1 }{ 2 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>的<span class="math inline">\(B\)</span>块,在<span class="math inline">\(A\)</span>块内部以<span class="math inline">\(B\)</span>块为单位做二维前缀和.</p></li>
<li><p>将整个平面横着分别分成一个个<span class="math inline">\(n \times
n^{ \frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(C\)</span>块.(竖着也要分成一个个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times
n\)</span>的块,是类似的,略去)</p></li>
<li><p>每个<span class="math inline">\(C\)</span>块内部分成<span class="math inline">\(\sqrt{ n }\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(D\)</span>块,在<span class="math inline">\(C\)</span>块内部以<span class="math inline">\(D\)</span>块为单位做二位前缀和.</p></li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.同时注意到空间复杂度是<span class="math inline">\(O ( n
)\)</span>的.</p>
<p>查询显然是分四种情况讨论:<span class="math inline">\(A , B ,
D\)</span>块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应<span class="math inline">\(O ( 1 )\)</span>个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个<span class="math inline">\(l\)</span>对应<span class="math inline">\(O ( 1
)\)</span>个<span class="math inline">\(r\)</span>,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有<span class="math inline">\(O ( \sqrt{ n }
)\)</span>个查询,记录一下即可.这样就做到了<span class="math inline">\(O
( \sqrt{ n } )\)</span>单点改,<span class="math inline">\(O ( 1
)\)</span>查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现<span class="math inline">\(O
( 1 )\)</span>单点改,那这种情况下如何实现<span class="math inline">\(O (
\sqrt{ n } )\)</span>求和呢?首先还是可以<span class="math inline">\(O (
\sqrt{ n } )\)</span>求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度<span class="math inline">\(&lt; n^{ \frac{ 1 }{ 2 }
}\)</span>,我们就可以在每次查询的时候用<span class="math inline">\(\sqrt{ n
}\)</span>的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以<span class="math inline">\(O ( \sqrt{ n } )\)</span>求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和<span class="math inline">\(a_r\)</span>颜色相同的点是<span class="math inline">\(r
&#39;\)</span>,则显然新增的逆序对只可能出现在<span class="math inline">\([ r &#39; , r ]\)</span>中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从<span class="math inline">\(n \rightarrow
1\)</span>扫左端点,总共做<span class="math inline">\(O ( n
)\)</span>次单点修改,做<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; +
1 , a_r )\)</span>,右上角是<span class="math inline">\(( r , \infty
)\)</span>的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令<span class="math inline">\(rev ( x ) = n - x +
1\)</span>.然后将所有点的纵坐标<span class="math inline">\(rev\)</span>掉,现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; + 1 , 1 )\)</span>,右上角是<span class="math inline">\(( r , rev ( a_r )
)\)</span>的矩阵,这玩意可以拆前缀和拆成形如左下角是<span class="math inline">\(( 1 , 1 )\)</span>,右上角是<span class="math inline">\(( i , rev ( a_i )
)\)</span>的矩阵.也就是说我们的<span class="math inline">\(O ( n \sqrt{
n } )\)</span>次矩阵查询本质上只有<span class="math inline">\(O ( n
)\)</span>种.</p>
<p>拆到这里发现其实到这一步<span class="math inline">\(a_r\)</span>和<span class="math inline">\(a_{ r
&#39;
}\)</span>是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉<span class="math inline">\([ l_1 , r_1
]\)</span>这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维<span class="math inline">\([ l_2
, r_2
]\)</span>扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点<span class="math inline">\(( a , a )\)</span>上加上一个相应的<span class="math inline">\(b\)</span>,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点<span class="math inline">\(A ( x_1 , x_1 )\)</span>和<span class="math inline">\(B ( x_2 , x_2 )\)</span>之间的<span class="math inline">\(( x_1 , x_2 )\)</span>上加上一个<span class="math inline">\(- b\)</span>,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li><p>莫队时查询一个点的前驱后继,这个操作就需要<span class="math inline">\(O ( 1 )\)</span>完成.</p></li>
<li><p><span class="math inline">\(n \sqrt{ n
}\)</span>次单点修改,这个操作需要<span class="math inline">\(O ( 1
)\)</span>完成.</p></li>
<li><p><span class="math inline">\(n\)</span>次矩阵求和,这个操作需要在小于<span class="math inline">\(O ( \sqrt{ n } )\)</span>的时间完成.</p></li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为<span class="math inline">\(O (
n \sqrt{ n }
)\)</span>,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是<span class="math inline">\(+
1\)</span>很难处理,因为它形如在trie上找到所有长度连续为<span class="math inline">\(1\)</span>到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是<span class="math inline">\(+ 1\)</span>的话就相当于反转一条从根开始均为<span class="math inline">\(1\)</span>的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对<span class="math inline">\(c\)</span>分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求<span class="math inline">\(\max\)</span>.而对于块间如何做呢?</p>
<p>我们设<span class="math inline">\(suf_i\)</span>为前一个块的后<span class="math inline">\(i\)</span>个数之和,<span class="math inline">\(pre_i\)</span>为后一个块的前<span class="math inline">\(i\)</span>个数之和.注意到我们要求的就是<span class="math inline">\(\max \{ suf_i + pre_j | i + j \leq c
\}\)</span>.这个咋做呢?</p>
<p>你注意到这个<span class="math inline">\(i + j \leq
c\)</span>的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用<span class="math inline">\(j \rightarrow c - j +
1\)</span>的话,这个限制就转化为了<span class="math inline">\(i + c - j +
1 \leq c\)</span>,也就是<span class="math inline">\(i &lt;
j\)</span>,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对<span class="math inline">\(c\)</span>分块?</p>
<p>一方面,题目中的<span class="math inline">\(c\)</span>是给定的.另一方面,我们注意到我们需要维护一个和<span class="math inline">\(c\)</span>有关的东西,而如果没有<span class="math inline">\(c\)</span>,或者说<span class="math inline">\(c =
n\)</span>的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了<span class="math inline">\(c = n\)</span>的条件.考虑到这一点,对<span class="math inline">\(c\)</span>分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将<span class="math inline">\(a [ l - 1 ]\)</span>和<span class="math inline">\(a [ r + 1 ]\)</span>都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个<span class="math inline">\(maxn\)</span>设成<span class="math inline">\(-
\infty\)</span>的.如果这两个东西设成等大的<span class="math inline">\(-
\infty\)</span>,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比<span class="math inline">\(- \infty\)</span>还要小的数字,最底层的<span class="math inline">\(maxn\)</span>有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到<span class="math inline">\([ i - r_i , i -
1 ]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两段的最大值,设为<span class="math inline">\(x\)</span>,则最后的答案就是<span class="math inline">\(\max \{ a_i + x \}\)</span>.</p>
<p>思考这个过程,我们将<span class="math inline">\([ i - r_i , i - 1
]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两条线段以<span class="math inline">\(a_i\)</span>的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的<span class="math inline">\(a_i\)</span>的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是<span class="math inline">\(sum\)</span>,则我们要在这些数中找到一个分界点,使得左边的和大于等于<span class="math inline">\(sum\)</span>,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(a_i , b_i\)</span>,选定至多<span class="math inline">\(k\)</span>个位置使这里的值为<span class="math inline">\(a_i - b_i\)</span>,其它位置的值是<span class="math inline">\(a_i\)</span>,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的<span class="math inline">\(mid\)</span>,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - b_k + \max_{ i = 1 }^k \{ sum_i \} )
\}\)</span>.注意改掉一个位置后要把它的<span class="math inline">\(b\)</span>变成<span class="math inline">\(0\)</span>.</p>
<p>那么什么样的<span class="math inline">\(b\)</span>有可能是我们要选中的呢?显然可能被选中的<span class="math inline">\(b\)</span>一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - \max_{ i = k }^n \{ b_i \} + \max_{ i = 1 }^k \{ sum_i
\} )
\}\)</span>,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的<span class="math inline">\(\max\)</span>尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - sufmax ( b
)_k + premax ( sum )_k \} \\
= &amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - \max (
sufmax ( b )_{ k + 1 } , b_k ) + premax ( sum )_k \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的<span class="math inline">\(k\)</span>后面最大的<span class="math inline">\(b\)</span>,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响<span class="math inline">\(sufmax ( b
)\)</span>的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的<span class="math inline">\(b\)</span>,这个<span class="math inline">\(b\)</span>必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理<span class="math inline">\(K\)</span>维正交范围(给定<span class="math inline">\(n\)</span>个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度<span class="math inline">\(O ( n^{ 1 - \frac{ 1 }{ k } } + \log n
)\)</span>.(单调修改复杂度只是<span class="math inline">\(O ( \log n
)\)</span>)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是<span class="math inline">\(\sum dep_u\)</span>,是可以被卡成<span class="math inline">\(O ( n^2 )\)</span>的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为<span class="math inline">\([ l , r ]\)</span>,这样会有:<span class="math inline">\([ l - 1 , i - 1 ] \rightarrow [ i , r
]\)</span>.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设<span class="math inline">\(f_{ i , j
}\)</span>表示前<span class="math inline">\(i\)</span>个测试点已经分成了<span class="math inline">\(j\)</span>段的方案数,然后做转移,复杂度<span class="math inline">\(O ( T^2 S )\)</span>.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到<span class="math inline">\(k\)</span>最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把<span class="math inline">\([ l , r
]\)</span>分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点<span class="math inline">\(r\)</span>,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把<span class="math inline">\(x\)</span>位置的值改为<span class="math inline">\(y\)</span>或查询一个区间中小于<span class="math inline">\(y\)</span>的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开<span class="math inline">\(100\)</span>个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><p><span class="math inline">\(x + y &lt; C\)</span>,取<span class="math inline">\(x + y\)</span>作为答案.</p></li>
<li><p><span class="math inline">\(x + y \geq C\)</span>,取<span class="math inline">\(x + y - C\)</span>作为答案.</p></li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在<span class="math inline">\([ 0 , \lceil \frac{ C }{ 2 } \rceil
)\)</span>中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,<span class="math inline">\(x + y &lt; C\)</span>也就是<span class="math inline">\(x &lt; C -
y\)</span>,我们把第二个集合中的元素全部变成<span class="math inline">\(C
- y\)</span>后插入,只需最小化<span class="math inline">\(C - x -
y\)</span>,这个只需要维护最大的<span class="math inline">\(x\)</span>和最小的<span class="math inline">\(C -
y\)</span>就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用<span class="math inline">\(O ( \log n
)\)</span>的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设<span class="math inline">\(w_i\)</span>为从上往下延伸到<span class="math inline">\(i\)</span>这个点后,还能多往下延伸多少,一开始<span class="math inline">\(w\)</span>都是<span class="math inline">\(-
1\)</span>,每次操作会让<span class="math inline">\(w + =
1\)</span>.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为<span class="math inline">\(w\)</span>的数字,但这样就炸了,因为每修改一个点可能要影响<span class="math inline">\(O ( n )\)</span>个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为<span class="math inline">\(w\)</span>的数字,而显然只有两个数互相匹配才可行.如果<span class="math inline">\(i &lt; j &lt; k , ( i , j ) , ( i , k
)\)</span>分别配对,那么显然<span class="math inline">\(( i , k
)\)</span>没有用.这样每个点只有<span class="math inline">\(O ( 1
)\)</span>个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑<span class="math inline">\(k =
1\)</span>怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p><span class="math inline">\(k \ne
1\)</span>怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在<span class="math inline">\(\bmod
k\)</span>意义下全部相等,维护差分数组的区间<span class="math inline">\(\gcd\)</span>就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为<span class="math inline">\(q\)</span>的衣服,<span class="math inline">\([ 0 ,
q )\)</span>的人肯定买不了,<span class="math inline">\([ q , 2 q - 1
]\)</span>的人买完后,手上的钱至少减半,我们暴力处理,至于<span class="math inline">\([ 2 q , + \infty
)\)</span>,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到<span class="math inline">\(0\)</span>,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是<span class="math inline">\(pre [ i ] = i - 1\)</span>).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改<span class="math inline">\(a , b ,
c\)</span>中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字<span class="math inline">\(x\)</span>,每次随机在<span class="math inline">\([ 1 , x ]\)</span>中一个数<span class="math inline">\(y\)</span>并令<span class="math inline">\(x
\leftarrow x \bmod y\)</span>,初始值为<span class="math inline">\(n\)</span>,求期望几次能变成<span class="math inline">\(0\)</span>.</p>
<p>注意到如果<span class="math inline">\(y\)</span>很小就直接做,<span class="math inline">\(y\)</span>很大的话<span class="math inline">\(\lfloor \frac{ x }{ y }
\rfloor\)</span>很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字<span class="math inline">\(x ,
y\)</span>,求最小的<span class="math inline">\(| i - j
|\)</span>满足<span class="math inline">\(a_i = x , a_j =
y\)</span>.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果<span class="math inline">\(x ,
y\)</span>出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于<span class="math inline">\(Y\)</span>很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于<span class="math inline">\(Y\)</span>很大的情况,<span class="math inline">\(\frac{ n }{ Y
}\)</span>一定很小,我们不断查询大于等于<span class="math inline">\(kY\)</span>的最小元素即可,这个可以值域分块来根号平衡做到<span class="math inline">\(O ( 1 )\)</span>查询,<span class="math inline">\(O
( \sqrt{ n }
)\)</span>单点修改.具体地,我们对每个块处理出大于等于这个块的最小的<span class="math inline">\(X\)</span>,以及块内每个点后面最小的<span class="math inline">\(X\)</span>(必须在块内),然后定位到<span class="math inline">\(kY\)</span>的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定<span class="math inline">\(n , m\)</span>,以及序列<span class="math inline">\(a\)</span>和长度为<span class="math inline">\(n\)</span>的排列<span class="math inline">\(y\)</span>,你需要回答<span class="math inline">\(m\)</span>个询问.对每个询问,给定<span class="math inline">\(l , r\)</span>,查询:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \sum_{ j = i + 1 }^n [ a_i = a_j ] \prod_{ k = i }^j [
l \leq y_k \leq r ]
\]</span></p>
<p>注意到<span class="math inline">\(y_i =
i\)</span>的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点<span class="math inline">\(( x , y ) , a_x
= a_y , \nexists x &lt; z &lt; y , a_z = a_x\)</span>,对于<span class="math inline">\(( x , y
)\)</span>这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,它们最多只有<span class="math inline">\(\sqrt{ n
}\)</span>个,考虑莫队复杂度<span class="math inline">\(O ( n \sqrt{ m }
+ m )\)</span>,因此我们可以对每个分别做莫队,总复杂度<span class="math inline">\(O ( n \sqrt{ m } + m \sqrt{ n }
)\)</span>,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,这些数字一共最多有<span class="math inline">\(n\)</span>个,每个点暴力配对就有<span class="math inline">\(O ( n \sqrt{ n } )\)</span>个点对,然后<span class="math inline">\(O ( m
)\)</span>次询问,用根号平衡做扫描线,这里复杂度<span class="math inline">\(O ( n \sqrt{ n } + m \sqrt{ n } )\)</span>.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为<span class="math inline">\(1\)</span>,支持把一条链上所有点加上<span class="math inline">\(k\)</span>,或者查询距离一个点<span class="math inline">\(&lt; = 1\)</span>的所有点的点权<span class="math inline">\(kth\)</span>.<span class="math inline">\(n \leq 2
\times 10^5\)</span>.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改<span class="math inline">\(O ( \log n )\)</span>个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个<span class="math inline">\(B\)</span>维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个<span class="math inline">\(B -
1\)</span>维的动态问题.不过扫描线处理的时候可能需要是低<span class="math inline">\(side\)</span>的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的<span class="math inline">\(popcount\)</span>,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点<span class="math inline">\(x\)</span>作为最大值的影响区间<span class="math inline">\([ l , r ]\)</span>,也就是如果一个区间左端点在<span class="math inline">\([ l , x ]\)</span>,右端点在<span class="math inline">\([ x , r
]\)</span>即可满足条件.我们考虑放入一个左下角坐标为<span class="math inline">\(( l , x )\)</span>,右上角坐标为<span class="math inline">\(( x , r
)\)</span>的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设<span class="math inline">\(S = \{ l \} \cup \{ r
\}\)</span>,考虑用<span class="math inline">\(len_i\)</span>表示<span class="math inline">\(i\)</span>节点及以前最多能有多少阳光.我们考虑用<span class="math inline">\(len_{ i - 1 }\)</span>更新<span class="math inline">\(len_i\)</span>,如果<span class="math inline">\([ i
- 1 , i ]\)</span>没被覆盖,显然直接加上这段的长度.如果<span class="math inline">\([ i - 1 , i
]\)</span>被覆盖大于两次,那显然直接继承<span class="math inline">\(len_{
i - 1 }\)</span>.</p>
<p>先考虑<span class="math inline">\([ i - 1 , i
]\)</span>被两朵云覆盖了怎么办,我们考虑用<span class="math inline">\(h_{
j , k }\)</span>表示当前被且只被<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>共同覆盖的区间长度,不难发现<span class="math inline">\(h_{ j , k
}\)</span>有值的地方很少,用map.然后还要加上它们各自的贡献,用<span class="math inline">\(g_j\)</span>表示当前被且只被<span class="math inline">\(j\)</span>覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断<span class="math inline">\([ i - 1 , i
]\)</span>是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果<span class="math inline">\([ i - 1 , i
]\)</span>被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为<span class="math inline">\(k\)</span>,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是<span class="math inline">\(g_j +
g_k\)</span>,用线段树处理出当前代价和小于等于<span class="math inline">\(C\)</span>的<span class="math inline">\(k\)</span>的<span class="math inline">\(g_k\)</span>的最大值就行.</p>
<p>再考虑有交的情况,答案应该为<span class="math inline">\(g_j + g_k +
h_{ j , k }\)</span>,我们在每次遇到<span class="math inline">\(( j , k
)\)</span>的时候都在对方那里打个tag就好,也就是对于每个<span class="math inline">\(j\)</span>,处理出和它有交的云中<span class="math inline">\(g_j + g_k + h_{ j , k
}\)</span>的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成<span class="math inline">\(0\)</span>后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为<span class="math inline">\(0\)</span>:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是<span class="math inline">\(L &lt; R\)</span>,自然有<span class="math inline">\(L \leq \min \{ r_i \} , R \geq \max \{ l_i
\}\)</span>,那么当我们确定<span class="math inline">\(L\)</span>后,我们有<span class="math inline">\(R
\in [ \max \{ l_i \} , f ( L ) ]\)</span>.接下来我们考虑如何计算<span class="math inline">\(f ( L )\)</span>.</p>
<p>注意到<span class="math inline">\(L &lt; l_i \Rightarrow R \leq
r_i\)</span>,我们考虑将<span class="math inline">\(l_i\)</span>这个点的权值设成<span class="math inline">\(r_i\)</span>,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是<span class="math inline">\(O ( nm^{ \frac{ 2 }{ 3 } } )\)</span>,<span class="math inline">\(B = n^{ \frac{ 2 }{ 3 } }\)</span>,排序原则是<span class="math inline">\(( ls , rs , t
)\)</span>,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个<span class="math inline">\(\log
n\)</span>的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带<span class="math inline">\(\log
n\)</span>的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有<span class="math inline">\(n
\sqrt{ n }\)</span>次询问,每次询问<span class="math inline">\(f ( l , r
, r + 1 )\)</span>表示区间<span class="math inline">\([ l , r
]\)</span>对<span class="math inline">\(r +
1\)</span>的逆序对贡献.考虑差分成<span class="math inline">\(f ( 1 , r ,
r + 1 ) - f ( 1 , l - 1 , r + 1
)\)</span>,前者显然可以迅速求出.而后者的右端点需要移动<span class="math inline">\(n\)</span>次,需要查询总共<span class="math inline">\(n \sqrt{ n }\)</span>次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都<span class="math inline">\(4 - side\)</span>了,但是有可减性,减成<span class="math inline">\(2 - side\)</span>就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉<span class="math inline">\(p =
2\)</span>和<span class="math inline">\(p =
5\)</span>的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字<span class="math inline">\(\bmod p\)</span>的值,设为<span class="math inline">\(suf_i\)</span>,假设存在两个点<span class="math inline">\(l , r\)</span>满足<span class="math inline">\(p |
( suf_l - suf_{ r + 1 } )\)</span>,那么<span class="math inline">\([ l ,
r ]\)</span>就是合法的,这是自然的,也就等价于<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>,相当于要对满足<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>的二元组<span class="math inline">\(( l , r )\)</span>计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的<span class="math inline">\(( l , r
)\)</span>的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,<span class="math inline">\(a_{ l , r } = maxn -
minn - ( r - l )\)</span>,显然只需要找到为<span class="math inline">\(0\)</span>的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有<span class="math inline">\(3 -
side\)</span>的,但是可差分成<span class="math inline">\(2 -
side\)</span>.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前<span class="math inline">\(k\)</span>个数,它们的取值是<span class="math inline">\([ 1 , k ]\)</span>,现在加入第<span class="math inline">\(k +
1\)</span>个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都<span class="math inline">\(+ 1\)</span>,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道<span class="math inline">\(p_i\)</span>是多少,根据上面的构造过程,首先将<span class="math inline">\(p_i =
a_i\)</span>,然后不断向后遍历,每遇到一个<span class="math inline">\(a_j\)</span>,如果<span class="math inline">\(a_j
\leq p_i\)</span>,则把<span class="math inline">\(p_i + =
1\)</span>.</p>
<p>我们将数列分块,设块长为<span class="math inline">\(B\)</span>,那一个值经过一个块的时候最多加块长个<span class="math inline">\(1\)</span>.也就是经过整块的时候是一个<span class="math inline">\(B\)</span>段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是<span class="math inline">\(\sum{ \cfrac{ B }{ 2^i } } = B\)</span>的,</p>
<p>于是最后复杂度为<span class="math inline">\(O ( T ( B + \cfrac{ n }{
B } \log n ) )\)</span>,取<span class="math inline">\(B = \sqrt{ n \log
n }\)</span>即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><p><span class="math inline">\(O ( 1 )\)</span>单点加,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>区间和:维护块内的和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>单点加,<span class="math inline">\(O ( 1
)\)</span>区间和:维护块内和块间的前缀和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>区间加,<span class="math inline">\(O ( 1 )\)</span>单点和:差分转化为<span class="math inline">\(( 2 )\)</span>.当然打标记也是可以的.</p></li>
<li><p><span class="math inline">\(O ( 1 )\)</span>区间加,<span class="math inline">\(O ( \sqrt{ n } )\)</span>单点和:差分转化为<span class="math inline">\(( 1 )\)</span>.当然打标记也是可以的.</p></li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( 1
)\)</span>插入,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块就可以.</p></li>
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( \sqrt{ n }
)\)</span>插入,<span class="math inline">\(O ( 1 )\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块,然后暴力改变每个点所属的块就行.</p></li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出<span class="math inline">\(f_{ l , r
}\)</span>表示块<span class="math inline">\([ l , r
]\)</span>的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是<span class="math inline">\(\log n\)</span>的,因此复杂度<span class="math inline">\(O ( n \sqrt{ n \log n } )\)</span>.</p>
<p>但是可以优化,我们设<span class="math inline">\(mx\)</span>表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于<span class="math inline">\(mx\)</span>可以<span class="math inline">\(O ( 1
)\)</span>判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然<span class="math inline">\(mx\)</span>增加总次数也不会超过<span class="math inline">\(O ( \sqrt{ n } )\)</span>,因此做到<span class="math inline">\(O ( n \sqrt{ n } )\)</span>.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个<span class="math inline">\(O ( 1 )\)</span>查询区间和,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有<span class="math inline">\(m\)</span>次查询,<span class="math inline">\(n \sqrt{ m }\)</span>次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有<span class="math inline">\(O ( n
)\)</span>种,用值域分块就可以平衡复杂度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">数学分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="实数">实数</span></h3>
<p>首先我们拿到了有理数,然后我们按照以下步骤定义无理数:</p>
<p>首先我们注意到有理数是不连续的.问题在于我们要将其中不连续的部分给补上.首先我们应当去发现一下如何去发现有理数中的一个断点:</p>
<p>设<span class="math inline">\(S\)</span>是一个全序非空集合,我们找到它的两个非空子集<span class="math inline">\(A , B\)</span>,若满足:</p>
<ol type="1">
<li><p><span class="math inline">\(A \cap B = \emptyset , A \cup B =
S\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a \in A , b \in B , a &lt;
b\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span>中无最大元素.</p></li>
</ol>
<p>则称这是<span class="math inline">\(S\)</span>的一个<strong>分划</strong>,记作<span class="math inline">\(( A | B )\)</span>.接下来我们先考虑<span class="math inline">\(S = \mathbb{ Q }\)</span>的情况.</p>
<p>我们注意到一些事,比如说注意到<span class="math inline">\(B\)</span>中有可能没有最小元素.举个例子的话,我们令<span class="math inline">\(S = \mathbb{ Q } , A = \{ x | x \leq 0 \lor ( x
&gt; 0 \land x^2 &lt; 2 ) \}\)</span>,显然<span class="math inline">\(A\)</span>中无最大元素,此时取<span class="math inline">\(B = S \setminus A\)</span>,则显然<span class="math inline">\(B\)</span>中无最小元素(反证法),假设存在最小元素则可以调整到更小的元素,因为容易证明不存在一个有理数的平方为<span class="math inline">\(2\)</span>.</p>
<p>通过上面的铺垫我们知道,有理数并非连续的,因此如果<span class="math inline">\(B\)</span>中有最小元素,则称这是一个<strong>有理分划</strong>;如果<span class="math inline">\(B\)</span>中无最小元素,则称这是一个<strong>无理分划</strong>.容易发现有理分划与有理数一一对应.我们将无理分划也去对应到一些数上,这就产生了无理数的定义.只需比较<span class="math inline">\(A\)</span>集合的大小包含关系就可以比较两个实数的大小.</p>
<p>那我们还需要做的一件事是去证明无理数也有四则运算法则.不妨直接拿分划去验证四则运算法则:</p>
<ol type="1">
<li><p>加法:对于<span class="math inline">\(( A_c | B_c ) + ( A_d | B_d
)\)</span>,我们取<span class="math inline">\(A_{ c + d } = \{ x + y | x
\in A_c , y \in A_d \}\)</span>即可.</p></li>
<li><p>减法:只需定义加法逆元.如果是无理分划的话,直接把<span class="math inline">\(A ,
B\)</span>中的元素全部取反再交换即可;如果是有理分划的话,需要注意取反再交换后<span class="math inline">\(A\)</span>中出现了最大元素,只需要在这里把那个元素给提出来就行.</p></li>
<li><p>乘法:两个正数相乘可以直接模仿加法,如果有负数的话就把负号提出来再把绝对值作乘法即可.</p></li>
<li><p>除法:只需定义乘法逆元,这个有点麻烦需要判断<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>哪个集合是同号的,但总之这个是平凡的.</p></li>
</ol>
<h4><span id="戴德金分割定理">戴德金分割定理</span></h4>
<p>对<span class="math inline">\(\mathbb{ R }\)</span>的任一分划<span class="math inline">\(( A | B )\)</span>,<span class="math inline">\(B\)</span>中必定有最小元素.</p>
<p>这个怎么证明呢?对于分划<span class="math inline">\(( A | B
)\)</span>,我们直接取<span class="math inline">\(A &#39; = A \cap
\mathbb{ Q } , B &#39; = B \cap \mathbb{ Q }\)</span>,不难发现<span class="math inline">\(( A &#39; | B &#39; )\)</span>一定是<span class="math inline">\(\mathbb{ Q }\)</span>的一个分划,也就是说<span class="math inline">\(( A &#39; | B &#39; )\)</span>对应了一个实数<span class="math inline">\(x\)</span>.</p>
<p>既然如此就可以考虑<span class="math inline">\(x\)</span>应该属于哪个集合.我们注意到:如果<span class="math inline">\(x \in A\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(A\)</span>中的最大元素;如果<span class="math inline">\(x \in B\)</span>,那么<span class="math inline">\(x\)</span>必定是<span class="math inline">\(B\)</span>中的最小元素.</p>
<p>两部分是类似的,只考虑前一部分.考虑反证,如果<span class="math inline">\(\exists y &gt; x , y \in A , x \in
A\)</span>,那么<span class="math inline">\(A &#39; \subsetneq
A_y\)</span>,那么<span class="math inline">\(A_y\)</span>就一定不是<span class="math inline">\(A\)</span>的子集.换言之,<span class="math inline">\(\exists w \in A_y\)</span>,<span class="math inline">\(\forall z \in A , w &gt; z\)</span>.但我们有<span class="math inline">\(y &gt; w\)</span>,这必然意味着<span class="math inline">\(y \notin A\)</span>,与假设不符.</p>
<h4><span id="确界存在定理">确界存在定理</span></h4>
<p>若<span class="math inline">\(M\)</span>有上(下)界,则必然有上(下)确界.</p>
<p>设<span class="math inline">\(M\)</span>有上界<span class="math inline">\(c\)</span>,由于它是一个实数,它应该可以写作<span class="math inline">\(( A_c | B_c )\)</span>的形式.<span class="math inline">\(\forall \alpha \in M , A_\alpha \subset
A_c\)</span>.</p>
<p>于是我们取<span class="math inline">\(A = \bigcup_{ \alpha \in M }
A_\alpha , B = \mathbb{ Q } \setminus A\)</span>,我们来说明<span class="math inline">\(( A | B )\)</span>是一个分划.</p>
<p>首先由于有上界,显然<span class="math inline">\(A , B \ne \emptyset ,
A \cap B = \emptyset , A \cup B = \mathbb{ Q }\)</span>.</p>
<p>如果 <span class="math inline">\(\exists b \in B , a \in A , b &lt;
a\)</span>,这是不可能的,因为如果<span class="math inline">\(b &lt;
a\)</span>,那么<span class="math inline">\(b \in A , b \notin
B\)</span>.</p>
<p>因为所有的<span class="math inline">\(A_\alpha\)</span>中都没有最大元素,反证即可说明<span class="math inline">\(A\)</span>中无最大元素.</p>
<p>那么<span class="math inline">\(( A | B )\)</span>就是<span class="math inline">\(M\)</span>的上确界.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明对于单增函数<span class="math inline">\(f : [ 0 , 1 ] \rightarrow
[ 0 , 1 ]\)</span>,<span class="math inline">\(f ( [ 0 , 1 ] ) \subseteq
( 0 , 1 )\)</span>,则<span class="math inline">\(f\)</span>与<span class="math inline">\(y = x\)</span>一定有交点.</p>
<p>取<span class="math inline">\(A = \{ x | f ( x ) &lt; x
\}\)</span>,则<span class="math inline">\(1 \in A , A \subseteq [ 0 , 1
]\)</span>.取<span class="math inline">\(a = \inf A\)</span>.</p>
<p>此时我们断言<span class="math inline">\(f ( a ) =
a\)</span>,否则:</p>
<p>如果<span class="math inline">\(f ( a ) &lt; a\)</span>,取<span class="math inline">\(\epsilon = a - f ( a )\)</span>,注意到<span class="math inline">\(f ( a - \frac{ \epsilon }{ 2 } ) &lt; f ( a ) &lt;
a - \frac{ \epsilon }{ 2 }\)</span>,因此<span class="math inline">\(( a
- \frac{ \epsilon }{ 2 } ) \in A\)</span>,与<span class="math inline">\(a\)</span>是下确界矛盾.</p>
<p>如果<span class="math inline">\(f ( a ) &gt; a\)</span>,取<span class="math inline">\(\epsilon = f ( a ) - a\)</span>.考虑由于<span class="math inline">\(a\)</span>是下确界,因此<span class="math inline">\(\exists b \in A , b \in ( a , a + \frac{ \epsilon
}{ 2 } )\)</span>.那么<span class="math inline">\(b &lt; a + \frac{
\epsilon }{ 2 } &lt; f ( a ) &lt; f ( b )\)</span>,这与<span class="math inline">\(b \in A\)</span>矛盾.</p>
<h4><span id="阿基米德性质">阿基米德性质</span></h4>
<p>以下命题等价,任取其一均可作为阿基米德性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall y \in \mathbb{ R
}\)</span>,<span class="math inline">\(\exists n \in \mathbb{ N } , n
&gt; y\)</span>.</p></li>
<li><p><span class="math inline">\(\forall x \in \mathbb{ R }_+ ,
\exists n \in \mathbb{ N }\)</span>,<span class="math inline">\(nx &gt;
1\)</span>.</p></li>
<li><p><span class="math inline">\(\{ \frac{ 1 }{ n }
\}\)</span>有聚点.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ n }\)</span>存在.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ n } = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
1 }{ 2^n } = 0\)</span>.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)<span class="math inline">\(\Rightarrow\)</span>(3)<span class="math inline">\(\Rightarrow\)</span>(4)<span class="math inline">\(\Rightarrow ( 5 )\)</span>是显然的.又考虑<span class="math inline">\(\{ \frac{ 1 }{ 2^n } \}\)</span>是<span class="math inline">\(\{ \frac{ 1 }{ n } \}\)</span>的子列,所以<span class="math inline">\(( 5 ) \Rightarrow ( 6 )\)</span>.而取一个<span class="math inline">\(\frac{ 1 }{ 2^k } &lt; \frac{ 1 }{ | y |
}\)</span>即可(6)<span class="math inline">\(\Rightarrow\)</span>(1).</p>
<p>阿基米德性质可以由确界存在定理推来,简单来说考虑<span class="math inline">\(x \in \mathbb{ R }_+ , A = \{ nx | nx &lt; 1
\}\)</span>.反证,如果<span class="math inline">\(A\)</span>是无限集合,那么根据确界存在定理一定存在最小上确界<span class="math inline">\(\alpha \leq 1\)</span>有<span class="math inline">\(\forall n , nx &lt; \alpha , ( n + 1 ) x &lt;
\alpha , nx &lt; \alpha - x\)</span>,这就说明<span class="math inline">\(\alpha -
x\)</span>是一个更小的上界,这就矛盾了.</p>
<h3><span id="实数集上的一元函数">实数集上的一元函数</span></h3>
<h4><span id="性质">性质</span></h4>
<h5><span id="奇偶性">奇偶性</span></h5>
<p>首先需要定义域关于原点对称.</p>
<p>然后注意到取<span class="math inline">\(f ( x ) = \frac{ f ( x ) + f
( - x ) }{ 2 } + \frac{ f ( x ) - f ( - x ) }{ 2
}\)</span>,可将任意定义域关于原点对称的函数写作奇偶函数之和.</p>
<p>事实上,对于一个可以求任意次导数的偶函数<span class="math inline">\(f\)</span>,是否总存在一个可以求任意次导数的函数<span class="math inline">\(g\)</span>使得<span class="math inline">\(f ( x )
= g ( x^2 )\)</span>.</p>
<p>这个问题的难点肯定在于<span class="math inline">\(0\)</span>附近对吧.</p>
<p>这个证明要用到泰勒展开.</p>
<p><span class="math display">\[
f ( \sqrt{ x } ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( 0 ) }{ k ! }
x^\frac{ k }{ 2 } + \frac{ f^{ ( n + 1 ) } ( \xi_n ) }{ ( n + 1 ) ! }
x^\frac{ n + 1 }{ 2 }
\]</span></p>
<p>两边求导,应该有:</p>
<p><span class="math display">\[
( f ( \sqrt{ x } ) )^{ ( t ) } = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( 0
) \prod \limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{
\frac{ k }{ 2 } - t } + \frac{ f^{ ( n + 1 ) } ( \xi_n ) \prod \limits_{
i = 0 }^{ t - 1 } ( \frac{ n + 1 }{ 2 } - i ) }{ ( n + 1 ) ! } x^{
\frac{ n + 1 }{ 2 } - t }
\]</span></p>
<p>我们知道<span class="math inline">\(f\)</span>任意阶导数存在,所以在闭区间<span class="math inline">\([ - 1 , 1
]\)</span>上任意阶导数有界.这就意味着,对于固定的<span class="math inline">\(t\)</span>.只要取足够大的<span class="math inline">\(n = 2 t + 2\)</span>满足<span class="math inline">\(\frac{ n + 1 }{ 2 } - t &gt;
1\)</span>,就可以让余项趋于<span class="math inline">\(0\)</span>.</p>
<p>现在来数学归纳,用多项式的特殊情况,假设<span class="math inline">\(g^{
( t ) } ( 0 ) = \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0
)\)</span>,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
g^{ ( t + 1 ) } ( 0 ) = \frac{ ( f ( \sqrt{ x } ) )^{ ( t ) } - \frac{ t
! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) }{ x } \\
= \cfrac{ \sum_{ k = 0 }^{ 2 t + 2 } \frac{ f^{ ( k ) } ( 0 ) \prod
\limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{
k }{ 2 } - t } - \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) }{ x } \\
= \cfrac{ \sum_{ k = 0 }^{ 2 t + 2 } \frac{ f^{ ( k ) } ( 0 ) \prod
\limits_{ i = 0 }^{ t - 1 } ( \frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{
k }{ 2 } } - \frac{ t ! }{ ( 2 t ) ! } f^{ ( 2 t ) } ( 0 ) x^t }{ x^{ 1
+ t } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>一片混乱,考虑一下下面这项:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ f^{ ( k ) } ( 0 ) \prod \limits_{ i = 0 }^{ t - 1 } (
\frac{ k }{ 2 } - i ) }{ k ! } x^{ \frac{ k }{ 2 } } \\
= &amp; \frac{ f^{ ( k ) } ( 0 ) \prod \limits_{ i = 0 }^{ t - 1 } ( k -
2 i ) }{ k ! 2^t } x^{ \frac{ k }{ 2 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个时候我们注意到,当<span class="math inline">\(k\)</span>是奇数的时候应该有<span class="math inline">\(f^{ ( k ) } ( 0 ) = 0\)</span>,当<span class="math inline">\(k\)</span>是偶数并且<span class="math inline">\(k
\leq t - 1\)</span>的时候应该有<span class="math inline">\(\prod
\limits_{ i = 0 }^{ t - 1 } ( k - 2 i ) =
0\)</span>,这意味着这个求和最后只会剩下<span class="math inline">\(\frac{ f^{ ( 2 t ) } ( 0 ) t ! }{ ( 2 t ) ! } x^{
t } + \frac{ f^{ 2 t + 2 } ( 0 ) ( t + 1 ) ! }{ ( 2 t + 2 ) ! } x^{ t +
1 }\)</span>,然而前半部分和后面的刚好消掉了,这就数学归纳成立了.</p>
<h5><span id="有界性">有界性</span></h5>
<h5><span id="单调性">单调性</span></h5>
<h5><span id="周期性">周期性</span></h5>
<p>周期函数不一定有最小正周期,比如狄利克雷函数.</p>
<p>还有个思考题:</p>
<p>如果<span class="math inline">\(f , g\)</span>是定义域为<span class="math inline">\(R\)</span>的最小正周期分别为<span class="math inline">\(T_1 , T_2\)</span>的周期函数,求问:</p>
<ol type="1">
<li><p>若<span class="math inline">\(\frac{ T_1 }{ T_2 } \in \mathbb{ Q
}\)</span>,则<span class="math inline">\(f +
g\)</span>是周期函数.</p></li>
<li><p>若<span class="math inline">\(\frac{ T_1 }{ T_2 } \in \mathbb{ R
} \setminus \mathbb{ Q }\)</span>,结论如何.</p></li>
<li><p>若<span class="math inline">\(f ,
g\)</span>均连续,结论如何.</p></li>
</ol>
<p>(1)显然,(3)必定不是周期函数,原因是考虑反证:</p>
<p>如果是的话,必定有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x + T ) + g ( x + T ) &amp; = f ( x ) + g ( x ) \\
f ( x + T ) - f ( x ) &amp; = g ( x ) - g ( x + T )
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(h ( x ) = f ( x + T ) - f ( x ) = g ( x
) - g ( x + T )\)</span>,则<span class="math inline">\(h ( x
)\)</span>以<span class="math inline">\(T_1 ,
T_2\)</span>为周期,那么其以<span class="math inline">\(pT_1 +
qT_2\)</span>为周期,可逼近这个无理数使得其周期趋近于<span class="math inline">\(0\)</span>,用<span class="math inline">\(h\)</span>的连续性,于是<span class="math inline">\(h ( x )\)</span>为常函数,不符题意.</p>
<p>(2)怎么办呢?有没有一种构造方式使得它是周期函数呢?</p>
<p>构造<span class="math inline">\(d_{ p , q } ( x ) = \begin{cases}1
&amp; \exists m , n \in \mathbb{ Z } , mp + nq = x \\ 0 &amp; \forall m
, n \in \mathbb{ Z } , mp + nq \ne x\end{cases}\)</span>.</p>
<p>取<span class="math inline">\(f ( x ) = d_{ 1 , \sqrt{ 2 } } ( x ) -
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x ) , g ( x ) = d_{ \sqrt{ 2 } , \sqrt{
3 } } ( x ) - d_{ 1 , \sqrt{ 3 } }\)</span>,容易见到<span class="math inline">\(f + g\)</span>的周期为<span class="math inline">\(1\)</span>,下面证明<span class="math inline">\(f\)</span>的最小正周期是<span class="math inline">\(\sqrt{ 2 }\)</span>,而<span class="math inline">\(g\)</span>的最小正周期是<span class="math inline">\(\sqrt{ 3 }\)</span>.</p>
<p>二者相似,只考虑证明前者,如若存在一个<span class="math inline">\(T\)</span>,使得<span class="math inline">\(f ( x )
= f ( x + T )\)</span>,则有:</p>
<p><span class="math display">\[
\begin{aligned}
d_{ 1 , \sqrt{ 2 } } ( x ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x ) &amp; =
d_{ 1 , \sqrt{ 2 } } ( x + T ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x + T )
\\
d_{ 1 , \sqrt{ 2 } } ( x ) - d_{ 1 , \sqrt{ 2 } } ( x + T ) &amp; = d_{
\sqrt{ 2 } , \sqrt{ 3 } } ( x ) - d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( x + T
)
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(x = \sqrt{ 3 }\)</span>得到:</p>
<p><span class="math display">\[
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( \sqrt{ 3 } + T ) - d_{ 1 , \sqrt{ 2 } }
( \sqrt{ 3 } + T ) = 1
\]</span></p>
<p>这就意味着:</p>
$$
<span class="math display">\[\begin{cases}
d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( \sqrt{ 3 } + T ) = 1 \\
d_{ 1 , \sqrt{ 2 } } ( \sqrt{ 3 } + T ) = 0 \\

\end{cases}\]</span>
<p>$$</p>
<p>从而<span class="math inline">\(T = n \sqrt{ 2 } + m \sqrt{ 3
}\)</span>,其中<span class="math inline">\(m \ne - 1\)</span>.再取<span class="math inline">\(x = 0\)</span>得到:</p>
<p><span class="math display">\[
d_{ 1 , \sqrt{ 2 } } ( T ) = d_{ \sqrt{ 2 } , \sqrt{ 3 } } ( T ) = 1
\]</span></p>
<p>这就必然意味着<span class="math inline">\(T = n \sqrt{ 2
}\)</span>,从而<span class="math inline">\(f\)</span>的最小正周期恰好就是<span class="math inline">\(\sqrt{ 2 }\)</span>.</p>
<h4><span id="基本初等函数">基本初等函数</span></h4>
<ol type="1">
<li><p>常值函数</p></li>
<li><p>指数函数</p></li>
<li><p>对数函数</p></li>
<li><p>幂函数</p></li>
<li><p>三角函数</p></li>
<li><p>反三角函数</p></li>
</ol>
<p>其中有一些函数的定义其实有一些缺陷,我们将在讨论完连续性后给出.</p>
<h4><span id="初等函数">初等函数</span></h4>
<p>由基本初等函数经过有限次四则运算和复合得到的函数.</p>
<p>举个逆天例子:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
\sqrt{ - x } &amp; x &lt; 0 \\
0 &amp; x \in [ 0 , 1 ] \\
\ln x &amp; x &gt; 1
\end{cases}
\]</span></p>
<p>注意到<span class="math inline">\(f ( x ) = \sqrt{ \frac{ \sqrt{ x^2
} - x }{ 2 } } + \ln \frac{ x + \sqrt{ ( x - 1 )^2 } + 1 }{ 2
}\)</span>.</p>
<h4><span id="代数函数">代数函数</span></h4>
<p>存在多项式<span class="math inline">\(F ( x , y )\)</span>满足<span class="math inline">\(F ( x , f ( x ) ) \equiv 0\)</span>的函数<span class="math inline">\(f ( x )\)</span>称为代数函数.</p>
<h3><span id="数列极限">数列极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>设<span class="math inline">\(\{ a_n
\}\)</span>是一个给定的序列,若<span class="math inline">\(\exists
l\)</span>,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , | a_n - l |
&lt; \epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是这个序列的<strong>极限</strong>,记作<span class="math inline">\(\lim_{ n \rightarrow \infty } a_n = l
\\\)</span>.</p>
<h4><span id="性质">性质</span></h4>
<ol type="1">
<li><p>若数列存在极限,则极限唯一.</p></li>
<li><p>有极限的数列有界.</p></li>
<li><p>数列的极限可以四则运算.</p></li>
<li><p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,若<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , a_n \geq
b_n\)</span>,则<span class="math inline">\(l_a \geq
l_b\)</span>.</p></li>
<li><p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,如果<span class="math inline">\(l_a &gt;
l_b\)</span>,则<span class="math inline">\(\exists N \in \mathbb{ N
}\)</span>,<span class="math inline">\(\forall n &gt; N , a_n &gt;
b_n\)</span>.</p></li>
<li><p>夹逼定理:设<span class="math inline">\(\{ a_n \} , \{ b_n \} , \{
c_n \}\)</span>是三个序列,且<span class="math inline">\(\exists N_0 ,
\forall n &gt; n_0 , a_n \leq b_n \leq c_n\)</span>.那么如果<span class="math inline">\(\lim_{ n \rightarrow \infty } a_n = \lim_{ n
\rightarrow \infty } c_n = l \\\)</span>,则<span class="math inline">\(\lim_{ n \rightarrow \infty } b_n = l
\\\)</span>.</p></li>
<li><p>对于原序列,若它有极限<span class="math inline">\(l\)</span>,取出它的无穷项子序列,那这个子序列的极限必然也是<span class="math inline">\(l\)</span>.(如果一个序列能取出两个无穷项子序列使得极限不相同,那么原序列必然无极限)</p></li>
</ol>
<p>大部分的证明都很显然,只需要套用极限定义即可,这里举几个证明为例.</p>
<p>(3):</p>
<p>设序列<span class="math inline">\(\{ a_n \} , \{ b_n
\}\)</span>有极限并且分别为<span class="math inline">\(l_a ,
l_b\)</span>,则要证<span class="math inline">\(\lim_{ n \rightarrow
\infty } ( a_n \pm b_n ) = l_a \pm l_b \\\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } ( a_n b_n ) = l_a
l_b \\\)</span>,若<span class="math inline">\(l_b \ne 0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } ( \frac{ a_n }{ b_n
} ) = \frac{ l_a }{ l_b } \\\)</span>.</p>
<p>先证明加减法,取<span class="math inline">\(\frac{ 1 }{ 2 }
\epsilon\)</span>然后合并起来就行.</p>
<p>乘法也类似,首先有:</p>
<p><span class="math display">\[
\begin{aligned}
l_a - \epsilon_1 &amp; &lt; a_n &lt; l_a + \epsilon_1 \\
l_b - \epsilon_2 &amp; &lt; b_n &lt; l_b + \epsilon_2
\end{aligned}
\]</span></p>
<p>于是自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| a_n b_n - l_a l_b | &amp; = | ( a_n - l_a ) b_n + l_a ( b_n - l_b ) |
\\
&amp; \leq | b_n | | a_n - l_a | + | l_a | | b_n - l_b | \\
&amp; &lt; | b_n | \epsilon_1 + | l_a | \epsilon_2 \\
&amp; &lt; | l_b \pm \epsilon_2 | \epsilon_1 + | l_a | \epsilon_2
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(\epsilon_1 =
\epsilon_2\)</span>,尝试构造一组解使得<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \epsilon_1 &gt;
0\)</span>,<span class="math inline">\(| l_b \pm \epsilon_1 | \epsilon_1
+ | l_a | \epsilon_1 &lt; \epsilon\)</span>.限制一下<span class="math inline">\(\epsilon &lt; 1 , \epsilon_1 &lt;
1\)</span>,取<span class="math inline">\(\epsilon_1 = \frac{ \epsilon }{
1 + | l_b | + | l_a | }\)</span>即可.</p>
<p>接下来证明除法,实际上只需要证明若<span class="math inline">\(l_b \ne
0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } (
\frac{ 1 }{ b_n } ) = \frac{ 1 }{ l_b } \\\)</span>.</p>
<p>考虑:<span class="math inline">\(l_b \lim_{ n \rightarrow \infty }
b_n = l_b^2 &gt; 0 \\\)</span>,这意味着当<span class="math inline">\(\exists N_0 , \forall n &gt; N_0 , l_b b_n &gt; 0
\\\)</span>,或者更强一点,<span class="math inline">\(\exists N_0 ,
\forall n &gt; N_0 , l_b b_n &gt; \frac{ 1 }{ 2 } l_b^2 \\\)</span>.</p>
<p>不妨设<span class="math inline">\(\epsilon &#39; &gt; 0 , \exists N_1
, \forall n &gt; N_1 , | l_b - b_n | &lt; \epsilon &#39;\)</span></p>
<p>取<span class="math inline">\(n &gt; \max ( N_0 , N_1
)\)</span>此时自然有:</p>
<p><span class="math display">\[
| \frac{ 1 }{ b_n } - \frac{ 1 }{ l_b } | = \frac{ | l_b - b_n | }{ |
b_n l_b | } \leq \frac{ 2 }{ l_b^2 } \epsilon &#39;
\]</span></p>
<p>取<span class="math inline">\(\epsilon &#39; = \frac{ l_b^2 }{ 2 }
\epsilon\)</span>即可得证.</p>
<p>(4):</p>
<p>反证,设<span class="math inline">\(l_a &lt; l_b\)</span>,那么取<span class="math inline">\(\epsilon = \frac{ l_b - l_a }{ 2
}\)</span>,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
| a_N - l_a | &amp; &lt; \epsilon \\
a_N &amp; &lt; \frac{ l_a + l_b }{ 2 } &lt; b_N
\end{aligned}
\]</span></p>
<p>这是不可能的.</p>
<h4><span id="单调收敛准则">单调收敛准则</span></h4>
<p>单调有界无穷数列有极限.</p>
<p>不妨设<span class="math inline">\(\{ a_n
\}\)</span>是一个单调有界无穷数列(不妨假设其单增,不然可以取反变成单增),且<span class="math inline">\(\forall n , a_n \leq l_a\)</span>.</p>
<p>考虑集合<span class="math inline">\(A = \{ x_n | n \in \mathbb{ N }_+
\}\)</span>,根据确界存在定理,其一定有上确界.令<span class="math inline">\(a\)</span>是它的上确界,我们来证明<span class="math inline">\(a\)</span>一定是数列的极限.</p>
<p>由于<span class="math inline">\(a\)</span>是上确界,这意味着<span class="math inline">\(\forall \epsilon &gt; 0 , a -
\epsilon\)</span>不是上确界,所以<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,<span class="math inline">\(\exists
N\)</span>,<span class="math inline">\(\forall n &gt; N , a - \epsilon
&lt; a_n \leq a &lt; a + \epsilon\)</span>,这就是极限的定义.</p>
<h4><span id="自然对数的底数">自然对数的底数</span></h4>
<p>定义<span class="math inline">\(e = \lim_{ n \rightarrow \infty } ( 1
+ \frac{ 1 }{ n } )^n
\\\)</span>.如何证明它存在极限呢?考虑单调有界无穷序列必定存在极限,定义<span class="math inline">\(x_n = ( 1 + \frac{ 1 }{ n }
)^n\)</span>,于是先证明它有界:</p>
<p><span class="math display">\[
\begin{aligned}
( 1 + \frac{ 1 }{ n } )^n &amp; = \sum_{ k = 0 }^n \frac{ n^{
\underline{ k } } }{ k ! } \frac{ 1 }{ n^k } \\
&amp; &lt; \sum_{ k = 0 }^n \frac{ 1 }{ k ! } \\
&amp; &lt; 2 + \sum_{ k = 2 }^n \frac{ 1 }{ k ( k - 1 ) } \\
&amp; = 2 + \sum_{ k = 2 }^n ( \frac{ 1 }{ k - 1 } - \frac{ 1 }{ k } )
&lt; 3
\end{aligned}
\]</span></p>
<p>接下来证明单调,只需证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[n + 1]{ ( 1 + \frac{ 1 }{ n } )^n } &amp; &lt; \frac{ n + 2 }{ n +
1 } \\
\sqrt[n + 1]{ 1 ( 1 + \frac{ 1 }{ n } )^n } &amp; &lt; \frac{ 1 + n ( 1
+ \frac{ 1 }{ n } ) }{ n + 1 }
\end{aligned}
\]</span></p>
<p>由均值不等式显然.</p>
<p>如果我们考虑另一个极限<span class="math inline">\(y_n = ( 1 + \frac{
1 }{ n } )^{ n + 1 }\)</span>,注意到:</p>
<p><span class="math display">\[
\frac{ 1 }{ y_n } = ( \frac{ n }{ n + 1 } )^{ n + 1 } \times 1 &lt; (
\frac{ n + 1 }{ n + 2 } )^{ n + 2 } = \frac{ 1 }{ y_{ n + 1 } }
\]</span></p>
<p>发现<span class="math inline">\(y_n\)</span>单调递减且<span class="math inline">\(y_n &gt; x_n\)</span>,并且<span class="math inline">\(\lim_{ n \rightarrow \infty } y_n - x_n =
0\)</span>,这就意味着二者必然同时趋向于一个常数的两侧,定义为<span class="math inline">\(e = 2 . 7182818284 \cdots\)</span>.</p>
<p>这里还可以推出一些结论.因为我们知道:</p>
<p><span class="math display">\[
\begin{aligned}
x_n &amp; &lt; e &lt; y_n \\
n \ln ( 1 + \frac{ 1 }{ n } ) &amp; &lt; 1 &lt; ( n + 1 ) \ln ( 1 +
\frac{ 1 }{ n } ) \\
\frac{ 1 }{ n + 1 } &amp; &lt; \ln ( n + 1 ) - \ln ( n ) &lt; \frac{ 1
}{ n } \\
H_{ n + 1 } - 1 &amp; &lt; \ln ( n + 1 ) &lt; H_n
\end{aligned}
\]</span></p>
<p>用这个可以注意到定义<span class="math inline">\(z_n = H_n - \ln
n\)</span>,这个东西肯定<span class="math inline">\(\geq
0\)</span>且<span class="math inline">\(\leq 1\)</span>,而且注意到<span class="math inline">\(z_{ n + 1 } - z_n = \frac{ 1 }{ n + 1 } - \ln
\frac{ n + 1 }{ n } &lt;
0\)</span>,所以单调有界,这个极限就是欧拉常数<span class="math inline">\(\gamma = 0 . 57 \cdots\)</span>.</p>
<p>接下来证明<span class="math inline">\(e\)</span>是无理数.</p>
<p>考虑<span class="math inline">\(e = \lim_{ n \rightarrow \infty } ( 1
+ \frac{ 1 }{ n } )^n\)</span>,取二项式定理,取<span class="math inline">\(x_k = \sum_{ k = 0 }^n \frac{ n^{ \underline{ k }
} }{ k ! n^k } \leq \sum_{ k = 0 }^n \frac{ 1 }{ k ! } =
U_n\)</span>.</p>
<p>而又注意到<span class="math inline">\(x_n = \sum_{ k = 0 }^n \frac{
n^{ \underline{ k } } }{ k ! n^k }\)</span>,取定一个确定的上界<span class="math inline">\(m \leq n\)</span>,则<span class="math inline">\(x_n \geq \sum_{ k = 0 }^m \frac{ n^{ \underline{ k
} } }{ k ! n^k } = y_n\)</span>.由于<span class="math inline">\(m\)</span>有限,所以当<span class="math inline">\(n
\rightarrow \infty\)</span>时,<span class="math inline">\(y_n
\rightarrow U_n\)</span>的前<span class="math inline">\(m\)</span>项,此时再令<span class="math inline">\(m
\to \infty\)</span>,根据夹逼定理,立刻得到<span class="math inline">\(x_n
\rightarrow U_n\)</span>.换言之,<span class="math inline">\(m\)</span>增大引起的误差总可以被后面的<span class="math inline">\(n\)</span>的增大抹平.</p>
<p>考虑一下计算误差,设<span class="math inline">\(r_n = e -
U_n\)</span>,则<span class="math inline">\(r_n = \sum_{ k \geq n + 1 }
\frac{ 1 }{ k ! } = \frac{ 1 }{ ( n + 1 ) ! } \sum_{ k \geq 0 } \frac{ 1
}{ ( n + 2 )^{ \overline{ k } } } &lt; \frac{ 1 }{ ( n + 1 ) ! } \sum_{
k \geq 0 } \frac{ 1 }{ ( n + 2 )^k } = \frac{ 1 }{ ( n + 1 ) ! } \frac{
n + 2 }{ n + 1 } &lt; \frac{ 1 }{ n \times n ! }\)</span>.</p>
<p>如果<span class="math inline">\(e\)</span>是有理数,设<span class="math inline">\(e = \frac{ m }{ n } \in \mathbb{ Q
}\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; &lt; r_n = \frac{ m }{ n } - U_n &lt; \frac{ 1 }{ n \times n ! }
\\
0 &amp; &lt; m \times ( n - 1 ) ! - U_n \times n ! &lt; \frac{ 1 }{ n }
\end{aligned}
\]</span></p>
<p>这立刻导出矛盾,因为<span class="math inline">\(U_n \times n
!\)</span>一定是整数.</p>
<h4><span id="开区间与闭区间">开区间与闭区间</span></h4>
<p>定义一个集合的内部点:<span class="math inline">\(x , \exists \delta
&gt; 0 , ( x - \delta , x + \delta ) \subseteq
A\)</span>.我们将一个集合的所有内部点组成的集合记作<span class="math inline">\(A^{ \degree }\)</span>.</p>
<p>这样就可以定义一个集合是内部为空的,就是其没有内部点.反之,如果每个点都是其内部点,那么称其为稠密的.</p>
<p>定义一个集合的边界点:<span class="math inline">\(x , \forall \delta
&gt; 0 , ( x - \delta , x + \delta ) \cap A \ne \emptyset , ( x - \delta
, x + \delta ) \cap A^C \ne \emptyset\)</span>.</p>
<p>一个集合称为开集合,当且仅当<span class="math inline">\(A = A^{
\degree }\)</span>.</p>
<p>一个集合称为闭集合,当且仅当对于集合中的任何一个数列,数列极限也存在于这个集合中.</p>
<p>当然也可以用补集来用开集合定义闭集合(补集是开集合的集合是闭集合)或者反之.</p>
<p>由此我们知道开集的并是开集,有限个开集的交是开集;闭集的交是闭集,有限个闭集的并是闭集.</p>
<p>容易发现包含于<span class="math inline">\(A\)</span>的所有开集的并是<span class="math inline">\(A^{ \degree }\)</span>.</p>
<p>我们类似定义<span class="math inline">\(A\)</span>的闭包是<span class="math inline">\(\bar{ A }\)</span>.</p>
<p>而且容易发现如果<span class="math inline">\(f\)</span>是连续函数,那么如果<span class="math inline">\(U\)</span>是开集,那么<span class="math inline">\(f^{ - 1 } ( U )\)</span>(也就是<span class="math inline">\(U\)</span>的原像)也是开集.</p>
<h4><span id="区间套定理">区间套定理</span></h4>
<p>设<span class="math inline">\(I_n = [ a_n , b_n ] \ne \emptyset , I_{
n + 1 } \subseteq I_{ n }\)</span>,则<span class="math inline">\(I =
\bigcap_{ n \geq 1 } I_n\)</span>存在且是一个非空闭区间.</p>
<p>怎么证明?考虑<span class="math inline">\(a_n\)</span>单增,<span class="math inline">\(b_n\)</span>单减并且<span class="math inline">\(a_1 \leq a_n \leq b_n \leq b_1\)</span>,所以<span class="math inline">\(a_n\)</span>存在极限,不妨设为<span class="math inline">\(l_a\)</span>,同理<span class="math inline">\(b_n\)</span>也存在极限,设为<span class="math inline">\(l_b\)</span>.容易验证<span class="math inline">\(I
= [ l_a , l_b ]\)</span>.</p>
<p>类似地,设<span class="math inline">\(I_n = ( a_n , b_n ) \ne
\emptyset , I_{ n + 1 } \subseteq I_{ n }\)</span>,并且<span class="math inline">\(a_n ,
b_n\)</span>不会从某一项开始往后全都是常数(换言之其极限不等于其每一项,且不会上下波动),则<span class="math inline">\(I = \bigcap_{ n \geq 1 }
I_n\)</span>存在且是一个非空闭区间.</p>
<p>特别地,当<span class="math inline">\(\lim | b_n - a_n | =
0\)</span>的时候,上述给出一个单点.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(x_1 = a , x_2 = b , a \ne b , x_{ n + 2
} = \frac{ x_{ n + 1 } + x_n }{ 2 }\)</span>,问<span class="math inline">\(\lim_{ n \rightarrow \infty }
x_n\)</span>是否存在.</p>
<p>可以设<span class="math inline">\(c_n = \min \{ x_n , x_{ n + 1 } \}
, d_n = \max \{ x_n , x_{ n + 1 } \}\)</span>,讨论<span class="math inline">\(x_{ n + 1 }\)</span>和<span class="math inline">\(x_n\)</span>的大小关系(二者显然不相等)可以知道<span class="math inline">\([ c_n , d_n
]\)</span>满足区间套定理的条件,又注意到<span class="math inline">\(| I_{
n + 1 } | = | x_{ n + 2 } - x_{ n + 1 } | = \frac{ 1 }{ 2 } | I_n
|\)</span>,所以区间长度趋近于<span class="math inline">\(0\)</span>,这样的话<span class="math inline">\(\lim_{ n \rightarrow \infty } c_n = \lim_{ n
\rightarrow \infty } x_n = \lim_{ n \rightarrow \infty }
d_n\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_1 &gt; b_1 &gt; 0\)</span>,<span class="math inline">\(a_{ n + 1 } = \frac{ a_n + b_n }{ 2 } , b_{ n + 1
} = \sqrt{ a_n b_n }\)</span>.求证<span class="math inline">\(a_n ,
b_n\)</span>极限都存在且相等.</p>
<p>还是区间套定理,容易验证满足区间套定理的条件,那么要注意到<span class="math inline">\(| I_{ n + 1 } | = \frac{ a_n + b_n }{ 2 } - \sqrt{
a_n b_n } &lt; \frac{ a_n + b_n }{ 2 } - b_n = \frac{ 1 }{ 2 } | I_n
|\)</span>,所以<span class="math inline">\(\lim_{ n \rightarrow \infty }
| I_n | = 0\)</span>,这就证明了二者存在且相等.</p>
<p>其实先用单调有界数列有极限,再对着递推式两边求下极限就可以了.</p>
<h4><span id="有限覆盖定理">有限覆盖定理</span></h4>
<p>覆盖:<span class="math inline">\(\Sigma
:\)</span>由一些开区间组成的集合.若<span class="math inline">\(M \subset
\mathbb{ R }\)</span>,称<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,当且仅当<span class="math inline">\(M \subseteq \bigcup_{ \sigma \in \Sigma }
\sigma\)</span>.</p>
<p>有限覆盖定理是说,如果<span class="math inline">\(M = [ a , b
]\)</span>是一个有界闭区间,且<span class="math inline">\(M\)</span>被<span class="math inline">\(\Sigma\)</span>覆盖,则一定存在一个<span class="math inline">\(\Sigma\)</span>的有限子集<span class="math inline">\(\Sigma_1\)</span>,使得<span class="math inline">\(M\)</span>能被<span class="math inline">\(\Sigma_1\)</span>覆盖.</p>
<p>换言之,有界闭区间若能被开区间覆盖,则一定能被有限个开区间覆盖.</p>
<p>反证:如果<span class="math inline">\(M\)</span>不能被有限覆盖,那么<span class="math inline">\([ a , \frac{ a + b }{ 2 } ]\)</span>和<span class="math inline">\([ \frac{ a + b }{ 2 } , b
]\)</span>至少有一个不能被有限覆盖(如果它俩都能那<span class="math inline">\([ a , b
]\)</span>肯定也能).不妨取出二者中任意一个不能被有限覆盖的区间,设为<span class="math inline">\([ a_1 , b_1
]\)</span>,再进行上面的操作就可以得到<span class="math inline">\([ a_2 ,
b_2
]\)</span>,以此类推,如此我们得到了一个满足区间套定理的区间序列而且均不能被有限覆盖,根据区间套定理,可以取出它们交集的那个元素<span class="math inline">\(c\)</span>.由于<span class="math inline">\(\{ c \}
\in M\)</span>,所以<span class="math inline">\(\exists \sigma \in \Sigma
, c \in \sigma\)</span>.因为<span class="math inline">\(\sigma\)</span>是开区间,所以<span class="math inline">\(\exists \epsilon &gt; 0 , [ c - \epsilon , c +
\epsilon ] \in \sigma\)</span>,而显然可以找到一个<span class="math inline">\(N &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N\)</span>,<span class="math inline">\([ a_n , b_n ] \in [ c - \epsilon , c + \epsilon
]\)</span>,这就矛盾了.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:有界闭区间上的局部有界(对于每一个点,它都存在一个开区间邻域是有界的)函数是整体有界函数.</p>
<p>设定义域为<span class="math inline">\([ a , b ]\)</span>,考虑<span class="math inline">\(\forall x_0 \in [ a , b ] , \exists \sigma &gt;
0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \sigma , x_0 + \sigma
)\)</span>上有界,注意到设<span class="math inline">\(I_{ x_0 } = ( x_0 -
\sigma , x_0 + \sigma )\)</span>,那么<span class="math inline">\([ a , b
]\)</span>一定被<span class="math inline">\(I\)</span>这个区间集合开覆盖,那么就能被有限开覆盖,取出那有限个区间对应的值域并起来就行.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:有界闭区间上的局部增(对于每一个点,它都存在一个开区间邻域是增的)函数是整体增函数.</p>
<p>证明和上面一样,合并两个开区间的时候找任意一个交集元素即可.</p>
<h4><span id="外测度与零测集">外测度与零测集</span></h4>
<p>定义<strong>外测度:</strong>对于<span class="math inline">\(E
\subseteq \mathbb{ R }\)</span>,定义<span class="math inline">\(m^* ( E
)\)</span>为<span class="math inline">\(E\)</span>的外测度,<span class="math inline">\(m^* ( E ) = \inf \{ ( \sum | I_k | ) \mid \bigcup
I_k \supseteq E \}\)</span>,也就是找一列区间使得其并起来能包含<span class="math inline">\(E\)</span>.</p>
<p>定义<strong>零测集</strong>:外测度为<span class="math inline">\(0\)</span>的集合.容易发现<span class="math inline">\(m^* ( \bigcup E_k ) \leq \sum m^* ( E_k
)\)</span>.于是可数个零测集的并仍然是零测集.</p>
<p>如果一个集合的势可数,那它当然是零测集,原因是可以构造<span class="math inline">\(I_n = ( x_n - \delta , x_n + \delta ) , \delta =
\frac{ 1 }{ 2^{ n + 1 } }\)</span>.由这个构造<span class="math inline">\(\epsilon_k = \frac{ \epsilon }{ 2^{ k + 1 }
}\)</span>可以说明可数个零测集的并仍然是零测集.</p>
<p>反之,一个集合是零测集不一定代表其可数,例如康托三分集:先把<span class="math inline">\([ 0 , 1 )\)</span>上扣去<span class="math inline">\([ \frac{ 1 }{ 3 } , \frac{ 2 }{ 3 }
)\)</span>,然后再对剩下的线段也做类似的操作,每次扣掉中间一段.算一下每次扣去的长度,发现长度恰好为<span class="math inline">\(1\)</span>,于是当然是零测集.但注意到这对应着一个三进制小数并且每一位只能是<span class="math inline">\(0 , 2\)</span>,那这当然势仍然是<span class="math inline">\(2^\mathbb{ N }\)</span>,于是不可数.</p>
<h4><span id="vitali覆盖引理">Vitali覆盖引理</span></h4>
<p>当<span class="math inline">\(E \subseteq R\)</span>,称一族区间<span class="math inline">\(\Gamma = \{ I_\alpha \}\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,若对<span class="math inline">\(\forall x \in E , \epsilon &gt; 0\)</span>,<span class="math inline">\(\exists I_{ \alpha } \in \Gamma , | I_\alpha |
&lt; \epsilon , x \in
I_\alpha\)</span>.也就是对于任何一个点都存在足够小的区间把它盖住.</p>
<p>Vitali覆盖引理是说,如果<span class="math inline">\(E\)</span>是一个有界集(或者推广到外测度有限的集合),<span class="math inline">\(\Gamma\)</span>是<span class="math inline">\(E\)</span>的一个Vitali覆盖,则<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(\Gamma\)</span>中可以拿出有限个两两不交的区间<span class="math inline">\(I_j \in \Gamma\)</span>,满足<span class="math inline">\(m^* ( E \setminus ( \bigcup I_j ) ) &lt;
\epsilon\)</span>.注意这里取区间的方式依赖于<span class="math inline">\(\epsilon\)</span>的选取.</p>
<p>取一个开集<span class="math inline">\(G \supseteq E , m^* ( G ) &lt;
\infty\)</span>,不妨设<span class="math inline">\(\Gamma\)</span>中的每个区间都<span class="math inline">\(\subseteq
G\)</span>(原因在于Vitali覆盖保证了任意小的区间覆盖,而开集的性质使得总有区间在其中).在此基础上,由于上面的<span class="math inline">\(\Gamma\)</span>是任意一个Vitali覆盖,所以我们不妨假设<span class="math inline">\(\Gamma\)</span>中的每个区间都是闭区间(也就是把端点加进去,那当然仍然是Vitali覆盖而且更难满足限制,因为闭区间更难以两两不交),这当然仍是可以的.</p>
<p>现在我们归纳取区间,我们任取一个<span class="math inline">\(I_1 \in
\Gamma\)</span>,开始不断往上添区间.设<span class="math inline">\(I_1 ,
\cdots , I_k\)</span>已经被我们拿到,而且两两不交.</p>
<p>如果此时<span class="math inline">\(E \subseteq \bigcup_{ j = 1 }^k
I_j\)</span>,当然直接满足条件.</p>
<p>反之,令<span class="math inline">\(\delta_k = \sup \{ ( | I | ) \mid
I \in \Gamma , I \cap I_j = \emptyset , 1 \leq j \leq k
\}\)</span>.容易发现<span class="math inline">\(\delta_k &lt;
\infty\)</span>.那我们取<span class="math inline">\(I_{ k + 1
}\)</span>使得<span class="math inline">\(\forall 1 \leq j \leq k , I_{
k + 1 } \cap I_j = \emptyset , | I_{ k + 1 } | &gt; \frac{ 1 }{ 2 }
\delta_k\)</span>,这当然做得到.</p>
<p>如果一直做下去都没有使得<span class="math inline">\(E \subseteq
\bigcup I_j\)</span>,那我们就可以拿到一个区间列.接下来我们考虑<span class="math inline">\(\sum | I_k |\)</span>,此时由于<span class="math inline">\(I_k\)</span>两两不交,当然有<span class="math inline">\(\sum | I_k | \leq m^* ( G ) &lt;
\infty\)</span>,那么根据单调收敛准则,<span class="math inline">\(\sum |
I_k |\)</span>趋于一个极限,于是<span class="math inline">\(| I_k
|\)</span>当然趋近于<span class="math inline">\(0\)</span>,那么<span class="math inline">\(\delta_k\)</span>趋近于<span class="math inline">\(0\)</span>.在此基础上,我们当然可以取一个<span class="math inline">\(N &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N , \sum_{ k \geq n + 1 } | I_k |
&lt; \frac{ 1 }{ 5 } \epsilon\)</span>.</p>
<p>此时<span class="math inline">\(\forall x \in E \setminus ( \bigcup_{
k \leq N } I_k )\)</span>.由于<span class="math inline">\(I_k\)</span>均为闭区间,所以<span class="math inline">\(E \setminus ( \bigcup_{ k \leq N } I_k
)\)</span>必定是开区间,这也就是说<span class="math inline">\(x\)</span>存在一个小邻域<span class="math inline">\(I &#39; \in \Gamma\)</span>并且<span class="math inline">\(I &#39; \subseteq E \setminus ( \bigcup_{ k \leq N
} I_k )\)</span>.那当然有<span class="math inline">\(I &#39; \cap (
\bigcup_{ k \leq N } I_k ) = \emptyset\)</span>,也就是<span class="math inline">\(I &#39; \cap I_k = \emptyset , 1 \leq k \leq
N\)</span>.由于<span class="math inline">\(| I &#39;
|\)</span>有限且不为<span class="math inline">\(0\)</span>,而<span class="math inline">\(\delta_n \rightarrow 0\)</span>.一定<span class="math inline">\(\exists n \geq N\)</span>,使得<span class="math inline">\(I &#39; \cap ( \bigcup_{ k \leq n } I_k ) =
\emptyset , I &#39; \cap I_{ n + 1 } \ne
\emptyset\)</span>.发现此时<span class="math inline">\(| I &#39; | \leq
\delta_n &lt; 2 | I_{ n + 1 } |\)</span>.</p>
<p>此时会出个什么事呢?由于<span class="math inline">\(| I &#39; | &lt; 2
| I_{ n + 1 } |\)</span>,所以我们把<span class="math inline">\(I_{ n + 1
}\)</span>这个区间扩大五倍(中心不变,半径扩大到原本的五倍)就一定能盖住<span class="math inline">\(I &#39;\)</span>.</p>
<p>那会怎么样呢?那<span class="math inline">\(m^* ( E \setminus (
\bigcup_{ k \leq N } I_k ) ) \leq 5 \sum_{ k \geq N + 1 } | I_k | &lt;
\epsilon\)</span>.于是证毕.</p>
<h4><span id="聚点原理">聚点原理</span></h4>
<p>假设<span class="math inline">\(M\)</span>是一个实数集,称<span class="math inline">\(x_0\)</span>是<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(( ( x_0 - \epsilon , x_0 ) \cup ( x_0 , x_0 +
\epsilon ) ) \cap M \ne \emptyset\)</span>,或说,<span class="math inline">\(\forall \epsilon &gt; 0 , ( x_0 - \epsilon , x_0 +
\epsilon ) \cap M\)</span>是一个无限集.可以理解为,<span class="math inline">\(x_0\)</span>不是一个孤点.</p>
<p>引理:<span class="math inline">\(x_0\)</span>为<span class="math inline">\(M\)</span>的聚点,当且仅当<span class="math inline">\(\exists \{ x_n \} \in M \setminus \{ x_0 \} ,
\lim_{ n \rightarrow \infty } x_n =
x_0\)</span>.充分性显然,必要性的话只需取<span class="math inline">\(\epsilon = 2^{ - n
}\)</span>然后从上面的交集拿点就行.</p>
<p>聚点原理:有界无穷集<span class="math inline">\(M\)</span>必有聚点.</p>
<p>我们可以找一个<span class="math inline">\(I_0 = [ a , b ] , M \subset
I_0\)</span>,我们找<span class="math inline">\([ a , \frac{ a + b }{ 2 }
] , [ \frac{ a + b }{ 2 } , b ]\)</span>,其中至少有一个和<span class="math inline">\(M\)</span>的交集为无穷集,我们取其为<span class="math inline">\([ a_1 , b_1
]\)</span>,不断这么做又会得到一个闭区间套列,交起来得到的那个元素<span class="math inline">\(c\)</span>就是聚点,因为<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N &gt; 0 ,
\forall n \geq N , | b_n - a_n | &lt; \epsilon\)</span>,那么<span class="math inline">\([ a_n , b_n ] \subseteq ( c - \epsilon , c +
\epsilon )\)</span>,立刻证毕.</p>
<h4><span id="baire纲定理">Baire纲定理</span></h4>
<ol type="1">
<li><p>设<span class="math inline">\(\{ F_n
\}\)</span>是一列内部为空(没有除空集以外的开子集)的闭集,则<span class="math inline">\(\bigcup_{ n = 1 }^{ \infty }
F_n\)</span>内部为空.</p></li>
<li><p>设<span class="math inline">\(\{ G_n
\}\)</span>是一列稠密(补集内部为空)的开集,则<span class="math inline">\(\bigcap_{ n = 1 }^{ \infty }
G_n\)</span>稠密.</p></li>
</ol>
<p>(1)(2)等价,下面只证明(1):</p>
<p>反证,假设<span class="math inline">\(F = \bigcup_{ n = 1 }^{ \infty }
F_n\)</span>内部不为空,也就是其存在一个内部开集<span class="math inline">\(( x_0 - \delta_0 , x_0 + \delta_0 ) \subseteq
F\)</span>.由于<span class="math inline">\(F_1\)</span>是一个闭集,因此<span class="math inline">\(( x_0 - \delta_0 , x_0 + \delta_0 ) \setminus
F_1\)</span>当然是一个开集,于是其就存在一个子区间<span class="math inline">\([ x_1 - \delta_1 , x_1 + \delta_1 ] \subseteq (
x_0 - \delta_0 , x_0 + \delta_0 )\)</span>并且<span class="math inline">\([ x_1 - \delta_1 , x_1 + \delta_1 ] \cap F_1 =
\emptyset\)</span>,同理可以找到一列闭区间<span class="math inline">\(\{
[ x_k - \delta_k , x_k + \delta_k ] \}\)</span>使得<span class="math inline">\([ x_k - \delta_k , x_k + \delta_k ] \cap \bigcup_{
j = 1 }^k F_j = \emptyset\)</span>.</p>
<p>容易见到我们可以任意调小<span class="math inline">\(\delta_k\)</span>的大小,调整使得<span class="math inline">\(\delta_k &lt; \frac{ 1 }{ k
}\)</span>总成立就得到了一列闭区间套,必然拿到了一个单独的点<span class="math inline">\(\xi\)</span>,那么<span class="math inline">\(\xi
\in ( x_0 - \delta_0 , x_0 + \delta_0 ) \subseteq
F\)</span>,然而对于任意区间都有<span class="math inline">\(\xi \notin
F_n\)</span>,因此<span class="math inline">\(\xi \notin
F\)</span>,这就导出了矛盾.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f ( x )\)</span>连续,并且<span class="math inline">\(\forall x &gt; 0 , \lim_{ n \rightarrow \infty } f
( nx ) = 0\)</span>,则<span class="math inline">\(\lim_{ x \rightarrow
\infty } f ( x ) = 0\)</span>.</p>
<p>对于一个<span class="math inline">\(\epsilon &gt;
0\)</span>,考虑构造内部为空的闭集<span class="math inline">\(F_n = \{ x
| \forall k \geq n , f ( kx ) \leq \epsilon
\}\)</span>(为什么这是闭集呢?因为当你设<span class="math inline">\(F_{ n
, k }\)</span>满足上述定义,那<span class="math inline">\(F_{ n , k
}\)</span>肯定是闭集,然后<span class="math inline">\(F_n\)</span>就是上述这些的交,当然也是闭集).容易发现<span class="math inline">\(F_n\)</span>的并是<span class="math inline">\(\mathbb{ R
}_+\)</span>,那就一定至少有一个闭集内部不为空,我们就可以取出其中的一个区间设为<span class="math inline">\(( a , b
)\)</span>,然后用这个区间在若干倍后覆盖后半部分数轴,原因是当<span class="math inline">\(n\)</span>足够大的时候,一定有<span class="math inline">\(nb &gt; ( n + 1 ) a\)</span>存在.</p>
<h4><span id="致密性定理">致密性定理</span></h4>
<p>有界无穷数列有收敛的子列.</p>
<p>考虑数列值域<span class="math inline">\(M = \{ x | x = x_n , n \in
\mathbb{ N }_+ \}\)</span>.</p>
<p>如果<span class="math inline">\(M\)</span>是有限集合,那<span class="math inline">\(\exists a\)</span>,<span class="math inline">\(I =
\{ n | x_n = a
\}\)</span>是无限集合,把这些数拿出来就是一个无限的常数列.</p>
<p>如果<span class="math inline">\(M\)</span>是无限集,那其存在聚点,设<span class="math inline">\(a\)</span>为其中一个聚点.则<span class="math inline">\(M_k = ( ( a - \frac{ 1 }{ k } , a + \frac{ 1 }{ k
} ) \setminus \{ a \} ) \cap M , k \in \mathbb{ N
}_+\)</span>是个无限集.</p>
<p>那只需要取<span class="math inline">\(x_{ n_k }\)</span>为<span class="math inline">\(M_k\)</span>中的某个<span class="math inline">\(x_{ n &#39; }\)</span>满足<span class="math inline">\(n &#39; &gt; n_{ k - 1
}\)</span>即可,由于这是无限集,所以显然可以取出.拿出来的这个数列显然以<span class="math inline">\(a\)</span>为极限.</p>
<h4><span id="柯西收敛准则">柯西收敛准则</span></h4>
<p>称一个数列为柯西数列,当且仅当<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists N &gt; 0 , \forall n , m \geq N , | x_n - x_m
| &lt; \epsilon\)</span>.</p>
<p>一个数列收敛的充要条件是他是一个柯西数列.</p>
<p>先证必要性:</p>
<p><span class="math inline">\(\forall \epsilon &gt; 0 , \exists N &gt;
0 , \forall n , m \geq N , | a - x_n | &lt; \frac{ \epsilon }{ 2 } , | a
- x_m | &lt; \frac{ \epsilon }{ 2 } , | x_n - x_m | \leq | x_n - a | + |
a - x_m | &lt; \epsilon\)</span>.</p>
<p>再证充分性:</p>
<p>考虑取<span class="math inline">\(\epsilon = 1\)</span>,则<span class="math inline">\(\exists N_1 , \forall n \geq N_1 , | x_n - x_{ N_1
} | &lt; 1\)</span>,于是<span class="math inline">\(| x_n | &lt; | x_{
N_1 } | + 1\)</span>,于是<span class="math inline">\(\forall n , | x_n |
&lt; \max_{ k = 1 }^{ N_1 } \{ | x_k | \} +
1\)</span>,于是这个数列有界,那么存在无穷子列有极限<span class="math inline">\(a\)</span>.</p>
<p>那么<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N
&gt; 0 , \forall n_k , m \geq N , | x_{ n_k } - x_m | &lt;
\epsilon\)</span>,其中<span class="math inline">\(\{ x_{ n_k }
\}\)</span>以<span class="math inline">\(a\)</span>为极限,于是可以取足够远的<span class="math inline">\(x_{ n_k }\)</span>.接下来就是简单说明的环节了.</p>
<p>柯西收敛准则的充分性还可以用上下极限证明:</p>
<p>取<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N ,
\forall n \geq N , x_n \in ( x_N - \epsilon , x_N + \epsilon
)\)</span>,那么上下极限之差<span class="math inline">\(\leq 2
\epsilon\)</span>.</p>
<p>于是引出了实数的第二种定义方式:我们定义两个柯西列等价,有<span class="math inline">\(\{ x_n \} \sim \{ y_n \} \Leftrightarrow \lim_{ n
\rightarrow \infty } | x_n - y_n | =
0\)</span>.那么所有有理数组成的柯西列的等价类构成实数集合.不难证明这样定义出来的实数和戴德金分割等价.</p>
<p>这个定义方式只依赖于距离的定义.而且我们可以证明任何一次扩充后得到的空间一定是封闭的.用这个例子就是说你对于一个实数的柯西列,证明它一定收敛到一个实数.那么就可以把这个柯西列的每一个数(作为实数,实际上对应了一个柯西列)中抽出一个数来,然后证明这些数组成的新的柯西列与刚才那个柯西列等价,这样就证明了其封闭性.其实只要第<span class="math inline">\(k\)</span>个数把其代表的任意一个柯西列中选第<span class="math inline">\(k\)</span>个元素构造即可.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>我们推广广义极限,也就是一个数列可以以<span class="math inline">\(+
\infty\)</span>或者<span class="math inline">\(-
\infty\)</span>为极限.这个容易用<span class="math inline">\(\epsilon -
N\)</span>语言写出来.这样的话我们立刻得到单调数列有极限.</p>
<p>那我们取任意一个数列从某一项往后的上确界<span class="math inline">\(h_n = \sup_{ k \geq n } \{ x_k
\}\)</span>和下确界<span class="math inline">\(l_n = \inf_{ k \geq n }
\{ x_k \}\)</span>,那么注意到<span class="math inline">\(\{ l_n
\}\)</span>单调不降,<span class="math inline">\(\{ h_n
\}\)</span>单调不增,所以二者都存在极限.由此可以定义上下极限,并且任意数列都一定存在上下极限.</p>
<p>注意到<span class="math inline">\(\lim_{ n \rightarrow \infty } l_n =
\sup_{ n \geq 1 } \inf_{ k \geq n } \{ x_k \} , \lim_{ n \rightarrow
\infty } h_n = \inf_{ n \geq 1 } \sup_{ k \geq n } \{ x_k
\}\)</span>,于是<span class="math inline">\(\varliminf_{ n \rightarrow
\infty } x_n = \lim_{ n \rightarrow \infty } l_n \leq \lim_{ n
\rightarrow \infty } h_n = \varlimsup_{ n \rightarrow \infty }
x_n\)</span>.</p>
<p>那么<span class="math inline">\(x_n\)</span>存在极限当且仅当<span class="math inline">\(\varlimsup_{ n \rightarrow \infty } x_n =
\varliminf_{ n \rightarrow \infty } x_n\)</span>.</p>
<p>充分性很好证明,只需要使用夹逼定理即可.</p>
<p>必要性也很好说如果极限不是<span class="math inline">\(\infty\)</span>,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n
\geq N , a - \epsilon &lt; x_n &lt; a + \epsilon\)</span>,那么<span class="math inline">\(a - \epsilon &lt; l_n \leq h_n &lt; a +
\epsilon\)</span>.自然得到两者极限相等.是<span class="math inline">\(\infty\)</span>也很好说.</p>
<p>上下极限同样有保序性,相反数有<span class="math inline">\(\varlimsup (
- x ) = - \varliminf x\)</span>,但是不能简单的四则运算,而是有<span class="math inline">\(\varliminf x_n + \varliminf y_n \leq \varliminf (
x_n + y_n ) \leq \varlimsup ( x_n + y_n ) \leq \varlimsup x_n +
\varlimsup y_n\)</span>,我们这里先不讨论出现<span class="math inline">\(\infty - \infty\)</span>的情况.</p>
<p>证明的话只需注意到<span class="math inline">\(\inf_{ k \geq n } x_k +
\inf_{ k \geq n } y_k \leq x_m + y_m , \forall m \geq
n\)</span>,因此对右边可以取下确界,然后两边一起取极限即可.</p>
<p>另外还有结论是<span class="math inline">\(\varliminf ( x_n + y_n )
\leq \varlimsup x_n + \varliminf
y_n\)</span>.这个又如何证明呢?只需证明:</p>
$$
<span class="math display">\[\begin{aligned}
\varliminf ( x_n + y_n ) - \varlimsup x_n &amp; \leq \varliminf y_n \\
\varliminf ( x_n + y_n ) + \varliminf ( - x_n ) &amp; \leq \varliminf
y_n \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是证毕.</p>
<p>乘法的话需要规定<span class="math inline">\(x_n , y_n &gt;
0\)</span>,然后和加法的不等式形式是类似的(同样先不考虑<span class="math inline">\(0 \times \infty\)</span>的情况).</p>
<p>如果<span class="math inline">\(\{ x_n \} , \{ y_n
\}\)</span>其中一个存在极限,那么上面的不等式就可以取等了(当然仍然不讨论出现<span class="math inline">\(\infty - \infty\)</span>和<span class="math inline">\(0 \times \infty\)</span>的情况).如果<span class="math inline">\(x_n = y_n &gt;
0\)</span>的话上面的乘法不等式也可以取等,换言之<span class="math inline">\(x_n &gt; 0\)</span>的时候<span class="math inline">\(\varlimsup x_n^2 = ( \varlimsup x_n
)^2\)</span>成立.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,满足<span class="math inline">\(a_n &gt; 0\)</span>,<span class="math inline">\(a_{ n + 2 } = \frac{ 2 }{ a_{ n + 1 } + a_n
}\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ a_n \}\)</span>有界.</p></li>
<li><p><span class="math inline">\(\lim_{ n \rightarrow \infty } a_n =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\exists \lambda \in ( 0 , 1 ) , c
&gt; 0\)</span>,<span class="math inline">\(\forall n , | a_n - 1 | &lt;
c \lambda^n\)</span>.</p></li>
<li><p>对所有满足条件的数列,求<span class="math inline">\(\min ( \lambda
) = \frac{ \sqrt{ 2 } }{ 2 }\)</span>.</p></li>
</ol>
<p>对于(1),取<span class="math inline">\(M = \max ( \max ( a_1 , a_2 ) ,
\frac{ 1 }{ \min ( a_1 , a_2 ) } )\)</span>,数学归纳可证明<span class="math inline">\(a_n \in [ \frac{ 1 }{ M } , M ]\)</span>.</p>
<p>两边取一下上极限和下极限,立刻得到<span class="math inline">\(1 \leq
\overline{ a } \underline{ a } \leq 1\)</span>,于是<span class="math inline">\(\overline{ a } \underline{ a } = 1\)</span>.</p>
<p>后面不会了(乐).</p>
<h4><span id="stolz定理">Stolz定理</span></h4>
<p>如果<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{
a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n } = A\)</span>,并且<span class="math inline">\(\{ b_n \}\)</span>单调递增且发散,那么<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ a_n }{ b_n }
= A\)</span>.</p>
<p>这个怎么证明呢?先取<span class="math inline">\(c_n = a_n -
Ab_n\)</span>,考虑<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists N &gt; 0 , \forall n \geq N\)</span>,有:</p>
<p><span class="math display">\[
c_{ n + 1 } - c_n \leq | c_{ n + 1 } - c_n | &lt; \epsilon ( b_{ n + 1 }
- b_n )
\]</span></p>
<p>两边求和,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
c_{ n } - c_N &amp; &lt; \epsilon ( b_{ n } - b_N ) \\
\frac{ c_n - c_N }{ b_n - b_N } &amp; &lt; \epsilon \\
\frac{ \frac{ c_n }{ b_n } - \frac{ c_N }{ b_n } }{ 1 - \frac{ b_N }{
b_n } } &amp; &lt; \epsilon
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(b_n\)</span>发散,对左边取极限就得到<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ c_n }{ b_n }
= 0\)</span>,也就证明了原结论.</p>
<p>如果将上述条件改为:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ b_n \}\)</span>单调递减且<span class="math inline">\(\lim b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim a_n = 0\)</span>.</p></li>
</ol>
<p>上述定理也是成立的.</p>
<p>证明仍然是上面那个过程,只是做一些小修改:</p>
<p><span class="math display">\[
\begin{aligned}
c_{ N } - c_n &amp; &lt; \epsilon ( b_{ N } - b_n ) \\
\frac{ c_N - c_n }{ b_N - b_n } &amp; &lt; \epsilon \\
\frac{ \frac{ c_N }{ b_N } - \frac{ c_n }{ b_N } }{ 1 - \frac{ b_n }{
b_N } } &amp; &lt; \epsilon
\end{aligned}
\]</span></p>
<p>两边取极限.</p>
<p>把Stolz定理推广到上下极限上.换言之,当:</p>
<ol type="1">
<li><span class="math inline">\(\{ b_n
\}\)</span>单调上升且趋近于无穷.</li>
</ol>
<p>或:</p>
<ol type="1">
<li><p><span class="math inline">\(\{ b_n \}\)</span>单调递减且<span class="math inline">\(\lim b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\lim a_n = 0\)</span>.</p></li>
</ol>
<p>此时应当有:</p>
<p><span class="math display">\[
\varliminf \frac{ a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n } \leq
\varliminf \frac{ a_n }{ b_n } \leq \varlimsup \frac{ a_n }{ b_n } \leq
\varlimsup \frac{ a_{ n + 1 } - a_n }{ b_{ n + 1 } - b_n }
\]</span></p>
<p>上述命题的一个平凡推论是:</p>
<p><span class="math display">\[
\varliminf ( a_{ n + 1 } - a_n ) \leq \varliminf \frac{ a_n }{ n } \leq
\varlimsup \frac{ a_n }{ n } \leq \varlimsup ( a_{ n + 1 } - a_n )
\]</span></p>
<h3><span id="实数的完备性基本定理">实数的完备性基本定理</span></h3>
<p>我们将以下定理称作实数的完备性的基本定理:</p>
<ol start="0" type="1">
<li><p>戴德金分割定理</p></li>
<li><p>确界存在定理</p></li>
<li><p>单调收敛准则</p></li>
<li><p>闭区间套定理(+阿基米德性质)</p></li>
<li><p>有限覆盖定理</p></li>
<li><p>聚点原理</p></li>
<li><p>致密性定理</p></li>
<li><p>柯西收敛准则(+阿基米德性质)</p></li>
</ol>
<p>这七条定理(除了3和7,它们需要与阿基米德性质配合使用)全部与戴德金分割定理等价.</p>
<p>我们上面已经论证了其中的部分推导关系,我们在下面声称它们分为若干组推导链条,分别代表了实数的不同性质.</p>
<h3><span id="函数极限">函数极限</span></h3>
<h4><span id="定义">定义</span></h4>
<p>函数的极限类型比较多:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的右侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a + 0\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>是从一点<span class="math inline">\(a\)</span>的左侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a - 0\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>同时从一点<span class="math inline">\(a\)</span>的两侧趋向于<span class="math inline">\(a\)</span>,这时记作<span class="math inline">\(x
\rightarrow a\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>无限制增大,记作<span class="math inline">\(x \rightarrow + \infty\)</span>.</p></li>
<li><p><span class="math inline">\(x\)</span>无限制减小,记作<span class="math inline">\(x \rightarrow - \infty\)</span>.</p></li>
<li><p><span class="math inline">\(| x |\)</span>无限制增大,<span class="math inline">\(x\)</span>同时增大或减小,记作<span class="math inline">\(x \rightarrow \infty\)</span>.</p></li>
</ol>
<p>序列极限的定理在函数极限的条件下几乎也全都成立.</p>
<h5><span id="单侧极限">单侧极限</span></h5>
<p>即<span class="math inline">\(x \rightarrow a + 0\)</span>和<span class="math inline">\(x \rightarrow a -
0\)</span>,这两种是对称的,我们只讨论前一种.</p>
<p>若<span class="math inline">\(\exists l , \forall \epsilon &gt; 0 ,
\exists \delta &gt; 0 , \forall 0 &lt; x - a &lt; \delta , | f ( x ) - l
| &lt; \epsilon\)</span>.我们称<span class="math inline">\(l\)</span>是<span class="math inline">\(x
\rightarrow a + 0\)</span>时<span class="math inline">\(f ( x
)\)</span>的<strong>右极限</strong>,记作<span class="math inline">\(\lim_{ x \rightarrow a + 0 } f ( x ) = l
\\\)</span>,同理可以定义<strong>左极限</strong>.</p>
<h5><span id="双侧极限">双侧极限</span></h5>
<p>若左右极限都存在且相等,那么双侧极限也存在并且<span class="math inline">\(\lim_{ x \rightarrow a } f ( x ) = \lim_{ x
\rightarrow a + 0 } f ( x ) = \lim_{ x \rightarrow a - 0 } f ( x )
\\\)</span>.</p>
<h5><span id="自变量趋于无穷时的极限">自变量趋于无穷时的极限</span></h5>
<p>设函数<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , + \infty )\)</span>上有定义,若<span class="math inline">\(\exists l\)</span>,<span class="math inline">\(\forall \epsilon , \exists A \geq a , \forall x
&gt; A , | f ( x ) - l | &lt; \epsilon\)</span>,则记<span class="math inline">\(\lim_{ x \rightarrow + \infty } f ( x ) = l
\\\)</span>,同理定义<span class="math inline">\(\lim_{ x \rightarrow -
\infty }\)</span>,若二者均存在且相等,定义<span class="math inline">\(\lim_{ x \rightarrow \infty } = \lim_{ x
\rightarrow + \infty } = \lim_{ x \rightarrow - \infty }\)</span>.</p>
<h4><span id="上下极限">上下极限</span></h4>
<p>定义去心邻域<span class="math inline">\(U_0 ( x_0 , \delta ) = ( x_0
- \delta , x_0 + \delta ) \setminus \{ x_0 \}\)</span>.</p>
<p>定义<span class="math inline">\(\varlimsup_{ x \rightarrow x_0 } f (
x ) = \lim_{ \delta \rightarrow + 0 } \sup_{ x \in U_0 ( x_0 , \delta )
} f ( x )\)</span>,下极限同理.</p>
<p>显然<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) =
A \Leftrightarrow \varlimsup_{ x \rightarrow x_0 } f ( x ) =
\varliminf_{ x \rightarrow x_0 } f ( x ) = A\)</span>.</p>
<h4><span id="第一可数公理">第一可数公理</span></h4>
<p>函数极限当然满足四则运算法则,保序性,夹逼定理,单调收敛准则,柯西收敛准则.</p>
<p>事实上函数极限和数列极限满足关系:</p>
<p><span class="math inline">\(\forall \{ x_n \} \in U_0 ( x_0
)\)</span>,如果<span class="math inline">\(\lim_{ n \rightarrow \infty }
x_n = x_0\)</span>,那么<span class="math inline">\(\lim_{ n \rightarrow
\infty } f ( x_n ) = \lim_{ x \rightarrow x_0 } f ( x
)\)</span>,前提是这两个极限都存在.</p>
<p>证明是堆<span class="math inline">\(\delta -
\epsilon\)</span>语言,不再赘述.</p>
<p>而它们之间关系的本质其实是:<span class="math inline">\(x_0\)</span>处的”任意小邻域”其实可以用某列邻域替代.</p>
<p>我们定义邻域基:一个由<span class="math inline">\(x_0\)</span>的邻域组成的集合<span class="math inline">\(U\)</span>,如果对于任意小邻域,<span class="math inline">\(U\)</span>中都存在一个邻域比这个邻域更小,那么就称<span class="math inline">\(U\)</span>是一个邻域基.<span class="math inline">\(\mathbb{ R
}\)</span>的特殊之处在于任意一个点都有可数邻域基,这被称为第一可数公理(<span class="math inline">\(C_1\)</span>公理).</p>
<p>另外<span class="math inline">\(\mathbb{ R
}\)</span>是可分的,也就是它存在可数稠密集(<span class="math inline">\(\mathbb{ Q }\)</span>).</p>
<h4><span id="无穷大量和无穷小量">无穷大量和无穷小量</span></h4>
<p>如果<span class="math inline">\(x \rightarrow x_0\)</span>时,<span class="math inline">\(f ( x )\)</span>有界,称<span class="math inline">\(f ( x ) = O ( 1 )\)</span>.</p>
<p>如果<span class="math inline">\(x \rightarrow
x_0\)</span>的时候,<span class="math inline">\(f ( x ) \rightarrow
0\)</span>,称<span class="math inline">\(f ( x ) = o ( 1 )\)</span>.</p>
<p>如果<span class="math inline">\(f , g = o ( 1 )\)</span>,<span class="math inline">\(\frac{ f }{ g } \rightarrow
1\)</span>,那么称二者为<strong>等价无穷小</strong>;如果<span class="math inline">\(\frac{ f }{ g } = c \ne
0\)</span>,则称二者为同阶无穷小(可记作<span class="math inline">\(f \sim
g\)</span>);如果<span class="math inline">\(\frac{ f }{ g } =
0\)</span>,则称<span class="math inline">\(f\)</span>为<span class="math inline">\(g\)</span>的<strong>高阶无穷小</strong>,可记作<span class="math inline">\(f = o ( g )\)</span>.</p>
<p>同阶无穷小在做乘除法的时候是可以替换的.</p>
<p>如果<span class="math inline">\(\frac{ f }{ g
}\)</span>是有界的,那么可以写作<span class="math inline">\(f = O ( g
)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ \sin x }{
x } = 1\)</span>.</p>
<p>因为其左右对称,考虑取<span class="math inline">\(x \in ( 0 , \frac{
\pi }{ 2 } )\)</span>我们有<span class="math inline">\(\sin x &lt; x
&lt; \tan x\)</span>(用单位元的面积证明).</p>
<p>那么考虑<span class="math inline">\(\frac{ \sin x }{ x } &lt;
1\)</span>,又注意到:</p>
<p><span class="math display">\[
\frac{ \sin x }{ x } &gt; \frac{ \sin x }{ \tan x } = \cos x
\]</span></p>
<p>夹逼定理一下就行.</p>
<p>类似可以证明<span class="math inline">\(\lim_{ x \rightarrow 0 }
\frac{ \tan x }{ x } = 1 , \lim_{ x \rightarrow 0 } \frac{ 1 - \cos x }{
x^2 } = \frac{ 1 }{ 2 } ,\)</span></p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ x - \sin
x }{ x^3 } = \frac{ 1 }{ 6 }\)</span>.</p>
<p>下面有个三次方,考虑套用一下三倍角公式,我们知道:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \frac{ x - \sin x }{ x^3 } = \frac{ x - ( 3 \sin \frac{
x }{ 3 } - 4 \sin^3 \frac{ x }{ 3 } ) }{ x^3 } \\
&amp; = \frac{ 3 ( \frac{ x }{ 3 } - \sin \frac{ x }{ 3 } ) + 4 \sin^3
\frac{ x }{ 3 } }{ ( \frac{ x }{ 3 } )^3 } \frac{ 1 }{ 27 } \\
&amp; = \frac{ 1 }{ 9 } f ( \frac{ x }{ 3 } ) + \frac{ 4 }{ 27 } (
\frac{ \sin \frac{ x }{ 3 } }{ \frac{ x }{ 3 } } )^3
\end{aligned}
\]</span></p>
<p>看上去两边取上下极限就做完了对吧!但是还差一点,因为我们要证明上下极限都不是无穷,起码得说明它有界.</p>
<p>注意到<span class="math inline">\(\frac{ x - \sin x }{ x^3 } &lt;
\frac{ \tan x - \sin x }{ x^3 } = \frac{ \sin x }{ x } ( \frac{ 1 - \cos
x }{ x^2 \cos x } ) = \frac{ \sin x }{ x } ( \frac{ 2 \sin^2 \frac{ x }{
2 } }{ x^2 \cos x }
)\)</span>,这样两边限定一下范围再取上极限可以说明原式上极限有界.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{ x \rightarrow 0 } \frac{ \sin x
- \tan x }{ x^3 }\)</span>.</p>
<p>考虑<span class="math inline">\(\frac{ \sin x - \tan x }{ x^3 } =
\frac{ \sin x }{ x } \frac{ 1 }{ x^2 } \frac{ \cos x - 1 }{ \cos x } =
\frac{ \tan x }{ x } \frac{ \cos x - 1 }{ x^2 } = - \frac{ 1 }{ 2
}\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ \log_{ a
} ( 1 + t ) }{ t } = \frac{ 1 }{ \ln a }\)</span>.</p>
<p><span class="math display">\[
\lim_{ t \rightarrow 0 } \frac{ \log_{ a } ( 1 + t ) }{ t } = \log_a
\lim_{ t \rightarrow 0 } ( 1 + t )^{ \frac{ 1 }{ t } } = \log_a e =
\frac{ 1 }{ \ln a }
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ a^t - 1
}{ t } = \ln a\)</span>.</p>
<p>令<span class="math inline">\(s = a^t - 1\)</span>,则原式等于<span class="math inline">\(\lim_{ s \rightarrow 0 } \frac{ s }{ \log_a ( s +
1 ) } = \ln a\)</span>.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\(\lim_{ t \rightarrow 0 } \frac{ ( 1 + t
)^\mu - 1 }{ t } = \mu\)</span>.</p>
<p>令<span class="math inline">\(s = ( 1 + t )^\mu -
1\)</span>,那么原式等于<span class="math inline">\(\lim_{ t \rightarrow
0 , s \rightarrow 0 } \mu \frac{ s }{ \ln ( 1 + s ) } \frac{ \ln ( 1 + t
) }{ t } = \mu\)</span>.</p>
<h4><span id="连续函数">连续函数</span></h4>
<p>不妨设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , b )\)</span>上有定义,若对于<span class="math inline">\(x_0 \in ( a , b )\)</span>,<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有双侧极限且<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) = f ( x_0
)\)</span>,称其在<span class="math inline">\(x_0\)</span>处<strong>连续</strong>,<span class="math inline">\(x_0\)</span>称为<strong>连续点</strong>,若<span class="math inline">\(\forall x_0 \in ( a , b )\)</span>,<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,则称其在<span class="math inline">\(( a , b
)\)</span>上<strong>连续</strong>.连续性相当于说:取极限和<span class="math inline">\(f\)</span>可以交换顺序,换言之<span class="math inline">\(\lim_{ x \rightarrow x_0 } f ( x ) = f ( \lim_{ x
\rightarrow x_0 } x )\)</span>.</p>
<p>我们也可以类似上面定义<strong>左连续</strong>和<strong>右连续</strong>,若<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a
, b ]\)</span>上有定义,且在<span class="math inline">\(( a , b
)\)</span>上连续,在<span class="math inline">\(a\)</span>处右连续,在<span class="math inline">\(b\)</span>处左连续,称其在<span class="math inline">\([ a , b ]\)</span>上连续.</p>
<p>如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>附近有定义且不连续,则称<span class="math inline">\(x_0\)</span>是一个<strong>间断点</strong>,间断点有以下几种:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\lim_{ x \rightarrow x_0 + 0 } f
( x )\)</span>和<span class="math inline">\(\lim_{ x \rightarrow x_0 - 0
} f ( x )\)</span>都存在但不相等或者不等于<span class="math inline">\(f
( x_0
)\)</span>,则称为<strong>第一类间断点</strong>.如果是后者情况,可以通过修改<span class="math inline">\(f ( x_0
)\)</span>的定义来去掉这个间断点,因而一般被称为<strong>可去间断点</strong>.</p></li>
<li><p>反之,如果<span class="math inline">\(\lim_{ x \rightarrow x_0 + 0
} f ( x )\)</span>和<span class="math inline">\(\lim_{ x \rightarrow x_0
- 0 } f ( x
)\)</span>至少有一个不存在,则称为<strong>第二类间断点</strong>.</p></li>
</ol>
<p>使用单调收敛准则,可证明单调函数没有第二类间断点.并且单调函数的间断点只有可数个(几乎处处连续).</p>
<p>这个怎么证明呢?考虑设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(x \in M , I_x = ( f ( x_0 - 0 ) , f ( x_0 + 0 )
)\)</span>,由于函数单调,所以这些<span class="math inline">\(I_x\)</span>两两不交.考虑映射<span class="math inline">\(M \rightarrow \mathbb{ Q } , x \mapsto \min ( I_x
\cap \mathbb{ Q } )\)</span>,也就是考虑每一个<span class="math inline">\(I_x\)</span>中都有若干个有理数,且互不相交,那么显然这个映射是个单射,<span class="math inline">\(M\)</span>可数.</p>
<p>事实上有更强的结论:任意函数的第一类间断点集都是可数的.</p>
<p>设<span class="math inline">\(M\)</span>是函数<span class="math inline">\(f\)</span>的第一类间断点集,取<span class="math inline">\(M_n = \{ x \in M \mid | f ( x + 0 ) - f ( x - 0 )
| &gt; \frac{ 1 }{ n } \} , M &#39; = \{ x \in M | f ( x + 0 ) = f ( x -
0 ) \ne f ( x ) \}\)</span>.</p>
<p>注意到<span class="math inline">\(M = ( \bigcup_{ n \geq 1 } M_n )
\cup M &#39;\)</span>.</p>
<p>我们定义孤立点:如果<span class="math inline">\(x \in A , \exists
\sigma , ( x - \sigma , x + \sigma ) \nsubseteq A\)</span>,则称<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>中的一个孤立点.类似刚才证明可数性,我们每个孤立点都可以取一段邻域,领域中一定存在有理数,所以任意一个集合中的孤立点个数一定是可数的.</p>
<p>又发现所有的<span class="math inline">\(x \in M_n\)</span>,<span class="math inline">\(x\)</span>都是孤立点,原因很显然因为在<span class="math inline">\(x\)</span>的两侧小区间都在趋近于一个极限,所以它们肯定不是第一类间断点.所以所有的<span class="math inline">\(M_n\)</span>都是可数集.</p>
<p>那怎么证明<span class="math inline">\(M
&#39;\)</span>是可数集呢?考虑取<span class="math inline">\(M &#39;_n =
\{ x \in M | | f ( x ) - f ( x - 0 ) | &gt; \frac{ 1 }{ n }
\}\)</span>,现在<span class="math inline">\(M &#39; = \bigcup_{ n \geq 1
} M &#39;_n\)</span>,而<span class="math inline">\(M
&#39;_n\)</span>一定是孤立点集,所以<span class="math inline">\(M
&#39;\)</span>可数.</p>
<p>综上就可以看出<span class="math inline">\(M\)</span>是一个可数集.</p>
<p>而第二类间断点则是可以有任意多个,例如对于迪利克雷函数,其处处都是第二类间断点.</p>
<p>由于连续性由极限定义,这意味着在<span class="math inline">\(( a , b
)\)</span>上的连续函数的有定义的四则运算必定得到的还是在<span class="math inline">\(( a , b
)\)</span>上的连续函数.那么,如果我们对于一个区间<span class="math inline">\(I\)</span>,定义<span class="math inline">\(C ( I
)\)</span>为所有在<span class="math inline">\(I\)</span>上连续的函数组成的集合,<span class="math inline">\(C ( I
)\)</span>就是一个线性空间.且不难发现,连续函数的复合仍然是连续函数.这其实对应着<span class="math inline">\(\lim_{ x \rightarrow a } g ( f ( x ) ) = g (
\lim_{ x \rightarrow a } f ( x ) ) = g ( f ( a ) ) \\\)</span>.</p>
<p>另外,如果一个连续函数有单值反函数,则反函数必连续.</p>
<p>不难证明,所有的初等函数在定义域上都是连续的.</p>
<p>另外:连续周期非常值函数一定有最小正周期.</p>
<p>考虑设正周期的集合是<span class="math inline">\(\{ t
\}\)</span>,取<span class="math inline">\(T = \inf \{ t \}\)</span>.</p>
<p>当<span class="math inline">\(T =
0\)</span>的时候,取一个正周期的数列<span class="math inline">\(\{ t_n \}
\rightarrow 0\)</span>,然后<span class="math inline">\(\forall x &lt; y
, x_n = x + \lfloor \frac{ y - x }{ t_n } \rfloor t_n , | y - x_n | \leq
t_n \rightarrow 0\)</span>,于是<span class="math inline">\(\lim_{ n } f
( x_n ) = f ( y )\)</span>,而恒有<span class="math inline">\(f ( x ) = f
( x_n )\)</span>于是这是一个常值函数.</p>
<p>反之,则取<span class="math inline">\(\{ t_n \} \rightarrow T , f ( x
+ T ) = \lim_{ n } f ( x + t_n ) = f ( x )\)</span>.</p>
<h5><span id="一致连续">一致连续</span></h5>
<p>假设<span class="math inline">\(f : I \rightarrow \mathbb{ R
}\)</span>,若<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists \delta &gt; 0 , \forall x_1 , x_2 \in I , | x_1 - x_2 | &lt;
\delta , | f ( x_1 ) - f ( x_2 ) | &lt;
\epsilon\)</span>,则称其<strong>一致连续</strong>.一致连续性是一个比连续性强得多的性质,例如<span class="math inline">\(f ( x ) = x^2\)</span>就不是一致连续的.</p>
<h5><span id="李氏连续">李氏连续</span></h5>
<p>假设<span class="math inline">\(f : I \rightarrow \mathbb{ R
}\)</span>,若<span class="math inline">\(\exists L , \forall x_1 , x_2
\in I , | f ( x_1 ) - f ( x_2 ) | \leq L | x_1 - x_2
|\)</span>,则称其<strong>李氏连续</strong>.李氏连续当然强于一致连续.</p>
<h4><span id="闭区间下的连续函数">闭区间下的连续函数</span></h4>
<h5><span id="介值定理零点存在定理">介值定理(零点存在定理)</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(f ( a ) \ne f ( b )\)</span>,则<span class="math inline">\(\forall \eta \in ( f ( a ) , f ( b ) ) , \exists c
\in ( a , b ) , f ( c ) = \eta\)</span>.这当然等价于<span class="math inline">\(f ( a ) f ( b ) &lt; 0 \Rightarrow \exists c \in (
a , b ) , f ( c ) = 0\)</span>.</p>
<p>考虑取<span class="math inline">\(f ( \frac{ a + b }{ 2 }
)\)</span>,如果<span class="math inline">\(f ( \frac{ a + b }{ 2 } ) =
0\)</span>那就完事了.不然的话考虑<span class="math inline">\(f ( a ) f (
\frac{ a + b }{ 2 } )\)</span>和<span class="math inline">\(f ( \frac{ a
+ b }{ 2 } ) f ( b )\)</span>中必定有恰好一个小于<span class="math inline">\(0\)</span>,这当然给出一个闭区间套,不妨设最后套出了一个单点<span class="math inline">\(c\)</span>.此时取极限立刻有<span class="math inline">\(0 \geq \lim f ( a_n ) f ( b_n ) = f ( c
)^2\)</span>,于是<span class="math inline">\(f ( c ) = 0\)</span>.</p>
<p>也有一个存在性证明:反证,如果<span class="math inline">\(\forall x \in
[ a , b ]\)</span>,<span class="math inline">\(f ( x ) \ne
0\)</span>.那么<span class="math inline">\(\forall x \in [ a , b ] ,
\exists \delta ( x ) &gt; 0\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\(( x -
\delta ( x ) , x + \delta ( x ) )\)</span>与<span class="math inline">\(f ( x
)\)</span>同号.根据有限覆盖定理,我们可以拿出有限个开区间来覆盖整个区间.此时可以将这些开区间排序,相邻两个区间两两有交,自然导出矛盾.</p>
<p>介质定理还有两个推论:</p>
<ol type="1">
<li><p><strong>介值定理的推论1</strong>:设<span class="math inline">\(f
( x )\)</span>在<span class="math inline">\([ a , b
]\)</span>上有定义且连续,那么<span class="math inline">\([ f ( a ) , f (
b ) ] \subseteq\)</span>其值域.</p></li>
<li><p><strong>介值定理的推论2</strong>:单调连续函数的反函数仍然是单调连续函数.</p></li>
</ol>
<p>推论(1)显然,考虑推论(2)的证明:</p>
<p>考虑对于连续单增函数<span class="math inline">\(f ( x ) \in C ( a , b
) , \alpha = f ( a + 0 ) , \beta = f ( b - 0
)\)</span>.先要证明其存在反函数<span class="math inline">\(\varphi \in C
( \alpha , \beta )\)</span>.</p>
<p>这里有一点小问题是我们要用介值定理要把定义域控制在闭区间,但这当然是好做的,对于任何一个<span class="math inline">\(c \in ( a , b )\)</span>,你一定可以取一个<span class="math inline">\(a_1 , b_1\)</span>使得<span class="math inline">\(f ( a_1 ) &lt; f ( c ) &lt; f ( b_1
)\)</span>,这样<span class="math inline">\(f ( x ) \in C [ a_1 , b_1
]\)</span>.</p>
<p>这样的话容易说明<span class="math inline">\(f\)</span>是<span class="math inline">\(( a , b ) \rightarrow ( \alpha , \beta
)\)</span>的双射,于是反函数是存在的.反函数的单调性是好证的.</p>
<p>对于反函数的连续性,反证,假设其在某一点<span class="math inline">\(c
\in ( \alpha , \beta )\)</span>处不连续,必然意味着<span class="math inline">\(a &lt; \varphi ( c - 0 ) &lt; \varphi ( c + 0 )
&lt; b\)</span>.此时容易说明<span class="math inline">\(\varphi ( x )
\in ( a , b ) \setminus ( \varphi ( c - 0 ) , \varphi ( c + 0 ) ) \cup
\{ \varphi ( c ) \}\)</span>,那只需要取<span class="math inline">\(w \in
( \varphi ( c - 0 ) , \varphi ( c + 0 ) ) \setminus \{ \varphi ( c )
\}\)</span>,<span class="math inline">\(\nexists x , \varphi ( x ) =
w\)</span>,这当然与我们上述结论不符.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于连续函数<span class="math inline">\(f \in C [ a , b ] , \forall
x_0 \in [ a , b ] \setminus \mathbb{ Q } , \varlimsup_{ \Delta x
\rightarrow 0 + 0 } \frac{ f ( x_0 + \Delta x ) - f ( x_0 ) }{ \Delta x
} \geq 0\)</span>,求证:<span class="math inline">\(f\)</span>单调递增.</p>
<p>先考虑把条件改成<span class="math inline">\(\forall x_0 \in [ a , b
]\)</span>怎么做.</p>
<p>一个想法是反证,如果不单调的话,找一个点使得它的右上导数小于<span class="math inline">\(0\)</span>.最自然的想法是找最大值,但最大值有可能只能证明右上导数<span class="math inline">\(\leq
0\)</span>.所以有一个想法是拿一条稍微斜一点(也就是斜率为较小的负数)的直线去截整个曲线.</p>
<p>下面反证,如果其不单增,总能找到两个点<span class="math inline">\(a
&#39; &lt; b &#39;\)</span>,使得<span class="math inline">\(f ( a &#39;
) &gt; f ( b &#39; )\)</span>.此时任意取一个<span class="math inline">\(\epsilon_0 &lt; f ( a &#39; ) - f ( b &#39;
)\)</span>,然后取一个点<span class="math inline">\(B = ( b &#39; , f ( b
&#39; ) + \epsilon_0 )\)</span>.当然可以再取一个<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(\epsilon + \epsilon_0 &lt; f ( a &#39; ) - f ( b
&#39; )\)</span>,然后取一个点<span class="math inline">\(A = ( a &#39; ,
f ( b &#39; ) + \epsilon_0 + \epsilon )\)</span>,这样<span class="math inline">\(AB\)</span>这条直线确定了一条斜率<span class="math inline">\(k &lt; 0\)</span>的一次函数<span class="math inline">\(g ( x )\)</span>,不妨设<span class="math inline">\(h ( x ) = f ( x ) - g ( x )\)</span>,容易发现<span class="math inline">\(h ( a &#39; ) &gt; 0 , h ( b &#39; ) &lt;
0\)</span>,所以可以取一个变号零点<span class="math inline">\(x_\epsilon
= \sup \{ x | h ( x ) \geq 0 , x \in [ a &#39; , b &#39; ]
\}\)</span>.当<span class="math inline">\(\epsilon\)</span>取值不一样的时候当然可以取不同的而且是不可数个<span class="math inline">\(x_\epsilon\)</span>,此时可以取出一个无理数<span class="math inline">\(x_0\)</span>,那考虑<span class="math inline">\(\varlimsup_{ \Delta x \rightarrow 0 + 0 } \frac{ f
( x_0 + \Delta x ) - f ( x_0 ) }{ \Delta x } = \varlimsup_{ \Delta x
\rightarrow 0 + 0 } \frac{ h ( x_0 + \Delta x ) }{ \Delta x } + k \leq k
&lt; 0\)</span>,这就矛盾了.</p>
<h5><span id="有界定理">有界定理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(\exists A , B\)</span>,<span class="math inline">\(\forall x_0 \in [ a , b ] , A \leq f ( x_0 ) \leq
B\)</span>.</p>
<p>可以用之前的有限覆盖定理所证明的闭区间上的局部有界函数是有界函数,然后还有另一个证明:</p>
<p>假设无界,则存在一个数列<span class="math inline">\(\{ x_n
\}\)</span>使得<span class="math inline">\(| f ( x_n ) | \rightarrow +
\infty\)</span>.由于<span class="math inline">\(\{ x_n
\}\)</span>是有界数列,其一定有收敛子列<span class="math inline">\(\{ x
&#39;_n \}\)</span>收敛于<span class="math inline">\(x
&#39;\)</span>,当然<span class="math inline">\(| f ( x &#39; ) | =
\lim_{ n \rightarrow \infty } | f ( x_n ) | = +
\infty\)</span>,这当然产生了矛盾.</p>
<p>还有一个闭区间套的证明方式:你考虑每次区间分两半,一定有其中一半是无界的,然后做闭区间套.</p>
<h5><span id="最值定理">最值定理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义且连续,<span class="math inline">\(\exists x_1 , x_2 \in [ a , b ]\)</span>,<span class="math inline">\(\forall x_0 \in [ a , b ] , f ( x_1 ) \leq f ( x_0
) \leq f ( x_2 )\)</span>.</p>
<p>考虑先用有界定理得知<span class="math inline">\(f ( x ) \in C [ a , b
]\)</span>有界,然后就可以拿到其上下确界<span class="math inline">\(m
\leq f ( x ) \leq M\)</span>,只需证明其上下确界均能取到就行.</p>
<p>反证,考虑若<span class="math inline">\(M\)</span>取不到,那考虑定义<span class="math inline">\(g ( x ) = \frac{ 1 }{ M - f ( x ) } &gt;
0\)</span>,根据有界定理<span class="math inline">\(g ( x
)\)</span>有上界<span class="math inline">\(C\)</span>,于是<span class="math inline">\(\frac{ 1 }{ M - f ( x ) } \leq C \Rightarrow f ( x
) \leq M - \frac{ 1 }{ C }\)</span>,矛盾.</p>
<p>或者我们知道<span class="math inline">\(M\)</span>是上确界则<span class="math inline">\(M - \frac{ 1 }{ n }\)</span>不是上界,取出<span class="math inline">\(\{ x_n \}\)</span>使得<span class="math inline">\(M - \frac{ 1 }{ n } &lt; f ( x_n ) \leq
M\)</span>,那么<span class="math inline">\(\{ x_n
\}\)</span>必然有收敛子列,设其收敛于<span class="math inline">\(x_0\)</span>,那么根据夹逼定理必然能得到<span class="math inline">\(f ( x_0 ) = M\)</span>.</p>
<h5><span id="康托尔定理">康托尔定理</span></h5>
<p>有界闭区间上的连续函数必然一致连续.</p>
<p>考虑反证,反命题是<span class="math inline">\(\exists \epsilon_0 &gt;
0 , \forall n &gt; 0 , \exists x &#39;_n , x &#39; &#39;_n , | x &#39;_n
- x &#39; &#39;_n | &lt; \frac{ 1 }{ n } , | f ( x &#39;_n ) - f ( x
&#39; &#39;_n ) | \geq \epsilon_0\)</span>.</p>
<p>用致密性定理,取出<span class="math inline">\(\{ x &#39;_n
\}\)</span>的收敛子列,可以拿到<span class="math inline">\(\{ x &#39;
&#39;_n \}\)</span>与其对应的数列,二者必然同时收敛于一个值<span class="math inline">\(x_0\)</span>,那么<span class="math inline">\(| f (
x &#39;_n ) - f ( x &#39; &#39;_n ) | = 0 \geq
\epsilon_0\)</span>,当然矛盾.</p>
<p>如果是开区间呢?如果<span class="math inline">\(f ( x ) \in C ( a , b
]\)</span>,其在开区间<span class="math inline">\(( a , b
]\)</span>上一致连续,这需要等价于<span class="math inline">\(\forall x_n
\in ( a , b ) , x_n \rightarrow a\)</span>,<span class="math inline">\(\{ f ( x_n ) \}\)</span>是柯西列(也就是<span class="math inline">\(f ( a + 0
)\)</span>极限存在),由此看出开区间上的一致连续函数必然能延拓称闭区间上的连续函数.</p>
<h4><span id="不动点和周期点">不动点和周期点</span></h4>
<p>定义<span class="math inline">\(f ( x
)\)</span>的<strong>不动点</strong><span class="math inline">\(\text{
fix } f ( x ) \Leftrightarrow f ( x ) =
x\)</span>,<strong>周期点</strong><span class="math inline">\(P_n = \{ x
| f^{ [ n ] } ( x ) = x \land \forall 0 &lt; m &lt; n , f^{ [ m ] } ( x
) \ne x \}\)</span>,其中<span class="math inline">\(f^{ [ n ] } ( x
)\)</span>表示将<span class="math inline">\(f\)</span>复合<span class="math inline">\(n\)</span>次.</p>
<h5><span id="压缩映照原理">压缩映照原理</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上有定义并且<span class="math inline">\(f ( [ a , b ] ) \subseteq [ a , b
]\)</span>,并且满足<span class="math inline">\(\exists 0 \leq q &lt; 1 ,
\forall x , y \in [ a , b ] , | f ( x ) - f ( y ) | \leq q | x - y
|\)</span>,那么<span class="math inline">\([ a , b
]\)</span>上存在唯一的不动点<span class="math inline">\(c\)</span>.</p>
<p>任取一个点<span class="math inline">\(x_0 \in [ a , b
]\)</span>,考虑<span class="math inline">\(x_{ n + 1 } = f ( x_n
)\)</span>,然后尝试判断这个数列的极限,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
| x_{ n + 1 } - x_n | &amp; = | f ( x_n ) - f ( x_{ n - 1 } ) | \leq q |
x_n - x_{ n - 1 } | \leq q^{ n } | x_1 - x_0 | \\
| x_{ n + p } - x_n | &amp; \leq \sum_{ k = 1 }^p | x_{ n + k } - x_{ n
+ k - 1 } | \\
&amp; \leq \sum_{ k = 0 }^{ p - 1 } q^{ n + k } | x_1 - x_0 | = | x_1 -
x_0 | q^n \frac{ 1 - q^{ p } }{ 1 - q }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\{ x_n
\}\)</span>是柯西列,其极限存在,取<span class="math inline">\(c = \lim
x_n\)</span>,容易发现:</p>
<p><span class="math display">\[
| f ( x_n ) - f ( c ) | \leq q | x_n - c |
\]</span></p>
<p>两边取极限得知<span class="math inline">\(f ( c ) =
c\)</span>,于是<span class="math inline">\(c\)</span>是一个不动点.如果还存在一个不动点<span class="math inline">\(c &#39; \ne c\)</span>,那么:</p>
<p><span class="math display">\[
| c - c &#39; | = | f ( c ) - f ( c &#39; ) | \leq q | c - c &#39; |
\]</span></p>
<p>不符.</p>
<h5><span id="李-约克定理">李-约克定理</span></h5>
<p>对于一个<span class="math inline">\(f ( x ) \in C [ a , b
]\)</span>,如果<span class="math inline">\(P_3 \ne
\emptyset\)</span>,那么<span class="math inline">\(\forall n \in
\mathbb{ N }_+\)</span>,<span class="math inline">\(P_n \ne
\emptyset\)</span>.</p>
<h6><span id="引理一">引理一</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G : J \rightarrow \mathbb{ R
}\)</span>是连续函数,<span class="math inline">\(\forall I = [ a , b ]
\subseteq G ( J )\)</span>,<span class="math inline">\(\exists Q = [ a
&#39; , b &#39; ] \subseteq J , G ( Q ) = I\)</span>.</p>
<p>根据介值定理,当然存在一对点<span class="math inline">\(p ,
q\)</span>,<span class="math inline">\(I = [ G ( p ) , G ( q )
]\)</span>.不妨设<span class="math inline">\(p &lt; q\)</span>,那么<span class="math inline">\(a &#39; = \sup \{ x \in [ p , q ] | G ( x ) = G (
p ) \} , b &#39; = \inf \{ x \in [ a &#39; , q ] | G ( x ) = G ( q )
\}\)</span>即可.</p>
<p>换言之,我们可以拿到一个区间使得它的像正是我们想要的区间.感性理解的话我们可以对一个区间求原像并且原像当然也是一个区间.那我们自然可以对区间进行迭代.这样迭代的区间有什么性质么?</p>
<h6><span id="引理二">引理二</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(F : J \rightarrow
J\)</span>是连续函数,取一列闭区间<span class="math inline">\(I_n\)</span>,满足<span class="math inline">\(\forall n \geq 0 , I_n \subseteq J , I_{ n + 1 }
\subseteq F ( I_n )\)</span>.不妨把这种区间列记作<span class="math inline">\(I_0 \Rightarrow I_1 \Rightarrow I_2 \Rightarrow
\cdots\)</span>.</p>
<p>那么我们可以找到一列闭区间<span class="math inline">\(I_0 = Q_0
\supseteq Q_1 \supseteq Q_2 \cdots\)</span>,<span class="math inline">\(\forall n \geq 0\)</span>,有<span class="math inline">\(F^{ [ n ] } ( Q_n ) = I_n\)</span>.</p>
<p>考虑数学归纳,假设对于<span class="math inline">\(\leq
n\)</span>的都已经满足,现在有<span class="math inline">\(I_{ n + 1 }
\subseteq F ( I_n ) = F^{ [ n + 1 ] } ( Q_n )\)</span>,令<span class="math inline">\(G = F^{ [ n + 1 ]
}\)</span>然后用引理一就可以.</p>
<p>这个引理的意义在于,<span class="math inline">\(\{ I_n
\}\)</span>当然不必是一条链,但是只要其满足一定的性质,我们就可以在它们中找到一条链,也就是每迭代一次都可能会将射出去的那个集合变小,或者是射出需要的集合所需要的初始集合变小.</p>
<p>这个当然也是给我们求原像的机会.我们尝试感性理解一下这个在干什么:</p>
<p>如果一个函数操作完一个区间后会把这个区间变小,那显然我如果想求<span class="math inline">\(F^{ [ - n ] } ( I )\)</span>,<span class="math inline">\(n\)</span>越大得到的原像就越大对吧.反之,如果会把这个区间变大,那<span class="math inline">\(n\)</span>越大得到的原像就越小对吧.</p>
<p>这个讨论显然是不好的,我们得想办法刻画一下这个东西.那当然要在这里蕴含一个<span class="math inline">\(F\)</span>本身.</p>
<p>于是用上面的定义会发现,即使<span class="math inline">\(F\)</span>会把这个区间扩张到奇怪的大小,只要我们能把它缩回去,那不断取原像的过程照样是可行的.</p>
<h6><span id="引理三">引理三</span></h6>
<p>设<span class="math inline">\(J\)</span>是实区间,<span class="math inline">\(G : J \rightarrow \mathbb{ R
}\)</span>是连续函数,<span class="math inline">\(I \subseteq
J\)</span>是闭区间,并且<span class="math inline">\(I \subseteq G ( I
)\)</span>或者<span class="math inline">\(G ( I ) \subseteq
I\)</span>,都可以推出<span class="math inline">\(\exists p \in I , G ( p
) = p\)</span>.</p>
<p>只需构造函数<span class="math inline">\(H ( x ) = x - G ( x
)\)</span>然后用介值定理即可.</p>
<h6><span id="李-约克定理">李-约克定理</span></h6>
<p>设<span class="math inline">\(q_3 \in P_3\)</span>,则<span class="math inline">\(F ( q_3 ) , F ( F ( q_3 ) ) \in
P_3\)</span>,容易看出,这三个点中必然有一个点<span class="math inline">\(a \in P_3\)</span>,使得<span class="math inline">\(a , b = F ( a ) , c = F ( F ( a )
)\)</span>这三个数单调递增或单调递减.不妨设<span class="math inline">\(a
&lt; b &lt; c\)</span>.</p>
<p>下面证明对于任意<span class="math inline">\(k &gt;
0\)</span>,存在<span class="math inline">\(k\)</span>周期点.</p>
<p>我们接下来取<span class="math inline">\(K = [ a , b ] , L = [ b , c
]\)</span>,立刻由介值定理发现<span class="math inline">\(F ( K )
\supseteq L\)</span>以及<span class="math inline">\(F ( L ) \supseteq [
a , c ] = K \cup L\)</span>.</p>
<p>接下来我们开始构造一列满足引理二的闭区间,我们考虑:</p>
<ol type="1">
<li><p>当<span class="math inline">\(k =
1\)</span>的时候,我们直接取<span class="math inline">\(\forall n , I_n =
L\)</span>.</p></li>
<li><p>当<span class="math inline">\(k &gt; 1\)</span>的时候,取<span class="math inline">\(I_n = \begin{cases}K &amp; n \equiv 0 \pmod{ k }
\\ L &amp; \text{ otherwise }\end{cases}\)</span></p></li>
</ol>
<p>现在我们可以用引理二立刻拿到区间列<span class="math inline">\(\{ Q_n
\}\)</span>,我们发现<span class="math inline">\(Q_k \subseteq Q_0 = I_0
= I_k = F^{ [ k ] } ( Q_k )\)</span>,根据引理三立刻得到<span class="math inline">\(\exists q \in Q_k , F^{ [ k ] } ( q ) =
q\)</span>.</p>
<p>那么这个<span class="math inline">\(q\)</span>有没有可能存在更小的周期<span class="math inline">\(d\)</span>呢?如果有的话,不妨取其中最小的那个<span class="math inline">\(d\)</span>,辗转相除一下自然有<span class="math inline">\(d | k\)</span>,那么当然要有<span class="math inline">\(F^{ [ k ] } ( q ) = F^{ [ k - d ] } ( q ) =
q\)</span>.</p>
<p>此时我们发现<span class="math inline">\(q \in Q_k \subseteq Q_{ k - d
}\)</span>,<span class="math inline">\(q \in I_{ k } \cap I_{ k - d } =
K \cap L = \{ b \}\)</span>,于是<span class="math inline">\(F^{ [ k ] }
( q ) = b , F^{ [ k + 1 ] } ( q ) = c , F^{ [ k + 2 ] } ( q ) =
a\)</span>.</p>
<p>这说明此时<span class="math inline">\(d = 3\)</span>.</p>
<p>而当<span class="math inline">\(k \geq 4\)</span>的时候,<span class="math inline">\(F^{ [ k + 2 ] } ( q ) = a \notin
L\)</span>,这当然与<span class="math inline">\(I_{ k + 2 } =
L\)</span>矛盾.</p>
<p>仔细观察一下上面的过程,我们到底依赖于什么东西得到了这个?</p>
<p>首先找到<span class="math inline">\(q\)</span>使得<span class="math inline">\(F^{ [ k ] } ( q ) =
q\)</span>这个其实反而并不是最主要的,因为只要<span class="math inline">\(F ( q ) = q\)</span>那么显然<span class="math inline">\(F^{ [ k ] } ( q ) =
q\)</span>,真正离谱的是竟然要让这个点在之前从未跳到过<span class="math inline">\(q\)</span>.这也是这个证明的最精髓的部分,那就是证明任何一个<span class="math inline">\(d &lt; q\)</span>都不是周期.</p>
<p>那我们考虑取一个区间(也就是<span class="math inline">\(K\)</span>),在<span class="math inline">\(K\)</span>中取一个合法的<span class="math inline">\(q\)</span>,然后我们只要找到一个闭区间(也就是<span class="math inline">\(Q_k \subseteq K\)</span>),使得它当且仅当复合<span class="math inline">\(k\)</span>次的时候才会打到<span class="math inline">\(K\)</span>上,在其它时候都得打在<span class="math inline">\(K\)</span>的外面(在这里是<span class="math inline">\(L\)</span>)上,那自然是可行的了对吧.而数字<span class="math inline">\(3\)</span>恰好完美地给出了这个构造.</p>
<p>如果我们再总结一下上面的过程,我们需要找到两个区间<span class="math inline">\(K , L\)</span>,找到一个<span class="math inline">\(Q_k \subseteq K\)</span>,使得<span class="math inline">\(F^k ( Q_k )\)</span>可以打到<span class="math inline">\(K\)</span>上但是对于<span class="math inline">\(d
&lt; k\)</span>,<span class="math inline">\(F^d ( Q_k
)\)</span>打到<span class="math inline">\(L\)</span>上.于是根据引理三其存在<span class="math inline">\(k\)</span>周期点,但是几乎不可能存在<span class="math inline">\(d\)</span>周期点(这里就需要简单判断一下<span class="math inline">\(L \cap K\)</span>的部分了)</p>
<p>这样的<span class="math inline">\(K\)</span>和<span class="math inline">\(L\)</span>怎么构造呢?如果我们构造<span class="math inline">\(F ( K )\)</span>打到<span class="math inline">\(L\)</span>上,<span class="math inline">\(F ( L
)\)</span>打到<span class="math inline">\(K\)</span>上显然是吧不合理的,那就可以一个打到另一个,另一个打到全集上再用引理一缩一下,这个看上去合理多了.这当然就是<span class="math inline">\(F ( K ) \supseteq L\)</span>以及<span class="math inline">\(F ( L ) \supseteq [ a , c ] = K \cup
L\)</span>.</p>
<h5><span id="sharkovskii定理">Sharkovskii定理</span></h5>
<p>定义如下的一种序关系<span class="math inline">\(\prec\)</span>(称为Sharkovskii序):</p>
<p><span class="math display">\[
\begin{gathered}
3 \prec 5 \prec 7 \prec \cdots \\
\prec 2 \times 3 \prec 2 \times 5 \prec \cdots \\
\cdots \\
\prec 2^k \times 3 \prec 2^k \times 5 \prec \cdots \\
\cdots \\
\cdots \prec 2^n \prec 2^{ n - 1 } \prec \cdots \prec 4 \prec 2 \prec 1
\end{gathered}
\]</span></p>
<p>对于<span class="math inline">\(f ( x ) \in C [ l , r ] , f : [ l , r
] \rightarrow [ l , r ]\)</span>.那么如果<span class="math inline">\(m
\prec n , P_m \ne \emptyset \Rightarrow P_n \ne \emptyset\)</span>.</p>
<p>(首先发现当然存在不动点)</p>
<p>这咋办呢?我们刚才用了<span class="math inline">\(3\)</span>的最重要的性质就是<span class="math inline">\(3\)</span>个点可以排成有序的一列,如果有类似的引理,那我们就可以尝试推广上面的结论.</p>
<h6><span id="引理">引理</span></h6>
<p>设<span class="math inline">\(f : I \rightarrow
I\)</span>是连续函数,<span class="math inline">\(f\)</span>有<span class="math inline">\(2 n +
1\)</span>周期点但无更小非一奇数阶周期点,我们取出其一个周期轨<span class="math inline">\(x_0 \rightarrow x_1 \rightarrow \cdots x_{ 2 n
}\)</span>,必有以下两者成立其一:</p>
<ol type="1">
<li><p><span class="math inline">\(x_{ 2 n } &lt; x_{ 2 n - 2 } &lt;
\cdots &lt; x_2 &lt; x_0 &lt; x_1 &lt; \cdots &lt; x_{ 2 n - 3 } &lt;
x_{ 2 n - 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(x_{ 2 n } &gt; x_{ 2 n - 2 } &gt;
\cdots &gt; x_2 &gt; x_0 &gt; x_1 &gt; \cdots &gt; x_{ 2 n - 3 } &gt;
x_{ 2 n - 1 }\)</span>.</p></li>
</ol>
<p>这个引理怎么证明呢?考虑把周期轨排一下序然后归纳,我们不妨假设排好序后的结果是<span class="math inline">\(y_0 &lt; y_1 &lt; \cdots &lt; y_{ 2 n
}\)</span>.</p>
<p>如果引理成立,(第一种情况下)取<span class="math inline">\(I_0 = [ x_0
, x_1 ]\)</span>,则<span class="math inline">\(I_0 \Rightarrow
I_0\)</span>.容易发现其实只有<span class="math inline">\(I_0\)</span>有这个性质,那我们不妨来看看满足<span class="math inline">\([ y_k , y_{ k + 1 } ] \Rightarrow [ y_k , y_{ k +
1 } ]\)</span>的情况是什么样子的,尝试去满足<span class="math inline">\([
f ( y_{ k + 1 } ) , f ( y_{ k } ) ] \supseteq [ y_k , y_{ k + 1 }
]\)</span>.这个时候注意到我们可以把所有点分成两类:满足<span class="math inline">\(f ( y_i ) \geq y_{ i + 1 }\)</span>(称为<span class="math inline">\(\alpha\)</span>类点,容易见到这里也就等价于<span class="math inline">\(f ( y_i ) &gt; y_i\)</span>)和<span class="math inline">\(f ( y_i ) \leq y_{ i - 1 }\)</span>(称为<span class="math inline">\(\beta\)</span>类点)的.那我们就是要找到一个<span class="math inline">\(k\)</span>使得<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点并且<span class="math inline">\(y_{ k + 1 }\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>由于<span class="math inline">\(f ( y_0 ) \geq y_1 , f ( y_{ 2 n } )
\leq y_{ 2 n - 1
}\)</span>,这两类点显然都有,那就一定存在交界的地方,这样我们就可以拿出这个分界的地方记作<span class="math inline">\(I_0 = [ y_k , y_{ k + 1 } ]\)</span>,其中<span class="math inline">\(y_k\)</span>是<span class="math inline">\(\alpha\)</span>类点,<span class="math inline">\(y_{ k + 1 }\)</span>是<span class="math inline">\(\beta\)</span>类点.</p>
<p>我们不妨定义一个集合<span class="math inline">\(S\)</span>的张成区间<span class="math inline">\(A\)</span>为<span class="math inline">\(A = [ \inf
S , \sup S ]\)</span>,那我们现在取<span class="math inline">\(S_0 = \{
y_k , y_{ k + 1 } \}\)</span>,设周期轨为<span class="math inline">\(O_f
= \{ x_0 , \cdots x_{ 2 n } \}\)</span>,我们递归定义<span class="math inline">\(S_{ k + 1 } = f ( A_k ) \cap
O_f\)</span>,容易根据上面对<span class="math inline">\(S_0\)</span>的构造发现<span class="math inline">\(S_0 \subsetneq S_1\)</span>,并且<span class="math inline">\(S_k\)</span>中因为取了一段极大的区间(但并没有包含所有周期点),所以一定能跳出这个区间(不然这个区间内部就可以自己射自己),所以<span class="math inline">\(S_k \subsetneq S_{ k + 1 }\)</span>.</p>
<p>那由此我们当然可以得到一条链:</p>
<p><span class="math display">\[
S_0 \subsetneq S_1 \subsetneq \cdots \subsetneq S_t = O_f
\]</span></p>
<p>按理来说应该有<span class="math inline">\(t = 2 n -
1\)</span>(这就会给出每次<span class="math inline">\(S\)</span>扩张只会多一个数),让我们先来证明这个结论:</p>
<p>反证,假设<span class="math inline">\(t &lt; 2 n -
1\)</span>,尝试找到一个更小的奇数周期来推出矛盾,不妨尝试找到一个<span class="math inline">\(2 n - 1\)</span>的周期(当然,如果<span class="math inline">\(2 n + 1 =
3\)</span>的话,这个结论我们在李约克定理已经证明了,所以下面假设<span class="math inline">\(2 n + 1 \geq 5\)</span>).</p>
<p>我不说你也知道我要干啥,我们考虑在末尾补<span class="math inline">\(2
n - t - 1\)</span>个<span class="math inline">\(A_t\)</span>,并把最后一个缩成<span class="math inline">\(A_0\)</span>,当然有:</p>
<p><span class="math display">\[
A_0 \Rightarrow A_1 \Rightarrow A_2 \Rightarrow \cdots \Rightarrow A_t
\Rightarrow A_t \supseteq A_0
\]</span></p>
<p>但这样并不太行,因为这些区间的交不是空的,我们起码得把其中的一个区间给挪出去,不妨考虑改掉最后一个<span class="math inline">\(A_t\)</span>,试图取一个<span class="math inline">\(l \ne k\)</span>使得<span class="math inline">\([
y_l , y_{ l + 1 } ] \Rightarrow A_0 = [ y_k , y_{ k + 1 }
]\)</span>.如果我们结合一下下面的主定理的证明部分,其实我们可以发现这里的<span class="math inline">\([ y_l , y_{ l + 1 } ]\)</span>也就是<span class="math inline">\(I_{ 2 n - 1 }\)</span>.</p>
<p>我们上面已经保证了<span class="math inline">\(f ( y_{ k + 1 } ) \leq
y_k\)</span>,如果有<span class="math inline">\(f ( y_{ k + 2 } ) \geq
y_{ k + 1 }\)</span>,那当然可以取<span class="math inline">\(l = k +
1\)</span>.也就是如果我们的这一列点类别中出现了<span class="math inline">\(\alpha \beta
\alpha\)</span>这样的结构就完事了.如果找不到,那说明<span class="math inline">\(f ( y_{ k + 2 } ) \leq y_{ k + 1
}\)</span>.我们继续往后找,如果可以遇到第一个<span class="math inline">\(f ( y_i ) \geq y_{ k + 1 }\)</span>,那<span class="math inline">\([ y_{ i - 1 } , y_i
]\)</span>自然是满足条件的.如果一直都找不到,说明始终有<span class="math inline">\(f ( y_i ) &lt; y_{ k + 1 } \leq y_{ i - 1 } , i
\in [ k + 2 , 2 n ]\)</span>,那说明后面全是<span class="math inline">\(\beta\)</span>点.</p>
<p>同理如果出现了<span class="math inline">\(\beta \alpha
\beta\)</span>这样的结构也找到了.不然类似同理,如果一直找不到就说明前面全是<span class="math inline">\(\alpha\)</span>点,前面的点始终满足<span class="math inline">\(f ( y_i ) \geq y_{ k + 1 } , i \in [ 0 , k
]\)</span>.</p>
<p>这已经推导出了矛盾,因为我们发现前面的点射到后面,后面的点射到前面,问题在于前面有<span class="math inline">\(k + 1\)</span>个点,后面有<span class="math inline">\(2 n - k\)</span>个点,于是<span class="math inline">\(k + 1 = 2 n - k \Rightarrow 2 k + 1 = 2
n\)</span>,这导出了矛盾.</p>
<p>所以确实可以找到这样的<span class="math inline">\(l \ne k , [ y_l ,
y_{ l + 1 } ] \Rightarrow [ y_k , y_{ k + 1 }
]\)</span>,那我们用上面的区间列自然可以推导出存在一个<span class="math inline">\(2 n -
1\)</span>周期点(或者其因子周期点,不过那也导出矛盾了).</p>
<p>于是<span class="math inline">\(t = 2 n -
1\)</span>,这表示我们拿到的这条链<span class="math inline">\(S_0
\subsetneq S_1 \subsetneq \cdots \subsetneq S_t =
O_f\)</span>每次只增加一个元素.如果<span class="math inline">\(S_0\)</span>到<span class="math inline">\(S_1\)</span>是只增加了一个元素,当然说明<span class="math inline">\(f ( y_k ) = y_{ k + 1 }\)</span>或者<span class="math inline">\(f ( y_{ k + 1 } ) =
y_k\)</span>.两者的证明是一样的,不妨设<span class="math inline">\(f (
y_k ) = y_{ k + 1 }\)</span>.</p>
<p>此时我们取<span class="math inline">\(x_0 = y_k , x_1 = y_{ k + 1
}\)</span>,此时其实也可以发现<span class="math inline">\(x_2 &lt; x_0
&lt; x_1\)</span>.并且根据上面的说法,我们知道<span class="math inline">\(A_{ k } \subsetneq A_{ k + 1
}\)</span>,那这个扩张一定是每次在边界上往外跑一个,也就是每次取一个新的迭代出来的结果扔到左边或者扔到右边.</p>
<p>网络上有关于这一点的证明往往是反证,假设不按规则走的话然后去尝试构造三周期点推到矛盾,但我们这里给出另一个证明方法:</p>
<p>考虑由于每次只增大一个数,那么如果我们能证明这一列<span class="math inline">\(y\)</span>形如<span class="math inline">\(\alpha
\cdots \alpha \beta \cdots \beta\)</span>的形式就做完了,这等价于<span class="math inline">\(I_0\)</span>的唯一性.</p>
<p>假设还有另一个区间也满足要求,对于这个新的区间,我们设其是<span class="math inline">\([ y_l , y_{ l + 1 }
]\)</span>,我们再拿一个周期点<span class="math inline">\(y_{ l + 2
}\)</span>出来,假设这三个数按照顺序是<span class="math inline">\(a &lt;
b &lt; c\)</span>,那么根据上面的结论一定有<span class="math inline">\(b
\rightarrow c \rightarrow a\)</span>或者<span class="math inline">\(b
\rightarrow a \rightarrow c\)</span>成立,这就说明<span class="math inline">\(b\)</span>被夹在了中间.而我们从一个<span class="math inline">\(I_0\)</span>扩张当然是逐步的,会将<span class="math inline">\(x_3 , x_4
\cdots\)</span>逐个加入,这必然意味着在<span class="math inline">\(b\)</span>加入之前,<span class="math inline">\(a ,
c\)</span>中已经有一个加进去了,但这是不可能的,只有<span class="math inline">\(b\)</span>加入后才能把<span class="math inline">\(a , c\)</span>给加进去.</p>
<h6><span id="sharkovskii定理">sharkovskii定理</span></h6>
<p>有了引理就可以开始类比了,不妨假设<span class="math inline">\(x_{ 2 n
} &lt; x_{ 2 n - 2 } &lt; \cdots &lt; x_2 &lt; x_0 &lt; x_1 &lt; \cdots
&lt; x_{ 2 n - 3 } &lt; x_{ 2 n - 1 }\)</span>.</p>
<p>现在我们要取区间列了,显然有一些奇偶对跳的现象,事实上我们取<span class="math inline">\(I_0 = [ x_0 , x_1 ] , I_{ 2 k - 1 } = [ x_{ 2 k }
, x_{ 2 k - 2 } ] , I_{ 2 k } = [ x_{ 2 k - 1 } , x_{ 2 k + 1 }
]\)</span>显然就是满足条件的.而且这些区间除了端点外完全不相交(而且任意三个区间的交都是空集).这一列一共有<span class="math inline">\(2 n\)</span>个区间.我们事实上可以取<span class="math inline">\(J = [ x_{ 0 } , x_{ 2 n - 1 } ] = \bigcup I_{ 2 k
}\)</span>放到整个区间的最后.</p>
<p>接下来我们用这些东西去对于多种情况来对跳.</p>
<p><strong>Case1</strong></p>
<p>(假设<span class="math inline">\(2 n +
1\)</span>是最小的非空的非一奇数周期)首先证明<span class="math inline">\(P_{ 2 n + 1 } \ne \emptyset \Rightarrow \forall 0
&lt; k , P_{ k + 2 n } \ne \emptyset\)</span>.</p>
<p>在前面补<span class="math inline">\(k\)</span>个<span class="math inline">\(I_0\)</span>,在最后也补一个<span class="math inline">\(I_0\)</span>,构造区间列:</p>
<p><span class="math display">\[
I_0 \Rightarrow I_0 \Rightarrow \cdots \Rightarrow I_0 \Rightarrow I_1
\Rightarrow I_2 \Rightarrow \cdots \Rightarrow I_{ 2 n - 1 } \Rightarrow
I_0
\]</span></p>
<p>也就是在前面补<span class="math inline">\(I_0\)</span>直到整个区间列的数量为<span class="math inline">\(k + 2 n + 1\)</span>,此时当然存在<span class="math inline">\(x_0 \in Q_{ k + 2 n }\)</span>使得<span class="math inline">\(f^{ [ k + 2 n ] } ( x_0 ) =
x_0\)</span>,只需证明<span class="math inline">\(\nexists d | ( k + 2 n
)\)</span>,<span class="math inline">\(f^{ [ d ] } ( x_0 ) =
x_0\)</span>即可.这当然好证,因为<span class="math inline">\(d \leq
\frac{ k + 2 n }{ 2 } \leq \max ( k , 2 n
)\)</span>,因为你只需要把它卡在那一堆<span class="math inline">\(I_0\)</span>和<span class="math inline">\(I_k\)</span>的分界线上就行.</p>
<p><strong>Case2</strong></p>
<p>(假设<span class="math inline">\(2 n +
1\)</span>是最小的非空的非一奇数周期)接下来我们来证明<span class="math inline">\(P_{ 2 n + 1 } \ne \emptyset \Rightarrow \forall 0
&lt; m , P_{ 2 m } \ne \emptyset\)</span>.</p>
<p>当<span class="math inline">\(2 m &gt; 2 n +
1\)</span>的时候我们已经证完了,接下来考虑<span class="math inline">\(2 m
&lt; 2 n + 1\)</span>的情况.</p>
<p>由于<span class="math inline">\(\forall k , I_{ 2 n - 1 } \Rightarrow
I_{ 2 k }\)</span>,我们考虑取出<span class="math inline">\(2 m +
1\)</span>个区间列,恰好有:</p>
<p><span class="math display">\[
I_{ 2 n - 2 m } \Rightarrow I_{ 2 n - 2 m + 1 } \Rightarrow \cdots
\Rightarrow I_{ 2 n - 1 } \Rightarrow I_{ 2 n - 2 m }
\]</span></p>
<p>接下来就是简单说明的过程了.</p>
<p><strong>Case3</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 4 } \ne \emptyset
\Rightarrow P_2 \ne \emptyset\)</span>.</p>
<p>这个证明就比较无聊了,我们进行暴力讨论,不妨假设<span class="math inline">\(a &lt; b &lt; c &lt; d\)</span>,那么:</p>
<ol type="1">
<li><span class="math inline">\(a \rightarrow b \rightarrow c
\rightarrow d \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ b , c ]
\Rightarrow [ c , d ] \Rightarrow [ a , d ] \supseteq [ a , b
]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="2" type="1">
<li><span class="math inline">\(a \rightarrow b \rightarrow d
\rightarrow c \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ b , d ]
\Rightarrow [ c , d ] \Rightarrow [ a , c ] \supseteq [ a , b
]\)</span>,于是可证明有三周期点,当然有二周期点.</p>
<ol start="3" type="1">
<li><span class="math inline">\(a \rightarrow c \rightarrow b
\rightarrow d \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ c , d ]
\Rightarrow [ a , b ]\)</span>,当然有二周期点.</p>
<ol start="4" type="1">
<li><span class="math inline">\(a \rightarrow c \rightarrow d
\rightarrow b \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , c ] \Rightarrow [ c , d ]
\Rightarrow [ b , d ] \Rightarrow [ a , b ] \Rightarrow [ a , c ]
\supseteq [ b , c ] \Rightarrow [ a , d ] \supseteq [ a , c
]\)</span>.于是有五周期点,于是有二周期点.</p>
<ol start="5" type="1">
<li><span class="math inline">\(a \rightarrow d \rightarrow b
\rightarrow c \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ a , b ] \Rightarrow [ c , d ]
\Rightarrow [ a , b ]\)</span>,当然有二周期点.</p>
<ol start="6" type="1">
<li><span class="math inline">\(a \rightarrow d \rightarrow c
\rightarrow b \rightarrow a\)</span>.</li>
</ol>
<p>此时<span class="math inline">\([ b , c ] \Rightarrow [ a , b ]
\Rightarrow [ a , d ] \supseteq [ b , c ]\)</span>,于是有二周期点.</p>
<p><strong>Case4</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n + 1 } } \ne
\emptyset \Rightarrow P_{ 2^n } \ne \emptyset\)</span>.</p>
<p>考虑上面命题等价于<span class="math inline">\(f^{ [ 2^{ n - 1 } ]
}\)</span>有四周期点,则其有二周期点.</p>
<p><strong>Case5</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^n q } \ne \emptyset\)</span>,其中<span class="math inline">\(p , q \in \text{ odd } , p &lt; q\)</span>.</p>
<p>考虑<span class="math inline">\(f^{ [ 2^n ] }\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q\)</span>周期点.</p>
<p><strong>Case6</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^m q } \ne \emptyset\)</span>,其中<span class="math inline">\(p , q \in \text{ odd } , m &gt; n\)</span>.</p>
<p>考虑<span class="math inline">\(f^{ [ 2^n ] }\)</span>有<span class="math inline">\(p\)</span>周期点,当然也就有<span class="math inline">\(q 2^{ m - n }\)</span>周期点.</p>
<p><strong>Case7</strong></p>
<p>接下来考虑证明:<span class="math inline">\(P_{ 2^{ n } p } \ne
\emptyset \Rightarrow P_{ 2^m } \ne \emptyset\)</span>,其中<span class="math inline">\(p \in \text{ odd }\)</span>.</p>
<p>选取<span class="math inline">\(N = \max ( n + 1 , m + 1
)\)</span>,则考虑<span class="math inline">\(f^{ [ 2^n ]
}\)</span>有<span class="math inline">\(p\)</span>周期点,则其有<span class="math inline">\(2^{ N - n }\)</span>周期点,<span class="math inline">\(P_{ 2^N } \ne \emptyset\)</span>.于是<span class="math inline">\(P_{ 2^m } \ne \emptyset\)</span>.</p>
<h3><span id="导数">导数</span></h3>
<p>设函数<span class="math inline">\(f ( x )\)</span>在一个区间<span class="math inline">\(( a , b )\)</span>上有定义,对于给定的<span class="math inline">\(x_0 \in ( a , b )\)</span>,考虑增量<span class="math inline">\(\Delta x \ne 0 \land x_0 + \Delta x \in ( a , b
)\)</span>,则<span class="math inline">\(\Delta y = f ( x_0 + \Delta x )
- f ( x_0 )\)</span>称为关于<span class="math inline">\(\Delta
x\)</span>的<strong>增量</strong>.若极限<span class="math inline">\(\lim_{ \Delta x \rightarrow 0 } \frac{ \Delta y }{
\Delta x } \\\)</span>存在则称这个函数在<span class="math inline">\(x_0\)</span>处<strong>可导</strong>,并称这个值为这个函数在<span class="math inline">\(x_0\)</span>处的<strong>导数</strong>或者<strong>微商</strong>,记作<span class="math inline">\(f &#39; ( x_0 )\)</span>或<span class="math inline">\(\frac{ \text{ d } f }{ \text{ d } x } |_{ x = x_0
}\)</span>.同理可以定义出<strong>左导数</strong>和<strong>右导数</strong>.如果某个函数的导数构成一个函数,我们称这个函数为其对应的<strong>导函数</strong>.</p>
<p>显然右可导能推出右连续,左可导能推出左连续.换言之,可导一定连续.</p>
<p>但是连续不一定可导,相当漂亮的一个反例是<span class="math inline">\(f
( x ) = \begin{cases}0 &amp; x = 0 \\ x \sin \frac{ 1 }{ x } &amp;
\text{ otherwise }\end{cases}\)</span>,其在零点没有左右导数.</p>
<p>如果<span class="math inline">\(f\)</span>的<span class="math inline">\(n - 1\)</span>次导数存在,记作<span class="math inline">\(f^{ ( n - 1 ) } ( x
)\)</span>,如果该函数可导则其导数称作<span class="math inline">\(f^{ ( n
) } ( x )\)</span>.</p>
<p>如果<span class="math inline">\(f^{ ( n ) } ( x )\)</span>在<span class="math inline">\(I\)</span>上连续,则称<span class="math inline">\(f
\in C^{ n } ( I )\)</span>.如果其任意阶可导,则称<span class="math inline">\(f \in C^{ \infty } ( I )\)</span>.</p>
<p>特别地,如果称一个函数是<span class="math inline">\(\alpha\)</span>次可导,即<span class="math inline">\(| f ( x ) - f ( y ) | \leq | x - y
|^\alpha\)</span>.其实就是Holder连续.</p>
<h4><span id="导数基本运算">导数基本运算</span></h4>
<p>导数也可以类似求出四则运算以及复合的法则:</p>
<ol type="1">
<li><p><span class="math inline">\([ cf ( x ) ] &#39; = cf &#39; ( x
)\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( x ) \pm g ( x ) ] &#39; = f
&#39; ( x ) \pm g &#39; ( x )\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( x ) g ( x ) ] &#39; = f &#39; (
x ) g ( x ) + g &#39; ( x ) f ( x )\)</span>.</p></li>
<li><p>(莱布尼茨公式):<span class="math inline">\([ f ( x ) g ( x ) ]^{
( n ) } = \sum_{ k = 0 }^n \binom{ n }{ k } f^{ ( k ) } ( x ) g^{ ( n -
k ) } ( x )\)</span>.</p></li>
<li><p><span class="math inline">\([ \frac{ f ( x ) }{ g ( x ) } ] &#39;
= \frac{ f &#39; ( x ) g ( x ) - g &#39; ( x ) f ( x ) }{ g^2 ( x ) } ,
g ( x ) \ne 0\)</span>.</p></li>
<li><p><span class="math inline">\([ g ( f ( x ) ) ] &#39; = g &#39; ( f
( x ) ) f &#39; ( x )\)</span>.</p></li>
</ol>
<p>(1)(2)比较平凡.</p>
<p>(3)(4)的证明的话,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ f ( x + \Delta x ) g ( x + \Delta x ) - f ( x ) g ( x ) }{
\Delta x } \\
= &amp; \frac{ f ( x + \Delta x ) - f ( x ) }{ \Delta x } g ( x + \Delta
x ) + f ( x ) \frac{ g ( x + \Delta x ) - g ( x ) }{ \Delta x }
\end{aligned}
\]</span></p>
<p>取一下极限就行.</p>
<p>(5)的话,其实求出<span class="math inline">\(( \frac{ 1 }{ g ( x ) } )
&#39;\)</span>就行了,我们来看:</p>
<p><span class="math display">\[
\begin{aligned}
( \frac{ 1 }{ g ( x ) } ) &#39; &amp; = \lim_{ \Delta x \rightarrow 0 }
\frac{ \frac{ 1 }{ g ( x + \Delta x ) } - \frac{ 1 }{ g ( x ) } }{
\Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \frac{ g ( x ) - g ( x +
\Delta x ) }{ g ( x + \Delta x ) g ( x ) } }{ \Delta x } \\
&amp; = \frac{ - g &#39; ( x ) }{ g^2 ( x ) }
\end{aligned}
\]</span></p>
<p>对于(6),不妨设<span class="math inline">\(f ( x_0 ) =
y_0\)</span>.</p>
<p>当<span class="math inline">\(\Delta y \ne
0\)</span>的时候,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \Delta y \rightarrow 0 } \frac{ g ( y_0 + \Delta y ) - g ( y_0 )
}{ \Delta y } &amp; = g &#39; ( y_0 ) \\
\lim_{ \Delta y \rightarrow 0 } [ \frac{ g ( y_0 + \Delta y ) - g ( y_0
) }{ \Delta y } - g &#39; ( y_0 ) ] &amp; = 0
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(\eta ( \Delta y ) = \frac{ g ( y_0 +
\Delta y ) - g ( y_0 ) }{ \Delta y } - g &#39; ( y_0 ) = \frac{ \Delta z
}{ \Delta y } - g &#39; ( y_0 ) , \Delta y \ne 0\)</span>,那么<span class="math inline">\(\lim_{ \Delta y \rightarrow 0 } \eta ( \Delta y )
= 0\)</span>.</p>
<p>此时有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ \Delta z }{ \Delta x } &amp; = \frac{ \Delta z }{ \Delta y }
\frac{ \Delta y }{ \Delta x } = \eta ( \Delta y ) \frac{ \Delta y }{
\Delta x } + g &#39; ( y_0 ) \frac{ \Delta y }{ \Delta x } \\

\end{aligned}\]</span>
<p>$$</p>
<p>带上极限,前者为<span class="math inline">\(0\)</span>.</p>
<p>另一种写法是,类似上面的讨论,我们这里有一些无穷小量,而且(除了<span class="math inline">\(\frac{ \Delta z }{ \Delta x
}\)</span>以外)也不会出现无穷小量之间的除法,用一下当然有,<span class="math inline">\(g ( y + \Delta y ) - g ( y ) = ( g &#39; ( y ) + o
( 1 ) ) \Delta y , f ( x + \Delta x ) - f ( x ) = ( f &#39; ( x ) + o (
1 ) ) \Delta x\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta z &amp; = ( g &#39; ( y ) + o ( 1 ) ) \Delta y \\
&amp; = ( g &#39; ( y ) + o ( 1 ) ) ( f &#39; ( x ) + o ( 1 ) ) \Delta x
\\

\end{aligned}\]</span>
<p>$$</p>
<p>两边除一下<span class="math inline">\(\Delta
x\)</span>两边求极限就行.</p>
<p>不难发现上面的过程等价于啥呢?等价于:</p>
<p><span class="math display">\[
\frac{ \text{ d } z }{ \text{ d } x } = \frac{ \text{ d } z }{ \text{ d
} y } \frac{ \text{ d } y }{ \text{ d } x }
\]</span></p>
<h4><span id="反函数的导数">反函数的导数</span></h4>
<p>我们首先声称:如果<span class="math inline">\(x = \varphi ( y ) ,
\varphi &#39; \ne 0 \Rightarrow\)</span><span class="math inline">\(有
反 函 数\)</span>f=^{-1}</p>
<p>然后我们声称:如果<span class="math inline">\(x = \varphi ( y ) \in C
( c , d )\)</span>,并且其严格单调且连续.如果<span class="math inline">\(( x_0 , y_0 )\)</span>处其导数存在,则<span class="math inline">\(f &#39; ( x_0 ) = \frac{ 1 }{ \varphi &#39; ( f (
x_0 ) ) }\)</span>.</p>
<p>这个可以用极限证明,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x_0 ) &amp; = \lim_{ x \rightarrow x_0 } \frac{ f ( x ) - f (
x_0 ) }{ x - x_0 } \\
&amp; = \lim_{ y \rightarrow y_0 } \frac{ y - y_0 }{ \varphi ( y ) -
\varphi ( y_0 ) } \\
&amp; = \lim_{ y \rightarrow y_0 } \frac{ 1 }{ \frac{ \varphi ( y ) -
\varphi ( y_0 ) }{ y - y_0 } } \\
&amp; = \frac{ 1 }{ \varphi &#39; ( y_0 ) }
\end{aligned}
\]</span></p>
<p>现在我们证明了反函数有导数,立即有:</p>
<p><span class="math display">\[
f ( g ( x ) ) = x \Rightarrow f &#39; ( x ) g &#39; ( f ( x ) ) = 1
\]</span></p>
<h4><span id="隐函数求导">隐函数求导</span></h4>
<p>这里我们不加证明地给出隐函数求导法则,也就是暂且把<span class="math inline">\(y\)</span>当成<span class="math inline">\(x\)</span>的函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>举例的话,我们来看方程:</p>
<p><span class="math display">\[
x = y + \epsilon \sin y
\]</span></p>
<p>两边对<span class="math inline">\(x\)</span>求导:</p>
<p><span class="math display">\[
\begin{aligned}
1 &amp; = y &#39; + y &#39; \epsilon \cos y \\
y &#39; &amp; = \frac{ 1 }{ 1 + \epsilon \cos y }
\end{aligned}
\]</span></p>
<h4><span id="参数方程的求导">参数方程的求导</span></h4>
<p>如果<span class="math inline">\(\begin{cases}x = x ( t ) \\ y = y ( t
)\end{cases}\)</span>,考虑求导<span class="math inline">\(\frac{ \text{
d } y }{ \text{ d } x }\)</span>.</p>
<p>这个做法就是反函数+链式法则.当然要保证下面需要的地方导数都不是<span class="math inline">\(0\)</span>.</p>
<p>不妨设<span class="math inline">\(t = t ( x )\)</span>,当然有<span class="math inline">\(y = y ( t ( x ) )\)</span>,那么<span class="math inline">\(\frac{ \text{ d } y }{ \text{ d } x } = y &#39; (
t ( x ) ) t &#39; ( x ) = \frac{ y &#39; ( t ) }{ x &#39; ( t )
}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>极坐标的求导:</p>
<p><span class="math display">\[
\begin{cases}
x = r ( \theta ) \cos \theta \\
y = r ( \theta ) \sin \theta
\end{cases}
\]</span></p>
<p>当然<span class="math inline">\(\frac{ \text{ d } y }{ \text{ d } x }
= \frac{ r &#39; \sin \theta + r \cos \theta }{ r &#39; \cos \theta - r
\sin \theta } = \frac{ \tan \theta + \frac{ r }{ r &#39; } }{ 1 - \tan
\theta \frac{ r }{ r &#39; } } = \tan ( \theta + \arctan ( \frac{ r }{ r
&#39; } ) ) = \tan \alpha\)</span>.</p>
<p>而容易发现<span class="math inline">\(\tan
\alpha\)</span>其实是切线和<span class="math inline">\(x\)</span>轴正半轴的夹角.</p>
<h4><span id="初等函数的导数">初等函数的导数</span></h4>
<p>下面给出若干初等函数的导数.</p>
<h5><span id="常函数">常函数</span></h5>
<p>常函数的连续性显然.</p>
<p>导数有:</p>
<p><span class="math display">\[
f ( x ) = c \Rightarrow f &#39; ( x ) = 0
\]</span></p>
<p>证明显然.</p>
<h5><span id="三角函数">三角函数</span></h5>
<p>三角函数的连续性比较有意思,考虑只需证明<span class="math inline">\(\sin x\)</span>连续即可,使用和差化积得到<span class="math inline">\(| \sin x - \sin x_0 | = | 2 \sin \frac{ x - x_0 }{
2 } \cos \frac{ x + x_0 }{ 2 } | \leq 2 | \sin \frac{ x - x_0 }{ 2 } |
\leq | x - x_0 |\)</span>.</p>
<p>导数有:</p>
<p><span class="math display">\[
\begin{aligned}
\sin &#39; ( x ) &amp; = \cos ( x ) \\
\cos &#39; ( x ) &amp; = - \sin ( x )
\end{aligned}
\]</span></p>
<p>只给出前者的证明,后者类似,或者换个元做诱导公式也行.</p>
<p>我们有和差化积:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin ( x + \Delta x ) - \sin ( x ) \\
= &amp; 2 \sin ( \frac{ \Delta x }{ 2 } ) \cos ( x + \frac{ \Delta x }{
2 } )
\end{aligned}
\]</span></p>
<p>自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \Delta x \rightarrow 0 } \frac{ \Delta y }{ \Delta x } &amp; =
\lim_{ \Delta x \rightarrow 0 } \frac{ 2 \sin ( \frac{ \Delta x }{ 2 } )
\cos ( x + \frac{ \Delta x }{ 2 } ) }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \sin ( \frac{ \Delta x }{
2 } ) }{ \frac{ \Delta x }{ 2 } } \cos ( x + \frac{ \Delta x }{ 2 } ) \\
&amp; = \cos ( x )
\end{aligned}
\]</span></p>
<p>进一步,我们可以考虑高阶导数:</p>
<p><span class="math display">\[
\begin{aligned}
( \sin x )^{ ( n ) } &amp; = \sin ( x + \frac{ n \pi }{ 2 } ) \\
( \cos x )^{ ( n ) } &amp; = \cos ( x + \frac{ n \pi }{ 2 } )
\end{aligned}
\]</span></p>
<p>而考虑<span class="math inline">\(( \tan x )
&#39;\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( \tan x ) &#39; &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \frac{
\sin ( x + \Delta x ) }{ \cos ( x + \Delta x ) } - \frac{ \sin x }{ \cos
x } }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \sin \Delta x }{ \Delta x
} \frac{ 1 }{ \cos x \cos ( x + \Delta x ) } \\
&amp; = \frac{ 1 }{ \cos^2 x }
\end{aligned}
\]</span></p>
<h5><span id="反三角函数">反三角函数</span></h5>
<p>使用反函数的导数公式:</p>
<p><span class="math display">\[
\begin{aligned}
\arctan &#39; ( x ) &amp; = \frac{ 1 }{ 1 + x^2 } \\
\arccos &#39; ( x ) &amp; = \frac{ - 1 }{ \sqrt{ 1 - x^2 } } \\
\arcsin &#39; ( x ) &amp; = \frac{ 1 }{ \sqrt{ 1 - x^2 } }
\end{aligned}
\]</span></p>
<p>反三角函数的高阶导数比较困难,我们来看个例子:</p>
<p>考虑<span class="math inline">\(y = \arctan x\)</span>,<span class="math inline">\(y &#39; = \frac{ 1 }{ 1 + x^2 } = \frac{ 1 }{ 1 +
\tan^2 y } = \cos^2 y\)</span>,那么<span class="math inline">\(y &#39;
&#39; = - 2 \cos y \sin y \times y &#39; = - \cos^2 y \sin 2
y\)</span>,事实上容易用归纳法证明<span class="math inline">\(y^{ ( n ) }
= ( n - 1 ) ! \cos^n y \sin ( n ( y + \frac{ \pi }{ 2 } )
)\)</span>.</p>
<p>不过还有一种办法,那就是我们考虑<span class="math inline">\(y &#39; =
- \frac{ 1 }{ 2 i } ( \frac{ 1 }{ i + x } + \frac{ 1 }{ i - x }
)\)</span>,用这个归纳立刻得到<span class="math inline">\(y^{ ( n ) } = -
\frac{ ( n - 1 ) ! }{ 2 i } ( ( i - x )^{ - n } - ( - 1 )^n ( i + x )^{
- n } )\)</span>.</p>
<p>然而<span class="math inline">\(y = \arcsin
x\)</span>要麻烦得多.下面我们来看一下:</p>
<p><span class="math display">\[
\begin{aligned}
y &#39; &amp; = \frac{ 1 }{ \sqrt{ 1 - x^2 } } \\
( y &#39; )^2 ( 1 - x^2 ) &amp; = 1 \\
( 1 - x^2 ) 2 y &#39; y &#39; &#39; - 2 x ( y &#39; )^2 &amp; \equiv 0
\\
( 1 - x^2 ) 2 y &#39; &#39; - 2 xy &#39; &amp; \equiv 0
\end{aligned}
\]</span></p>
<p>两边求<span class="math inline">\(n -
2\)</span>次导,利用莱布尼茨公式,化简后得到:</p>
<p><span class="math display">\[
( 1 - x^2 ) y^{ ( n ) } + ( 3 - 2 n ) xy^{ ( n - 1 ) } - ( n - 2 )^2 y^{
( n - 2 ) } \equiv 0
\]</span></p>
<h5><span id="指数函数">指数函数</span></h5>
<p>我们需要首先拿到指数为有理数的东西.</p>
<p>首先整数次方是有定义的,我们需要拿到形如<span class="math inline">\(f
( x ) = a^{ \frac{ 1 }{ x }
}\)</span>的东西,这个考虑取一下反函数即可.然后二者嵌套一下得到形如<span class="math inline">\(a^{ \frac{ q }{ p }
}\)</span>的幂函数,取反一下得到形如<span class="math inline">\(a^{ -
\frac{ q }{ p } }\)</span>的幂函数.</p>
<p>然后要定义无理数指数幂,类似戴德金分割,定义<span class="math inline">\(a^x = \sup_{ q \leq x , q \in Q }
a^q\)</span>.</p>
<p>当然我们要验证那些指数的运算法则,还有一些单调性(两个无理数之间插入两个有理数就可以拆成单调的,这里还需要讨论一下和<span class="math inline">\(1\)</span>的大小关系),这些当然都是对的.</p>
<p>然后我们就可以拿出指数函数,用反函数定义对数函数.</p>
<p>指数函数的连续性:考虑对于<span class="math inline">\(f ( x ) =
a^x\)</span>,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N &gt; 0 , a &lt; ( 1 +
\epsilon )^N\)</span>,此时取<span class="math inline">\(q_1 &lt; x_0
&lt; q_2\)</span>,<span class="math inline">\(q_2 - q_1 &lt; \frac{ 1 }{
N }\)</span>,这当然能做得到.考虑<span class="math inline">\(a^{ x_0 }
\leq f ( x_0 + 0 ) \leq f ( q_2 )\)</span>,于是<span class="math inline">\(1 \leq \frac{ a^{ q_2 } }{ a^{ q_1 } } \leq a^{
\frac{ 1 }{ N } } \leq 1 + \epsilon\)</span>.</p>
<p>先来看最特殊的指数函数:</p>
<p><span class="math display">\[
f ( x ) = e^x \Rightarrow f &#39; ( x ) = e^x
\]</span></p>
<p>事实上我们还有:</p>
<p><span class="math display">\[
f ( x ) = a^x \Rightarrow f &#39; ( x ) = a^x \ln a , a &gt; 0
\]</span></p>
<p>下面来看下为啥:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ a^{ x +
\Delta x } - a^x }{ \Delta x } \\
&amp; = a^x \lim_{ \Delta x \rightarrow 0 } \frac{ a^{ \Delta x } - 1 }{
\Delta x } \\
&amp; = a^x \ln a
\end{aligned}
\]</span></p>
<p>而高阶导数有:</p>
<p><span class="math display">\[
f ( x ) = e^{ ax } \Rightarrow f^{ ( n ) } = a^n e^{ ax }
\]</span></p>
<h5><span id="对数函数">对数函数</span></h5>
<p>先看:</p>
<p><span class="math display">\[
f ( x ) = \log_a ( x ) \Rightarrow f &#39; ( x ) = \frac{ 1 }{ x \ln a }
\]</span></p>
<p>证明的话考虑:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \log_a ( 1
+ \frac{ \Delta x }{ x } ) }{ \Delta x } \\
&amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ \log_a ( 1 + \frac{
\Delta x }{ x } ) }{ \frac{ \Delta x }{ x } } \frac{ 1 }{ x } \\
&amp; = \frac{ 1 }{ x \ln a }
\end{aligned}
\]</span></p>
<p>再看:</p>
<p><span class="math display">\[
f ( x ) = \ln | x | \Rightarrow f &#39; ( x ) = \frac{ 1 }{ x }
\]</span></p>
<p>考虑<span class="math inline">\(f ( x ) = \ln | x | = \frac{ 1 }{ 2 }
\ln x^2\)</span>.</p>
<p>考虑对数函数的高阶导数:</p>
<p><span class="math display">\[
f ( x ) = \ln x \Rightarrow f^{ ( n ) } ( x ) = ( - 1 )^{ n - 1 } ( n -
1 ) ! x^{ - n }
\]</span></p>
<h5><span id="幂函数">幂函数</span></h5>
<p>我们只需要定义<span class="math inline">\(x^{ \alpha } = e^{ \alpha
\ln x }\)</span>即可.</p>
<p>导数有:</p>
<p><span class="math display">\[
f ( x ) = x^\mu \Leftrightarrow f &#39; ( x ) = \mu x^{ \mu - 1 }
\]</span></p>
<p>证明的话,考虑<span class="math inline">\(x =
0\)</span>的时候根据定义显然,如果<span class="math inline">\(x \ne
0\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ \Delta x \rightarrow 0 } \frac{ ( x +
\Delta x )^\mu - x^\mu }{ \Delta x } \\
&amp; = \lim_{ \frac{ \Delta x }{ x } \rightarrow 0 } \frac{ ( 1 +
\frac{ \Delta x }{ x } )^\mu - 1 }{ \frac{ \Delta x }{ x } } x^{ \mu - 1
} \\
&amp; = \mu x^{ \mu - 1 }
\end{aligned}
\]</span></p>
<p>容易发现其高阶导数是:</p>
<p><span class="math display">\[
f ( x ) = x^\alpha \Rightarrow f^{ ( n ) } ( x ) = \alpha^{ \underline{
n } } x^{ \alpha - n }
\]</span></p>
<h5><span id="一般初等函数">一般初等函数</span></h5>
<p>定理:初等函数在其定义域上除了至多一个孤立点集外,可求导并且导函数也是初等函数.</p>
<h4><span id="单调函数的导数">单调函数的导数</span></h4>
<p>定义右上导数<span class="math inline">\(D^+ f ( x_0 ) = \varlimsup_{
h \rightarrow 0 + 0 } \frac{ f ( x_0 + h ) - f ( x_0 ) }{ h
}\)</span>,同理定义右下导数<span class="math inline">\(D_+\)</span>,左上导数<span class="math inline">\(D^{ - }\)</span>,左下导数<span class="math inline">\(D_-\)</span>.那么<span class="math inline">\(f
&#39; ( x_0 )\)</span>存在的充要条件当然是<span class="math inline">\(D_+ = D^+ = D_- = D^-\)</span>并且有限.</p>
<p>下面证明单调(不妨设为单增)函数<span class="math inline">\(f : [ a , b
] \rightarrow \mathbb{ R }\)</span>几乎处处有导数.</p>
<p>我们接下来尝试证明<span class="math inline">\(E_1 = \{ x \in [ a , b
] \mid D^+ f ( x ) &gt; D_- f ( x ) \} , E_2 = \{ x \in [ a , b ] \mid
D^- f ( x ) &gt; D_+ f ( x ) \}\)</span>两个集合是零测集.此时<span class="math inline">\(E_1 \cup E_2\)</span>就是零测集,而<span class="math inline">\(\mathbb{ R } \setminus ( E_1 \cup E_2
)\)</span>中的点都满足<span class="math inline">\(D^{ + } f ( x ) \leq
D_- f ( x ) \leq D^- f ( x ) \leq D_+ f ( x ) \leq D^+ f ( x
)\)</span>,于是它们都相等(可能等于<span class="math inline">\(+
\infty\)</span>).</p>
<p>二者类似,我们下面挑选前者进行证明:</p>
<p>考虑设<span class="math inline">\(A_{ r , s } = \{ x | D^+ f ( x )
&gt; r &gt; s &gt; D_- f ( x ) \}\)</span>,其中<span class="math inline">\(r ,
s\)</span>都是正有理数(因为是单调递增).这当然是可数个集合,所以只需要证明其中任意一个是零测集就可以.我们取<span class="math inline">\(A = A_{ r , s }\)</span>,下面证明<span class="math inline">\(A\)</span>是零测集.</p>
<p>反证,先假设<span class="math inline">\(A\)</span>不是零测集,<span class="math inline">\(m^* ( A ) &gt; 0\)</span>且有限(最大是<span class="math inline">\(b - a\)</span>).</p>
<p>首先删除<span class="math inline">\(A\)</span>中的孤立点集.由于孤立点集是零测集,这当然不会对答案有什么影响,也不会删成空集.这样下面可以直接假设<span class="math inline">\(A\)</span>是开集.</p>
<p>根据定义,存在任意小的<span class="math inline">\(h &gt;
0\)</span>使得<span class="math inline">\(\frac{ f ( x - h ) - f ( x )
}{ - h } &lt; s \Rightarrow f ( x ) - f ( x - h ) &lt;
sh\)</span>,那么我们取出这些<span class="math inline">\(I_{ x , h } = [
x - h , x ]\)</span>,并且满足<span class="math inline">\(I_{ x , h }
\subseteq A\)</span>.它们当然构成<span class="math inline">\(A\)</span>的一个Vitali覆盖.</p>
<p>根据Vitali覆盖引理我们有<span class="math inline">\(\exists I_{ k } =
[ x_k - h_k , x_k ]\)</span>两两不交并且满足<span class="math inline">\(m^* ( A \setminus ( \bigcup I_k ) ) &lt;
\epsilon\)</span>.而考虑<span class="math inline">\(m^* ( A \setminus (
\bigcup I_k ) ) + m^* ( \bigcup I_k ) \geq m^* ( A
)\)</span>,不妨令<span class="math inline">\(B = \bigcup
I_k\)</span>于是我们得到了<span class="math inline">\(m^* ( B ) &gt; m^*
( A ) - \epsilon\)</span>.</p>
<p>这里我曾经以为可以直接写<span class="math inline">\(m^* ( B ) = m^* (
A )\)</span>,但实际上是不行的,因为我们<span class="math inline">\(B\)</span>的构造依赖于<span class="math inline">\(\epsilon\)</span>.</p>
<p>同时由于所有的<span class="math inline">\(I_k \subseteq
A\)</span>并且两两不交,我们还有<span class="math inline">\(\sum_j h_j
\leq m^* ( A ) &lt; ( 1 + \epsilon ) m^* ( A )\)</span>.</p>
<p>而我们发现我们又有<span class="math inline">\(f ( x_j ) - f ( x_j -
h_j ) &lt; sh_j\)</span>,两边求和就有<span class="math inline">\(\sum f
( x_j ) - f ( x_j - h_j ) &lt; sm^* ( A )\)</span>.</p>
<p>而接下来考虑<span class="math inline">\(B\)</span>,<span class="math inline">\(B\)</span>当然仍然是一个开集.对于<span class="math inline">\(\forall y \in
B\)</span>,当然应该存在一个任意小的<span class="math inline">\(k &gt;
0\)</span>使得<span class="math inline">\(f ( y + k ) - f ( y ) &gt;
rk\)</span>.取出这些区间<span class="math inline">\([ y , y + k
]\)</span>当然仍然构成<span class="math inline">\(B\)</span>的一个Vitali覆盖.类似上面,我们当然有结论<span class="math inline">\(\sum f ( y_j + k_j ) - f ( y_j ) &gt; rm^* ( B )
&gt; r ( m^* ( A ) - \epsilon )\)</span>.但考虑<span class="math inline">\([ y_j , y_j + k_j ]\)</span>一定被包含在某个<span class="math inline">\([ x_j - h_j , x_j
]\)</span>中,又根据函数的单调性,自然可以知道<span class="math inline">\(sm^* ( A ) &gt; \sum f ( x_j ) - f ( x_j - h_j )
\geq \sum f ( y_j + k_j ) - f ( y_j ) &gt; r ( m^* ( A ) - \epsilon
)\)</span>.于是<span class="math inline">\(sm^* ( A ) \geq rm^* ( A
)\)</span>,这当然导出<span class="math inline">\(m^* ( A ) =
0\)</span>,与条件不符!</p>
<p>接下来的修补工作是证明<span class="math inline">\(E = \{ x | f &#39;
( x ) = + \infty \}\)</span>的集合是零测集.这意味着对于<span class="math inline">\(\forall N &gt; 0 , \exists \Delta x &gt; 0 , f ( x
+ \Delta x ) - f ( x ) &gt; N \Delta x\)</span>,取<span class="math inline">\([ x , x + \Delta x ]\)</span>当然仍然是<span class="math inline">\(E\)</span>的一个Vitali覆盖.同样根据Vitali覆盖引理得知<span class="math inline">\(\sum \Delta x &gt; m^* ( E ) -
\epsilon\)</span>,如果<span class="math inline">\(m^* ( E ) \ne
0\)</span>,做Vitali覆盖后对<span class="math inline">\(f ( x + \Delta x
) - f ( x ) &gt; N \Delta
x\)</span>左右两边分别求和,左边是有界,上界当然是<span class="math inline">\(f ( b ) - f ( a
)\)</span>,但右边无界.这就给出矛盾了.</p>
<p>理解一下上面的过程的话就是,由于该单调函数定义在一个闭区间上,那么这个单调函数应该有某种最值性.这必然会限制其大小,而如果哪里的大小崩坏了导致没有导数,这些地方的外测度一定要是<span class="math inline">\(0\)</span>,不然整体的最值性无法保证.</p>
<h4><span id="李氏连续函数的导数">李氏连续函数的导数</span></h4>
<p>注意到李氏连续的定义<span class="math inline">\(| f ( x ) - f ( y ) |
\leq L | x - y |\)</span>,注意到<span class="math inline">\(f ( x ) = f
( x ) - Lx + Lx\)</span>.</p>
<p>如果钦定<span class="math inline">\(x &lt;
y\)</span>,那李氏连续等价于<span class="math inline">\(f ( y ) - f ( x )
\leq | f ( x ) - f ( y ) | \leq L ( y - x ) , f ( y ) - Ly \leq f ( x )
- Lx\)</span>,于是<span class="math inline">\(f ( x ) -
Lx\)</span>是单调降函数,当然几乎处处可导,而<span class="math inline">\(Lx\)</span>作为初等函数当然处处可导.</p>
<p>李氏连续几乎等价于导函数有界.</p>
<p>下面我们证明:如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上可导,那么<span class="math inline">\(| f &#39; | \leq L \Leftrightarrow | f ( x_1 ) - f
( x_2 ) | \leq L | x_1 - x_2 |\)</span>.</p>
<p>右推左是显然的,除一下然后取极限即可.</p>
<p>左推右也很显然,只需用一下拉格朗日中值定理即可.</p>
<h4><span id="微分">微分</span></h4>
<p>设<span class="math inline">\(y = f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有定义,假设有一个常数<span class="math inline">\(A\)</span>使得<span class="math inline">\(f ( x_0
+ \Delta x ) - f ( x_0 ) = A \Delta x + o ( \Delta x ) , \Delta x
\rightarrow 0\)</span>,称<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处<strong>可微</strong>,并把<span class="math inline">\(\text{ d } f = \text{ d } y = A \Delta
x\)</span>称为<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处的<strong>微分</strong>,由于后半部分是一个更高阶的无穷小量,我们说微分是函数改变量的线性主要部分.</p>
<h5><span id="微分与导数微商">微分与导数(微商)</span></h5>
<p>结合导数极限的定义,就可以得到<span class="math inline">\(\text{ d } y
= f &#39; ( x ) \text{ d } x\)</span>,<span class="math inline">\(f
&#39; ( x ) = \frac{ \text{ d } y }{ \text{ d } x }
\\\)</span>.这就是我们将导数称作<strong>微商</strong>的原因.换言之,一阶可微一定一阶可导,反之亦然.但容易发现,可微的定义要比可导好得多,可微可以往外拓展到平面等拓扑结构,但可导不行.</p>
<p>一阶微分具有<strong>形式不变性</strong>.换言之就是,我们在求导的时候是需要选定一个自变量的,当选定的自变量是<span class="math inline">\(y\)</span>的时候,根据上面自然会有<span class="math inline">\(z = g ( y ) , \text{ d } z = g &#39; ( y ) \text{
d } y\)</span>.</p>
<p>但是当选定的自变量不是<span class="math inline">\(y\)</span>的时候,上面的形式是同样成立的.我们下面证明这个结论,令<span class="math inline">\(y = f ( x )\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
[ g ( f ( x ) ) ] &#39; &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \\
\text{ d } z &amp; = g &#39; ( f ( x ) ) f &#39; ( x ) \text{ d } x \\
\text{ d } z &amp; = g &#39; ( y ) \text{ d } y \\

\end{aligned}\]</span>
<p>$$</p>
<p>必须提出高阶微分不存在形式不变性,换句话说,<span class="math inline">\(z = g ( y )\)</span>的二阶微分的形式不等价于<span class="math inline">\(z = g ( y = f ( x )
)\)</span>的二阶微分,你不能乱换元.</p>
<p>一般将高阶微分记作<span class="math inline">\(\frac{ \text{ d }^n y
}{ \text{ d } x^n }\)</span>.</p>
<h4><span id="导函数的性质">导函数的性质</span></h4>
<h5><span id="费马定理">费马定理</span></h5>
<p>如果<span class="math inline">\(f ( x )\)</span>在邻域<span class="math inline">\(U ( \xi , \delta )\)</span>上有定义,<span class="math inline">\(\xi\)</span>是其的一个极值点,在<span class="math inline">\(\xi\)</span>处存在导数,那么<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>不妨考虑最大值情况,<span class="math inline">\(f &#39; ( \xi ) =
\lim_{ \Delta x \to + 0 } \frac{ f ( \xi + \Delta x ) - f ( \xi ) }{
\Delta x } = \lim_{ \Delta x \to - 0 } \frac{ f ( \xi + \Delta x ) - f (
\xi ) }{ \Delta x }\)</span>,前者<span class="math inline">\(\leq
0\)</span>,后者<span class="math inline">\(\geq 0\)</span>,此时当然<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<h5><span id="罗尔中值定理">罗尔中值定理</span></h5>
<p>如果<span class="math inline">\(f \in C [ a , b
]\)</span>且可导,并且<span class="math inline">\(f ( a ) = f ( b
)\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>即:可导函数两个零点间一定有导数的零点.</p>
<p>设<span class="math inline">\(M\)</span>为<span class="math inline">\(f [ a , b ]\)</span>上的最大值,<span class="math inline">\(m\)</span>是最小值,当二者相等即常值函数的时候,当然成立.</p>
<p>当<span class="math inline">\(M &gt; m\)</span>的时候,则<span class="math inline">\(M &gt; f ( a )\)</span>和<span class="math inline">\(m &lt; f ( a )\)</span>至少有一个成立.不妨设<span class="math inline">\(f ( M ) &gt; f ( a ) = f ( b )\)</span>.</p>
<p>根据费马定理,这个极值点的导数为<span class="math inline">\(0\)</span>.</p>
<p>由此可以推论:函数的零点数量<span class="math inline">\(| \{ x | f ( x
) = 0 \} | \leq 1 + | \{ x | f &#39; ( x ) = 0 \} |\)</span>.</p>
<p>这当然可以推出<span class="math inline">\(n\)</span>次多项式至多<span class="math inline">\(n\)</span>个实根.</p>
<p>事实上可以证明更强的结论,当<span class="math inline">\(c_i\)</span>不全为<span class="math inline">\(0\)</span>的时候,取<span class="math inline">\(n\)</span>个不同实数<span class="math inline">\(\lambda_k\)</span>,<span class="math inline">\(f (
x ) = \sum_{ i = 1 }^n c_i x^{ \lambda_i }\)</span>至多有<span class="math inline">\(n - 1\)</span>个正根.</p>
<p>归纳法,<span class="math inline">\(n = 1\)</span>的时候显然成立.<span class="math inline">\(n - 1\)</span>时成立的话,考虑<span class="math inline">\(f ( x ) = 0 \Leftrightarrow x^{ - \lambda_n } f (
x ) = 0\)</span>,而后者有一项是常数项,求导后少一项.</p>
<h5><span id="拉格朗日中值定理">拉格朗日中值定理</span></h5>
<p><span class="math inline">\(f \in C [ a , b ]\)</span>,并且在<span class="math inline">\(( a , b )\)</span>上可导，<span class="math inline">\(\exists \xi \in ( a , b ) , f &#39; ( \xi ) =
\frac{ f ( b ) - f ( a ) }{ b - a }\)</span>.</p>
<p>考虑先把函数放平,设<span class="math inline">\(g ( x ) = f ( x ) -
\frac{ f ( b ) - f ( a ) }{ b - a } ( x - a ) - f ( a
)\)</span>,容易发现<span class="math inline">\(g ( a ) = g ( b ) =
0\)</span>,根据罗尔中值定理,<span class="math inline">\(\exists \xi , g
&#39; ( \xi ) = 0 = f &#39; ( \xi ) - \frac{ f ( b ) - f ( a ) }{ b - a
} , f &#39; ( \xi ) = \frac{ f ( b ) - f ( a ) }{ b - a }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\(f &#39; ( x ) \equiv 0
\Rightarrow f ( x ) \equiv C\)</span>.</p>
<p>考虑<span class="math inline">\(\forall x , y , x \ne
y\)</span>,<span class="math inline">\(\forall \xi , f &#39; ( \xi ) =
\frac{ f ( y ) - f ( x ) }{ y - x } = 0 \Rightarrow f ( x ) = f ( y
)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>证明:如果<span class="math inline">\(f &#39; ( x ) \equiv g &#39; ( x
)\)</span>,那么<span class="math inline">\(f ( x ) = g ( x ) +
C\)</span>.</p>
<p>考虑<span class="math inline">\(h ( x ) = f ( x ) - g ( x ) , h &#39;
( x ) \equiv 0 \Rightarrow h ( x ) = C\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑对抛物线用拉格朗日中值定理,设<span class="math inline">\(f ( x )
= px^2 + qx + r\)</span>,则<span class="math inline">\(\frac{ f ( b ) -
f ( a ) }{ b - a } = \frac{ p ( b^2 - a^2 ) + q ( b - a ) }{ b - a } = p
( b + a ) + q = f &#39; ( \frac{ a + b }{ 2 } )\)</span>.</p>
<p>反过来,如果恒有<span class="math inline">\(\frac{ f ( b ) - f ( a )
}{ b - a } = f &#39; ( \frac{ a + b }{ 2 }
)\)</span>,事实上也可以推出<span class="math inline">\(f ( x
)\)</span>是抛物线.</p>
<p>此时我们有<span class="math inline">\(f ( x + y ) - f ( x - y ) = 2
yf &#39; ( x )\)</span>,取<span class="math inline">\(y =
1\)</span>,知道<span class="math inline">\(f ( x ) \in C^{ \infty
}\)</span>,于是可以两边对<span class="math inline">\(y\)</span>求两次导数,得到<span class="math inline">\(f &#39; &#39; ( x + y ) - f &#39; &#39; ( x - y )
\equiv 0\)</span>,取<span class="math inline">\(y =
x\)</span>,这当然意味着<span class="math inline">\(f &#39; &#39; ( x
)\)</span>是常函数.</p>
<h5><span id="柯西中值定理">柯西中值定理</span></h5>
<p><span class="math inline">\(f , g \in C [ a , b
]\)</span>,并且均在<span class="math inline">\(( a , b
)\)</span>上可导,其中<span class="math inline">\(g &#39; ( x ) \ne
0\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(\frac{ f ( b ) - f ( a ) }{ g ( b
) - g ( a ) } = \frac{ f &#39; ( \xi ) }{ g &#39; ( \xi )
}\)</span>.</p>
<p>此时注意到<span class="math inline">\(g ( b ) \ne g ( a
)\)</span>,原因是根据拉格朗日中值定理,如果<span class="math inline">\(g
( b ) = g ( a ) , \exists \xi \in ( a , b ) , g &#39; ( \xi ) =
0\)</span>,这与<span class="math inline">\(g &#39; ( x ) \ne
0\)</span>矛盾.</p>
<p>令<span class="math inline">\(F ( x ) = f ( x ) ( g ( b ) - g ( a ) )
- g ( x ) ( f ( b ) - f ( a ) )\)</span>.</p>
<p>接下来注意到上述命题等价于<span class="math inline">\(\exists \xi \in
( a , b ) , F &#39; ( \xi ) = 0\)</span>.</p>
<p>而注意到<span class="math inline">\(F ( a ) = f ( a ) g ( b ) - g ( a
) f ( b ) = F ( b )\)</span>,根据罗尔中值定理立刻得到答案.</p>
<p>然而这个东西竟然还能推广,我们有:</p>
<p>如果<span class="math inline">\(f , g , h \in C [ a , b
]\)</span>并且在<span class="math inline">\(( a , b
)\)</span>上可导,<span class="math inline">\(\exists \xi \in ( a , b )
,\)</span>有:</p>
<p><span class="math display">\[
\left | \begin{matrix}
f &#39; ( \xi ) &amp; g &#39; ( \xi ) &amp; h &#39; ( \xi ) \\
f ( a ) &amp; g ( a ) &amp; h ( a ) \\
f ( b ) &amp; g ( b ) &amp; h ( b )
\end{matrix} \right | = 0
\]</span></p>
<p>证明的话考虑构造:</p>
<p><span class="math display">\[
F ( x ) = \left | \begin{matrix}
f ( x ) &amp; g ( x ) &amp; h ( x ) \\
f ( a ) &amp; g ( a ) &amp; h ( a ) \\
f ( b ) &amp; g ( b ) &amp; h ( b )
\end{matrix} \right |
\]</span></p>
<p>注意到<span class="math inline">\(F ( a ) = F ( b ) = 0\)</span>.</p>
<h5><span id="广义微分中值定理">广义微分中值定理</span></h5>
<h6><span id="广义罗尔中值定理">广义罗尔中值定理</span></h6>
<p>如果<span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\forall x \in ( a , b ) , f &#39;_\pm ( x
)\)</span>均存在,并且<span class="math inline">\(f ( a ) = f ( b ) =
0\)</span>.则<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>,<span class="math inline">\(f_+ &#39; ( \xi ) f_- &#39; ( \xi
) \leq 0\)</span>.</p>
<p>证明和罗尔中值定理没区别,仍然是找最值.</p>
<h6><span id="广义拉格朗日中值定理">广义拉格朗日中值定理</span></h6>
<p>如果<span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\forall x \in ( a , b ) , f &#39;_\pm ( x
)\)</span>均存在,<span class="math inline">\(\eta = \frac{ f ( a ) - f (
b ) }{ a - b }\)</span>,则<span class="math inline">\(\exists \xi \in (
a , b )\)</span>,<span class="math inline">\(( f_+ &#39; ( \xi ) - \eta
) ( f_- &#39; ( \xi ) - \eta ) \leq 0\)</span>.</p>
<p>证明差不多,仍然是把函数放平然后用广义罗尔中值定理就行.</p>
<h5><span id="导函数与间断点">导函数与间断点</span></h5>
<p>导函数不存在第一类间断点.</p>
<p>证明的话,考虑证明当<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处可导的时候,<span class="math inline">\(\exists x_n &lt; x_0 &lt; y_n\)</span>,使得<span class="math inline">\(x_n , y_n \rightarrow x_0\)</span>,并且满足<span class="math inline">\(\lim f &#39; ( x_n ) = \lim f &#39; ( y_n ) = f
&#39; ( x_0 )\)</span>.</p>
<p>原因根据拉格朗日中值定理,<span class="math inline">\(\exists x_n \in
( x_0 - \frac{ 1 }{ n } , x_0 )\)</span>,<span class="math inline">\(f
&#39; ( x_n ) = \frac{ f ( x_0 ) - f ( x_0 - \frac{ 1 }{ n } ) }{ \frac{
1 }{ n } }\)</span>,直接这么取当然就是可行的.</p>
<h5><span id="函数的升降性">函数的升降性</span></h5>
<p><span class="math inline">\(f \in C [ a , b ]\)</span>并且在<span class="math inline">\(( a , b )\)</span>上可导,<span class="math inline">\(f\)</span>单调不减<span class="math inline">\(\Leftrightarrow\)</span>f’(x)</p>
<p>左推右当然是导数定义,右推左可以用拉格朗日微分中值定理.</p>
<p>另外由于保号性,<span class="math inline">\(f &#39; ( x ) &gt; 0
\Rightarrow f \uparrow\)</span>,但反之不成立.</p>
<h5><span id="函数的极值">函数的极值</span></h5>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \delta , x_0 + \delta )\)</span>上<span class="math inline">\(n - 1\)</span>次可导,<span class="math inline">\(\forall 1 \leq k \leq n - 1 , f^{ ( k ) } ( x_0 )
= 0\)</span>.而且<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处存在<span class="math inline">\(n\)</span>阶导数并有<span class="math inline">\(f^{ ( n ) } ( x_0 ) \ne
0\)</span>.我们有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(x_0\)</span>不是极值点.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{ ( n ) } ( x_0 ) &lt; 0\)</span>时,<span class="math inline">\(x_0\)</span>是极大值点.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数且<span class="math inline">\(f^{ ( n ) } ( x_0 ) &gt; 0\)</span>时,<span class="math inline">\(x_0\)</span>是极小值点.</p></li>
</ol>
<p>证明考虑泰勒公式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = f ( x_0 ) + \sum_{ k = 1 }^n \frac{ f^{ ( k ) } ( x_0 )
}{ k ! } ( x - x_0 )^k + o ( ( x - x_0 )^n ) \\
f ( x ) - f ( x_0 ) &amp; = ( x - x_0 )^n ( \frac{ f^{ ( n ) } ( x_0 )
}{ n ! } + o ( 1 ) )
\end{aligned}
\]</span></p>
<p>于是取极小邻域并且<span class="math inline">\(n\)</span>是偶数的时候<span class="math inline">\(f ( x ) - f ( x_0 )\)</span>和<span class="math inline">\(f^{ ( n ) } ( x_0 )\)</span>同号,上述命题立见.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>也即:导函数拥有介值性.</p>
<p>如果<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上可导,<span class="math inline">\(f &#39; ( a ) f &#39; ( b ) &lt;
0\)</span>,那么<span class="math inline">\(\exists \xi \in ( a , b ) , f
&#39; ( \xi ) = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(f &#39; ( a ) &gt; 0 &gt; f &#39; (
b )\)</span>,那么<span class="math inline">\(f\)</span>在<span class="math inline">\(a\)</span>处附近递增,在<span class="math inline">\(b\)</span>处附近递减.那我们取一下<span class="math inline">\(f ( \xi ) = \max_{ [ a , b ] } \{ f ( x )
\}\)</span>,那么<span class="math inline">\(\xi \ne a , \xi \ne
b\)</span>,于是<span class="math inline">\(\xi \in ( a , b
)\)</span>,<span class="math inline">\(f &#39; ( \xi ) = 0\)</span>.</p>
<p>那我们加个常数就可以把这个推广到导函数的介值性.</p>
<p>然而这个介值性比连续性弱得多,例如下面这个函数的导函数就在闭区间<span class="math inline">\([ 0 , 1 ]\)</span>上有界但没有最值:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
- x^2 ( 1 + \sin{ \frac{ 1 }{ x } } ) &amp; x \ne 0 \\
0 &amp; x = 0
\end{cases}
\]</span></p>
<p>其构造思路是让其在<span class="math inline">\(0\)</span>附近的导数在<span class="math inline">\(( - 1 , 1 )\)</span>上下波动,这样上确界为<span class="math inline">\(1\)</span>,但<span class="math inline">\(0\)</span>处跳出去,所以取不到<span class="math inline">\(1\)</span>.</p>
<p>下面这个函数更极端,其导函数在闭区间<span class="math inline">\([ 0 ,
1 ]\)</span>上无界:</p>
<p><span class="math display">\[
f ( x ) = \begin{cases}
x^2 \sin{ \frac{ 1 }{ x^2 } } &amp; x \ne 0 \\
0 &amp; x = 0
\end{cases}
\]</span></p>
<p>其构造思路应当是让其在<span class="math inline">\(0\)</span>处相当厉害地波动.</p>
<h5><span id="函数的凹凸性">函数的凹凸性</span></h5>
<p>定义一个函数是下凸的,若对<span class="math inline">\(\forall x_1 ,
x_2 \in I , \forall \lambda \in [ 0 , 1 ] , f ( \lambda x_1 + ( 1 -
\lambda ) x_2 ) \leq \lambda f ( x_1 ) + ( 1 - \lambda ) f ( x_2
)\)</span>.</p>
<p>如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1 , x_2 , x_3 \in I\)</span>满足<span class="math inline">\(x_1 &lt; x_2 &lt; x_3\)</span>,<span class="math inline">\(\left | \begin{matrix}1 &amp; x_1 &amp; f ( x_1 )
\\ 1 &amp; x_2 &amp; f ( x_2 ) \\ 1 &amp; x_3 &amp; f ( x_3
)\end{matrix} \right | \geq 0\)</span>.只需设<span class="math inline">\(x_2 = \lambda x_1 + ( 1 - \lambda )
x_3\)</span>然后简单变形即可.</p>
<p>不妨设<span class="math inline">\(k ( x_1 , x_2 ) = \frac{ f ( x_1 )
- f ( x_2 ) }{ x_1 - x_2
}\)</span>也就是这里的割线斜率.还可以证明如果一个函数是下凸的,那么其充要条件是<span class="math inline">\(\forall x_1 , x_2 , x_3 \in I , x_1 &lt; x_2 &lt;
x_3\)</span>,斜率有<span class="math inline">\(k ( x_1 , x_2 ) \leq k (
x_1 , x_3 ) \leq k ( x_2 , x_3
)\)</span>,即所谓三弦引理.这个性质容易证明,而且该性质立刻说明开区间上的有界下凸函数一定是李氏连续函数.这意味着其应当几乎处处可导.另外三弦引理还可以改为<span class="math inline">\(k ( x_1 , x_2 ) \leq k ( x_2 , x_3
)\)</span>,原因是中间项一定是两项的带权平均.</p>
<p>另外显然的是:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f\)</span>可导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span>f’</p></li>
<li><p>如果<span class="math inline">\(f\)</span>可二阶导,那么<span class="math inline">\(f\)</span>下凸<span class="math inline">\(\Leftrightarrow\)</span>f’’</p></li>
</ol>
<p>如果<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>附近连续并且在<span class="math inline">\(x_0\)</span>左右小邻域内凸性相反,称其为<span class="math inline">\(f ( x )\)</span>的一个<strong>拐点</strong>.</p>
<p>容易说明<span class="math inline">\(f &#39; &#39; ( x_0 ) =
0\)</span>是拐点的必要条件,原因是拐点处<span class="math inline">\(f
&#39; ( x )\)</span>的增减性相反,<span class="math inline">\(x_0\)</span>必定是<span class="math inline">\(f
&#39; ( x )\)</span>的极值点.由此还可以套用之前的极值点结论:</p>
<p>若<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>上<span class="math inline">\(n\)</span>次可导,<span class="math inline">\(\exists x_0 \in ( a , b ) , \forall 1 \leq k \leq
n - 1 , f^{ ( k ) } ( x_0 ) = 0\)</span>.并且<span class="math inline">\(\forall x \in ( a , b ) , f^{ ( n ) } ( x ) &gt;
0\)</span>我们有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(n\)</span>是奇数的时候,<span class="math inline">\(f ( x )\)</span>是严格单增函数.</p></li>
<li><p><span class="math inline">\(n\)</span>是偶数的时候,<span class="math inline">\(f ( x )\)</span>是严格下凸函数.</p></li>
</ol>
<p>但上述条件疑似有点过强,能不能放弱一点呢?</p>
<p>可以发现一个在开区间<span class="math inline">\(( a , b
)\)</span>上的函数是下凸的充要条件应当是以下条件同时成立:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall x \in ( a , b
)\)</span>,<span class="math inline">\(f &#39;_\pm ( x
)\)</span>均存在,并且<span class="math inline">\(f &#39;_- ( x ) \leq f
&#39;_+ ( x )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall x_1 , x_2 \in ( a , b ) , x_1
&lt; x_2\)</span>,<span class="math inline">\(f &#39;_+ ( x_1 ) \leq f
&#39;_- ( x_2 )\)</span>.</p></li>
</ol>
<p>必要性几乎是显然的,只需用三弦引理然后在每个点都卡一下极限就行.</p>
<p>充分性略有麻烦.考虑反证,只需反推三弦引理即可.设其不是凸的,那就<span class="math inline">\(\exists x_1 , x_2 , x_3 \in ( a , b ) , x_1 &lt;
x_2 &lt; x_3 , k ( x_1 , x_2 ) &gt; k ( x_2 , x_3 )\)</span>.不妨设<span class="math inline">\(\eta_1 = k ( x_1 , x_2 ) , \eta_2 = k ( x_2 , x_3
)\)</span>那么根据广义拉格朗日中值定理,<span class="math inline">\(\exists \xi_1 \in ( x_1 , x_2 ) , \xi_2 \in ( x_2
, x_3 )\)</span>,使得<span class="math inline">\(( f_+ &#39; ( \xi_1 ) -
\eta_1 ) ( f &#39;_- ( \xi_1 ) - \eta_1 ) \leq 0 , ( f_+ &#39; ( \xi_2 )
- \eta_2 ) ( f &#39;_- ( \xi_2 ) - \eta_2 ) \leq 0\)</span>.</p>
<p>立刻得到<span class="math inline">\(f &#39;_+ ( \xi_1 ) \geq \eta_1
\geq f_- &#39; ( \xi_1 ) , f &#39;_+ ( \xi_2 ) \geq \eta_2 \geq f_-
&#39; ( \xi_2 )\)</span>,由于<span class="math inline">\(\eta_1 &gt;
\eta_2\)</span>,所以<span class="math inline">\(f &#39;_+ ( \xi_1 ) \geq
\eta_1 &gt; \eta_2 \geq f &#39;_- ( \xi_2 )\)</span>,但<span class="math inline">\(\xi_1 &lt; \xi_2\)</span>,这就出现了矛盾.</p>
<p>还可以证明下凸函数除了可数个点以外都可导,并且几乎处处有二阶导数.</p>
<p>这个怎么证明呢?考虑由(1)(2),可以发现<span class="math inline">\(f
&#39;_+ ( x )\)</span>和<span class="math inline">\(f_- &#39; ( x
)\)</span>都是单调函数,那么除了可数个点以外它们均连续,而它们在连续处必定可导,原因是<span class="math inline">\(f_+ &#39; ( x_0 - \epsilon ) \leq f &#39;_- ( x_0
) \leq f &#39;_+ ( x_0
)\)</span>,夹逼一下就可以了.而这样的话其导数单调,于是处处二阶可导.</p>
<p>由此还可以发现:<span class="math inline">\(f\)</span>在开区间<span class="math inline">\(I\)</span>上,是下凸的等价于:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall x_0 \in I , f &#39;_\pm ( x_0
)\)</span>存在.</p></li>
<li><p><span class="math inline">\(\forall x \in I , f ( x ) \geq f (
x_0 ) + f &#39;_\pm ( x_0 ) ( x - x_0 )\)</span>.</p></li>
</ol>
<p>必要性:</p>
<p>考虑已知凸函数,只需证明<span class="math inline">\(f ( x ) - f ( x_0
) \geq f &#39;_\pm ( x_0 ) ( x - x_0 )\)</span>.不妨假设<span class="math inline">\(x &gt;
x_0\)</span>(另一方向同理),于是只需证明<span class="math inline">\(\frac{ f ( x ) - f ( x_0 ) }{ x - x_0 } \geq f
&#39;_\pm ( x_0 )\)</span>,用广义拉格朗日微分中值定理立刻得见此成立.</p>
<p>充分性:</p>
<p>任取两点<span class="math inline">\(x_1 , x_2 \in I , x_1 &lt;
x_2\)</span>,有<span class="math inline">\(\frac{ f ( x_2 ) - f ( x_1 )
}{ x_2 - x_1 } \geq f_- &#39; ( x_1
)\)</span>,那么左边那个东西取极限得到<span class="math inline">\(f
&#39;_+ ( x_1 )\)</span>,这样就说明了任何一个点都有<span class="math inline">\(f &#39;_+ ( x ) \geq f &#39;_- ( x )\)</span>.</p>
<p>接下来仍然容易得到:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x_2 ) &amp; \geq f ( x_1 ) + f &#39;_+ ( x_1 ) ( x_2 - x_1 ) \\
f ( x_1 ) &amp; \geq f ( x_2 ) + f &#39;_- ( x_2 ) ( x_1 - x_2 )
\end{aligned}
\]</span></p>
<p>由上述式子立刻得到<span class="math inline">\(f_+ &#39; ( x_1 ) &#39;
\leq f_- &#39; ( x_2 )\)</span>.这样就证明了充分性.</p>
<h4><span id="经典不等式">经典不等式</span></h4>
<h5><span id="琴生不等式">琴生不等式</span></h5>
<p>如果<span class="math inline">\(f\)</span>在区间<span class="math inline">\(I\)</span>上是下凸的,则<span class="math inline">\(\forall x_i \in I , \lambda_i \in [ 0 , 1 ] , \sum
\lambda_i = 1\)</span>,那么<span class="math inline">\(f ( \sum
\lambda_i x_i ) \leq \sum \lambda_i f ( x_i
)\)</span>.从几何角度来看,这意味着在<span class="math inline">\(f ( \sum
\lambda_i x_i
)\)</span>处作的切线位于原函数下方.所以函数如果是上凸的话不等号要反向.</p>
<p>当所有<span class="math inline">\(x_i\)</span>均相等的时候显然成立.</p>
<p>不然考虑直接取<span class="math inline">\(x_0 = \sum \lambda_i
x_i\)</span>,此时发现<span class="math inline">\(x_0\)</span>一定在区间内部.于是我们知道<span class="math inline">\(f ( x_i ) \geq f ( x_0 ) + f &#39;_+ ( x_0 ) ( x_i
- x_0 )\)</span>,求和得到<span class="math inline">\(\sum \lambda_i f (
x_i ) \geq f ( x_0 ) + f_+ &#39; ( x_0 ) \sum \lambda_i ( x_i - x_0 ) =
f ( x_0 )\)</span>,这样就证毕了.</p>
<p>容易将琴生不等式推广到积分形式,当<span class="math inline">\(\varphi
( x )\)</span>是下凸连续函数的时候,当然有<span class="math inline">\(\varphi ( \int_0^1 f \text{ d } x ) \leq \int_0^1
\varphi ( f ( x ) ) \text{ d } x\)</span>,证明只需对黎曼和求极限.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:圆内接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最大.</p>
<p>不妨设其为单位元,用圆心向顶点连边,会得到一圈圆心角<span class="math inline">\(\alpha_1 , \ldots ,
\alpha_n\)</span>,它们之和应当是<span class="math inline">\(2
\pi\)</span>并且范围均在<span class="math inline">\(( 0 , \pi
]\)</span>里(原因是圆心肯定得包含在正<span class="math inline">\(n\)</span>边形里,不然肯定不算大),此范围内<span class="math inline">\(\sin\)</span>是下凸函数,那么<span class="math inline">\(S = \frac{ 1 }{ 2 } \sum \sin \alpha_i \leq \frac{
n }{ 2 } \sin \frac{ \sum \alpha_i }{ n } = \frac{ n }{ 2 } \sin \frac{
2 \pi }{ n }\)</span>,<span class="math inline">\(L = 2 \sum \sin \frac{
\alpha_i }{ 2 } \leq 2 n \sin \frac{ \sum \alpha_i }{ 2 n } = 2 n \sin
\frac{ \pi }{ n }\)</span>.</p>
<p>同理还可以证明圆外接<span class="math inline">\(n\)</span>边形以正<span class="math inline">\(n\)</span>边形面积和周长最小,证明可以考虑取切线然后用<span class="math inline">\(\tan\)</span>的凸性.</p>
<h5><span id="均值不等式">均值不等式</span></h5>
<p>当<span class="math inline">\(x_i &gt; 0\)</span>时:</p>
<p><span class="math display">\[
\frac{ n }{ \sum \frac{ 1 }{ x_i } } \leq ( \prod x_i )^{ \frac{ 1 }{ n
} } \leq \frac{ \sum x_i }{ n }
\]</span></p>
<p>取<span class="math inline">\(f ( x ) = \ln x\)</span>,<span class="math inline">\(f ( x )\)</span>是上凸的,于是<span class="math inline">\(\ln \frac{ \sum x_i }{ n } \geq \frac{ 1 }{ n }
\sum \ln x_i\)</span>,右边得证,取倒数得到左边.</p>
<h5><span id="柯西-赫尔德不等式">柯西-赫尔德不等式</span></h5>
<p>当<span class="math inline">\(a_i , b_i &gt; 0\)</span>并且<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,有<span class="math inline">\(\sum a_i b_i \leq ( \sum
a_i^p )^{ \frac{ 1 }{ p } } ( \sum b_i^q )^{ \frac{ 1 }{ q }
}\)</span>.其特例给出柯西不等式.</p>
<p>套用琴生不等式,取<span class="math inline">\(f ( x ) = x^{ \frac{ 1
}{ q } } , \lambda_i = \frac{ a_i^p }{ \sum_j a_j^p } , x_i = \frac{
b_i^q }{ a_i^p }\)</span>,容易发现<span class="math inline">\(f ( x
)\)</span>上凸.</p>
<p>这样就会得到:</p>
$$
<span class="math display">\[\begin{aligned}
f ( \sum \lambda_i x_i ) &amp; \geq \sum \lambda_i f ( x_i ) \\
( \sum_i \frac{ b_i^q }{ \sum_j a_j^p } )^{ \frac{ 1 }{ q } } &amp; \geq
\sum_i \frac{ a_i b_i }{ \sum_j a_j^p } \\

\end{aligned}\]</span>
<p>$$</p>
<p>化简一下就可以了.</p>
<p>在这里也可以将此形式拓展到积分形式,注意到当<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,<span class="math inline">\(a^{ \frac{ 1 }{ p } } b^{
\frac{ 1 }{ q } } = e^{ \frac{ \ln a }{ p } + \frac{ \ln b }{ q } } \leq
\frac{ a }{ p } + \frac{ b }{ q }\)</span>,原因是琴生不等式.</p>
<p>此时令<span class="math inline">\(F = ( \int_a^b | f ( x ) |^p \text{
d } x )^{ \frac{ 1 }{ p } } , G = ( \int_a^b | g ( x ) |^q \text{ d } x
)^{ \frac{ 1 }{ q } }\)</span>,再令<span class="math inline">\(a =
\frac{ | f ( x ) |^p }{ F^p } , b = \frac{ | g ( x ) |^q }{ G^q
}\)</span>,根据上面的不等式立刻得到<span class="math inline">\(\frac{ |
f ( x ) g ( x ) | }{ FG } \leq \frac{ a }{ p } + \frac{ b }{ q
}\)</span>,此时做两边积分,注意到<span class="math inline">\(\int a =
\int b = 1\)</span>,立刻得到<span class="math inline">\(( \int_a^b | f (
x ) |^p \text{ d } x )^{ \frac{ 1 }{ p } } ( \int_a^b | g ( x ) |^q
\text{ d } x )^{ \frac{ 1 }{ q } } \geq \int_a^b | f ( x ) g ( x ) |
\text{ d } x\)</span>.</p>
<h5><span id="闵可夫斯基minkovski不等式">闵可夫斯基(Minkovski)不等式</span></h5>
<p><span class="math inline">\(x_i , y_i \geq 0 , p \geq
1\)</span>,则<span class="math inline">\(( \sum ( x_i + y_i )^p )^{
\frac{ 1 }{ p } } \leq ( \sum x_i^p )^{ \frac{ 1 }{ p } } + ( \sum y_i^p
)^{ \frac{ 1 }{ p } }\)</span>.这其实揭示了某种度量下的三角形不等式.</p>
<p>套用琴生不等式,取<span class="math inline">\(f ( x ) = ( 1 - x^{
\frac{ 1 }{ p } } )^p , x \in ( 0 , 1 )\)</span>.求导得到<span class="math inline">\(f &#39; ( x ) = - ( 1 - x^{ \frac{ 1 }{ p } } )^{
p - 1 } x^{ \frac{ 1 }{ p } - 1 }\)</span>,再来一次化简得到<span class="math inline">\(f &#39; &#39; ( x ) = ( 1 - \frac{ 1 }{ p } ) ( 1
- x^{ \frac{ 1 }{ p } } )^{ p - 2 } x^{ \frac{ 1 }{ p } - 2 } \geq
0\)</span>.于是<span class="math inline">\(f ( x )\)</span>下凸.</p>
<p>取<span class="math inline">\(\lambda_i = \frac{ ( x_i + y_i )^p }{
\sum_j ( x_j + y_j )^p }\)</span>,<span class="math inline">\(u_i = (
\frac{ x_i }{ x_i + y_i } )^p\)</span>.这样得到:</p>
<p><span class="math display">\[
\begin{aligned}
( 1 - \frac{ ( \sum x_i^p )^{ \frac{ 1 }{ p } } }{ ( \sum_j ( x_j + y_j
)^p )^{ \frac{ 1 }{ p } } } )^p &amp; \leq \sum_i \frac{ ( x_i + y_i )^p
}{ \sum_j ( x_j + y_j )^p } ( \frac{ y_i }{ x_i + y_i } )^p \\
( ( \sum ( x_i + y_i )^p )^{ \frac{ 1 }{ p } } - ( \sum x_i^p )^{ \frac{
1 }{ p } } )^p &amp; \leq \sum y_i^p
\end{aligned}
\]</span></p>
<p>化简一下就做完了.</p>
<h4><span id="洛必达法则">洛必达法则</span></h4>
<p>来看几个抽象的问题:</p>
<ol type="1">
<li><p><span class="math inline">\(\infty - \infty\)</span>.</p></li>
<li><p><span class="math inline">\(0 \times \infty\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ 0 }{ 0 }\)</span>.</p></li>
<li><p><span class="math inline">\(\frac{ \infty }{ \infty
}\)</span>.</p></li>
<li><p><span class="math inline">\(0^0\)</span>.</p></li>
<li><p><span class="math inline">\(1^\infty\)</span>.</p></li>
<li><p><span class="math inline">\(\infty^0\)</span>.</p></li>
</ol>
<p>(1)可以写成<span class="math inline">\(\infty ( 1 - \frac{ \infty }{
\infty } )\)</span>,这样就转化成了(4)和(2).</p>
<p>(2)可以写成<span class="math inline">\(\frac{ 0 }{ \frac{ 1 }{ \infty
} }\)</span>,就转化成了(3).</p>
<p>(5)可以写成<span class="math inline">\(e^{ 0 \ln 0
}\)</span>,就转化成了(2).</p>
<p>(6)可以写成<span class="math inline">\(e^{ \infty \ln 1
}\)</span>,就转化成了(2).</p>
<p>(7)可以写成<span class="math inline">\(e^{ 0 \ln \infty
}\)</span>,就转化成了(2).</p>
<p>这样的话我们只需要解决俩问题就行了,也就是<span class="math inline">\(\frac{ 0 }{ 0 }\)</span>和<span class="math inline">\(\frac{ \infty }{ \infty }\)</span>.</p>
<h5><span id="00型">0/0型</span></h5>
<p>如果<span class="math inline">\(f , g\)</span>在<span class="math inline">\(U_0 ( a , \delta )\)</span>上可导,<span class="math inline">\(g &#39; ( x ) \ne 0\)</span>,<span class="math inline">\(\lim_{ x \rightarrow a } f ( x ) = \lim_{ x
\rightarrow a } g ( x ) = 0\)</span>.那么若<span class="math inline">\(\lim_{ x \rightarrow a } \frac{ f &#39; ( x ) }{ g
&#39; ( x ) } = k \Rightarrow \lim_{ x \rightarrow a } \frac{ f ( x ) }{
g ( x ) } = k\)</span>.</p>
<p>这个只需要定义<span class="math inline">\(f ( a ) = g ( a ) =
0\)</span>,这样这俩函数就连续了.然后直接跑柯西中值定理就可以对<span class="math inline">\(\frac{ f ( x ) - f ( a ) }{ g ( x ) - g ( a ) } =
\frac{ f &#39; ( \xi ) }{ g &#39; ( \xi ) }\)</span>.</p>
<p>这里可以看出洛必达法则是单向的,因为我们取得<span class="math inline">\(\xi\)</span>并不是连续变化的,只是取了一个<span class="math inline">\(\rightarrow 0\)</span>的<span class="math inline">\(\xi\)</span>的子列.</p>
<p>而如果<span class="math inline">\(a = \infty\)</span>,那就考虑取<span class="math inline">\(t \rightarrow 0\)</span>,然后把<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{ 1
}{ t }\)</span>,做复合函数求导即可,结论无差异.</p>
<h5><span id="inftyinfty型"><span class="math inline">\(\infty\)</span>/<span class="math inline">\(\infty\)</span>型</span></h5>
<p>如果<span class="math inline">\(f , g\)</span>在<span class="math inline">\(U_0 ( a , \delta )\)</span>上可导,<span class="math inline">\(g &#39; ( x ) \ne 0\)</span>,<span class="math inline">\(\lim_{ x \rightarrow a } g ( x ) =
\infty\)</span>.那么若<span class="math inline">\(\lim_{ x \rightarrow a
} \frac{ f &#39; ( x ) }{ g &#39; ( x ) } = k \Rightarrow \lim_{ x
\rightarrow a } \frac{ f ( x ) }{ g ( x ) } = k\)</span>.</p>
<p>这个证明麻烦一点,先来讨论<span class="math inline">\(k \ne \pm
\infty\)</span>的情况.</p>
<p>考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \delta &gt; 0 , \forall
\xi \in ( a , a + \delta )\)</span>,应当有<span class="math inline">\(k
- \epsilon &lt; \frac{ f &#39; ( \xi ) }{ g &#39; ( \xi ) } &lt; k +
\epsilon\)</span>,那么<span class="math inline">\(\forall x \in ( a , a
+ \delta )\)</span>,取<span class="math inline">\(x_1 = a +
\delta\)</span>当然有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ f ( x ) - f ( x_1 ) }{ g ( x ) - g ( x_1 ) } &amp; = \frac{ f
&#39; ( \xi ) }{ g &#39; ( \xi ) } \\
\frac{ f ( x ) }{ g ( x ) } &amp; = \frac{ f &#39; ( \xi ) }{ g &#39; (
\xi ) } ( 1 - \frac{ g ( x_1 ) }{ g ( x ) } ) + \frac{ f ( x_1 ) }{ g (
x ) }
\end{aligned}
\]</span></p>
<p>两边取极限就做完了.</p>
<p>当<span class="math inline">\(k = \pm
\infty\)</span>的时候容易发现上面那个还能用.</p>
<h4><span id="泰勒公式">泰勒公式</span></h4>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<strong>泰勒公式</strong>声称<span class="math inline">\(x \rightarrow x_0\)</span>时<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } + o ( ( x - x_0 )^n )\)</span>,其中<span class="math inline">\(o ( ( x - x_0 )^n
)\)</span>称作<strong>皮亚诺余项</strong>.特别地,当<span class="math inline">\(x_0 =
0\)</span>的时候,称其为<strong>麦克劳林公式</strong>.</p>
<p>要证明这个式子只需证明<span class="math inline">\(\lim_{ x
\rightarrow x_0 } \frac{ f ( x ) - \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } }{ ( x - x_0 )^n } =
0\)</span>.对上下分别用<span class="math inline">\(n -
1\)</span>次洛必达法则后,那么只需要证明<span class="math inline">\(\lim_{ x \rightarrow x_0 } \frac{ f^{ ( n - 1 ) }
( x ) - f^{ ( n - 1 ) ( x_0 ) } }{ ( x - x_0 ) } - f^{ ( n ) } ( x_0 ) =
0\)</span>.而这当然就是导数的定义,于是就证毕了.</p>
<h5><span id="拉格朗日余项">拉格朗日余项</span></h5>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( a , b )\)</span>上有<span class="math inline">\(n + 1\)</span>阶导数,并且<span class="math inline">\(f ( x ) \in C^n [ a , b ]\)</span>,泰勒公式有<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n f^{ ( k ) } ( x_0 )
\frac{ ( x - x_0 )^k }{ k ! } + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n +
1 ) ! } ( x - x_0 )^{ n + 1 }\)</span>,其中<span class="math inline">\(\xi \in ( x_0 , x )\)</span>.一般将<span class="math inline">\(\frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! } (
x - x_0 )^{ n + 1 }\)</span>称作<strong>拉格朗日余项</strong>.</p>
<p>证明的话,考虑对于一个固定的<span class="math inline">\(x\)</span>,构造<span class="math inline">\(F ( t )
= f ( x ) - \sum_{ k = 0 }^n f^{ ( k ) } ( t ) \frac{ ( x - t )^k }{ k !
}\)</span>,<span class="math inline">\(G ( t ) = ( x - t )^{ n + 1
}\)</span>.这里之所以固定<span class="math inline">\(x\)</span>而移动<span class="math inline">\(x_0\)</span>的原因是,如果反过来固定则求导就不能实现下面的错项相消.不难发现<span class="math inline">\(F ( x ) = G ( x ) =
0\)</span>,此时考虑必定有一个<span class="math inline">\(\xi \in ( x_0 ,
x )\)</span>满足<span class="math inline">\(\frac{ F &#39; ( \xi ) }{ G
&#39; ( \xi ) } = \frac{ F ( x_0 ) - F ( x ) }{ G ( x_0 ) - G ( x ) } =
\frac{ F ( x_0 ) }{ G ( x_0 ) }\)</span>.</p>
<p>这个时候研究一下他们的导数,注意到<span class="math inline">\(G &#39;
( t ) = - ( n + 1 ) ( x - t )^{ n }\)</span>,<span class="math inline">\(F &#39; ( t ) = - \sum_{ k = 0 }^n f^{ ( k + 1 ) }
( t ) \frac{ ( x - t )^k }{ k ! } + \sum_{ k = 1 }^n f^{ ( k ) } ( t )
\frac{ ( x - t )^{ k - 1 } }{ ( k - 1 ) ! } = - f^{ ( n + 1 ) } ( t )
\frac{ ( x - t )^n }{ n ! }\)</span>.</p>
<p>于是<span class="math inline">\(\frac{ F ( x_0 ) }{ G ( x_0 ) } =
\frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! }\)</span>,<span class="math inline">\(F ( x_0 ) = \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n
+ 1 ) ! } ( x - x_0 )^{ n + 1 }\)</span>.</p>
<p>下面给出一些常见的泰勒展开公式(其中<span class="math inline">\(0 &lt;
\theta &lt; 1\)</span>):</p>
<ol type="1">
<li><p><span class="math inline">\(e^x = \sum_{ k = 0 }^n \frac{ x^k }{
k ! } + \frac{ e^{ \theta x } x^{ n + 1 } }{ ( n + 1 ) ! } = 1 + \frac{
x }{ 1 ! } + \frac{ x^2 }{ 2 ! } + \frac{ x^3 }{ 3 ! } + o ( x^3
)\)</span>.</p></li>
<li><p><span class="math inline">\(\sin x = \sum_{ k = 0 }^{ n } \frac{
( - 1 )^k x^{ 2 k + 1 } }{ ( 2 k + 1 ) ! } + ( - 1 )^{ n + 1 } \frac{
\cos \theta x }{ ( 2 n + 3 ) ! } x^{ 2 n + 3 } = x - \frac{ 1 }{ 3 ! }
x^3 + o ( x^4 )\)</span>.</p></li>
<li><p><span class="math inline">\(\cos x = \sum_{ k = 0 }^n \frac{ ( -
1 )^k x^{ 2 k } }{ ( 2 k ) ! } + ( - 1 )^{ n + 1 } \frac{ \cos \theta x
}{ ( 2 n + 2 ) ! } x^{ 2 n + 2 } = 1 - \frac{ 1 }{ 2 ! } x^2 + \frac{ 1
}{ 4 ! } x^4 + o ( x^5 )\)</span>.</p></li>
<li><p><span class="math inline">\(\tan x = x + \frac{ 1 }{ 3 } x^3 +
\frac{ 2 }{ 15 } x^5 + o ( x^6 )\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 + x ) = \sum_{ k = 1 }^n
\frac{ ( - 1 )^{ k - 1 } x^k }{ k } + ( - 1 )^n \frac{ x^{ n + 1 } }{ (
n + 1 ) ( 1 + \theta x )^{ n + 1 } } = x - \frac{ 1 }{ 2 } x^2 + \frac{
1 }{ 3 } x^3 + o ( x^3 )\)</span>.</p></li>
<li><p><span class="math inline">\(( 1 + x )^\alpha = \sum_{ k = 0 }^n
\frac{ \alpha^{ \underline{ k } } }{ k ! } x^k + \frac{ \alpha^{
\underline{ n + 1 } } }{ ( n + 1 ) ! } ( 1 + \theta x )^{ \alpha - n - 1
} x^{ n + 1 }\)</span>.</p></li>
</ol>
<h4><span id="解析函数">解析函数</span></h4>
<p>不妨设<span class="math inline">\(f_n ( x , x_0 ) = \sum_{ k = 0 }^n
f^{ ( k ) } ( x_0 ) \frac{ ( x - x_0 )^k }{ k ! }\)</span>.我们称<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,若<span class="math inline">\(\exists \delta &gt; 0\)</span>,<span class="math inline">\(\lim_{ n \rightarrow \infty } f_n ( x , x_0 ) = f
( x )\)</span>,也即泰勒展式在一个邻域上可以逼近原函数.</p>
<p>如果其在<span class="math inline">\(( a , b
)\)</span>上任何一点都解析,那么称其在<span class="math inline">\(( a , b
)\)</span>上解析,记作<span class="math inline">\(f \in C^\omega ( a , b
)\)</span>.</p>
<p>解析函数应当有如下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f , g\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f , g\)</span>的四则运算在<span class="math inline">\(x_0\)</span>处也解析.</p></li>
<li><p><span class="math inline">\(f , g\)</span>均解析,并且<span class="math inline">\(f \circ g\)</span>有意义,那么<span class="math inline">\(f \circ g\)</span>也解析.</p></li>
<li><p><span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处解析,那么<span class="math inline">\(f^{ - 1 }\)</span>在<span class="math inline">\(f
( x_0 )\)</span>处解析.</p></li>
<li><p>初等函数基本是解析函数.</p></li>
</ol>
<p>对于(1):</p>
<p><span class="math inline">\(f \pm g\)</span>当然是平凡的,至于<span class="math inline">\(fg\)</span>和<span class="math inline">\(\frac{ f
}{ g }\)</span>如何证明解析性,我们回头再说.</p>
<p>对于(2):</p>
<p>回头再说.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(P_n = \sum_{ i = 0 }^{ n } y_i
( \prod_{ j = 0 \land j \ne i }^{ n } \frac{ x - x_j }{ x_i - x_j } )
\\\)</span>.显然当<span class="math inline">\(x =
x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>用这个在一个<span class="math inline">\(n +
1\)</span>次可导的函数<span class="math inline">\(f \in C ( a , b
)\)</span>上打<span class="math inline">\(n +
1\)</span>个点并且取出这个多项式<span class="math inline">\(P_n\)</span>,考虑它们的误差.取<span class="math inline">\(\omega ( x ) = \prod_{ k = 0 }^n ( x - x_k
)\)</span>,事实上有:<span class="math inline">\(\exists \xi \in ( a , b
) , f ( x ) = P_n ( x ) + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) !
} \omega ( x )\)</span>.</p>
<p>取<span class="math inline">\(h ( t ) = f ( t ) - P_n ( t
)\)</span>,考虑对于一个固定的<span class="math inline">\(x \ne
x_i\)</span>,取<span class="math inline">\(g ( t ) = \frac{ h ( x ) }{
\omega ( x ) } \omega ( t ) - h ( t )\)</span>.注意到<span class="math inline">\(g ( x ) = 0 , g ( x_i ) = 0\)</span>,所以<span class="math inline">\(g\)</span>有<span class="math inline">\(n +
2\)</span>个零点,所以<span class="math inline">\(g^{ ( n + 1 )
}\)</span>一定有一个零点,记为<span class="math inline">\(\xi\)</span>.</p>
<p>那么我们就有<span class="math inline">\(g^{ ( n + 1 ) } ( \xi ) =
\frac{ h ( x ) }{ \omega ( x ) } ( n + 1 ) ! - f^{ ( n + 1 ) } ( \xi ) =
0\)</span>.上述命题就得证了.</p>
<p>那么怎么样能让<span class="math inline">\(\omega ( x
)\)</span>这个东西的最大值尽可能小呢?</p>
<p>我们定义所谓<span class="math inline">\(n\)</span>次切比雪夫多项式<span class="math inline">\(f\)</span>,使得对于任何一个首项为<span class="math inline">\(1\)</span>的多项式<span class="math inline">\(T_n\)</span>,<span class="math inline">\(\max_{ (
a , b ) } | T_n | \geq \max_{ ( a , b ) } | f |\)</span>.</p>
<p>事实上<span class="math inline">\([ - 1 , 1
]\)</span>上的切比雪夫多项式可以用递推关系描述:</p>
<p><span class="math display">\[
P_n = \begin{cases}
1 &amp; n = 0 \\
x &amp; n = 1 \\
x^2 - \frac{ 1 }{ 2 } &amp; n = 2 \\
xP_{ n - 1 } - \frac{ 1 }{ 4 } P_{ n - 2 } &amp; \text{ otherwise }
\end{cases}
\]</span></p>
<p>还可以写成<span class="math inline">\(P_n = \frac{ 1 }{ 2^{ n - 1 } }
\cos ( n \arccos x )\)</span>.</p>
<h4><span id="函数的作图">函数的作图</span></h4>
<h5><span id="渐近线">渐近线</span></h5>
<p>如果对于一个函数<span class="math inline">\(y = f ( x
)\)</span>,存在一条直线<span class="math inline">\(l\)</span>使得函数上一点<span class="math inline">\(P ( x , f ( x ) )\)</span>距离原点距离<span class="math inline">\(\to + \infty\)</span>的时候,<span class="math inline">\(( x , f ( x ) )\)</span>与<span class="math inline">\(l\)</span>的距离<span class="math inline">\(\to
0\)</span>.</p>
<p>大概可以有以下几类渐近线:</p>
<ol type="1">
<li><p>水平渐近线:<span class="math inline">\(f ( + \infty ) =
C\)</span>或<span class="math inline">\(f ( - \infty ) =
C\)</span>.</p></li>
<li><p>垂直渐近线:<span class="math inline">\(f ( x_0 - 0 ) =
\infty\)</span>或<span class="math inline">\(f ( x_0 + 0 ) =
\infty\)</span>.</p></li>
<li><p>斜渐近线:<span class="math inline">\(l = kx +
b\)</span>,那么<span class="math inline">\(\lim_{ x \to + \infty }
\frac{ f ( x ) }{ x } = a , \lim_{ x \to \infty } ( f ( x ) - ax ) =
b\)</span>.</p></li>
</ol>
<h5><span id="作图">作图</span></h5>
<ol type="1">
<li><p>确定定义域和值域.</p></li>
<li><p>研究其奇偶性,周期性.</p></li>
<li><p>研究<span class="math inline">\(f &#39; ( x ) =
0\)</span>的根以确定极值点和升降区间.</p></li>
<li><p>研究<span class="math inline">\(f &#39; &#39; ( x ) =
0\)</span>的根找出拐点.</p></li>
<li><p>求出渐近线.</p></li>
</ol>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>目的是找到一个函数<span class="math inline">\(f\)</span>的零点,尝试取上面任何一点并作切线,找到切线与<span class="math inline">\(x\)</span>轴的交点.或者说任取<span class="math inline">\(x_0\)</span>,取<span class="math inline">\(x_{ n +
1 } = x_n - \frac{ f ( x_n ) }{ f &#39; ( x_n ) }\)</span>.</p>
<p>我们需要证明这个做法的正确性,事实上:</p>
<p>如果<span class="math inline">\(f &#39; , f &#39;
&#39;\)</span>在<span class="math inline">\([ a , b
]\)</span>上非零,<span class="math inline">\(\exists c \in [ a , b ] , f
( c ) = 0\)</span>,那我们取<span class="math inline">\(x_0 \in [ a , b
]\)</span>满足<span class="math inline">\(f ( x_0 ) f &#39; &#39; ( x_0
) &gt; 0\)</span>,那么取<span class="math inline">\(x_{ n + 1 } = x_n -
\frac{ f ( x_n ) }{ f &#39; ( x_n ) }\)</span>的数列<span class="math inline">\(\{ x_n \} \rightarrow c\)</span>.事实上:</p>
<ol type="1">
<li><p>当<span class="math inline">\(f &#39; f &#39; &#39; &gt;
0\)</span>,<span class="math inline">\(x_n\)</span>单调下降趋近于<span class="math inline">\(c\)</span>.</p></li>
<li><p>当<span class="math inline">\(f &#39; f &#39; &#39; &lt;
0\)</span>,<span class="math inline">\(x_n\)</span>单调上升趋近于<span class="math inline">\(c\)</span>.</p></li>
</ol>
<p>并且<span class="math inline">\(| x_n - c | \sim O ( 2^{ - 2^n }
)\)</span>.</p>
<p>上述讨论情况有点多,我们下面只讨论其中一种进行证明:</p>
<p>当<span class="math inline">\(f &#39; &gt; 0 , f &#39; &#39; &gt;
0\)</span>的时候,<span class="math inline">\(f\)</span>是一个单调上升的下凸函数.容易发现这个数列单调下降并且应当大于<span class="math inline">\(c\)</span>,那它就有极限,两边取极限得知<span class="math inline">\(\lim_{ n \to \infty } f ( x_n ) = 0\)</span>.</p>
<p>接下来看一下逼近速度,泰勒公式展开一下知道<span class="math inline">\(0 = f ( c ) = f ( x_n ) + f &#39; ( x_n ) ( c -
x_n ) + \frac{ f &#39; &#39; ( \xi ) }{ 2 } ( c - x_n
)^2\)</span>.从上面的结果容易看出<span class="math inline">\(n \geq
1\)</span>的时候,<span class="math inline">\(| x_{ n + 1 } - c | =
\frac{ | f ( x_n ) + f &#39; ( x_n ) ( c - x_n ) | }{ | f &#39; ( x_n )
| } = \frac{ f &#39; &#39; ( \xi ) }{ 2 | f &#39; ( x_n ) | } ( c - x_n
)^2\)</span>.前面那个系数是有界的,可以看作一个常数.于是这一次的误差应当是上一次误差的平方级别.</p>
<h3><span id="积分">积分</span></h3>
<h4><span id="不定积分">不定积分</span></h4>
<p>如果存在可导函数<span class="math inline">\(F\)</span>满足<span class="math inline">\(F &#39; ( x ) = f ( x )\)</span>,则称一个函数<span class="math inline">\(f\)</span>是<strong>可积</strong>的,<span class="math inline">\(F ( x )\)</span>是<span class="math inline">\(f (
x )\)</span>的<strong>原函数</strong>,或称其为<span class="math inline">\(f ( x )\)</span>的不定积分.</p>
<p>我们之前已经证明过导数相等的两个函数最多只差一个常数,因此一个函数的原函数是有唯一的<span class="math inline">\(F ( x ) + C\)</span>的形式的.</p>
<h5><span id="不定积分的运算">不定积分的运算</span></h5>
<p>只给出以下两个运算法则:</p>
<p><span class="math display">\[
\begin{aligned}
\int ( f ( x ) \pm g ( x ) ) \text{ d } x &amp; = \int f ( x ) \text{ d
} x \pm \int g ( x ) \text{ d } x \\
\int \alpha f ( x ) \text{ d } x &amp; = \alpha \int f ( x ) \text{ d }
x
\end{aligned}
\]</span></p>
<h5><span id="积分表">积分表</span></h5>
<ol type="1">
<li><p><span class="math inline">\(\int x^\alpha \text{ d } x = \frac{
x^{ \alpha + 1 } }{ \alpha + 1 } + C , \alpha \ne - 1\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ x } = \ln
| x | + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int e^x \text{ d } x = e^x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \cos x \text{ d } x = \sin x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sin x \text{ d } x = - \cos x +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \cos^2 x
} = \tan x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sin^2 x
} = - \cot x + C = - \frac{ 1 }{ \tan x } + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ 1 + x^2 }
= \arctan x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{ 1
- x^2 } } = \arcsin x + C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } } = \ln | x + \sqrt{ x^2 \pm a^2 } | +
C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sqrt{ a^2 - x^2 } \text{ d } x
= \frac{ 1 }{ 2 } ( x \sqrt{ a^2 - x^2 } + a^2 \arcsin \frac{ x }{ a } )
+ C\)</span>.</p></li>
<li><p><span class="math inline">\(\int \sqrt{ x^2 \pm a^2 } \text{ d }
x = \frac{ 1 }{ 2 } ( x \sqrt{ x^2 \pm a^2 } \pm a^2 \ln | x + \sqrt{
x^2 \pm a^2 } | ) + C\)</span>.</p></li>
</ol>
<h5><span id="换元法">换元法</span></h5>
<p>第一换元法:设<span class="math inline">\(\int g ( t ) \text{ d } t =
G ( t ) + C\)</span>,<span class="math inline">\(w ( x
)\)</span>可导,则<span class="math inline">\(\int g ( w ( x ) ) w &#39;
( x ) \text{ d } x = G ( w ( x ) ) +
C\)</span>.证明只需对右边求导即可.</p>
<p>第二换元法:设<span class="math inline">\(x ( t
)\)</span>可导,且有反函数<span class="math inline">\(t ( x
)\)</span>,那么如果<span class="math inline">\(\int f ( x ( t ) ) x
&#39; ( t ) \text{ d } t = G ( t ) + C\)</span>,则<span class="math inline">\(\int f \text{ d } x = G ( t ( x ) ) +
C\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n = \int \tan^n x \text{ d }
x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \tan^{ n - 2 } ( \frac{ 1 }{ \cos^2 x } - 1 ) \text{ d
} x \\
&amp; = \int \tan^{ n - 2 } x ( \text{ d } \tan x ) - I_{ n - 2 } \\
&amp; = \frac{ \tan^{ n - 1 } x }{ n - 2 } - I_{ n - 2 }
\end{aligned}
\]</span></p>
<p>边界条件的话<span class="math inline">\(I_0 = x + C , I_1 = \int
\frac{ \sin x }{ \cos x } \text{ d } x = - \int \frac{ 1 }{ \cos x } (
\text{ d } \cos x ) = - \ln ( \cos x ) + C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>我们应当有<span class="math inline">\(( uv ) &#39; = u &#39; v + v
&#39; u\)</span>,两边积分得到<span class="math inline">\(uv = \int u
&#39; v \text{ d } x + \int v &#39; u \text{ d }
x\)</span>,变形得到<span class="math inline">\(\int v \text{ d } u = uv
- \int u \text{ d } v\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I_n = \int \cos^n x \text{ d }
x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \cos^{ n - 1 } x ( \text{ d } \sin x ) \\
&amp; = \cos^{ n - 1 } x \sin x + ( n - 1 ) \int \sin^2 x \cos^{ n - 2 }
x \text{ d } x \\
&amp; = \cos^{ n - 1 } x \sin x + ( n - 1 ) \int ( 1 - \cos^2 x ) \cos^{
n - 2 } x \text{ d } x \\
&amp; = \cos^{ n - 1 } \sin x + ( n - 1 ) I_{ n - 2 } - ( n - 1 ) I_n
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(I_n = \frac{ 1 }{ n } \cos^{ n -
1 } x \sin x + \frac{ n - 1 }{ n } I_{ n - 2 }\)</span>.</p>
<p>边界条件当然是<span class="math inline">\(I_0 = x + C , I_1 = \sin x
+ C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I_n = \int \frac{ \text{ d } x }{
\cos^n x }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \int \frac{ \text{ d } \tan x }{ \cos^{ n - 2 } x } \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } - \int \tan x ( \text{ d }
\cos^{ 2 - n } x ) \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) \int \cos^{ - n
} x \sin^2 x \text{ d } x \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) \int \cos^{ - n
} x ( 1 - \cos^2 x ) \text{ d } x \\
&amp; = \frac{ \tan x }{ \cos^{ n - 2 } x } + ( 2 - n ) I_n - ( 2 - n )
I_{ n - 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(I_n = \frac{ 1 }{ n - 1 } \frac{
\tan x }{ \cos^{ n - 2 } x } + \frac{ n - 2 }{ n - 1 } I_{ n - 2
}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I_{ m , n } = \int \sin^m x \cos ( nx )
\text{ d } x\)</span>,其中<span class="math inline">\(m &lt;
n\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_{ m , n } &amp; = \int \sin^m x \cos ( nx ) \text{ d } x \\
&amp; = \frac{ 1 }{ n } \int \sin^m x \text{ d } \sin ( nx ) \\
&amp; = \frac{ 1 }{ n } \left ( \sin^m x \sin ( nx ) - \frac{ m }{ n }
\int \sin ( nx ) \sin^{ m - 1 } x \cos x \text{ d } x \right )
\end{aligned}
\]</span></p>
<p>然后观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int \sin ( nx ) \sin^{ m - 1 } x \cos x \text{ d } x \\
= &amp; - \frac{ 1 }{ n } \int \sin^{ m - 1 } x \cos x \text{ d } \cos (
nx ) \\
= &amp; - \frac{ 1 }{ n } ( \cos ( nx ) \sin^{ m - 1 } x \cos x - \int
\cos ( nx ) ( \text{ d } \sin^{ m - 1 } x \cos x ) )
\end{aligned}
\]</span></p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int \cos ( nx ) ( \text{ d } \sin^{ m - 1 } x \cos x ) \\
= &amp; \int \cos ( nx ) ( - \sin^{ m } + ( m - 1 ) \sin^{ m - 2 } x
\cos^2 x ) \text{ d } x \\
= &amp; \int \cos ( nx ) ( ( m - 1 ) \sin^{ m - 2 } x - m \sin^m x ) )
\text{ d } x \\
= &amp; ( m - 1 ) I_{ m - 2 , n } - mI_{ m , n }
\end{aligned}
\]</span></p>
<p>往回倒腾倒腾,边界条件是:</p>
<p><span class="math display">\[
\begin{aligned}
I_{ 0 , n } &amp; = \int \cos ( nx ) \text{ d } x = \frac{ \sin ( nx )
}{ n } + C \\
I_{ 1 , n } &amp; = \int \sin x \cos ( nx ) \text{ d } x \\
&amp; = \frac{ 1 }{ 2 } \int ( \sin ( ( n + 1 ) x ) - \sin ( ( n - 1 ) x
) ) \text{ d } x \\
&amp; = \frac{ 1 }{ 2 } ( \frac{ - \cos ( ( n + 1 ) x ) }{ n + 1 } +
\frac{ \cos ( ( n - 1 ) x ) }{ n - 1 } ) + C
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(I_n = \int \frac{ \text{ d } x }{ ( x^2
+ a^2 )^n }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
I_n &amp; = \frac{ x }{ ( x^2 + a^2 )^n } - \int x \text{ d } \frac{ 1
}{ ( x^2 + a^2 )^n } \\
&amp; = \frac{ x }{ ( x^2 + a^2 )^n } + 2 n \int \frac{ x^2 + a^2 - a^2
}{ ( x^2 + a^2 )^{ n + 1 } } \text{ d } x \\
&amp; = \frac{ x }{ ( x^2 + a^2 )^n } + 2 nI_{ n } - 2 a^2 nI_{ n + 1 }
\end{aligned}
\]</span></p>
<p>边界是<span class="math inline">\(I_1 = \frac{ 1 }{ a } \arctan
\frac{ x }{ a } + C\)</span>.</p>
<h6><span id="example5">Example5</span></h6>
<p>求<span class="math inline">\(I = \int x \cos^3 x \text{ d }
x\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
I &amp; = \int x \cos^3 x \text{ d } x = \int x \cos^2 x \text{ d } (
\sin x ) \\
&amp; = x \cos^2 x \sin x - \int \sin x ( \cos^2 x \text{ d } x - 2 x
\cos x \sin x ) \\
&amp; = x \cos^2 x \sin x + \int \cos^2 x ( \text{ d } \cos x ) + 2 \int
x \cos x \sin^2 x \text{ d } x \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x \cos x ( 1
- \cos^2 x ) \text{ d } x \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x \cos x
\text{ d } x - 2 I \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 \int x ( \text{ d
} \sin x ) - 2 I \\
&amp; = x \cos^2 x \sin x + \frac{ \cos^3 x }{ 3 } + 2 ( x \sin x + \cos
x ) - 2 I + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是<span class="math inline">\(3 I = x \cos^2 x \sin x + \frac{
\cos^3 x }{ 3 } + 2 ( x \sin x + \cos x ) + C\)</span>.</p>
<h5><span id="有理分式的不定积分">有理分式的不定积分</span></h5>
<p>考虑真分式<span class="math inline">\(R ( x ) = \frac{ P ( x ) }{ Q (
x ) }\)</span>,其中<span class="math inline">\(\deg P ( x ) &lt; \deg Q
( x )\)</span>.至于其他分式可以做长除法变成真分式.</p>
<p>定义最简真分式形如<span class="math inline">\(\frac{ A }{ ( x - a )^m
} , \frac{ Bx + C }{ ( x^2 + px + q )^n }\)</span>.</p>
<p>先证明一个引理:实数域上,任何一个多项式可以分解为若干不可约的一次多项式和二次多项式的乘积.</p>
<p>原因是复根一定成对出现,如果<span class="math inline">\(z\)</span>是复根,那么<span class="math inline">\(\bar{ z }\)</span>一定也是复根,原因是<span class="math inline">\(\overline{ zw } = \bar{ z } \bar{ w
}\)</span>,对一个多项式两边逐项取共轭就可以发现上述结论.那只需要把成对的复根扔到一个二次多项式里就行.</p>
<p>再证明一个引理:实数上,任何一个真分式都可以转化为若干最简真分式的线性组合.</p>
<p>先拆一次项,如上将<span class="math inline">\(Q ( x ) = ( x - a )^m R
( x )\)</span>,其中<span class="math inline">\(R ( a ) \ne
0\)</span>,那我们考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ P ( x ) }{ Q ( x ) } - \frac{ A_1 }{ ( x - a )^m } &amp; = \frac{
P ( x ) - A_1 R ( x ) }{ ( x - a )^m R ( x ) } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时取<span class="math inline">\(A_1 = \frac{ P ( a ) }{ R ( a )
}\)</span>,立刻见到<span class="math inline">\(( x - a ) | ( P ( x ) -
A_1 R ( x ) )\)</span>,于是上下至少少一次,这样就可以继续分解了.</p>
<p>再拆二次项,如上将<span class="math inline">\(Q ( x ) = ( x^2 + px + q
)^m R ( x )\)</span>,其中<span class="math inline">\(( x^2 + px + q )
\nmid R ( x )\)</span>,那:</p>
<p><span class="math display">\[
\frac{ P ( x ) }{ Q ( x ) } - \frac{ A_1 x + B_1 }{ ( x^2 + px + q )^m }
= \frac{ P ( x ) - ( A_1 x + B_1 ) R ( x ) }{ ( x^2 + px + q )^m R ( x )
}
\]</span></p>
<p>令<span class="math inline">\(T ( x ) = P ( x ) - ( A_1 x + B_1 ) R (
x )\)</span>,类似上面应当要确定<span class="math inline">\(A_1 ,
B_1\)</span>使得上面那部分是<span class="math inline">\(x^2 + px +
q\)</span>的倍数就可以.直接取<span class="math inline">\(x^2 + px +
q\)</span>的某个复根<span class="math inline">\(\alpha\)</span>,则只需<span class="math inline">\(T ( \alpha ) =
0\)</span>即可,这是两个方程(实部虚部),而我们有两个未知数,理应可以解出答案.具体解得过程其实也可以直接把<span class="math inline">\(P ( x )\)</span>和<span class="math inline">\(R (
x )\)</span>直接先用多项式长除法杀一杀然后剩的部分判一下方程.</p>
<p>这样最后就只需要对拆出来的东西逐项积分就行.意味着有理函数的原函数是初等函数.</p>
<h5><span id="有理三角函数的不定积分">有理三角函数的不定积分</span></h5>
<p>即<span class="math inline">\(\sin x , \cos
x\)</span>经过有限步四则运算得到的函数.</p>
<p>我们定义二元有理函数<span class="math inline">\(R ( u , v
)\)</span>,那么有理三角函数实际上是<span class="math inline">\(R ( \cos
x , \sin x )\)</span>.</p>
<p>下面给出以下命题:</p>
<ol type="1">
<li><p>如果其对于<span class="math inline">\(u\)</span>是奇函数,也即<span class="math inline">\(R ( u , v ) = - R ( - u , v )\)</span>,那么<span class="math inline">\(R ( u , v ) = uR_1 ( u^2 , v )\)</span>,其中<span class="math inline">\(R_1\)</span>是另一个二元有理函数.如果对于<span class="math inline">\(v\)</span>是奇函数则同理.</p></li>
<li><p>当<span class="math inline">\(R ( - u , - v ) = R ( u , v
)\)</span>时,那么<span class="math inline">\(R ( u , v ) = R_1 ( \frac{
u }{ v } , v^2 )\)</span>.</p></li>
</ol>
<p>证明只需要拆做<span class="math inline">\(R ( u , v ) = \frac{ P ( u
, v ) }{ Q ( u , v ) }\)</span>,其中<span class="math inline">\(P ,
Q\)</span>是两个多项式,然后只需简单书写即可证明.</p>
<p>对于(1)形式的有理三角函数,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int R ( \cos x , \sin x ) \text{ d } x \\
= &amp; \int \cos xR ( \cos^2 x , \sin x ) \text{ d } x \\
\\
= &amp; \int R_1 ( 1 - \sin^2 x , \sin x ) \text{ d } ( \sin x ) \\
= &amp; \int R_1 ( 1 - t^2 , t ) \text{ d } t
\end{aligned}
\]</span></p>
<p>对于(2)形式的有理三角函数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int R ( \cos x , \sin x ) \text{ d } x \\
= &amp; \int R_1 ( \cos^2 x , \tan x ) \text{ d } x \\
= &amp; \int R_1 ( \frac{ 1 }{ 1 + \tan^2 x } , \tan x ) \text{ d } x \\
= &amp; \int R_1 ( \frac{ 1 }{ 1 + t^2 } , t ) \frac{ \text{ d } t }{ 1
+ t^2 }
\end{aligned}
\]</span></p>
<p>有了这两种形式后呢?我们注意到任意的有理三角函数都可以表示为以上两种函数之和,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; R ( u , v ) \\
= &amp; \frac{ R ( u , v ) - R ( - u , v ) }{ 2 } \\
+ \frac{ R ( - u , v ) - R ( - u , - v ) }{ 2 } \\
+ \frac{ R ( - u , - v ) + R ( u , v ) }{ 2 }
\end{aligned}
\]</span></p>
<p>或者,令<span class="math inline">\(t = \tan \frac{ x }{ 2
}\)</span>,那么<span class="math inline">\(\sin x = \frac{ 2 t }{ 1 +
t^2 } , \cos x = \frac{ 1 - t^2 }{ 1 + t^2 } , \text{ d } x = 2 \frac{
\text{ d } t }{ 1 + t^2 }\)</span>.</p>
<h5><span id="无理函数的不定积分">无理函数的不定积分</span></h5>
<p>我们考虑以下几类无理函数:</p>
<p>第一类是<span class="math inline">\(R ( x , \sqrt[m]{ \frac{ ax + b
}{ cx + d } } )\)</span>的形式.只需做换元<span class="math inline">\(t^m
= \frac{ a_1 x + b_1 }{ a_2 x + b_2 }\)</span>,立刻得到原式其实就是<span class="math inline">\(R ( \frac{ b_2 t^m - b_1 }{ a_1 - a_2 t^m } , t
)\)</span>,并且<span class="math inline">\(\text{ d }
x\)</span>也可以转化到<span class="math inline">\(\text{ d }
t\)</span>.</p>
<p>第二类是形如<span class="math inline">\(\int x^m ( a + bx^n )^p
\text{ d } x\)</span>,其中<span class="math inline">\(m , n , p \in
\mathbb{ Q }\)</span>.</p>
<p>令<span class="math inline">\(t = x^n\)</span>,上式就变成了<span class="math inline">\(\frac{ 1 }{ n } \int t^{ \frac{ m + 1 }{ n } - 1 }
( a + bt )^p \text{ d } t\)</span>.令<span class="math inline">\(q =
\frac{ m + 1 }{ n } - 1\)</span>.我们只需要做<span class="math inline">\(\frac{ 1 }{ n } \int t^q ( a + bt )^p \text{ d } t
= \frac{ 1 }{ n } \int t^{ p + q } ( \frac{ a + bt }{ t }
)^p\)</span>.事实上,下面三种情况可以积出来:</p>
<ol type="1">
<li><p><span class="math inline">\(p \in \mathbb{ Z }\)</span>.</p></li>
<li><p><span class="math inline">\(q \in \mathbb{ Z }\)</span>.</p></li>
<li><p><span class="math inline">\(p + q \in \mathbb{ Z
}\)</span>.</p></li>
</ol>
<p>其它的都无初等形式.</p>
<p>第三类是形如<span class="math inline">\(R ( x , \sqrt{ ax^2 + bx + c
} )\)</span>,不妨假设<span class="math inline">\(b^2 - 4 ac \ne 0 , a
\ne 0\)</span>.</p>
<ol type="1">
<li><p><span class="math inline">\(b^2 - 4 ac &gt;
0\)</span>,则有两个实根<span class="math inline">\(\alpha &gt;
\beta\)</span>,此时提一下实根就可以知道原式等于<span class="math inline">\(R ( x , ( x - \beta ) \sqrt{ \frac{ a ( x - \alpha
) }{ x - \beta } } )\)</span>,这就能做了.</p></li>
<li><p><span class="math inline">\(b^2 - 4 ac &lt;
0\)</span>,则无实根,不妨假设<span class="math inline">\(a &gt;
0\)</span>.则做<span class="math inline">\(t - \sqrt{ a } x = \sqrt{
ax^2 + bx + c }\)</span>并两边平方就可以反解出<span class="math inline">\(x = \frac{ t^2 - c }{ b + 2 \sqrt{ a } t
}\)</span>,原本的积分就变成了关于<span class="math inline">\(t\)</span>的有理函数的积分.</p></li>
</ol>
<h5><span id="双曲换元">双曲换元</span></h5>
<p>引入双曲三角函数<span class="math inline">\(\sinh ( x ) = \frac{ e^x
- e^{ - x } }{ 2 } , \cosh = \frac{ e^x + e^{ - x } }{ 2
}\)</span>以及<span class="math inline">\(\tanh ( x ) = \frac{ \sinh ( x
) }{ \cosh ( x ) }\)</span>.留意到<span class="math inline">\(\cosh^2 -
\sinh^2 = 1\)</span>.以及:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\sinh ( x ) = \cosh ( x )\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\cosh ( x ) = \sinh ( x )\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\tanh ( x ) = \frac{ 1 }{ \cosh^2 ( x ) } = 1 - \tanh^2 ( x
)\)</span></p></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><p><span class="math inline">\(\sinh ( 2 x ) = 2 \sinh ( x ) \cosh (
x )\)</span></p></li>
<li><p><span class="math inline">\(\cosh ( 2 x ) = \cosh^2 ( x ) +
\sinh^2 ( x ) = 2 \cosh^2 ( x ) - 1 = 1 + 2 \sinh^2 ( x
)\)</span></p></li>
</ol>
<p>另外其反函数应当是:</p>
<ol type="1">
<li><p><span class="math inline">\(\text{ arsinh } ( x ) = \ln ( x +
\sqrt{ x^2 + 1 } )\)</span></p></li>
<li><p><span class="math inline">\(\text{ arcosh } ( x ) = \ln ( x +
\sqrt{ x^2 - 1 } )\)</span></p></li>
</ol>
<p>应当发现:</p>
<ol type="1">
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ arsinh } ( x ) = \frac{ 1 }{ \sqrt{ x^2 + 1 } }\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ arcosh } ( x ) = \frac{ 1 }{ \sqrt{ x^2 - 1 } }\)</span></p></li>
<li><p><span class="math inline">\(\frac{ \text{ d } }{ \text{ d } x }
\text{ artanh } ( x ) = \frac{ 1 }{ 1 - x^2 }\)</span></p></li>
</ol>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(I = \int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } }\)</span>,其中<span class="math inline">\(a &gt;
0\)</span>.</p>
<p>于是<span class="math inline">\(\int \frac{ \text{ d } x }{ \sqrt{
x^2 \pm a^2 } } = \ln | x + \sqrt{ x^2 \pm a^2 } | + C\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int \sqrt{ a^2 - x^2 } \text{ d }
x\)</span>.</p>
<p>考虑三角换元,应当小心符号,这里注意到<span class="math inline">\(x \in
[ - a , a ]\)</span>,因此直接取<span class="math inline">\(x = a \sin
t\)</span>,<span class="math inline">\(t \in [ - \frac{ \pi }{ 2 } ,
\frac{ \pi }{ 2 } ]\)</span>,此时<span class="math inline">\(\cos t \geq
0\)</span>恒成立,则有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = a^2 \int \cos^2 t \text{ d } t \\
&amp; = a^2 \int \frac{ 1 + \cos ( 2 t ) }{ 2 } \text{ d } t \\
&amp; = \frac{ a^2 t }{ 2 } + \frac{ a^2 }{ 4 } \sin ( 2 t ) + C \\
&amp; = \frac{ 1 }{ 2 } ( x \sqrt{ a^2 - x^2 } + a^2 \arcsin \frac{ x }{
a } ) + C
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(I = \int \sqrt{ x^2 \pm a^2 } \text{ d
} x\)</span>.</p>
<p>使用双曲换元,先考虑<span class="math inline">\(\int \sqrt{ x^2 + a^2
} \text{ d } x\)</span>的情况,此时换<span class="math inline">\(x = a
\sinh t\)</span>,<span class="math inline">\(\cosh t \geq
0\)</span>,根号是平凡开出的,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = a^2 \int \cosh^2 t \text{ d } t \\
&amp; = a^2 \int \frac{ 1 + \cosh ( 2 t ) }{ 2 } \text{ d } t \\
&amp; = \frac{ a^2 t }{ 2 } + \frac{ a^2 }{ 4 } \sinh ( 2 t ) + C \\
&amp; = \frac{ 1 }{ 2 } ( x \sqrt{ x^2 + a^2 } + a^2 \text{ arsinh }
\frac{ x }{ a } ) + C
\end{aligned}
\]</span></p>
<p>另一个同理,仍然使用双曲换元,结果是<span class="math inline">\(\frac{
1 }{ 2 } ( x \sqrt{ x^2 - a^2 } + a^2 \text{ arcosh } \frac{ x }{ a } )
+ C\)</span></p>
<h5><span id="椭圆积分">椭圆积分</span></h5>
<p>以下是几个常见的无初等形式的积分:</p>
<ol type="1">
<li><p><span class="math inline">\(\int \frac{ e^x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } x }{ \ln x
}\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \sin x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \cos x }{ x } \text{ d }
x\)</span>.</p></li>
<li><p><span class="math inline">\(\int e^{ x^2 } \text{ d }
x\)</span>.</p></li>
</ol>
<p>另外还有一类椭圆积分也无初等形式:设<span class="math inline">\(R ( x
, y )\)</span>是二元有理函数,其中<span class="math inline">\(y = \sqrt{
P_3 ( x ) }\)</span>或<span class="math inline">\(\sqrt{ P_4 ( x )
}\)</span>,也即根号下放了个三次或者四次多项式,那么<span class="math inline">\(\int R ( x , y ) \text{ d }
x\)</span>可能很难有初等形式.这样的积分可以被归结为三类椭圆积分.</p>
<p>首先说明<span class="math inline">\(R ( x , \sqrt{ P_3 ( x ) }
)\)</span>可以转化,原因是<span class="math inline">\(P_3 ( x ) =
0\)</span>一定有至少一个实数解,任意取出一个设为<span class="math inline">\(\lambda\)</span>,则<span class="math inline">\(P_3
( x ) = ( x - \lambda ) P_2 ( x )\)</span>,令<span class="math inline">\(t^2 + \lambda = x\)</span>,带入可以转化为<span class="math inline">\(R ( t^2 + \lambda , \sqrt{ P_2 ( t^2 + \lambda ) }
) = R_1 ( t , \sqrt{ P_4 ( t ) }
)\)</span>.这就意味着其实根号下四次多项式是更本质一些的.</p>
<p>而四次多项式可以分解为<span class="math inline">\(P_4 ( x ) = a ( x^2
+ p_1 x + q_1 ) ( x^2 + p_2 x + q_2
)\)</span>.不妨假设其无重根(如果有重根的话,那么根号下就可以开出去一部分,那就可积了),设其四个根(可能有复根)分别为<span class="math inline">\(\alpha_1 , \beta_1 , \alpha_2 ,
\beta_2\)</span>,并且<span class="math inline">\(\alpha_1 ,
\beta_1\)</span>是上述分解中前半部分的根,特别地,如果这是四个实根,则不妨调整它们的顺序使得<span class="math inline">\(\alpha_1 &gt; \beta_1 &gt; \alpha_2 &gt;
\beta_2\)</span>.那么根据韦达定理总有:<span class="math inline">\(p_1 =
- ( \alpha_1 + \beta_1 ) , q_1 = \alpha_1
\beta_1\)</span>,后半部分同理.</p>
<p>我们尝试把这两个式子的一次项都去掉,当<span class="math inline">\(p_1
= p_2\)</span>的时候可以直接一起配方令<span class="math inline">\(x = t
- \frac{ p }{ 2 }\)</span>.当<span class="math inline">\(p_1 \ne
p_2\)</span>的时候,尝试换元用<span class="math inline">\(t\)</span>代替<span class="math inline">\(x\)</span>,不妨设<span class="math inline">\(x =
\frac{ u t + v }{ 1 + t }\)</span>,那么<span class="math inline">\(( x^2
+ p_1 x + q_1 ) = \frac{ P_2 &#39; ( t ) }{ ( 1 + t )^2
}\)</span>.为了让其没有一次项应当解以下方程:</p>
<p><span class="math display">\[
\begin{cases}
2 u v + p_1 ( u + v ) + 2 q_1 = 0 \\
2 u v + p_2 ( u + v ) + 2 q_2 = 0
\end{cases}
\]</span></p>
<p>此时可以解出来<span class="math inline">\(\begin{cases}u + v = -
\frac{ 2 ( q_1 - q_2 ) }{ p_1 - p_2 } \\ u v = \frac{ p_2 q_1 - p_1 q_2
}{ p_1 - p_2 }\end{cases}\)</span>,为了解出<span class="math inline">\(u
, v\)</span>是两个实数,应当检验<span class="math inline">\(( u + v )^2 -
4 uv \geq 0\)</span>是否成立.带入韦达定理发现左边等于<span class="math inline">\(( \alpha_1 - \alpha_2 ) ( \alpha_1 - \beta_2 ) (
\beta_1 - \alpha_2 ) ( \beta_1 - \beta_2 ) &gt;
0\)</span>.原因是如果是四个实根,则根据假设立刻得到.如果存在复根则配对一下复根也可以立刻得到.</p>
<p>总之,在上面的一系列操作后,我们要研究的形式统一成了<span class="math inline">\(R ( t , y = \sqrt{ A ( 1 + m_1 t^2 ) ( 1 + m_2 t^2
) } ) = \frac{ a ( t ) + b ( t ) y }{ c ( t ) + d ( t ) y } = B_1 ( t )
+ B_2 ( t ) y\)</span>,其中<span class="math inline">\(B_1 ( t ) , B_2 (
t )\)</span>都是<span class="math inline">\(t\)</span>的有理函数.前者可以直接积分拆出去,那我们关心的就只剩下后面的<span class="math inline">\(B_2 ( t ) y = \frac{ B_2 ( t ) y }{ y
}\)</span>的部分.</p>
<p>我们之前已经提过可以将一个函数拆为偶函数和奇函数之和,事实上:</p>
<p><span class="math display">\[
R ( t ) = \frac{ R ( t ) + R ( - t ) }{ 2 } + \frac{ R ( t ) - R ( - t )
}{ 2 } = R_1 ( t^2 ) + tR_2 ( t^2 )
\]</span></p>
<p>那么后者立刻可以换元积分,只剩下前者做不动.剩下的形式是:<span class="math inline">\(\int \frac{ R ( t^2 ) }{ \sqrt{ A ( 1 + m_1 t^2 )
( 1 + m_2 t^2 ) } } \text{ d } t\)</span>,其中<span class="math inline">\(A\)</span>可以先扔出去一些,使得<span class="math inline">\(A = \pm
1\)</span>.而且由于被积函数是偶函数,所以还可以不妨设<span class="math inline">\(t \geq
0\)</span>.由于根号下不能变成二次函数(不然就直接做完了),还不妨设<span class="math inline">\(m_1 \ne m_2 , m_1 \ne 0 , m_2 \ne
0\)</span>.下面开始讨论:</p>
<ol type="1">
<li><span class="math inline">\(A = 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = - h_2^2 , h_1 &gt; h_2 &gt;
0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t = \frac{ z }{ h_1
}\)</span>带入化简变形再扔出去点常数得到原式变化为<span class="math inline">\(\int \frac{ R ( z^2 ) }{ \sqrt{ ( 1 - z^2 ) ( 1 -
k^2 z^2 ) } } \text{ d } z\)</span>,其中<span class="math inline">\(k =
\frac{ h_2 }{ h_1 }\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(A = 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = h_2^2 , h_1 &gt; 0 , h_2
&gt; 0\)</span>.</li>
</ol>
<p>此时令<span class="math inline">\(t = \frac{ \sqrt{ 1 - z^2 } }{ h_1
}\)</span>.扔出去一些常数仍然可以化简成(1)的形式,只是<span class="math inline">\(k = \frac{ h_2 }{ \sqrt{ h_1^2 + h_2^2 }
}\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(A = 1 , m_1 = h_1^2 , m_2 = h_2^2 , h_1
&gt; h_2 &gt; 0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ z }{ h_1 \sqrt{ 1 - z^2 }
}\)</span>.扔出去一些常数仍然是(1)的形式,只是<span class="math inline">\(k = \frac{ \sqrt{ h_1^2 - h_2^2 } }{ h_1
}\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(A = - 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = h_2^2 , h_1 &gt; 0 , h_2
&gt; 0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ 1 }{ h_1 \sqrt{ 1 - z^2 }
}\)</span>,还是(1)的形式,只是<span class="math inline">\(k = \frac{ h_1
}{ \sqrt{ h_1^2 + h_2^2 } }\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(A = - 1\)</span>,<span class="math inline">\(m_1 = - h_1^2 , m_2 = - h_2^2 , h_1 &gt; h_2 &gt;
0\)</span>.</li>
</ol>
<p>令<span class="math inline">\(t = \frac{ \sqrt{ 1 - \frac{ h_1^2 -
h^2_2 }{ h_1^2 } z^2 } }{ h_2 }\)</span>,还是(1),只是<span class="math inline">\(k = \frac{ \sqrt{ h_1^2 - h_2^2 } }{ h_1
}\)</span>.</p>
<p>这样就全都转化为了<span class="math inline">\(\int \frac{ R ( z^2 )
}{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } } \text{ d }
z\)</span>的形式了.然后把<span class="math inline">\(R ( z^2
)\)</span>给拆开,那么这个式子就应该是<span class="math inline">\(I_n =
\int \frac{ z^{ 2 n } }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } } \text{ d
} z\)</span>和<span class="math inline">\(H_m = \int \frac{ \text{ d } z
}{ ( z^2 - a )^m \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
}\)</span>的线性组合,注意这里系数有可能是复数.</p>
<p>此时注意到</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( z^{ 2 n - 3 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } ) &#39; \\
= &amp; ( 2 n - 3 ) z^{ 2 n - 4 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } +
z^{ 2 n - 3 } \frac{ 2 k^2 z^3 - ( k^2 + 1 ) z }{ \sqrt{ ( 1 - z^2 ) ( 1
- k^2 z^2 ) } } \\
= &amp; \frac{ ( 2 n - 3 ) z^{ 2 n - 4 }{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
+ z^{ 2 n - 3 } ( 2 k^2 z^3 - ( k^2 + 1 ) z ) }{ \sqrt{ ( 1 - z^2 ) ( 1
- k^2 z^2 ) } } \\
= &amp; \frac{ ( 2 n - 1 ) k^2 z^{ 2 n } - ( 2 n - 2 ) ( k^2 + 1 ) z^{ 2
n - 2 } + ( 2 n - 3 ) z^{ 2 n - 4 } }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2
) } }
\end{aligned}
\]</span></p>
<p>两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( 2 n - 1 ) k^2 I_n - ( 2 n - 2 ) ( k^2 + 1 ) I_{ n - 1 } + ( 2 n
- 3 ) I_{ n - 2 } \\
= &amp; z^{ 2 n - 3 } \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) }
\end{aligned}
\]</span></p>
<p>上述只要<span class="math inline">\(n\)</span>是整数就行,甚至不需要<span class="math inline">\(n\)</span>是正的.所以所有的<span class="math inline">\(I_n\)</span>,包括负整数<span class="math inline">\(n\)</span>,都可以被<span class="math inline">\(I_0
, I_1\)</span>表示.</p>
<p>接下来看<span class="math inline">\(H_m\)</span>,当<span class="math inline">\(a = 0\)</span>的时候无非是<span class="math inline">\(H_m = I_{ - m }\)</span>,</p>
<p>接下来注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; ( \frac{ z }{ ( z^2 - a )^{ m - 1 } } \sqrt{ ( 1 - z^2 ) ( 1 - k^2
z^2 ) } ) &#39; \\
= &amp; \frac{ ( 2 - 2 m ) z^2 + z^2 - a }{ ( z^2 - a )^m } \sqrt{ ( 1 -
z^2 ) ( 1 - k^2 z^2 ) } \\
+ \frac{ 2 k^2 z^4 - ( k^2 + 1 ) z^2 }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2
) } } \frac{ 1 }{ ( z^2 - a )^{ m - 1 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(C = \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 )
}\)</span>,<span class="math inline">\(W = z^2 - a\)</span>,那么<span class="math inline">\(C^2 = k^2 ( W + a )^2 - ( k^2 + 1 ) ( W + a ) +
1\)</span>.上式化简为:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; = \frac{ ( 2 - 2 m ) ( W + a ) C^2 }{ W^m C } + \frac{ C^2 + 2 k^2
( W + a )^2 - ( k^2 + 1 ) ( W + a ) }{ W^{ m - 1 } C } \\
&amp; = \frac{ ( 2 - 2 m ) ( W + a ) ( k^2 ( W + a )^2 - ( k^2 + 1 ) ( W
+ a ) + 1 ) }{ W^m C } \\
+ \frac{ 3 k^2 ( W + a )^2 - 2 ( k^2 + 1 ) ( W + a ) + 1 }{ W^{ m - 1 }
C }
\end{aligned}
\]</span></p>
<p>接下来是繁复的化简,然后两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ z }{ ( z^2 - a )^{ m - 1 } } \sqrt{ ( 1 - z^2 ) ( 1 - k^2
z^2 ) } \\
= &amp; ( 2 m - 2 ) ( - a + ( k^2 + 1 ) a^2 - k^2 a^3 ) H_m \\
- ( 2 m - 3 ) ( 1 - 2 a ( k^2 + 1 ) + 3 k^2 a^2 ) H_{ m - 1 } \\
+ ( 2 m - 4 ) ( k^2 + 1 - 3 k^2 a ) H_{ m - 2 } \\
- ( 2 m - 5 ) k^2 H_{ m - 3 }
\end{aligned}
\]</span></p>
<p>而注意到<span class="math inline">\(H_0 = I_0 , H_{ - 1 } = I_1 -
aI_0\)</span>.</p>
<p>综上,所有的椭圆积分都可以由<span class="math inline">\(I_0 , I_1 ,
H_1\)</span>表示.也就是椭圆积分可以转化为以下三种积分:</p>
<ol type="1">
<li><p><span class="math inline">\(\int \frac{ \text{ d } z }{ \sqrt{ (
1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ z^2 \text{ d } z }{
\sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>.</p></li>
<li><p><span class="math inline">\(\int \frac{ \text{ d } z }{ ( 1 +
hz^2 ) \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</p></li>
</ol>
<p>有意思的是如果令<span class="math inline">\(z = \sin
\varphi\)</span>,<span class="math inline">\(\text{ d } z = \sqrt{ 1 -
z^2 } \text{ d }
\varphi\)</span>,这样形式就好看了很多.椭圆积分可以用以下的优美形式表示:</p>
<ol type="1">
<li><p><span class="math inline">\(E ( k , \varphi ) = \int \frac{
\text{ d } \varphi }{ \sqrt{ 1 - k^2 \sin^2 \varphi }
}\)</span>.</p></li>
<li><p><span class="math inline">\(F ( k , \varphi ) = \int \sqrt{ 1 -
k^2 \sin^2 \varphi } \ \text{ d } \varphi\)</span>.</p></li>
<li><p><span class="math inline">\(\Pi ( h , k , \varphi ) = \int \frac{
\text{ d } \varphi }{ ( 1 + h \sin^2 \varphi ) \sqrt{ 1 - k^2 \sin^2
\varphi } }\)</span>,其中<span class="math inline">\(h\)</span>可以是复数.</p></li>
</ol>
<p>其中:</p>
<p><span class="math display">\[
\begin{aligned}
\int \frac{ z^2 \text{ d } z }{ \sqrt{ ( 1 - z^2 ) ( 1 - k^2 z^2 ) } }
&amp; = \int \frac{ \sin^2 \varphi \text{ d } \varphi }{ \sqrt{ 1 - k^2
\sin^2 \varphi } } \\
&amp; = \int ( \frac{ 1 }{ k^2 \sqrt{ 1 - k^2 \sin^2 \varphi } } \text{
) } - \frac{ 1 - k^2 \sin^2 \varphi }{ k^2 \sqrt{ 1 - k^2 \sin^2 \varphi
} } \text{ ) } d \varphi \\
&amp; = \frac{ E ( k , \varphi ) }{ k^2 } - \frac{ F ( k , \varphi ) }{
k^2 }
\end{aligned}
\]</span></p>
<h4><span id="黎曼积分">黎曼积分</span></h4>
<p>设<span class="math inline">\(f ( x )\)</span>是定义在<span class="math inline">\([ a , b ]\)</span>上的函数,对于区间<span class="math inline">\([ a , b ]\)</span>插入分点<span class="math inline">\(x_i ( i = 0 , 1 , \cdots , n )\)</span>,且有<span class="math inline">\(a = x_0 &lt; x_1 &lt; \cdots &lt; x_n =
b\)</span>,我们称之为对区间<span class="math inline">\([ a , b
]\)</span>的一种<strong>分割</strong>,并记为<span class="math inline">\(\Delta\)</span>.又记<span class="math inline">\(\Delta x_i = x_i - x_{ i - 1 } , i \in [ 1 , n
]\)</span>,<span class="math inline">\(\lambda ( \Delta ) = \max \{
\Delta x_i \mid i \in [ 1 , n ] \}\)</span>,并定义黎曼和<span class="math inline">\(S_\Delta = \sum_{ i = 1 }^n f ( \xi_i ) \Delta
x_i\)</span>.</p>
<p>若存在实数<span class="math inline">\(J\)</span>,对<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,对于任意分划,只要<span class="math inline">\(\lambda ( \Delta
) &lt; \delta\)</span>,都有<span class="math inline">\(| S_\Delta - J |
&lt; \epsilon \\\)</span>,则称<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ a , b
]\)</span>上<strong>黎曼可积</strong>,这个<span class="math inline">\(J\)</span>为<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ a , b
]\)</span>上的<strong>定积分</strong>,记作<span class="math inline">\(\int_{ a }^b f ( x ) \text{ d } x
\\\)</span>.容易见到定积分唯一,证明无非也是拿<span class="math inline">\(\epsilon\)</span>去卡.</p>
<p>对于<span class="math inline">\([ a , b
]\)</span>上的连续函数,定积分实际上就是其与<span class="math inline">\(f
( x )\)</span>围成面积的代数和.</p>
<p>由此可以顺便定义<strong>达布上下和</strong>,即令<span class="math inline">\(m_i = \inf_{ [ x_{ i - 1 } , x_i ] } f ( x ) , M_i
= \sup_{ [ x_{ i - 1 } , x_i ] } f ( x
)\)</span>,并定义<strong>振幅</strong><span class="math inline">\(w_i =
M_i - m_i\)</span>,特别地定义<span class="math inline">\(M = \sup ( M_i
) , m = \inf ( m_i )\)</span>.定义<span class="math inline">\(\overline{
S }_\Delta = \sum M_i \Delta x_i , \underline{ S }_{ \Delta } = \sum m_i
\Delta x_i\)</span>.</p>
<p>并在此基础上定义上下积分,上积分<span class="math inline">\(\overline{
\int_a^b } f ( x ) \text{ d } x = \inf \overline{ S }_\Delta ,
\underline{ \int_a^b } f ( x ) \text{ d } x = \sup \underline{ S
}_\Delta\)</span>.上下积分显然都是存在的,我们会在后面证明黎曼可积等价于上下积分相等.</p>
<p>为了方便,我们约定:</p>
<ol type="1">
<li><p><span class="math inline">\(a = b\)</span>,<span class="math inline">\(\int_a^b f ( x ) \text{ d } x =
0\)</span>.</p></li>
<li><p><span class="math inline">\(a &gt; b\)</span>,<span class="math inline">\(\int_a^b f ( x ) \text{ d } x = - \int_b^a f ( x )
\text{ d } x\)</span>.</p></li>
</ol>
<p>下列性质应当是成立的:</p>
<ol type="1">
<li><p>(必要条件)如果一个函数黎曼可积,则它在该闭区间上有界.</p></li>
<li><p>对于任意分划任取<span class="math inline">\(\xi\)</span>,都有<span class="math inline">\(\underline{ S }_\Delta \leq S_\Delta ( \xi ) \leq
\overline{ S }_\Delta\)</span>.</p></li>
<li><p><span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \xi_1 ,
\xi_2\)</span>,使得<span class="math inline">\(\underline{ S }_\Delta -
\epsilon \leq S_\Delta ( \xi_1 )\)</span>,<span class="math inline">\(\overline{ S }_\Delta + \epsilon \geq S_\Delta (
\xi_2 )\)</span>.</p></li>
</ol>
<p>再定义所谓加细:如果<span class="math inline">\(\Delta_1 \subseteq
\Delta_2\)</span>,那么称<span class="math inline">\(\Delta_2\)</span>是<span class="math inline">\(\Delta_1\)</span>的加细.此时应当有<span class="math inline">\(\overline{ S }_{ \Delta_1 } \geq \overline{ S }_{
\Delta_2 } , \underline{ S }_{ \Delta_1 } \leq \underline{ S }_{
\Delta_2 }\)</span>.另外容易注意到如果<span class="math inline">\(|
\Delta_2 \setminus \Delta_1 | = k\)</span>,那么<span class="math inline">\(0 \leq \overline{ S }_{ \Delta_1 } - \overline{ S
}_{ \Delta_2 } \leq k \lambda ( \Delta_1 ) ( M - m
)\)</span>,原因是考虑把这些新的断点一个一个加上去,每次加一个会新断开原本的断点,此时最多造成<span class="math inline">\(( M - m ) \Delta x \leq ( M - m ) \lambda (
\Delta_1 )\)</span>的差.注意到此时这些东西似乎全都可以被限制住.</p>
<p>这同样给出了原因:为什么我们会定义上下积分呢?因为随着分点的加多,也就是随着划分的加细,达布上下和会分别单调递减或递增,这样就应当存在一个极限,然而问题在于我们难以在划分上定义序,这样就少了某种极限的方式.然而,我们试图绕开来找到一种确定的能探到极限的方式.</p>
<p>另外的结论是对于任意两个分划<span class="math inline">\(\Delta_1 ,
\Delta_2\)</span>,总有<span class="math inline">\(\underline{ S }_{
\Delta_1 } \leq \overline{ S }_{ \Delta_2 }\)</span>.原因是<span class="math inline">\(\Delta = \Delta_1 \cup
\Delta_2\)</span>,立刻见到<span class="math inline">\(\underline{ S }_{
\Delta_1 } \leq \underline{ S }_{ \Delta } \leq \overline{ S }_\Delta
\leq \overline{ S }_{ \Delta_2 }\)</span>.这意味着<span class="math inline">\(\overline{ \int } f \geq \underline{ \int }
f\)</span>.</p>
<p>接下来证明定积分中的<strong>达布定理</strong>,也就是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,<span class="math inline">\(\forall \Delta , \lambda ( \Delta
) &lt; \delta\)</span>的时候,<span class="math inline">\(0 \leq
\overline{ S }_\Delta - \overline{ \int_a^b } f ( x ) \text{ d } x \leq
\epsilon\)</span>.换言之<span class="math inline">\(\lim_{ \lambda (
\Delta ) \to 0 } \overline{ S }_{ \Delta } = \overline{ \int_a^b } f ( x
) \text{ d } x\)</span>,当然下积分也是同理的.</p>
<p>这个的证明考虑先用上积分的定义,应当存在一个<span class="math inline">\(\Delta &#39;\)</span>,满足<span class="math inline">\(0 \leq \overline{ S }_{ \Delta &#39; } -
\overline{ \int_a^b } f ( x ) \text{ d } x \leq \frac{ \epsilon }{ 2
}\)</span>.不妨设<span class="math inline">\(| \Delta &#39; | =
n_0\)</span>,接下来取<span class="math inline">\(\delta &lt; \frac{
\epsilon }{ 2 n_0 ( M - m ) }\)</span>,那么接下来对于<span class="math inline">\(\forall \Delta , \lambda ( \Delta ) &lt;
\delta\)</span>的时候,取<span class="math inline">\(\Delta^* = \Delta
&#39; \cup \Delta\)</span>,根据上面我们证明的步骤,这里最多会多<span class="math inline">\(n_0\)</span>个断点,自然得知<span class="math inline">\(\overline{ S }_{ \Delta } - \overline{ S }_{
\Delta^* } \leq n_0 \lambda ( \Delta ) ( M - m ) &lt; \frac{ \epsilon }{
2 }\)</span>.</p>
<p>这样的话就可以注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \overline{ S }_\Delta - \overline{ \int_a^b } f ( x ) \text{ d } x
\\
= &amp; ( \overline{ S }_{ \Delta &#39; } - \overline{ \int_a^b } f ( x
) \text{ d } x ) - ( \overline{ S }_{ \Delta &#39; } - \overline{ S }_{
\Delta } ) \\
&lt; &amp; \frac{ \epsilon }{ 2 } - ( \overline{ S }_{ \Delta^* } -
\overline{ S }_\Delta ) &lt; \epsilon
\end{aligned}
\]</span></p>
<p>这里可以证明原函数可积的充分必要条件是上下积分相等.</p>
<p>首先证明充分性:当上下积分相等的时候,设其为<span class="math inline">\(J\)</span>,取足够小的<span class="math inline">\(\epsilon\)</span>,由上知道<span class="math inline">\(\exists \delta &gt; 0\)</span>,使得<span class="math inline">\(J - \epsilon &lt; \underline{ S }_\Delta \leq
S_\Delta ( \xi ) \leq \overline{ S }_\Delta &lt; J +
\epsilon\)</span>,夹逼一下立刻知道其满足.</p>
<p>然后证明必要性:当原函数可积分的时候,只要分点足够密,应当有<span class="math inline">\(J - \epsilon &lt; \underline{ S }_\Delta \leq
\underline{ \int } f ( x ) \text{ d } x \leq \overline{ \int } f ( x )
\text{ d } x \leq \overline{ S }_\Delta &lt; J + \epsilon\)</span>.</p>
<p>而由于我们可以见到上和与下和应当是错开来的,而如果它们中间能接上自然意味着上下积分相等.因此推论为:如果<span class="math inline">\(f\)</span>在闭区间上有界并且<span class="math inline">\(\forall \epsilon , \exists
\Delta\)</span>使得<span class="math inline">\(0 \leq \overline{ S
}_\Delta - \underline{ S }_\Delta \leq \epsilon\)</span>,则<span class="math inline">\(f\)</span>可积.我们最初拿到的那个定义也可以这么改:只需要存在一个分划而不需要使得任意分划都这么满足.方式就是用我们已经找到的这个去并我们想要限制的那个,然后把限制延后一点使得这些全被限制住.</p>
<p>由上述可以证明闭区间上的连续函数一定是闭区间上的可积函数.原因是闭区间上的连续函数一定是一致连续函数,那么对于一个<span class="math inline">\(\epsilon\)</span>,可以找到一个<span class="math inline">\(\delta\)</span>控制住区间长度,使得极差<span class="math inline">\(&lt; \epsilon\)</span>.此时直接找一个<span class="math inline">\(\Delta\)</span>,注意到<span class="math inline">\(\overline{ S } - \underline{ S } = \sum ( M_i -
m_i ) \Delta x_i \leq \sum \epsilon \Delta x \leq ( b - a )
\epsilon\)</span>,只需取<span class="math inline">\(\epsilon \to
0\)</span>就可以搞定.</p>
<p>还可以证明如果<span class="math inline">\(f\)</span>在闭区间上有界并且只有有限个间断点,那么<span class="math inline">\(f\)</span>可积.原因也很简单,只需要拿足够小的区间把这有限个间断点盖住,然后外面继续如上操作,间断点处尽可能缩小区间长度来取出其影响.</p>
<p>还可以证明单调函数一定可积,原因是<span class="math inline">\(\overline{ S } - \underline{ S } \leq \delta ( f (
b ) - f ( a ) ) \to 0\)</span>.</p>
<h5><span id="可积性与连续性的关系勒贝格定理">可积性与连续性的关系(勒贝格定理)</span></h5>
<p>我们还可以进一步探索黎曼可积和连续性的关系,例如,我们可以证明:<span class="math inline">\(\forall f \in R [ a , b ] , \forall \epsilon &gt;
0 , \exists g \in C [ a , b ] \int_a^b | f ( x ) - g ( x ) | \text{ d }
x &lt; \epsilon\)</span>.</p>
<p>如何证明呢?感觉上只需要用分段线性函数去逼近一下就可以了对吧.所以我们考虑对于划分<span class="math inline">\(\Delta\)</span>,直接把所有的<span class="math inline">\(( x_i , f ( x_i )
)\)</span>连起来形成一个分段线性函数.然后观察此时的<span class="math inline">\(| f - g |\)</span>,不妨分段考虑,对于<span class="math inline">\(\int_{ x_{ i - 1 } }^{ x_i } ( f - g ) ( x )
\text{ d } x \leq ( M_i - m_i ) \Delta
x_i\)</span>,而后者求和之后实际上就是<span class="math inline">\(\overline{ S } - \underline{ S }\)</span>,当<span class="math inline">\(f\)</span>可积的时候这个当然会趋近于<span class="math inline">\(0\)</span>.</p>
<p>我们还可以证明<span class="math inline">\(f \in R [ a , b
]\)</span>的连续点在<span class="math inline">\([ a , b
]\)</span>上稠密,只需要证明<span class="math inline">\(\forall [ \alpha
, \beta ] \in R [ a , b ] , \alpha &lt; \beta\)</span>,<span class="math inline">\([ \alpha , \beta
]\)</span>这个区间内存在连续点即可.考虑定义一点处的振幅<span class="math inline">\(w_{ f } ( x_0 ) = \lim_{ \delta \to + 0 } w_f (
x_0 - \delta , x_0 + \delta )\)</span>,这个随着<span class="math inline">\(\delta\)</span>缩小当然应当是单调不增的,因此一定有非负极限(但可能是无穷大).我们注意到<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处连续的充要条件是<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>处的振幅为<span class="math inline">\(0\)</span>.必要性和充分性都容易证明.</p>
<p>我们考虑用区间套来找到这个连续点,考虑对于<span class="math inline">\([ \alpha_0 , \beta_0 ] \in [ a , b
]\)</span>,取分划<span class="math inline">\(\Delta_0\)</span>使得<span class="math inline">\(\sum w_i \Delta x_i &lt; \frac{ 1 }{ 2 } ( \beta_0
- \alpha_0 )\)</span>,并且加细使得<span class="math inline">\(\lambda (
\Delta_0 ) &lt; \frac{ 1 }{ 2 } ( \beta_0 - \alpha_0
)\)</span>,注意这里的两个<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>其实用处不同,前者是为了让<span class="math inline">\(w_i\)</span>足够小,后者是为了让区间长度足够小.此时考虑由于<span class="math inline">\(\sum \Delta x_i = \beta_0 -
\alpha_0\)</span>,所以一定存在一个<span class="math inline">\(w_i &lt;
\frac{ 1 }{ 2 }\)</span>,拿出这个区间作为<span class="math inline">\([
\alpha_1 , \beta_1 ]\)</span>,则区间长度至少折半,并且只需在上述对<span class="math inline">\([ \alpha_n , \beta_n ]\)</span>时取<span class="math inline">\(\sum w_i \Delta x_i &lt; \frac{ 1 }{ 2^{ n + 1 } }
( \beta_0 - \alpha_0 )\)</span>就可以使得<span class="math inline">\(w_i\)</span>也趋近于<span class="math inline">\(0\)</span>,这样就能用区间套找到一个点使得它是连续点.</p>
<p>事实上可以证明一个函数黎曼可积的充分必要条件是其有界并且几乎处处连续.</p>
<p>为了方便不妨把<span class="math inline">\(f\)</span>延拓到整个实轴,令<span class="math inline">\(f ( x ) = \begin{cases}f ( a ) &amp; x \leq a \\ f
( b ) &amp; x \geq b \\ f ( x ) &amp; \text{ otherwise
}\end{cases}\)</span>.</p>
<p>下面定义<span class="math inline">\(E_r = \{ x_0 \mid w_f ( x_0 )
\geq \frac{ 1 }{ r }
\}\)</span>.我们考虑证明其是闭集,也就是证明其补集<span class="math inline">\(E_r^c = \{ x_0 \in ( a , b ) \mid w_f ( x_0 ) &lt;
\frac{ 1 }{ r } \}\)</span>是开集.如果<span class="math inline">\(x_0
\in E_r^c\)</span>,注意到此时<span class="math inline">\(\exists \delta
&gt; 0 , w_f ( x_0 - \delta , x_0 + \delta ) &lt; \frac{ 1 }{ r
}\)</span>,那么这必然意味着<span class="math inline">\(x_0\)</span>邻域中的点的振幅也会<span class="math inline">\(&lt; \frac{ 1 }{ r
}\)</span>,这当然意味着其是开集.</p>
<p>令<span class="math inline">\(D\)</span>是<span class="math inline">\(f\)</span>的间断点集,容易见到<span class="math inline">\(D = \bigcup_{ n = 1 }^{ \infty }
E_n\)</span>,下面只需要证明每个<span class="math inline">\(E_n\)</span>都是零测集即可.</p>
<p>先证明必要性:当<span class="math inline">\(f \in R [ a , b
]\)</span>时,则<span class="math inline">\(f\)</span>有界,现在对于固定的<span class="math inline">\(m\)</span>,尝试证明<span class="math inline">\(E_m\)</span>是零测的,由达布定理,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,<span class="math inline">\(\exists \Delta\)</span>,使得<span class="math inline">\(\sum w_i \Delta x_i = \overline{ S }_\Delta -
\underline{ S }_\Delta &lt; \epsilon\)</span>.</p>
<p>观察前者,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\epsilon &amp; &gt; \sum w_i \Delta x_i = \overline{ S }_\Delta -
\underline{ S }_\Delta \\
&amp; = \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) \ne \emptyset } w_k \Delta
x_k + \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) = \emptyset } w_k \Delta x_k
\\
&amp; \geq \frac{ 1 }{ m } \sum_{ E_m \cap ( x_{ k - 1 } , x_k ) \ne
\emptyset } \Delta x_k
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(m^* ( E_m ) \leq \sum_{ E_m \cap (
x_{ k - 1 } , x_k ) \ne \emptyset } \Delta x_k &lt; m
\epsilon\)</span>,由于<span class="math inline">\(m\)</span>一开始就固定,<span class="math inline">\(\epsilon\)</span>可以尽量小,所以这意味着<span class="math inline">\(E_m\)</span>是零测集.必要性得证.</p>
<p>再证明充分性:当每一个<span class="math inline">\(E_m\)</span>都是零测集的时候,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,取<span class="math inline">\(r \in N_+ , r &gt; \frac{ 1 }{ \epsilon
}\)</span>.此时见到<span class="math inline">\(E_{ r
}^c\)</span>是开集,那它可以写成若干两两不交开区间的并,不妨记作<span class="math inline">\(E_r^c = \bigcup_{ k = 1 }^{ \infty }
T_k\)</span>.由于此时<span class="math inline">\(E_m\)</span>是零测集,这意味着<span class="math inline">\(\sum | T_k | = b -
a\)</span>.接下来可以取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\sum_1^n
| T_k | &gt; b - a - \frac{ \epsilon }{ 2 }\)</span>,接下来取<span class="math inline">\(T_k\)</span>的闭子区间<span class="math inline">\(J_k\)</span>,使得<span class="math inline">\(\sum_1^n | J_k | &gt; b - a -
\epsilon\)</span>.这里为什么要把开区间再进一步缩成闭区间呢?原因是你这里如果直接用开区间构造分划可能会把端点处给包进去,因此我们不得不设其端点处的一部分值拿到闭区间,这样那些振幅较大的就被舍弃了.</p>
<p>接下来考虑由于每个点<span class="math inline">\(x_0 \in
J_k\)</span>的<span class="math inline">\(w_f ( x_0 ) &lt; \frac{ 1 }{ r
} &lt; \epsilon\)</span>,必定有其一个小邻域<span class="math inline">\((
x_0 - \delta , x_0 + \delta )\)</span>满足整个邻域的振幅<span class="math inline">\(&lt;
\epsilon\)</span>,用有限覆盖定理拿出一个开覆盖,然后缩掉这些开覆盖的区间就能拿到一个<span class="math inline">\(J_k\)</span>的分划(或者干脆将这些开区间的端点和<span class="math inline">\(J_k\)</span>的端点直接当作一个分划),把这些分划全都并起来就得到了一个划分<span class="math inline">\(\Delta\)</span>.</p>
<p>此时观察这个划分,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \overline{ S }_\Delta - \underline{ S }_\Delta \\
= &amp; \sum w_k \Delta x_k \\
= &amp; \sum_{ [ x_{ k - 1 } , x_k ] \subseteq \bigcup J_i } w_k \Delta
x_k + \sum_{ [ x_{ k - 1 } , x_k ] \subsetneq \bigcup J_i } w_k \Delta
x_k \\
&lt; &amp; \epsilon ( b - a ) + ( M - m ) \epsilon
\end{aligned}
\]</span></p>
<p>这样就可以使其任意小.</p>
<p>上述证明同样声明了:黎曼可积的充要条件是震荡区间超过某个值的区间长度之和随着细分的增加应当尽可能小.</p>
<p>上述结论立刻能见到比如黎曼函数是黎曼可积的,因为其间断点集就是有理点集,就是零测集.</p>
<h5><span id="可积函数的简单性质">可积函数的简单性质</span></h5>
<p>不妨设<span class="math inline">\(f , g \in R [ a , b
]\)</span>,则:</p>
<ol type="1">
<li><p><span class="math inline">\(m ( b - a ) \leq \int_a^b f ( x )
\text{ d } x \leq M ( b - a )\)</span>.</p></li>
<li><p><span class="math inline">\(f \geq 0\)</span>则<span class="math inline">\(\int_a^b f ( x ) \text{ d } x \geq
0\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ a }^b ( f \pm g ) \text{ d } x
= \int_a^b f \text{ d } x \pm \int_a^b g \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ a }^b Cf \text{ d } x = C
\int_a^b f \text{ d } x\)</span>.</p></li>
<li><p>(保序性)<span class="math inline">\(f \geq g\)</span>则<span class="math inline">\(\int_a^b f \text{ d } x \geq \int_a^b g \text{ d }
x\)</span>.事实上只要<span class="math inline">\(f \geq
g\)</span>在一个稠密子集上成立即可.</p></li>
<li><p>如果<span class="math inline">\(c \in [ a , b
]\)</span>,那么此时<span class="math inline">\(f \in R [ a , c ] , f \in
R [ c , b ]\)</span>,并且<span class="math inline">\(\int_a^b f \text{ d
} x = \int_a^c f \text{ d } x + \int_c^b f \text{ d }
x\)</span>.</p></li>
<li><p>如果<span class="math inline">\(g\)</span>是连续函数,那么<span class="math inline">\(g ( f ( x ) ) \in R [ a , b ]\)</span>.</p></li>
<li><p><span class="math inline">\(| f | \in R [ a , b
]\)</span>,并且<span class="math inline">\(| \int_a^b f ( x ) \text{ d }
x | \leq \int_a^b | f ( x ) | \text{ d } x\)</span>.</p></li>
<li><p>如果除了一个有限的点集以外,<span class="math inline">\(g =
f\)</span>,则<span class="math inline">\(g \in R [ a , b
]\)</span>并且<span class="math inline">\(\int_a^b g \text{ d } x =
\int_a^b f \text{ d } x\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f \geq 0 , \int_a^b f \text{ d }
x = 0\)</span>,那么<span class="math inline">\(f\)</span>在其连续点集合上恒等于<span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>(1)(2)是显然的,(3)(4)(5)只需将积分看作黎曼和的极限,(6)的话考虑在<span class="math inline">\([ a , b
]\)</span>上间断点集都是零测的了,那么其子集<span class="math inline">\([
a , c ] , [ c , b ]\)</span>上的间断点集当然也是零测集.</p>
<p>(7)的话考虑一个几乎处处连续的函数在外面套一层连续函数当然也是几乎处处连续的.</p>
<p>(8)的话考虑绝对值函数是连续函数,然后注意到<span class="math inline">\(- | f ( x ) | \leq f ( x ) \leq | f ( x )
|\)</span>使用保序性就可以了.</p>
<p>(9)的证明是简单的.但是为什么是有限点集而不是零测集呢?因为如果是无限个点,那么它们不仅会影响自己的连续性,还会影响旁边点的连续性,例如迪利克雷函数.这里可以看出来黎曼函数是有其限制性的,推广到勒贝格积分后会消除这个问题.</p>
<p>(10)的话只需考虑反证法,对于一个连续点<span class="math inline">\(x_0\)</span>,如果<span class="math inline">\(f (
x_0 ) &gt; 0\)</span>,那么周围应当有一个小邻域也大于<span class="math inline">\(0\)</span>,或者干脆用一致连续性取<span class="math inline">\(&gt; \frac{ f ( x ) }{ 2
}\)</span>的一个小邻域,这样就反证完了.</p>
<h5><span id="广义原函数">广义原函数</span></h5>
<p>对于<span class="math inline">\(f ( x ) : I \to \mathbb{ R
}\)</span>,称<span class="math inline">\(F ( x
)\)</span>为其<strong>广义原函数</strong>,若<span class="math inline">\(\forall c , d \in I , c &lt; d\)</span>满足<span class="math inline">\(\frac{ F ( d ) - F ( c ) }{ d - c } \in [ \inf_{ [
c , d ] } f ( x ) , \sup_{ [ c , d ] } f ( x )
]\)</span>.容易见到原函数一定是广义原函数,原因是拉格朗日中值定理.</p>
<p>应当容易注意到以下命题:</p>
<ol type="1">
<li><p>局部有界函数的广义原函数是局部李氏连续的,故几乎处处有导数.</p></li>
<li><p><span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,<span class="math inline">\(F (
x )\)</span>是<span class="math inline">\(f ( x
)\)</span>的广义原函数,则<span class="math inline">\(F &#39; ( x_0
)\)</span>存在并且恰好等于<span class="math inline">\(f ( x_0
)\)</span>.</p></li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的证明的话,考虑<span class="math inline">\(| \frac{ F ( x ) - F (
x_0 ) }{ x - x_0 } - f ( x_0 ) | \leq w_f [ x_0 , x ]\)</span>,由于<span class="math inline">\(f ( x_0 )\)</span>连续,那么此时其振幅<span class="math inline">\(w_f [ x_0 , x ]\)</span>在<span class="math inline">\(x \to x_0\)</span>时应当趋近于<span class="math inline">\(0\)</span>,使用夹逼定理,于是证毕.</p>
<h5><span id="牛顿-莱布尼茨公式微积分基本定理">牛顿-莱布尼茨公式(微积分基本定理)</span></h5>
<p>先证明一个引理:如果<span class="math inline">\(f ( x ) \in [ a , b
]\)</span>,<span class="math inline">\(F ( x
)\)</span>是其广义原函数,那么<span class="math inline">\(\underline{
\int_a^b } f ( x ) \text{ d } x \leq F ( b ) - F ( a ) \leq \overline{
\int_a^b } f ( x ) \text{ d } x\)</span>.</p>
<p>证明的话,只需证明对于任意分划<span class="math inline">\(\Delta\)</span>都有<span class="math inline">\(\underline{ S }_\Delta ( f ) \leq F ( b ) - F ( a
) \leq \overline{ S }_\Delta f ( x )\)</span>.而注意到<span class="math inline">\(F ( b ) - F ( a ) = \sum F ( x_i ) - F ( x_{ i - 1
} ) = \sum \frac{ F ( x_i ) - F ( x_{ i - 1 } ) }{ x_i - x_{ i - 1 } }
\Delta x_i\)</span>.而根据广义原函数的定义,<span class="math inline">\(m_i \leq \frac{ F ( x_i ) - F ( x_{ i - 1 } ) }{
x_i - x_{ i - 1 } } \leq M_i\)</span>,立刻证毕.</p>
<p>由此显然证明了牛顿-莱布尼茨公式(NL公式):设<span class="math inline">\(f ( x ) \in R [ a , b
]\)</span>,并且能找到其一个广义原函数<span class="math inline">\(F ( x
)\)</span>,则<span class="math inline">\(F ( b ) - F ( a ) = \int_a^b f
( x ) \text{ d } x\)</span>.</p>
<p>接下来声明一个定理:如果一个函数<span class="math inline">\(f ( x )
\in R [ a , b
]\)</span>,它就存在广义原函数,而且不同的广义原函数最多相差一个常数.</p>
<p>先证明存在性,我们注意到变限积分<span class="math inline">\(F ( x ) =
\int_a^x f ( t ) \text{ d } t\)</span>显然是<span class="math inline">\(f ( x
)\)</span>的广义原函数,而且它是处处连续的,只需套用定义就可以证明.</p>
<p>再证唯一性,设<span class="math inline">\(F_1 ( x ) , F_2 ( x
)\)</span>都是<span class="math inline">\(f ( x
)\)</span>的广义原函数.根据LN公式,有<span class="math inline">\(F_1 ( x
) - F_1 ( a ) = \int_{ a }^x f ( t ) \text{ d } t = F_2 ( x ) - F_2 ( a
)\)</span>,立刻有<span class="math inline">\(F_1 ( x ) - F_2 ( x ) = F_1
( a ) - F_2 ( a ) = C\)</span>.</p>
<p>此时回忆到<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续可以推出<span class="math inline">\(F ( x
)\)</span>可导,那么反过来是否成立呢?考虑以下经典反例:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = \begin{cases}
0 &amp; x = 0 \\
x^2 \sin \frac{ 1 }{ x } &amp; \text{ otherwise }
\end{cases} \\
f ( x ) &amp; = F &#39; ( x ) = \begin{cases}
0 &amp; x = 0 \\
2 x \sin \frac{ 1 }{ x } - \cos \frac{ 1 }{ x } &amp; \text{ otherwise }
\end{cases}
\end{aligned}
\]</span></p>
<p>但总之可以看到连续函数一定有原函数.</p>
<p>此时回忆到我们曾经定义过左右上下导数<span class="math inline">\((
F_\pm ) &#39;\)</span>和<span class="math inline">\(( F^\pm )
&#39;\)</span>.设<span class="math inline">\(f \in R [ a , b
]\)</span>,<span class="math inline">\(F\)</span>是<span class="math inline">\(f\)</span>的广义原函数,不妨直接设<span class="math inline">\(F ( x ) = \int_a^x f ( t ) \text{ d }
t\)</span>,那么我们声明<span class="math inline">\(\int_a^b ( F_\pm )
&#39; \text{ d } x = \int_a^b ( F^\pm ) &#39; \text{ d } x = \int_a^b f
( x ) \text{ d } x\)</span>.</p>
<p>四个证明类似,只考虑其中之一<span class="math inline">\(F_+
&#39;\)</span>如何证明.取<span class="math inline">\(m_0 = \inf_{ [ c ,
d ] } f\)</span>,下面令<span class="math inline">\(G ( x ) = F ( x ) - F
( c ) - m_0 ( x - c ) = \int_c^x ( f ( t ) - m_0 ) \text{ d }
t\)</span>.当<span class="math inline">\(x \in [ c , d
]\)</span>时,容易发现<span class="math inline">\(G ( x
)\)</span>单增.既然如此,其任意左右上下导数当然都<span class="math inline">\(\geq 0\)</span>,也就是<span class="math inline">\(( G_+ ) &#39; = ( F_+ ) &#39; - m_0 \geq
0\)</span>.同理如果取<span class="math inline">\(M_0 = \sup_{ [ c , d ]
} f\)</span>的话还可以证明<span class="math inline">\(( F_+ ) &#39; \leq
M_0\)</span>.</p>
<p>那么就有<span class="math inline">\(w_{ F_+ &#39; } [ c , d ] \leq
w_{ f } [ c , d ]\)</span>,我们知道<span class="math inline">\(f\)</span>是黎曼可积的,也就是<span class="math inline">\(0 \leq \sum w_{ F_+ &#39; } [ x_{ i - 1 } , x_i ]
\Delta x_i \leq \sum w_f [ x_{ i - 1 } , x_i ] \Delta x_i &lt;
\epsilon\)</span>,此时就可以证明其可积性.</p>
<p>而注意到<span class="math inline">\(f\)</span>几乎处处连续,<span class="math inline">\(F\)</span>几乎处处可导,并且在<span class="math inline">\(f\)</span>的连续点处<span class="math inline">\(f
( x ) = F_+
&#39;\)</span>,这个连续点集当然是稠密集,因此它们的积分相等,这样就做完了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_a^b \text{ sgn } ( x ) \text{ d }
x\)</span>.</p>
<p>注意到<span class="math inline">\(\text{ sgn } ( x
)\)</span>的广义原函数是<span class="math inline">\(| x
|\)</span>,所以<span class="math inline">\(\int_a^b \text{ sgn } ( x )
\text{ d } x = | b | - | a |\)</span>.</p>
<h6><span id="example2黎曼引理">Example2(黎曼引理)</span></h6>
<p>设<span class="math inline">\(f \in R [ a , b ] , g \in R [ 0 , T
]\)</span>并且<span class="math inline">\(g\)</span>在<span class="math inline">\(\mathbb{ R }\)</span>上以<span class="math inline">\(T\)</span>为周期.求证:</p>
<p><span class="math display">\[
\lim_{ \lambda \to \infty } \int_a^b f ( x ) g ( \lambda x ) \text{ d }
x = \cfrac{ \int_0^T g ( x ) \text{ d } x }{ T } \int_a^b f ( x ) \text{
d } x
\]</span></p>
<p>首先注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \lim_{ \lambda \to \infty } \int_a^b f ( x ) g ( \lambda x )
\text{ d } x \\
= &amp; \lim_{ \lambda \to \infty } \int_a^b f ( x ) ( g ( \lambda x ) -
\cfrac{ \int_0^T g ( x ) \text{ d } x }{ T } + \cfrac{ \int_0^T g ( x )
\text{ d } x }{ T } ) \text{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>因此可以用<span class="math inline">\(g ( \lambda x ) - \cfrac{
\int_0^T g ( x ) \text{ d } x }{ T }\)</span>代替<span class="math inline">\(g\)</span>,这样就能满足<span class="math inline">\(\int_0^T g ( x ) \text{ d } x = 0\)</span>.</p>
<p>接下来只需证明<span class="math inline">\(\lim_{ \lambda \to \infty }
\int_a^b f ( x ) g ( \lambda x ) \text{ d } x = 0\)</span>,不妨设<span class="math inline">\(| f ( x ) | \leq M , | g ( x ) | \leq
M\)</span>.</p>
<p>考虑对分划<span class="math inline">\(\Delta\)</span>,满足<span class="math inline">\(\sum w_i \Delta x_i \leq \epsilon\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f ( x ) g ( \lambda x ) \text{ d } x | \\
= &amp; | \sum \int_{ x_{ i - 1 } }^{ x_i } ( f ( x ) - f ( x_i ) + f (
x_i ) ) g ( \lambda x ) \text{ d } x | \\
\leq &amp; | \sum \int_{ x_{ i - 1 } }^{ x_i } f ( x_i ) g ( \lambda x )
\text{ d } x | + | \sum \int_{ x_{ i - 1 } }^{ x_i } ( f ( x ) - f ( x_i
) ) g ( \lambda x ) \text{ d } x | \\
\leq &amp; \sum | f ( x_i ) | \cdot | \int_{ x_{ i - 1 } }^{ x_i } g (
\lambda x ) \text{ d } x | + M \sum w_i \Delta x_i \\
\leq &amp; M \sum | \int_{ x_{ i - 1 } }^{ x_i } g ( \lambda x ) \text{
d } x | + M \sum w_i \Delta x_i \\
\leq &amp; M \sum | \frac{ 1 }{ \lambda } \int_{ \lambda x_{ i - 1 } }^{
\lambda x_i } g ( x ) \text{ d } x | + M \epsilon
\end{aligned}
\]</span></p>
<p>接下来设<span class="math inline">\(G ( x ) = \int_0^x g ( t ) \text{
d } t\)</span>,由于<span class="math inline">\(g\)</span>的周期性,而且其在任何一个长度为<span class="math inline">\(T\)</span>的区间上积分为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(| G ( x
) | \leq W\)</span>,那么<span class="math inline">\(\forall x , y , | G
( x ) - G ( y ) | \leq 2 W\)</span>.</p>
<p>那么上式就<span class="math inline">\(\leq 2 MW \frac{ n }{ \lambda }
+ M \epsilon\)</span>,这里虽然有个无穷大的<span class="math inline">\(n\)</span>,但由于<span class="math inline">\(\lambda\)</span>可以尽可能大且在<span class="math inline">\(n\)</span>之后决定取值,因此这个影响可以被消除.</p>
<p>这个命题的一个平凡推论是<span class="math inline">\(g ( x ) = \sin (
nx )\)</span>:</p>
<p><span class="math display">\[
\lim_{ \lambda \to \infty } \int_a^b f ( x ) \sin ( \lambda x ) \mathrm{
d } x = \lim_{ \lambda \to \infty } \int_a^b f ( x ) \cos ( \lambda x )
\mathrm{ d } x = 0
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\lim_{ n \to \infty }
I_n\)</span>,其中<span class="math inline">\(I_n = \frac{ 1 }{ n^{ 1 +
\alpha } } ( \sum_{ k = 1 }^n k^\alpha ) = \frac{ 1 }{ n } \sum_{ k = 1
}^n ( \frac{ k }{ n } )^\alpha\)</span>.</p>
<p>注意到<span class="math inline">\(n \to
\infty\)</span>的时候,上面就等于<span class="math inline">\(\int_0^1
x^\alpha \text{ d } x = \frac{ 1 }{ 1 + \alpha }\)</span>.</p>
<h6><span id="example4dirichlet核">Example4(Dirichlet核)</span></h6>
<p>求<span class="math inline">\(\int_0^{ \frac{ \pi }{ 2 } } \frac{
\sin ( ( 2 n + 1 ) x ) }{ \sin x } \text{ d } x\)</span>.</p>
<p>注意到根据积化和差有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ \sin ( ( 2 n + 1 ) x ) }{ \sin
x } \text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 2 } } ( 1 + 2 \sum_k \cos ( 2 kx ) )
\text{ d } x \\
= &amp; \frac{ \pi }{ 2 } + 2 \sum_{ k } \frac{ 1 }{ 2 k } \sin ( k \pi
) \\
= &amp; \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f \in \mathbb{ R }\)</span>,<span class="math inline">\(\forall a &lt; b\)</span>,都有<span class="math inline">\(f \in R [ a , b ]\)</span>,已知<span class="math inline">\(f ( x ) = \int_0^x f ( t ) \text{ d }
t\)</span>,求证<span class="math inline">\(f \equiv 0\)</span>.</p>
<p>首先注意到变限积分是李氏连续的,因此<span class="math inline">\(f\)</span>当然就是局部李氏连续的,因此自然看出<span class="math inline">\(f\)</span>在<span class="math inline">\(\mathbb{ R
}\)</span>上都是连续的.既然如此,那<span class="math inline">\(f\)</span>就在<span class="math inline">\(\mathbb{
R }\)</span>上处处可导并且<span class="math inline">\(f &#39; ( x )
\equiv f ( x )\)</span>,同理还可以看出<span class="math inline">\(f\)</span>实际上任意阶可导.理应见到<span class="math inline">\(f\)</span>应当和<span class="math inline">\(e^x\)</span>有关,凑<span class="math inline">\(g (
x ) = \frac{ f ( x ) }{ e^x }\)</span>,则<span class="math inline">\(g
&#39; ( x ) = \frac{ f &#39; - f }{ e^x } \equiv
0\)</span>,这立刻得到<span class="math inline">\(g ( x ) \equiv
C\)</span>.</p>
<p>然而<span class="math inline">\(g ( 0 ) = f ( 0 ) =
0\)</span>,于是<span class="math inline">\(g \equiv C \equiv
0\)</span>,所以<span class="math inline">\(f \equiv 0\)</span>.</p>
<h5><span id="换元法">换元法</span></h5>
<p>不妨设<span class="math inline">\(f \in R [ a , b ] , F &#39; =
f\)</span>,<span class="math inline">\(\varphi ( t ) : [ \alpha , \beta
] \to [ a , b ]\)</span>,<span class="math inline">\(\varphi ( \alpha )
= a , \varphi ( \beta ) = b\)</span>,并且<span class="math inline">\(\varphi\)</span>可导,而且<span class="math inline">\(f ( \varphi ( t ) ) \varphi &#39; ( t ) \in R [
\alpha , \beta ]\)</span>,则:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \text{ d } x = \int_\alpha^\beta f ( \varphi ( t ) )
\varphi &#39; ( t ) \text{ d } t
\]</span></p>
<p>证明的话,考虑考虑NL公式,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
( F ( \varphi ( t ) ) ) &#39; &amp; = f ( \varphi ( t ) ) \varphi &#39;
( t ) \\
\int_\alpha^\beta ( F ( \varphi ( t ) ) ) &#39; &amp; =
\int_\alpha^\beta f ( \varphi ( t ) ) \varphi &#39; ( t ) \\
F ( b ) - F ( a ) &amp; = \int_\alpha^\beta f ( \varphi ( t ) ) \varphi
&#39; ( t )
\end{aligned}
\]</span></p>
<p>然而回忆到有原函数和是否黎曼可积之间是有区别的,适当调整条件可以得到另一个策略的换元法:不妨设<span class="math inline">\(f \in R [ a , b ] , \varphi ( t ) : [ \alpha ,
\beta ] \to [ a , b ]\)</span>,并且<span class="math inline">\(\varphi (
t )\)</span>单增,<span class="math inline">\(\varphi ( \alpha ) = a ,
\varphi ( \beta ) = b\)</span>,<span class="math inline">\(\varphi\)</span>可导并且<span class="math inline">\(\varphi &#39; \in R [ \alpha , \beta
]\)</span>,则<span class="math inline">\(f ( \varphi ( t ) ) \varphi
&#39; ( t ) \in R [ \alpha , \beta ]\)</span>且上述积分仍然成立.</p>
<p>策略是对两边做黎曼和,利用<span class="math inline">\(\varphi\)</span>的单调性和一致连续性,可以取<span class="math inline">\(S_{ \Delta } = \sum f ( \eta_k ) \Delta
x_k\)</span>,利用中值定理可以写作<span class="math inline">\(S_{ \Delta
} = \sum f ( \varphi ( \xi_k ) ) \varphi &#39; ( \mu_k ) \Delta
t_k\)</span>.</p>
<p>而另一边的黎曼和<span class="math inline">\(\sigma_{ \Delta &#39; } =
\sum f ( \varphi ( \xi_k ) ) \varphi &#39; ( \xi_k ) \Delta
t_k\)</span>.</p>
<p>只需证明二者之差趋近于<span class="math inline">\(0\)</span>,令<span class="math inline">\(M = \sup | f | ,\)</span>做差得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum f ( \varphi ( \xi_k ) ) ( \varphi &#39; ( \xi_k ) - \varphi
&#39; ( \mu_k ) ) \Delta t_k | \\
\leq &amp; M | \sum ( \varphi &#39; ( \xi_k ) - \varphi &#39; ( \mu_k )
) \Delta t_k | \\
\leq &amp; M | \sum w_k \Delta t_k |
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(\varphi\)</span>可积,上述趋近于<span class="math inline">\(0\)</span>.</p>
<p>这些定理都有点诡异,它们会在RS积分处再详细讨论.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\int_0^{ \frac{ \pi }{ 2 } } \frac{
\sin x }{ \sin x + \cos x } \text{ d } x\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ \sin x }{ \sin x + \cos x }
\text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 4 } } \left ( \frac{ \sin x }{ \sin x +
\cos x } + \frac{ \sin ( \frac{ \pi }{ 2 } - x ) }{ \sin ( \frac{ \pi }{
2 } - x ) + \cos ( \frac{ \pi }{ 2 } - x ) } \right ) \text{ d } x \\
= &amp; \int_0^{ \frac{ \pi }{ 4 } } \frac{ \sin x + \cos x }{ \sin x +
\cos x } \text{ d } x \\
= &amp; \frac{ \pi }{ 4 }
\end{aligned}
\]</span></p>
<p>其实就是找个点对折.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int_0^\pi \frac{ \theta \sin
\theta }{ a + b \cos^2 \theta } \text{ d } \theta\)</span>,其中<span class="math inline">\(a , b &gt; 0\)</span>.</p>
<p>令<span class="math inline">\(\theta = \pi -
\varphi\)</span>,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = - \int_\pi^0 \frac{ ( \pi - \varphi ) \sin \varphi }{ a + b
\cos^2 \varphi } \text{ d } \varphi \\
&amp; = \int_0^\pi \frac{ ( \pi - \varphi ) \sin \varphi }{ a + b \cos^2
\varphi } \text{ d } \varphi \\
&amp; = \pi \int_{ 0 }^\pi \frac{ \sin \varphi }{ a + b \cos^2 \varphi }
\text{ d } \varphi - I
\end{aligned}
\]</span></p>
<p>移项得到:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = \frac{ \pi }{ 2 } \int_0^\pi \frac{ - \text{ d } \cos \theta
}{ a + b \cos^2 \theta } \\
&amp; = \frac{ \pi }{ \sqrt{ ab } } \arctan \sqrt{ \frac{ b }{ a } }
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>如果<span class="math inline">\(\forall a &lt; b , f \in R [ a , b
]\)</span>,并且<span class="math inline">\(f ( x + y ) = f ( x ) + f ( y
)\)</span>恒成立,求证<span class="math inline">\(f ( x ) \equiv f ( 1 )
x\)</span>.</p>
<p>固定<span class="math inline">\(x\)</span>,对<span class="math inline">\(y\)</span>从<span class="math inline">\([ 0 , 1
]\)</span>积分,得到:</p>
<p><span class="math display">\[
f ( x ) = \int_x^{ x + 1 } f ( t ) \text{ d } t - \int_0^1 f ( y )
\text{ d } y
\]</span></p>
<p>而变限积分是局部李氏连续的,所以<span class="math inline">\(f ( x
)\)</span>局部连续,所以<span class="math inline">\(f ( x
)\)</span>整体连续,立刻得到<span class="math inline">\(f ( x
)\)</span>可导,立刻得到其是<span class="math inline">\(C^\infty\)</span>的.</p>
<p>那就可以两边对<span class="math inline">\(x\)</span>求导,得到<span class="math inline">\(\forall y , f &#39; ( x + y ) = f &#39; ( x
)\)</span>,因此<span class="math inline">\(f &#39; \equiv
C\)</span>.</p>
<h5><span id="分部积分">分部积分</span></h5>
<p>设<span class="math inline">\(u , v \in R [ a , b
]\)</span>并且均可导,而且<span class="math inline">\(u &#39; , v &#39;
\in R [ a , b ]\)</span>,则:</p>
<p><span class="math display">\[
( uv ) &#39; = u &#39; v + uv &#39;
\]</span></p>
<p>从这里能看出<span class="math inline">\(( uv )
&#39;\)</span>也是黎曼可积的,那就可以用牛顿莱布尼茨公式两边积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b uv &#39; \text{ d } x &amp; = uv \mid_a^b - \int_a^b u &#39; v
\text{ d } x \\
&amp; = \int_a^b u \text{ d } v = uv \mid_a^b - \int_a^b v \text{ d } u
\end{aligned}
\]</span></p>
<p>这个版本当然是简单的,那能不能上点难度呢?</p>
<p>不妨考虑<span class="math inline">\(f , g \in R [ a , b
]\)</span>,那它们的广义原函数可以取为<span class="math inline">\(F ( x )
= \int_a^x f ( t ) \text{ d } t + A , G ( x ) = \int_a^x g ( t ) \text{
d } t + B\)</span>.</p>
<p>则<span class="math inline">\(\int_a^b Fg \text{ d } x = FG \mid_a^b
- \int_a^b Gf \text{ d } x\)</span>.</p>
<p>先证明一个引理:</p>
<p><span class="math display">\[
\lim_{ \lambda ( \Delta ) \to 0 } \sum_k^n f ( \xi_k ) \int_{ x_{ i - 1
} }^{ x_i } g ( t ) \text{ d } t = \int_a^b f ( x ) g ( x ) \text{ d } x
\]</span></p>
<p>证明无非是用黎曼和,设<span class="math inline">\(M = \sup | f
|\)</span>,直接考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_k^n f ( \xi ) \int_{ x_{ i - 1 } }^{ x_i } g \mathrm{ d } t
- \sum_k^n \int_{ x_{ i - 1 } }^{ x_i } fg \text{ d } t | \\
\leq &amp; \sum | f ( \xi_k ) | \int_{ x_{ i - 1 } }^{ x_i } | g ( t ) -
g ( \xi_k ) | \text{ d } t + | \sum f ( \xi_k ) g ( \xi_k ) \Delta t_k -
\int_a^b f g \text{ d } t | \\
\leq &amp; M \sum w_k ( g ) \text{ d } t + \sum w_k ( fg ) \Delta t_i
\end{aligned}
\]</span></p>
<p>这个当然趋向于<span class="math inline">\(0\)</span>.</p>
<p>使用abel求和法则,得到:</p>
<p><span class="math display">\[
\begin{aligned}
( FG ) \mid_a^b &amp; = \sum_k ( F ( x_k ) G ( x_k ) - F ( x_{ k - 1 } )
G ( x_{ k - 1 } ) ) \\
&amp; = \sum_k ( F ( x_k ) G ( x_k ) - F ( x_{ k - 1 } ) G ( x_k ) + F (
x_{ k - 1 } ) G ( x_k ) - F ( x_{ k - 1 } ) G ( x_{ k - 1 } ) ) \\
&amp; = \sum_{ k }^n G ( x_k ) ( F ( x_k ) - F ( x_{ k - 1 } ) ) +
\sum_{ k } F ( x_{ k - 1 } ) ( G ( x_i ) - G ( x_{ i - 1 } ) ) \\
&amp; = \sum_k G ( x_i ) \int_{ x_{ i - 1 } }^{ x_i } f ( x ) \text{ d }
x + \sum_{ k }^n F ( x_{ i - 1 } ) \int_{ x_{ i - 1 } }^{ x_i } g ( x )
\text{ d } x
\end{aligned}
\]</span></p>
<p>使用引理就完事了.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_a^x ( \int_a^t f ( u ) \text{ d } u ) \text{ d } t = \int_a^x ( x -
t ) f ( t ) \text{ d } t
\]</span></p>
<p>令<span class="math inline">\(F ( x ) = \int_a^t f ( t ) \text{ d }
t\)</span>,<span class="math inline">\(g ( x ) = 1 , G ( x ) = x -
a\)</span>就可以直接套用分部积分公式得到:</p>
$$
<span class="math display">\[\begin{aligned}
LHS &amp; = \int_a^x F ( t ) g ( t ) \text{ d } t \\
&amp; = FG \mid_a^x - \int_a^x f ( t ) G ( t ) \text{ d } t \\
&amp; = ( x - a ) \int_a^x f ( t ) \text{ d } t - \int_a^x f ( t ) ( t -
a ) \text{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就做完了.</p>
<p>或者设<span class="math inline">\(F ( a ) =
0\)</span>,将上式记作:</p>
<p><span class="math display">\[
\int_a^x F ( t ) \mathrm{ d } t = \int_a^x ( x - t ) F &#39; ( t )
\mathrm{ d } t
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } } \frac{
x \sin x \cos x }{ ( a^2 \cos^2 x + b^2 \sin^2 x )^2 } \text{ d }
x\)</span>,其中<span class="math inline">\(a , b &gt; 0\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ \pi }{ 2 } } \frac{ x \sin x \cos x }{ ( a^2
\cos^2 x + b^2 \sin^2 x )^2 } \text{ d } x \\
= &amp; \frac{ - 1 }{ 2 ( b^2 - a^2 ) } \int_0^{ \frac{ \pi }{ 2 } } x
\text{ d } ( \frac{ 1 }{ a^2 + ( b^2 - a^2 ) \sin^2 x } ) \\
= &amp; \frac{ - 1 }{ 2 ( b^2 - a^2 ) } ( \frac{ \pi }{ 2 b^2 } -
\int_0^{ \frac{ \pi }{ 2 } } \frac{ \text{ d } x }{ a^2 \cos^2 x + b^2
\sin^2 x } ) \\
= &amp; \frac{ 1 }{ 2 ( b^2 - a^2 ) } ( - \frac{ \pi }{ 2 b^2 } +
\int_0^{ \frac{ \pi }{ 2 } } \frac{ \text{ d } \tan x }{ a^2 + b^2
\tan^2 x } ) \\
= &amp; \frac{ 1 }{ 2 ( b^2 - a^2 ) } ( - \frac{ \pi }{ 2 b^2 } + \frac{
\pi }{ 2 ab } ) \\
= &amp; \frac{ \pi }{ 4 ab^2 ( a + b ) }
\end{aligned}
\]</span></p>
<h6><span id="example3wallis公式">Example3(Wallis公式)</span></h6>
<p>求<span class="math inline">\(I_n = \int_0^{ \frac{ \pi }{ 2 } }
\sin^n x \text{ d } x\)</span>.</p>
<p>换元后直接分部积分:</p>
$$
<span class="math display">\[\begin{aligned}
I_n &amp; = - \int_0^{ \frac{ \pi }{ 2 } } \sin^{ n - 1 } x \text{ d }
\cos x \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \cos x \text{ d } ( \sin^{ n - 1 }
x ) \\
&amp; = ( n - 1 ) \int_0^{ \frac{ \pi }{ 2 } } \sin^{ n - 2 } x ( 1 -
\sin^2 x ) \text{ d } x \\
&amp; = ( n - 1 ) I_{ n - 2 } - ( n - 1 ) I_n \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是<span class="math inline">\(I_n = \frac{ n - 1 }{ n } I_{ n - 2
}\)</span>.</p>
<p>注意到<span class="math inline">\(I_0 = \frac{ \pi }{ 2 } , I_1 =
1\)</span>,所以<span class="math inline">\(I_{ 2 m } = \frac{ ( 2 m - 1
) ! ! }{ ( 2 m ) ! ! } \frac{ \pi }{ 2 } , I_{ 2 m + 1 } = \frac{ ( 2 m
) ! ! }{ ( 2 m + 1 ) ! ! }\)</span>.</p>
<p>然而注意到<span class="math inline">\(I_n\)</span>随着<span class="math inline">\(n\)</span>增大而减小,于是应该有<span class="math inline">\(I_{ 2 m + 1 } \leq I_{ 2 m } \leq I_{ 2 m - 1
}\)</span>,展开得到:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ 2 n + 1 } ( \frac{ ( 2 n ) ! ! }{ ( 2 n - 1 ) !
! } )^2 \\
&amp; \leq \frac{ \pi }{ 2 } \leq \\
\frac{ 1 }{ 2 n } ( \frac{ ( 2 n ) ! ! }{ ( 2 n - 1 ) ! ! } )^2 &amp; =
b_n
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(\lim a_n = \lim b_n\)</span>,因此<span class="math inline">\(\lim a_n = \lim b_n = \frac{ \pi }{ 2
}\)</span>.</p>
<h5><span id="泰勒公式的积分余项">泰勒公式的积分余项</span></h5>
<p>回忆到泰勒公式的余项:</p>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(a\)</span>处有<span class="math inline">\(n\)</span>阶导数,则<span class="math inline">\(f (
x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a ) }{ k ! } ( x - a )^k + o
( ( x - a )^n )\)</span>.</p>
<p>设<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\(( \alpha , \beta )\)</span>上有<span class="math inline">\(n + 1\)</span>阶导数,则<span class="math inline">\(f ( x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a
) }{ k ! } ( x - a )^k + \frac{ f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! }
( x - a )^{ n + 1 }\)</span>.</p>
<p>事实上还可以写积分余项,若<span class="math inline">\(f^{ ( n + 1 ) }
\in R [ \alpha , \beta ]\)</span>,则<span class="math inline">\(f ( x )
= \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( a ) }{ k ! } ( x - a )^k +
\frac{ 1 }{ n ! } \int_a^x ( x - t )^n f^{ ( n + 1 ) } ( t ) \text{ d }
t\)</span>.</p>
<p>首先能写出<span class="math inline">\(f ( x ) = f ( a ) + \int_a^x f
&#39; ( t ) \text{ d }
t\)</span>,考虑不断展开后面那一项,用分部积分注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^x f^{ ( m + 1 ) } ( t ) \frac{ ( x - t )^m }{ m ! } \text{
d } t \\
= &amp; \int_a^x f^{ ( m + 1 ) } ( t ) \text{ d } ( - \frac{ ( x - t )^{
m + 1 } }{ ( m + 1 ) ! } ) \\
= &amp; f^{ ( m + 1 ) } ( a ) \frac{ ( x - a )^{ m + 1 } }{ ( m + 1 ) !
} + \frac{ 1 }{ ( m + 1 ) ! } \int_a^x ( x - t )^{ m + 1 } f^{ ( m + 2 )
} ( t ) \text{ d } t
\end{aligned}
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>函数<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\([ a , b ]\)</span>上各阶导数存在且非负,求证:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ n = 0 }^\infty \frac{ f^{ ( n ) } ( a ) }{ n ! } ( x -
a )^n
\]</span></p>
<p>其实这个题应该放到幂级数那里,不过确实和积分余项关系更大.分析的话首先会发现要证两边相等一定要搞定余项对吧,但是拉格朗日余项要求对所有的点的任意阶导数都存在一个控制,但这是做不到的,原函数对导函数的控制只能是在一段连续区间上的控制(用NL公式),而做不到对所有单点的控制.因此使用积分余项,一个自然的想法是除了<span class="math inline">\(b\)</span>端点以外的误差应该都比<span class="math inline">\(b\)</span>处的误差要小,注意到:</p>
<p><span class="math display">\[
\frac{ x - t }{ x - a } \leq \frac{ b - t }{ b - a }
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
\begin{aligned}
R_n ( x ) &amp; = \frac{ 1 }{ n ! } \int_a^x f^{ ( n + 1 ) } ( t ) ( x -
t )^n \mathrm{ d } t \\
&amp; \leq \frac{ ( x - a )^n }{ ( b - a )^n } \frac{ 1 }{ n ! }
\int_a^x f^{ ( n + 1 ) } ( t ) ( b - t )^n \mathrm{ d } t \\
&amp; \leq \frac{ ( x - a )^n }{ ( b - a )^n } R_n ( b )
\end{aligned}
\]</span></p>
<p>接下来如果能控制<span class="math inline">\(R_n ( b
)\)</span>就万事大吉,发现:</p>
<p><span class="math display">\[
\begin{aligned}
R_n ( b ) &amp; = \frac{ 1 }{ n ! } \int_a^b f^{ ( n + 1 ) } ( t ) ( b -
t )^n \mathrm{ d } t \\
&amp; = \frac{ 1 }{ n ! } \int_a^b ( b - t )^n \mathrm{ d } f^{ ( n ) }
( t ) \\
&amp; = - \frac{ ( b - a )^n }{ n ! } f^{ ( n ) } ( a ) + \frac{ 1 }{ (
n - 1 ) ! } \int_a^b ( b - t )^{ n - 1 } f^{ ( n ) } ( t ) \\
&amp; \leq R_{ n - 1 } ( b ) \\
&amp; \leq \cdots \leq f ( b ) - f ( a )
\end{aligned}
\]</span></p>
<p>这就搞定了,当<span class="math inline">\(x \in [ a , b
)\)</span>的时候,由于<span class="math inline">\(\frac{ ( x - a )^n }{ (
b - a )^n } \to
0\)</span>而自然完事.而单调函数的端点是随便延拓的,写下来的话,如果端点处不满足则必然端点处不收敛,意味着:</p>
<p><span class="math display">\[
\lim_{ x \to b - 0 } \sum_{ n = 0 }^\infty \frac{ f^{ ( n ) } ( a ) }{ n
! } ( x - a )^n = + \infty
\]</span></p>
<p>但这不可能,因为左边的恰好是原本收敛的那个函数<span class="math inline">\(x \to b - 0\)</span>处的表现.</p>
<h5><span id="积分第一中值定理">积分第一中值定理</span></h5>
<p>设<span class="math inline">\(f , g \in R [ a , b ]\)</span>并且<span class="math inline">\(g\)</span>不变号.不妨设<span class="math inline">\(f\)</span>的连续点集为<span class="math inline">\(A\)</span>,称它的<strong>本性上界</strong>为<span class="math inline">\(M = \inf_{ x \in A } ( f ( x )
)\)</span>,同理定义<strong>本性下界</strong><span class="math inline">\(m\)</span>.则<span class="math inline">\(\exists
\mu \in [ m , M ]\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg ( x ) \text{ d } x = \mu \int_a^b g ( x ) \text{ d } x
\]</span></p>
<p>来证明这个事,不妨设<span class="math inline">\(g ( x ) \geq
0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g ( x ) \text{ d } x =
0\)</span>的时候,此时由于<span class="math inline">\(g ( x ) \geq
0\)</span>,因此<span class="math inline">\(g ( x
)\)</span>一定几乎处处为零(否则,存在一个<span class="math inline">\(g\)</span>的连续点处不为<span class="math inline">\(0\)</span>,在这个点邻域附近卡一下就能卡掉),那左右两边都等于<span class="math inline">\(0\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b g ( x ) \text{ d } x &gt;
0\)</span>的时候,由于<span class="math inline">\(mg \leq gf \leq
Mg\)</span>对于<span class="math inline">\(f\)</span>的连续点集<span class="math inline">\(A\)</span>成立,而这是个稠密集,立刻见到<span class="math inline">\(\int_a^b mg \text{ d } x \leq \int_a^b gf \text{ d
} x \leq \int_a^b Mg \text{ d } x\)</span>.于是<span class="math inline">\(\mu = \frac{ \int_a^b f g \text{ d } x }{ \int_a^b
g \text{ d } x } \in [ m , M ]\)</span>.</p>
<p>作为更加常见的版本,当<span class="math inline">\(f \in C [ a , b
]\)</span>的时候,<span class="math inline">\(\exists \xi \in ( a , b
)\)</span>使得:</p>
<p><span class="math display">\[
\int_a^b fg ( x ) \text{ d } x = f ( \xi ) \int_a^b g ( x ) \text{ d } x
\]</span></p>
<p>该版本与之前的区别在于要断言<span class="math inline">\(\xi \ne a ,
\xi \ne b\)</span>.使用反证法,在<span class="math inline">\(\int_a^b g (
x ) \text{ d } x &gt; 0\)</span>的时候,不妨假设<span class="math inline">\(\xi = b\)</span>,此时前面<span class="math inline">\(( a , b )\)</span>中不能有和<span class="math inline">\(f ( b
)\)</span>相同的,又因为其是连续函数,因此不妨设<span class="math inline">\(( a , b )\)</span>中<span class="math inline">\(f
( x )\)</span>均比<span class="math inline">\(f ( b
)\)</span>要小,用极限把端点用保号性卡出来就知道<span class="math inline">\([ a , b ]\)</span>中<span class="math inline">\(f
( x ) \leq f ( b )\)</span>.</p>
<p>由于此时<span class="math inline">\(\int_a^b g ( x ) \text{ d } x
&gt; 0\)</span>,于是一定存在一个<span class="math inline">\(x_0 , g (
x_0 ) &gt; 0\)</span>,并且<span class="math inline">\(x_0\)</span>是一个连续点.此时就存在其一个小邻域都<span class="math inline">\(&gt; \frac{ 1 }{ 2 } g ( x_0 ) &gt;
0\)</span>,并且这个邻域上的<span class="math inline">\(f ( x ) &lt; f (
b )\)</span>.在这个邻域上立刻可以发现:</p>
<p><span class="math display">\[
\int_a^b ( M - f ( x ) ) g ( x ) \text{ d } x &gt; 0
\]</span></p>
<p>这就有了矛盾.</p>
<h6><span id="example1">Example1</span></h6>
<p><span class="math inline">\(f \in R [ 0 , 1 ]\)</span>,<span class="math inline">\(f ( + 0 )\)</span>存在,则:</p>
<p><span class="math display">\[
\lim_{ n \to + \infty } \int_0^1 \frac{ n f ( x ) }{ 1 + n^2 x^2 }
\text{ d } x = \frac{ \pi }{ 2 } f ( + 0 )
\]</span></p>
<p>不妨设<span class="math inline">\(f ( 0 ) = f ( + 0
)\)</span>,因为改变有限个点的取值是不会改变其积分的.</p>
<p>此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ n f ( x ) }{ 1 + n^2 x^2 } \text{ d } x \\
= &amp; \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n f ( x ) }{ 1 + n^2
x^2 } \text{ d } x + \int_{ \frac{ 1 }{ \sqrt{ n } } }^{ 1 } \frac{ n f
( x ) }{ 1 + n^2 x^2 } \text{ d } x
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n f ( x ) }{ 1 + n^2
x^2 } \text{ d } x \\
= &amp; \mu \int_0^{ \frac{ 1 }{ \sqrt{ n } } } \frac{ n }{ 1 + n^2 x^2
} \text{ d } x \\
= &amp; \mu \arctan \sqrt{ n } \to f ( 0 ) \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<p>而后者:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ \frac{ 1 }{ \sqrt{ n } } }^{ 1 } \frac{ n f ( x ) }{ 1 +
n^2 x^2 } \text{ d } x | \\
\leq &amp; \sup | f | ( \arctan ( nx ) \mid_{ \frac{ 1 }{ \sqrt{ n } }
}^1 ) \\
= &amp; \sup | f | \arctan ( \frac{ n - \sqrt{ n } }{ 1 + n \sqrt{ n } }
) \to 0
\end{aligned}
\]</span></p>
<p>这样就做完了.这里拆成两部分可能是难以想到的,事实上这么做的意义是使得<span class="math inline">\(\mu \to f ( 0 )\)</span>而放缩,其中这个<span class="math inline">\(nx\)</span>的变化量很大,因此可以稍微匀一下变化.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f\)</span>二阶可导,并且一,二阶导可积,则<span class="math inline">\(\exists \xi \in ( a , b )\)</span>,使得<span class="math inline">\(\int_a^b f ( x ) \text{ d } x = ( b - a ) f (
\frac{ a + b }{ 2 } ) + \frac{ ( b - a )^3 }{ 24 } f &#39; &#39; ( \xi
)\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \text{ d } x \\
= &amp; \int_{ a }^{ \frac{ a + b }{ 2 } } f ( x ) \text{ d } x + \int_{
\frac{ a + b }{ 2 } }^{ b } f ( x ) \text{ d } x \\
= &amp; \int_0^{ \frac{ b - a }{ 2 } } f ( a + t ) \text{ d } t +
\int_0^{ \frac{ b - a }{ 2 } } f ( b - t ) \text{ d } t \\
= &amp; \int_0^{ \frac{ b - a }{ 2 } } f ( a + t ) + f ( b - t ) \text{
d } t \\
= &amp; t ( f ( a + t ) + f ( b - t ) ) \mid_0^{ \frac{ b - a }{ 2 } } -
\int_0^{ \frac{ b - a }{ 2 } } t ( f &#39; ( a + t ) - f &#39; ( b - t )
) \text{ d } t \\
= &amp; ( b - a ) f ( \frac{ a + b }{ 2 } ) - \int_0^{ \frac{ b - a }{ 2
} } t ( f &#39; ( a + t ) - f &#39; ( b - t ) ) \text{ d } t
\end{aligned}
\]</span></p>
<p>前半部分已经完事了,接下来看后半部分,继续分部积分:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \frac{ b - a }{ 2 } } t ( f &#39; ( a + t ) - f &#39; ( b
- t ) ) \text{ d } t \\
= &amp; \frac{ 1 }{ 2 } \int_0^{ \frac{ b - a }{ 2 } } ( f &#39; ( a + t
) - f &#39; ( b - t ) ) \text{ d } ( t^2 ) \\
= &amp; \left ( \frac{ t^2 }{ 2 } ( f &#39; ( a + t ) - f &#39; ( b - t
) ) \right ) \mid_{ 0 }^{ \frac{ b - a }{ 2 } } - \int_0^{ \frac{ b - a
}{ 2 } } \frac{ t^2 }{ 2 } ( f &#39; &#39; ( a + t ) + f &#39; &#39; ( b
- t ) ) \text{ d } t \\
= &amp; - \int_0^{ \frac{ b - a }{ 2 } } \frac{ t^2 }{ 2 } ( f &#39;
&#39; ( a + t ) + f &#39; &#39; ( b - t ) ) \text{ d } t \\
= &amp; \mu \int_0^{ \frac{ b - a }{ 2 } } \frac{ t^2 }{ 2 } \text{ d }
t \\
= &amp; \mu \frac{ ( b - a )^3 }{ 48 }
\end{aligned}
\]</span></p>
<p>接下来看<span class="math inline">\(\mu\)</span>,<span class="math inline">\(\mu \in [ \inf ( f &#39; &#39; ( a + t ) + f &#39;
&#39; ( b - t ) ) , \sup ( f &#39; &#39; ( a + t ) + f &#39; &#39; ( b -
t ) ) ]\)</span>,由导函数介值性,意味着必然<span class="math inline">\(\exists \xi_1 \in [ 0 , \frac{ b - a }{ 2 }
]\)</span>使得<span class="math inline">\(\mu = f &#39; &#39; ( a +
\xi_1 ) + f &#39; &#39; ( b - \xi_1 )\)</span>.再用一次<span class="math inline">\(2 f &#39; &#39;\)</span>的介值性得到<span class="math inline">\(\mu = 2 f &#39; &#39; ( \xi ) , \xi \in ( a +
\xi_1 , b - \xi_1 ) \subseteq ( a , b )\)</span>.</p>
<h5><span id="积分第二中值定理">积分第二中值定理</span></h5>
<p>设<span class="math inline">\(g \in R [ a , b ] , f \geq
0\)</span>,并且<span class="math inline">\(f\)</span>单调,则:</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span>单调递减时,<span class="math inline">\(\exists \xi \in [ a , b ]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a + 0 ) \int_a^\xi
g ( x ) \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(f\)</span>单调递增时,<span class="math inline">\(\exists \xi \in [ a , b ]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( b - 0 ) \int_\xi^b
g ( x ) \text{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\exists \xi \in [ a , b
]\)</span>,<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a
+ 0 ) \int_a^\xi g \text{ d } x + f ( b - 0 ) \int_\xi^b g \text{ d }
x\)</span>.</p></li>
<li><p>在上述基础上,如果<span class="math inline">\(f\)</span>不是几乎常值函数,那么上述的<span class="math inline">\(\xi \in ( a , b )\)</span>.</p></li>
</ol>
<p>(1)(2)相似,下面只对(1)进行证明:</p>
<p>不妨设<span class="math inline">\(f ( a ) = f ( a + 0 ) , G =
\int_a^x g ( x ) \text{ d } x\)</span>是<span class="math inline">\(g\)</span>的广义原函数,其满足<span class="math inline">\(G ( a ) = 0\)</span>,不妨设<span class="math inline">\(M = \sup G , m = \inf G\)</span>,回忆到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f g \text{ d } x &amp; = \lim_{ \lambda ( \Delta ) \to 0 }
\sum_{ i = 1 }^n f ( x_{ i - 1 } ) \int_{ x_{ i - 1 } }^{ x_i } g \text{
d } x \\
&amp; = \sum_{ i = 1 }^n f ( x_{ i - 1 } ) ( G ( x_i ) - G ( x_{ i - 1 }
) ) \\
&amp; = f ( x_{ n - 1 } ) G ( x_n ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{
i - 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\
&amp; \leq f ( a ) M
\end{aligned}
\]</span></p>
<p>在最后一步放缩进行修改就可以改为<span class="math inline">\(\geq f (
a ) m\)</span>,而我们已经得知<span class="math inline">\(G\)</span>的连续性,因此用介值性就可以解决上述问题.</p>
<p>难点在于(4)如何证明.</p>
<p>当其不是几乎常值函数的时候,应该满足<span class="math inline">\(f ( a
+ 0 ) &gt; f ( b - 0 )\)</span>.</p>
<p>当<span class="math inline">\(\int_a^b f g \text{ d } x =
0\)</span>的时候,如果迫不得已必须取端点就应当有<span class="math inline">\(\forall \xi \in ( a , b )\)</span>,都有<span class="math inline">\(\int_a^\xi g \text{ d } x \ne
0\)</span>,由于其连续导出的介值性那就当然拿到了<span class="math inline">\(G\)</span>的保号性.我们上面已经用Abel变换得到了:</p>
$$
<span class="math display">\[\begin{aligned}
\int_a^b f g \text{ d } x &amp; = \sum_{ i = 1 }^n f ( x_{ i - 1 } ) ( G
( x_i ) - G ( x_{ i - 1 } ) ) \\
&amp; = f ( x_{ n - 1 } ) G ( x_n ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{
i - 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时考虑取<span class="math inline">\(c , d\)</span>使得<span class="math inline">\(a &lt; c &lt; d &lt; b\)</span>,并且满足<span class="math inline">\(f ( c ) &gt; f ( d )\)</span>,由于<span class="math inline">\(f\)</span>并不是几乎常值函数,这当然可以做到,上式每一项都是<span class="math inline">\(\geq 0\)</span>的,那就可以把区间从<span class="math inline">\([ a , b ]\)</span>重新控制到<span class="math inline">\([ c , d ]\)</span>中.于是此时上式立刻:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
\geq &amp; ( f ( c ) - f ( d ) ) \min_{ [ c , d ] } G ( x ) &gt; 0
\end{aligned}
\]</span></p>
<p>然而我们假设中<span class="math inline">\(\int_a^b f g \text{ d } x =
0\)</span>,这样就导出了矛盾.</p>
<p>接下来考虑<span class="math inline">\(\int_a^b f g \text{ d } x \ne
0\)</span>的情况,如果其迫不得已必须取在端点的话当然要取到右端点此时应该有<span class="math inline">\(\int_a^b f g \text{ d } x = f ( a ) \int_a^b g
\text{ d } x\)</span>.</p>
<p>仍然看上面的Abel变换后的结果,同时按照上面同样的办法取出一个子区间<span class="math inline">\([ c , d
]\)</span>.回忆到为了保证前面都没有能和<span class="math inline">\(G ( b
)\)</span>相同的,因此<span class="math inline">\(G ( b
)\)</span>必然是前面的最大值.再回忆到<span class="math inline">\(G ( a )
= 0\)</span>,立刻能得到<span class="math inline">\(G ( b ) &gt; \sup_{ [
a , c ] } G ( x )\)</span>,设后者为<span class="math inline">\(M\)</span>,应当有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
= &amp; f ( x_{ n - 1 } ) G ( b ) + \sum_{ i = 1 }^{ n - 1 } ( f ( x_{ i
- 1 } ) - f ( x_{ i } ) ) G ( x_i ) \\
\leq &amp; f ( x_{ n - 1 } ) G ( b ) + M ( f ( a ) - f ( c ) ) + G ( b )
( f ( c ) - f ( b ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里这个<span class="math inline">\(f ( x_{ n - 1 }
)\)</span>很烦,但是当<span class="math inline">\(\lambda ( \Delta ) \to
0\)</span>的时候当然会使得<span class="math inline">\(f ( x_{ n - 1 } )
\to f ( b - 0 )\)</span>,上式变更为:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f g \text{ d } x \\
\leq &amp; f ( b ) G ( b ) + M ( f ( a ) - f ( c ) ) + G ( b ) ( f ( c )
- f ( b ) ) \\
= &amp; M ( f ( a ) - f ( c ) ) + G ( b ) f ( c ) \\
&lt; &amp; f ( a ) G ( b )
\end{aligned}
\]</span></p>
<p>这就导出了矛盾.</p>
<p>最后来看(3),不妨设<span class="math inline">\(f\)</span>单减,设<span class="math inline">\(\varphi ( x ) = f ( x ) - f ( b ) \geq
0\)</span>且单减,用(1)的结论得到<span class="math inline">\(\exists \xi
\in [ a , b ]\)</span>使得<span class="math inline">\(\int_a^b \varphi g
\text{ d } x = \varphi ( a ) \int_a^\xi g \text{ d }
x\)</span>.变形后就可以得到原本的式子.单增是同理的.总之,(3)是(1)(2)的一个更为优美的推论.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f \in C^1 [ a , b
]\)</span>,并且满足<span class="math inline">\(f
&#39;\)</span>单调递减,且<span class="math inline">\(f &#39; ( b ) \geq
M &gt; 0\)</span>.求证:<span class="math inline">\(| \int_a^b \cos f ( x
) \text{ d } x | \leq \frac{ 2 }{ M }\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_a^b \cos f ( x ) \text{ d } x \\
= &amp; \int_a^b \frac{ f &#39; \cos f }{ f &#39; } \text{ d } x \\
= &amp; \frac{ 1 }{ f &#39; ( b ) } \int_\xi^b f &#39; \cos f \text{ d }
x \\
= &amp; \frac{ 1 }{ f &#39; ( b ) } ( \sin f ( b ) - \sin f ( \xi ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就完事了.</p>
<h5><span id="有界变差函数">有界变差函数</span></h5>
<p>对于一个<span class="math inline">\(f : [ a , b ] \to
R\)</span>的函数,做分划<span class="math inline">\(\Delta : a = x_0 &lt;
\cdots &lt; x_n = b\)</span>,定义其变差为<span class="math inline">\(V_\Delta = \sum_k | f ( x_i ) - f ( x_{ i - 1 } )
|\)</span>,定义其全变差为<span class="math inline">\(V_{ [ a , b ] } ( f
) = \sup_\Delta V_\Delta\)</span>.当全变差为有限的时候,称<span class="math inline">\(f\)</span>是有界变差函数.容易见到由介值定理,如果<span class="math inline">\(f\)</span>可导而且<span class="math inline">\(f
&#39;\)</span>可积,则<span class="math inline">\(V_{ [ a , b ] } ( f ) =
\int_a^b | f &#39; | \mathrm{ d } x\)</span>.</p>
<p>应当容易见到,闭区间上的单调函数是有界变差的,且<span class="math inline">\(V_{ | f | } \leq V_f , V_{ f + g } \leq V_f +
V_g\)</span>.</p>
<p>接下来我们来证明:<span class="math inline">\(f\)</span>是有界变差函数,当且仅当<span class="math inline">\(f\)</span>是两个单调(不一定严格)函数的差.或者更严格一点,可以写成两个单调不减函数的差.另外,作为这个命题的平凡推论,我们知道有界变差函数几乎处处可导,并且有至多可数个间断点,且只有第一类间断点.</p>
<p>充分性显然,下面来看必要性.假设<span class="math inline">\(f\)</span>是有界变差的,此时类似积分可以定义一个变上限函数<span class="math inline">\(V_f ( x ) = V_f [ a , x
]\)</span>,其显然是单调不降的.</p>
<p>接下来定义<span class="math inline">\(g = V_f ( x ) - f ( x
)\)</span>,我们来说明它一定也是单调不减的.</p>
<p>那考虑当<span class="math inline">\(x_2 &gt; x_1\)</span>时,观察<span class="math inline">\(g ( x_2 ) - g ( x_1 ) = V_f ( x_2 ) - V_f ( x_1 )
- ( f ( x_2 ) - f ( x_1 ) )\)</span>.</p>
<p>既然全变差的定义依赖于分划,我们当然可以加分点,自然有<span class="math inline">\(V_f ( x_2 ) - V_f ( x_1 ) = V_{ f , [ x_1 , x_2 ]
} \geq | f ( x_2 ) - f ( x_1 ) | \geq f ( x_2 ) - f ( x_1
)\)</span>.</p>
<p>自然得证.</p>
<p>可应当意识到连续函数不一定是有界变差函数,原因仍然考虑<span class="math inline">\(f ( x ) = \begin{cases}0 &amp; x = 0 \\ x \sin
\frac{ 1 }{ x } &amp; \text{ otherwise
}\end{cases}\)</span>.在闭区间<span class="math inline">\([ 0 , 1
]\)</span>上取<span class="math inline">\(x_k = \frac{ 1 }{ ( k + \frac{
1 }{ 2 } ) \pi }\)</span>,这样<span class="math inline">\(\sin \frac{ 1
}{ x_i }\)</span>的取值正负交替,容易见到出现了调和级数.</p>
<p>然而,稍微加点条件,我们可以证明李氏连续是有界变差的.可以直接套用定义,也可以回忆到<span class="math inline">\(f ( x ) = f ( x ) - Lx + Lx = Lx - ( Lx - f ( x )
)\)</span>.因此导函数有界就一定有界变差.并且此时,可以让其拆出两个不降的可导函数.</p>
<h5><span id="定积分的应用">定积分的应用</span></h5>
<h6><span id="example1图形证明不等式">Example1(图形证明不等式)</span></h6>
<p>回忆到我们证明积分形式的柯西不等式的时候,证明了当<span class="math inline">\(\frac{ 1 }{ p } + \frac{ 1 }{ q } =
1\)</span>时,<span class="math inline">\(a^{ \frac{ 1 }{ p } } b^{
\frac{ 1 }{ q } } = e^{ \frac{ \ln a }{ p } + \frac{ \ln b }{ q } } \leq
\frac{ a }{ p } + \frac{ b }{ q }\)</span>.</p>
<p>下面可以用类似的策略理解这个式子,首先等价于证明<span class="math inline">\(ab \leq \frac{ a^p }{ p } + \frac{ b^q }{ q
}\)</span>.原因是考虑设<span class="math inline">\(S_1 = \frac{ a^p }{ p
} , S_2 = \frac{ b^q }{ q }\)</span>,设<span class="math inline">\(f ( x
) = x^{ p - 1 }\)</span>,留意到<span class="math inline">\(f ( x
)\)</span>的积分表示出了<span class="math inline">\(S_1\)</span>,而<span class="math inline">\(f^{ - 1 } ( x )\)</span>恰好表示出了<span class="math inline">\(S_2\)</span>.</p>
<h6><span id="example2参数方程曲线面积">Example2(参数方程曲线面积)</span></h6>
<p>回忆到换元法,取参数方程<span class="math inline">\(\begin{cases}x = x
( t ) \\ y = y ( t )\end{cases}\)</span>,此时不妨假设<span class="math inline">\(x ( \alpha ) = a , x ( \beta ) =
b\)</span>,且<span class="math inline">\(x ( t
)\)</span>单调递增且连续,<span class="math inline">\(x &#39; ( t
)\)</span>除有限点外都存在且黎曼可积.那当然应当有:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \text{ d } x = \int_\alpha^\beta y ( t ) x &#39; ( t )
\text{ d } t
\]</span></p>
<p>注意到如果反之条件使得<span class="math inline">\(x ( \alpha ) = b ,
x ( \beta ) = a\)</span>,则需要补一个<span class="math inline">\(-
1\)</span>.</p>
<p>由此可见,对于不自交的任意参数方程表示的曲线,直接积分的正负号一抵消,仍然可以求出曲线下方的面积.如果自交,就是要把自交部分的面积减去.顺便而言,简单封闭曲线(例如圆或者椭圆)当然是上述我们所说的特殊情况.</p>
<p>不过对于封闭曲线,由于转一圈会回到同一个点处,使用分部积分得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_\alpha^\beta y x &#39; \text{ d } t \\
= &amp; \int_\alpha^\beta y \text{ d } x \\
= &amp; xy |_a^b - \int_\alpha^\beta xy &#39; \text{ d } t \\
= &amp; - \int_\alpha^\beta xy &#39; \text{ d } t
\end{aligned}
\]</span></p>
<p>兼顾一下对称性,可以写作<span class="math inline">\(S = \frac{ 1 }{ 2
} | \int_\alpha^\beta ( x &#39; y - y &#39; x ) \text{ d } t
|\)</span>.由此立刻得到椭圆面积为<span class="math inline">\(ab
\pi\)</span>.</p>
<h6><span id="example3极坐标的面积">Example3(极坐标的面积)</span></h6>
<p>设<span class="math inline">\(r = r ( \theta ) , \theta \in [ \alpha
, \beta ] , r ( \theta ) \in C ( \alpha , \beta )\)</span>.</p>
<p>此时考虑对<span class="math inline">\(\theta\)</span>做划分,取<span class="math inline">\(\Delta : \alpha = \theta_0 &lt; \cdots &lt;
\theta_n = \beta\)</span>,并取<span class="math inline">\(m_i = \inf_{ [
\theta_{ i - 1 } , \theta_i ] } r , M_i = \sup_{ [ \theta_{ i - 1 } ,
\theta_i ] }\)</span>,立刻得到<span class="math inline">\(\frac{ 1 }{ 2
} m_i^2 \Delta \theta_i \leq \Delta S_i \leq \frac{ 1 }{ 2 } \sum M_i^2
\Delta \theta_i\)</span>,这样加密后得到<span class="math inline">\(S =
\frac{ 1 }{ 2 } \int_\alpha^\beta r^2 ( \theta ) \text{ d }
\theta\)</span>.</p>
<h6><span id="example4参数方程曲线的弧长">Example4(参数方程曲线的弧长)</span></h6>
<p>取参数方程<span class="math inline">\(\begin{cases}x = x ( t ) \\ y =
y ( t )\end{cases}\)</span>,并且假设<span class="math inline">\(x ,
y\)</span>均连续.首先我们应当定义其”弧长”的含义.</p>
<p>可以使用折线逼近的策略定义弧长.具体而言,直接取分划<span class="math inline">\(\Delta : \alpha = t_0 &lt; \cdots &lt; t_n =
\beta\)</span>.定义一个点<span class="math inline">\(P_i = ( x ( t_i ) ,
y ( t_i )
)\)</span>,这样我们当然就得到了若干个点,在这些点上就可以将相邻两个点求出折线,设折线长为<span class="math inline">\(\overline{ M_{ i - 1 } M_i }\)</span>.</p>
<p>接下来,称曲线是可求长的,当且仅当取出的折线的上确界是有限的,并将此上确界定义为曲线长.</p>
<p>我们接下来证明,其可求长当且仅当<span class="math inline">\(x ( t
)\)</span>和<span class="math inline">\(y ( t
)\)</span>都是有界变差的.</p>
<p>先看必要性,任取分划<span class="math inline">\(\Delta : \alpha = t_0
&lt; \cdots &lt; t_n = \beta\)</span>.立刻得到<span class="math inline">\(V_\Delta ( x ) = \sum | x_i - x_{ i - 1 } | \leq
\sum \overline{ M_{ i - 1 } M_i }\)</span>,当然是有界的,对于<span class="math inline">\(y ( t )\)</span>同理.</p>
<p>另外,斜边小于两条直角边的和(三角形不等式),于是充分性也显然.</p>
<p>然而真要实际应用需要稍加条件,即:<span class="math inline">\(x ( t ) ,
y ( t
)\)</span>可导且导函数黎曼可积(说明其导函数有界,为李氏连续函数,那自然是有界变差函数).则弧长为<span class="math inline">\(\int_\alpha^\beta \sqrt{ ( x &#39; ( t ) )^2 + ( y
&#39; ( t ) )^2 } \text{ d } t\)</span>.</p>
<p>证明比较容易,考虑勾股定理,<span class="math inline">\(\overline{ M_{
i - 1 } M_i } = \sqrt{ ( x ( t_i ) - x ( t_{ i - 1 } ) )^2 + ( y ( t_i )
- y ( t_{ i - 1 } ) )^2 }\)</span>.使用微分中值定理,得到其等于<span class="math inline">\(\Delta t_i \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \eta_i ) )^2 }\)</span>.这里强行换成一个东西,于是就会得到<span class="math inline">\(\Delta t_i \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \xi_i ) )^2 } + w_i\)</span>的形式,其中<span class="math inline">\(w_i\)</span>恰为两项之差.然后换黎曼和,只需证明后者<span class="math inline">\(w_i\)</span>随着加密而趋向于<span class="math inline">\(0\)</span>.而这个根号差可以做分子有理化.具体而言:</p>
<p><span class="math display">\[
\begin{aligned}
w_i &amp; = \Delta t_i \left ( \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y
&#39; ( \eta_i ) )^2 } - \sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; (
\xi_i ) )^2 } \right ) \\
&amp; = \Delta t_i \frac{ y &#39; ( \eta_i )^2 - y &#39; ( \xi_i )^2 }{
\sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; ( \eta_i ) )^2 } + \sqrt{ ( x
&#39; ( \xi_i ) )^2 + ( y &#39; ( \xi_i ) )^2 } } \\
&amp; = \Delta t_i \frac{ ( y &#39; ( \eta_i ) + y &#39; ( \xi_i ) ) }{
\sqrt{ ( x &#39; ( \xi_i ) )^2 + ( y &#39; ( \eta_i ) )^2 } + \sqrt{ ( x
&#39; ( \xi_i ) )^2 + ( y &#39; ( \xi_i ) )^2 } } ( y &#39; ( \eta_i ) -
y &#39; ( \xi_i ) ) \\
&amp; \leq \Delta t_i ( y &#39; ( \eta_i ) - y &#39; ( \xi_i ) )
\end{aligned}
\]</span></p>
<p>最后会得到<span class="math inline">\(\leq \sum \omega_{ y &#39; }
\Delta t_i\)</span>,立刻得到其趋向于<span class="math inline">\(0\)</span>.顺便还要证明这个是上确界,只需要证明加点后答案增加即可,然后用黎曼积分那一部分的对划分取并的技巧即可.</p>
<p>由此应当能推出直角坐标系下弧长公式,即<span class="math inline">\(l =
\int_a^b \sqrt{ 1 + ( f &#39; ( x ) )^2 } \text{ d } x\)</span>.</p>
<h6><span id="example5极坐标下的弧长公式">Example5(极坐标下的弧长公式)</span></h6>
<p>此时应当有<span class="math inline">\(x &#39; = r &#39; \cos \theta -
r \sin \theta , y &#39; = r &#39; \sin \theta + r \cos
\theta\)</span>,注意到<span class="math inline">\(( x &#39; )^2 + ( y
&#39; )^2 = r^2 + ( r &#39; )^2\)</span>,于是极坐标下的公式当然是<span class="math inline">\(l = \int_\alpha^\beta \sqrt{ r^2 + ( r &#39; )^2 }
\text{ d } \theta\)</span>.</p>
<h6><span id="example6等周不等式">Example6(等周不等式)</span></h6>
<p>求给定长度的闭合曲线能围出的最大面积.</p>
<p>设<span class="math inline">\(\Gamma\)</span>是一个周长为<span class="math inline">\(l\)</span>的简单可求长闭曲线,其面积为<span class="math inline">\(A\)</span>,我们下面证明<span class="math inline">\(A \leq \frac{ l^2 }{ 4 \pi }\)</span>.</p>
<p>先考虑<span class="math inline">\(\Gamma\)</span>比较光滑的情况,也就是其有导函数且导函数可积.参数方程给出<span class="math inline">\(l = \int_\alpha^\beta \sqrt{ ( x &#39; )^2 + ( y
&#39; )^2 } \text{ d } \theta\)</span>而<span class="math inline">\(A =
\int_\alpha^\beta xy &#39; \text{ d }
\theta\)</span>.注意这里假设曲线是逆时针方向旋转的.</p>
<p>接下来,考虑在原基础上画个圆,这个圆的参数方程横坐标继承自上述<span class="math inline">\(x ( \theta )\)</span>而纵坐标由圆定义为<span class="math inline">\(\bar{ y } = \pm \sqrt{ r^2 - x^2
}\)</span>,这里的<span class="math inline">\(2 r = \sup x - \inf
x\)</span>.也就是横着的最长距离.为了使得这个圆转起来是合理的,实际上应该找到上述曲线的左右端点然后分段函数定义,我们这里略去此细节.</p>
<p>然后呢,此时观察到应当有<span class="math inline">\(\pi r^2 = -
\int_\alpha^\beta \bar{ y } x &#39; \text{ d }
\theta\)</span>,发挥注意力得到:</p>
<p><span class="math display">\[
\begin{aligned}
2 \sqrt{ A \pi r^2 } &amp; \leq A + \pi r^2 \\
&amp; = \int_\alpha^\beta ( xy &#39; + \bar{ y } x &#39; ) \text{ d }
\theta \\
&amp; \leq \int_\alpha^\beta \sqrt{ x^2 + ( \bar{ y } )^2 } \sqrt{ y
&#39;^2 + x &#39;^2 } \text{ d } t \\
&amp; = rl
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<p>那么不光滑怎么办呢?可以用分段光滑函数(比如折线)逼近,这样就行了.</p>
<h6><span id="example7求多面体体积">Example7(求多面体体积)</span></h6>
<p>体积的定义无非类似面积,用夹逼定理定义任意形状的体积.</p>
<p>考虑对于每个<span class="math inline">\(x\)</span>,在<span class="math inline">\(x\)</span>那里做截面,设得到的截面面积是<span class="math inline">\(S ( x )\)</span>,那么体积感觉上应当是<span class="math inline">\(V = \int_a^b S ( x ) \text{ d } x\)</span>.</p>
<p>然而这个结论的准确证明可能需要一些重积分知识.我们尝试越级打怪,加一个很神秘的条件:就是两个截面之间一定存在包含关系以及<span class="math inline">\(S ( x )\)</span>是关于<span class="math inline">\(x\)</span>连续变化的.然后看看能不能把这个结论证出来.</p>
<p>考虑<span class="math inline">\(x\)</span>的范围是<span class="math inline">\([ a , b ]\)</span>,接下来对其作分划<span class="math inline">\(\Delta : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>.接下来取<span class="math inline">\(\eta_i ,
\xi_i\)</span>满足<span class="math inline">\(S ( \xi_i ) = \max_{ [ x_{
i - 1 } , x_i ] } S ( x ) , S ( \eta_i ) = \min_{ [ x_{ i - 1 } , x_i ]
} S ( x )\)</span>.此时回忆到包含关系,那么我们拿出来的<span class="math inline">\(\xi_i\)</span>和<span class="math inline">\(\eta_i\)</span>当然就是包含别人以及被包含的两个截面,以它们为底面积做柱体,留意到此时当然有:</p>
<p><span class="math display">\[
S ( \eta_i ) ( x_{ i } - x_{ i - 1 } ) \leq V_{ [ x_{ i - 1 } , x_i ] }
\leq S ( \xi_i ) ( x_i - x_{ i - 1 } )
\]</span></p>
<p>回忆到假设<span class="math inline">\(S ( x
)\)</span>是连续变化的因此黎曼可积,于是这个东西两边其实就是达布上下和,立刻得到积分的结论.</p>
<p>旋转体当然满足以上条件,易见旋转体的体积为<span class="math inline">\(\pi \int_a^b f^2 ( x ) \mathrm{ d }
x\)</span>,参数方程同理.</p>
<h6><span id="example8旋转体的侧面积公式">Example8(旋转体的侧面积公式)</span></h6>
<p>曲面的面积难以定义,所以我们现在暂时成为物理系学生.下面只考虑旋转体.</p>
<p>对于旋转体来说,先用折线逼近原曲线,然后旋转后得到若干圆台,用圆台的侧面积之和去逼近旋转体的侧面积.</p>
<p>对于<span class="math inline">\([ a , b
]\)</span>,我们先做一个分划<span class="math inline">\(\Delta : a = x_0
&lt; \cdots &lt; x_n = b\)</span>,<span class="math inline">\(y_i = f (
x_i )\)</span>.圆台侧面积给出<span class="math inline">\(\Delta S_i =
\pi ( y_{ i - 1 } + y_i ) | \overline{ M_{ i - 1 } M_i } | = \pi ( y_{ i
- 1 } + y_i ) \sqrt{ 1 + ( \cfrac{ y_i - y_{ i - 1 } }{ x_i - x_{ i - 1
} } )^2 } \Delta x_i\)</span>,利用微分中值定理,就有:</p>
<p><span class="math display">\[
\begin{aligned}
S_i &amp; = \pi ( y_{ i - 1 } + y_i ) \sqrt{ 1 + ( f &#39; ( \xi_i ) )^2
} \Delta x_i \\
&amp; = 2 \pi f ( \xi_i ) \sqrt{ 1 + ( f &#39; ( \xi_i ) )^2 } \Delta
x_i + ( y_i + y_{ i - 1 } - 2 \pi f ( \xi_i ) ) \sqrt{ 1 + ( f &#39; (
\xi_i ) )^2 } \Delta x_i
\end{aligned}
\]</span></p>
<p>加密后第二项可以用振幅控制住,所以答案就是<span class="math inline">\(2 \pi \int_a^b f ( x ) \sqrt{ 1 + ( f &#39; ( x )
)^2 } \mathrm{ d } x\)</span>.</p>
<p>对于参数方程当然也是平凡的,答案应当是<span class="math inline">\(2
\pi \int_a^b y \sqrt{ 1 + ( \frac{ y &#39; }{ x &#39; } )^2 } x &#39;
\mathrm{ d } t = 2 \pi \int_a^b y \sqrt{ ( x &#39; )^2 + ( y &#39; )^2 }
\mathrm{ d } t\)</span>,注意这里是按照<span class="math inline">\(x\)</span>轴翻转.应当看到由此一段球面上的环的面积就是<span class="math inline">\(2 \pi r \Delta x\)</span>.</p>
<h6><span id="example9pi的无理性证明">Example9(<span class="math inline">\(\pi\)</span>的无理性证明)</span></h6>
<p>假设<span class="math inline">\(\pi = \frac{ p }{ q } \in \mathbb{ Q
}\)</span>并且<span class="math inline">\(p \bot q , p , q \in \mathbb{
N_+ }\)</span>.</p>
<p>考虑设<span class="math inline">\(f_n ( x ) = q^n x^n ( p - qx
)^n\)</span>,留意到<span class="math inline">\(\forall 0 \leq i \leq n -
1\)</span>,有<span class="math inline">\(f_n^{ ( i ) } ( 0 ) = f_n^{ ( i
) } ( \pi ) = 0\)</span>.</p>
<p>接下来考察<span class="math inline">\(\forall n \leq i \leq 2
n\)</span>,此时留意到<span class="math inline">\(f_n^{ ( i ) } ( 0
)\)</span>和<span class="math inline">\(f_n^{ ( i ) } ( \pi
)\)</span>都应当是整数并且是<span class="math inline">\(n
!\)</span>的倍数(是<span class="math inline">\(0\)</span>也是<span class="math inline">\(n !\)</span>的倍数).</p>
<p>考虑积分<span class="math inline">\(I_n = \frac{ 1 }{ n ! }
\int_0^\pi f_n ( x ) \sin x \mathrm{ d } x &gt;
0\)</span>.对其狂暴使用分部积分:</p>
$$
<span class="math display">\[\begin{aligned}
I_n &amp; = \frac{ 1 }{ n ! } \int_0^\pi f_n ( x ) \sin x \mathrm{ d } x
\\
&amp; = \frac{ 1 }{ n ! } \int_0^\pi f_n ( x ) \mathrm{ d } ( - \cos x )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>不断做分部积分,前面扔出来的项也就是<span class="math inline">\(f_n^{
( i ) } ( 0 )\)</span>或者<span class="math inline">\(f_n^{ ( i ) } (
\pi )\)</span>然后再乘上<span class="math inline">\(\sin ,
\cos\)</span>在<span class="math inline">\(0 ,
\pi\)</span>之类取值的问题.总之,这个东西算出来一定是<span class="math inline">\(n !\)</span>的倍数,前面乘了个<span class="math inline">\(\frac{ 1 }{ n !
}\)</span>,他就一定是整数.又因为其大于<span class="math inline">\(0\)</span>,他就一定<span class="math inline">\(\geq 1\)</span>.</p>
<p>那么矛盾在哪呢?留意到<span class="math inline">\(f_n = ( qx ( p - qx
) )^n \leq ( \frac{ p }{ 2 } )^{ 2 n } , \sin x \leq
1\)</span>,所以<span class="math inline">\(I_n \leq \frac{ 1 }{ n ! } (
\frac{ p }{ 2 } )^{ 2 n } \pi \to 0\)</span>.</p>
<h6><span id="example10古鲁金第一定理">Example10(古鲁金第一定理)</span></h6>
<p>躲开微元法,要证明一些东西可以扔进去的话(比如密度函数),应当可以通过”平均密度”的概念用之前那个引理(分部积分那里,步骤是先积分,乘系数,后求和),总之都是平凡的.</p>
<p>考虑一个旋转体,反正用上面那套东西,搞出来质心应当有<span class="math inline">\(\bar{ y } = \frac{ \int_\alpha^\beta y \sqrt{ x
&#39;^2 + y &#39;^2 } \mathrm{ d } t }{ l }\)</span>.移项得到<span class="math inline">\(2 \pi \bar{ y } l = 2 \pi \int_\alpha^\beta y
\sqrt{ x &#39;^2 + y &#39;^2 } \mathrm{ d }
t\)</span>.也就是:旋转线转一圈,质心周长乘以曲线的弧长等于侧面积.</p>
<h6><span id="example11古鲁金第二定理">Example11(古鲁金第二定理)</span></h6>
<p>考虑两条曲线夹起来的部分,也就是设<span class="math inline">\([ a , b
]\)</span>上有<span class="math inline">\(f ( x ) \geq g ( x ) \geq
0\)</span>,那这两条线就会围出一块二维出来.这一块的质心能不能求呢?当然也可以,只不过略有区别,<span class="math inline">\(\bar{ x } = \frac{ \int_a^b x ( f ( x ) - g ( x )
\mathrm{ d } x ) }{ S }\)</span>,而<span class="math inline">\(\bar{ y }
= \frac{ 1 }{ 2 } \frac{ \int_a^b ( f^2 ( x ) - g^2 ( x ) \mathrm{ d } x
) }{ S }\)</span>.移项得到<span class="math inline">\(2 S \bar{ y } =
\int_a^b ( f^2 ( x ) - g^2 ( x ) \mathrm{ d } x
)\)</span>,也就是旋转面转一圈,质心周长乘以面积等于体积.</p>
<h6><span id="example12转动惯量">Example12(转动惯量)</span></h6>
<p>定义为<span class="math inline">\(J = \int mr^2\)</span>.</p>
<p>考虑以<span class="math inline">\(x\)</span>轴为旋转轴,先考虑线的情况,无非是分成小段每一段分别处理,对于每一段用长度和密度的乘积来逼质量,关于<span class="math inline">\(x\)</span>轴的转动惯量<span class="math inline">\(J = \int_\alpha^\beta y^2 ( t ) \rho ( t ) \sqrt{
( x &#39; ( t ) )^2 + ( y &#39; ( t ) )^2 } \text{ d } t\)</span>.</p>
<h6><span id="example13">Example13</span></h6>
<p>设<span class="math inline">\(F\)</span>是所有满足<span class="math inline">\(f \in C^1 [ 0 , 1 ] \mid f ( 0 ) = 0 , f ( 1 ) = 1
, f &#39; \geq 0\)</span>,<span class="math inline">\(f
&#39;\)</span>单调不降的函数<span class="math inline">\(f\)</span>组成的集合,记<span class="math inline">\(S_f\)</span>为<span class="math inline">\(f ( x
)\)</span>绕<span class="math inline">\(x\)</span>轴转一圈得到的侧面积,求<span class="math inline">\(\sup_{ f \in F } S_f\)</span>和<span class="math inline">\(\inf_{ f \in F } S_f\)</span>.</p>
<p>先猜下确界是<span class="math inline">\(\pi\)</span>,上确界是<span class="math inline">\(\sqrt{ 2 } \pi\)</span>.</p>
<p>先证明下界是对的,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S_f &amp; = 2 \pi \int_0^1 f \sqrt{ 1 + ( f &#39; )^2 } \mathrm{ d } x
\geq 2 \pi \int_0^1 f \cdot f &#39; \mathrm{ d } x \\
&amp; = \pi
\end{aligned}
\]</span></p>
<p>怎么逼近呢?这个当然是直接平的是最优秀的对吧,考虑<span class="math inline">\(f_n ( x ) = x^n\)</span>,发现:</p>
<p><span class="math display">\[
\pi \leq S_{ f_n } \leq 2 \pi \int_0^1 f_n ( 1 + f_n &#39; ) \mathrm{ d
} x = \pi + 2 \pi \int_0^1 f_n \mathrm{ d } x = \pi + \frac{ 2 \pi }{ n
+ 1 } \to \pi
\]</span></p>
<p>上界怎么搞定呢?考虑肯定是<span class="math inline">\(f ( x ) =
x\)</span>是最好的,我们下面证明任意一段曲线,如果把曲线拉直就更优秀.</p>
<p>也就是考虑<span class="math inline">\(( 0 , 0 )\)</span>和<span class="math inline">\(( x_0 , f ( x_0 ) )\)</span>的连线<span class="math inline">\(y = \frac{ f ( x_0 ) }{ x_0 }
x\)</span>,容易见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ x_0 } y \sqrt{ 1 + ( y &#39; )^2 } \mathrm{ d } x \\
= &amp; \int_0^{ x_0 } \frac{ f ( x_0 ) }{ x_0 } x \sqrt{ 1 + ( \frac{ f
( x_0 ) }{ x_0 } )^2 } \mathrm{ d } x \\
= &amp; \frac{ 1 }{ 2 } f ( x_0 ) \sqrt{ x_0^2 + f ( x_0 )^2 }
\end{aligned}
\]</span></p>
<p>只要我们证明:</p>
<p><span class="math display">\[
\int_0^x f ( t ) \sqrt{ 1 + ( f &#39; ( t ) )^2 } \mathrm{ d } t \leq
\frac{ 1 }{ 2 } f ( x ) \sqrt{ x^2 + f^2 ( x ) }
\]</span></p>
<p>即可.注意到它们在零点的取值相同,因此直接算导数之差,要证:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ 2 } f &#39; \sqrt{ x^2 + f^2 } + \frac{ x + f \cdot f &#39;
}{ 2 \sqrt{ x^2 + f^2 } } f - f \sqrt{ 1 + ( f &#39; )^2 } &amp; \geq 0
\\
2 f \sqrt{ 1 + ( f &#39; )^2 } \sqrt{ x^2 + f^2 } &amp; \leq ( x^2 + 2
f^2 ) f &#39; + xf
\end{aligned}
\]</span></p>
<p>敢算就敢赢,两边平方得到:</p>
<p><span class="math display">\[
3 f^2 x^2 + 4 f^4 \leq x^4 ( f &#39; )^2 + 2 x^3 f \cdot f &#39; + 2
xf^3 f &#39;
\]</span></p>
<p>注意到下凸函数满足<span class="math inline">\(f &#39; \geq \frac{ f
}{ x }\)</span>,上述结论刚刚好得证,出这个题的lwg老师真是高人了.</p>
<h5><span id="定积分近似计算">定积分近似计算</span></h5>
<p>考虑对<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d }
x\)</span>做数值近似,将<span class="math inline">\([ a , b
]\)</span>等分,取<span class="math inline">\(x_k = a + \frac{ k }{ n } (
b - a )\)</span>,其中<span class="math inline">\(0 \leq k \leq
n\)</span>,而<span class="math inline">\(\Delta x = \frac{ b - a }{ n
}\)</span>,<span class="math inline">\(x_{ k - \frac{ 1 }{ 2 } } =
\frac{ x_k + x_{ k - 1 } }{ 2 }\)</span>.</p>
<p>那么用黎曼和逼积分,那么无非三种方式:要么算左端点的函数值,要么算右端点的函数值,要么算中间点的函数值.</p>
<p>问题在于计算误差,我们下面证明,如果<span class="math inline">\(f\)</span>一阶可导,则:</p>
<ol type="1">
<li><p><span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x =
\frac{ b - a }{ n } \sum_{ k = 1 }^n y_k - \frac{ ( b - a )^2 }{ 2 n } f
&#39; ( \xi )\)</span></p></li>
<li><p><span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x =
\frac{ b - a }{ n } \sum_{ k = 1 }^n y_{ k - 1 } + \frac{ ( b - a )^2 }{
2 n } f &#39; ( \eta )\)</span></p></li>
</ol>
<p>两个是类似的,只证第一个,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \mathrm{ d } x - \frac{ b - a }{ n } \sum_{ k = 1
}^n y_k \\
= &amp; \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f (
x_k ) ) \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f (
x_k ) ) \mathrm{ d } ( x - x_{ k - 1 } ) \\
= &amp; - \sum_{ k = 1 }^n \int_{ x_{ k - 1 } }^{ x_k } ( x - x_{ k - 1
} ) f &#39; ( x ) \mathrm{ d } x \\
= &amp; - \sum_{ k = 1 }^n f &#39; ( \xi_k ) \int_{ x_{ k - 1 } }^{ x_k
} ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; - \sum_{ k = 1 }^n f &#39; ( \xi_k ) \frac{ ( b - a )^2 }{ 2 n^2
} \\
= &amp; - \frac{ ( b - a )^2 }{ 2 n } f &#39; ( \xi )
\end{aligned}
\]</span></p>
<p>最后一步是因为求均值也可以用介值定理.</p>
<p>那么在中点估计会怎么样呢?考虑给<span class="math inline">\(f\)</span>更好的条件,让<span class="math inline">\(f\)</span>二阶可导,则:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \mathrm{ d } x = \frac{ b - a }{ n } \sum_{ k = 1 }^n
y_{ k - \frac{ 1 }{ 2 } } - \frac{ ( b - a )^3 }{ 24 n^2 } f &#39; &#39;
( \xi )
\]</span></p>
<p>在<span class="math inline">\(x_{ k - \frac{ 1 }{ 2 }
}\)</span>处做泰勒展开,应当有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( x ) - f ( x_{ k - \frac{ 1 }{ 2 } } ) &amp; = ( x - x_{ k - \frac{ 1
}{ 2 } } ) f &#39; ( x_{ k - \frac{ 1 }{ 2 } } ) + \frac{ 1 }{ 2 } ( x -
x_{ k - \frac{ 1 }{ 2 } } )^2 f &#39; &#39; ( \xi_k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设<span class="math inline">\(m_k \leq f &#39; &#39; ( \xi_k )
\leq M_k\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ x_{ k - 1 } }^{ x_k } ( f ( x ) - f ( x_{ k - \frac{ 1 }{ 2 } } )
) \mathrm{ d } x &amp; \leq \frac{ M_k }{ 2 } \int_{ x_{ k - 1 } }^{ x_k
} ( x - x_{ k - \frac{ 1 }{ 2 } } )^2 \mathrm{ d } x \\
&amp; = M_k \frac{ ( b - a )^3 }{ 24 n^3 }
\end{aligned}
\]</span></p>
<p>用介值定理就可以求和,原命题自然得证.</p>
<p>而上面的做法是矩形逼近,能不能用梯形逼近呢?用梯形逼近的话其实无非是<span class="math inline">\(\frac{ b - a }{ n } ( \frac{ y_0 + y_n }{ 2 }
\sum_{ k = 1 }^{ n - 1 } y_k )\)</span>,然而,对于<span class="math inline">\(f \in C^2 [ a , b ]\)</span>,我们声明:</p>
<p><span class="math display">\[
\int_a^b f ( x ) \mathrm{ d } x = \frac{ b - a }{ n } ( \frac{ y_0 + y_n
}{ 2 } \sum_{ k = 1 }^{ n - 1 } y_k ) - \frac{ ( b - a )^3 }{ 12 n^2 } f
&#39; &#39; ( \xi )
\]</span></p>
<p>证明当然还是分部积分,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } ( x - x_{ k -
1 } ) \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \int_{ x_{ k - 1 } }^{ x_k } ( x
- x_{ k - 1 } ) f &#39; ( x ) \mathrm{ d } x \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \frac{ 1 }{ 2 } \int_{ x_{ k - 1
} }^{ x_k } f &#39; ( x ) \mathrm{ d } ( x - x_{ k - 1 } )^2 \\
= &amp; f ( x_k ) \frac{ b - a }{ n } - \frac{ 1 }{ 2 } f &#39; ( x_k )
( \frac{ b - a }{ n } )^2 + \frac{ 1 }{ 2 } \int_{ x_{ k - 1 } }^{ x_k }
f &#39; &#39; ( x ) ( x - x_{ k - 1 } )^2 \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>同理,在上面换<span class="math inline">\(x - x_k\)</span>而非<span class="math inline">\(x - x_{ k - 1 }\)</span>,就可以得到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; f ( x_{ k - 1 } ) \frac{ b - a }{ n } + \frac{ 1 }{ 2 } f &#39;
( x_{ k - 1 } ) ( \frac{ b - a }{ n } )^2 + \frac{ 1 }{ 2 } \int_{ x_{ k
- 1 } }^{ x_k } f &#39; &#39; ( x ) ( x - x_{ k } )^2 \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时用NL公式,应当能见到把上面两式子相加可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } f ( x ) \mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 4 } \int_{ x_{ k - 1 } }^{ x_k } f &#39; &#39; ( x ) ( ( x
- x_{ k } )^2 + ( x - x_{ k - 1 } )^2 - ( \frac{ b - a }{ n } )^2 )
\mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 2 } \int_{ x_{ k - 1 } }^{ x_k } f &#39; &#39; ( x ) ( x -
x_k ) ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; \frac{ f ( x_{ k - 1 } ) + f ( x_k ) }{ 2 } \frac{ b - a }{ n }
+ \frac{ 1 }{ 2 } f &#39; &#39; ( \xi_k ) \int_{ x_{ k - 1 } }^{ x_k } (
x - x_k ) ( x - x_{ k - 1 } ) \mathrm{ d } x \\
= &amp; \frac{ y_{ k - 1 } + y_k }{ 2 } \Delta x - \frac{ 1 }{ 12 } f
&#39; &#39; ( \xi_k ) \frac{ ( b - a )^3 }{ n^3 }
\end{aligned}
\]</span></p>
<p>这样就完事了,接下来对<span class="math inline">\(n\)</span>求个和就能得到之前的公式.</p>
<p>接下来是二次曲线逼近.考虑用<span class="math inline">\(( x_{ k - 1 }
, y_{ k - 1 } ) , ( x_{ k - \frac{ 1 }{ 2 } } , y_{ k - \frac{ 1 }{ 2 }
} ) , ( x_k , y_k
)\)</span>三个点确定一条二次曲线.不妨设这条二次曲线为<span class="math inline">\(Q_k ( x ) = px^2 + qx +
r\)</span>.然而,此时观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_{ k - 1 } }^{ x_k } Q_k ( x ) \mathrm{ d } x \\
= &amp; \frac{ p }{ 3 } ( x_k^3 - x_{ k - 1 }^3 ) + \frac{ q }{ 2 } (
x_k^2 - x_{ k - 1 }^2 ) + r ( x_k - x_{ k - 1 } ) \\
= &amp; \frac{ x_k - x_{ k - 1 } }{ 6 } ( Q_k ( x_k ) + Q_k ( x_{ k - 1
} ) + Q_k ( x_{ k - \frac{ 1 }{ 2 } } ) ) \\
= &amp; \frac{ b - a }{ 6 n } ( y_{ k - 1 } + y_k + 4 y_{ k - \frac{ 1
}{ 2 } } )
\end{aligned}
\]</span></p>
<p>这也很合理,观察一下就可以知道这个恰好是在尝试把梯形逼近和中点逼近两种方式尝试约掉后面的误差项系数.</p>
<p>定理是,如果<span class="math inline">\(f \in C^4 [ a , b
]\)</span>,误差项为<span class="math inline">\(- \frac{ ( b - a )^5 }{
2880 n^4 } f^{ ( 4 ) } ( \xi )\)</span>.这就是所谓辛普森积分法.</p>
<h5><span id="广义积分">广义积分</span></h5>
<p>考虑函数<span class="math inline">\(f : [ a , + \infty ) \to \mathbb{
R }\)</span>,如果其<span class="math inline">\(\forall b &gt;
a\)</span>,<span class="math inline">\(f \in R [ a , b
]\)</span>,我们称其<strong>内闭可积</strong>.那我们就定义其广义积分为<span class="math inline">\(\int_a^{ + \infty } f \mathrm{ d } x = \lim_{ b
\to + \infty } \int_a^b f \mathrm{ d }
x\)</span>,当后者极限存在时.同理当然可以定义区间<span class="math inline">\(( - \infty , b ]\)</span>上的广义积分.而如果<span class="math inline">\(\int_0^{ + \infty } f \mathrm{ d }
x\)</span>和<span class="math inline">\(\int_{ - \infty }^0 f \mathrm{ d
} x\)</span>都收敛,则定义它们的和为<span class="math inline">\(\int_{ -
\infty }^{ + \infty } f \mathrm{ d } x\)</span>.</p>
<p>称一个函数的<strong>瑕点</strong>为其局部无界的点,则考虑<span class="math inline">\(f : [ a , b ) \to \mathbb{ R }\)</span>,其中<span class="math inline">\(b\)</span>是<span class="math inline">\(f\)</span>的瑕点,且<span class="math inline">\(f\)</span>内闭可积,则<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x = \lim_{ A \to b -
0 } \int_a^A f ( x ) \mathrm{ d }
x\)</span>,若后者极限存在.瑕积分和上述广义积分并无明显区别,下述也不再区分.</p>
<p>在进一步讨论前,我们应当再仔细研究一下广义积分的收敛性,也就是当什么时候其极限存在呢?我们有以下命题:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( x ) \geq 0 , x \in [ a , + \infty
)\)</span>时,<span class="math inline">\(F ( A ) = \int_a^A f ( x )
\mathrm{ d } x\)</span>单增.那么此时<span class="math inline">\(F ( +
\infty )\)</span>存在当且仅当<span class="math inline">\(F ( A
)\)</span>有界.</p></li>
<li><p>比较原理:<span class="math inline">\(0 \leq f \leq cg , c &gt;
0\)</span>,若<span class="math inline">\(\int_a^{ + \infty } g \mathrm{
d } x\)</span>收敛,则<span class="math inline">\(\int_a^{ + \infty } f
\mathrm{ d } x\)</span>收敛.该结论可以移植到瑕积分上.</p></li>
<li><p>比较原理的推论:<span class="math inline">\(f , g \geq 0 , 0 &lt;
c_1 \leq \frac{ f }{ g } \leq c_2\)</span>,则<span class="math inline">\(\int f \mathrm{ d } x , \int g \mathrm{ d }
x\)</span>收敛性相同.进一步地,如果<span class="math inline">\(f , g \geq
0\)</span>,在趋近于某个瑕点的时候,<span class="math inline">\(\frac{ f
}{ g }\)</span>趋近于某个非零常数,那它们在这一点的收敛性相同.</p></li>
</ol>
<p>(1)是根据单调收敛准则,而(2)则是(1)的推论,只是给出了一个界.</p>
<p>定义函数<span class="math inline">\(f\)</span>是<strong>绝对收敛</strong>,当<span class="math inline">\(\int_a^{ + \infty } | f | \mathrm{ d } x &lt;
\infty\)</span>时.而考虑<span class="math inline">\(f = | f | - ( | f |
- f )\)</span>,而<span class="math inline">\(0 \leq | f | - f \leq 2 | f
|\)</span>,所以绝对收敛可以推出收敛,但反之不可.因此,我们将收敛但不绝对收敛的函数称为<strong>条件收敛</strong>.该结论也可以移植到瑕积分上.</p>
<p>接下来,我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\int_a^{ + \infty } f \mathrm{ d }
x\)</span>收敛的充要条件是对于<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists M &gt; a\)</span>使得<span class="math inline">\(\forall A &gt; B \geq M\)</span>,都有<span class="math inline">\(| \int_{ B }^A f \mathrm{ d } x | &lt;
\epsilon\)</span>.</p>
<p>证明当然无非是函数部分柯西收敛准则的重复应用.</p>
<p>柯西收敛原理推到瑕积分上的话,考虑<span class="math inline">\(F ( x )
= \int_a^x f ( t ) \mathrm{ d } t\)</span>,则瑕积分<span class="math inline">\(\lim_{ t \to b - 0 } F ( t
)\)</span>存在当且仅当<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists \delta &gt;
0\)</span>,当<span class="math inline">\(x_1 , x_2 \in ( b - \delta , b
)\)</span>的时候,有<span class="math inline">\(| F ( x_1 ) - F ( x_2 ) |
&lt; \epsilon\)</span>.</p>
<p>接下来还有<strong>Dirichlet-Abel判别法</strong>,设<span class="math inline">\(f , g : [ a , + \infty ) \to \mathbb{ R
}\)</span>内闭可积,<span class="math inline">\(f\)</span>单调,那有:</p>
<ol type="1">
<li><p>Dirichlet判别法:如果<span class="math inline">\(f ( + \infty ) =
0\)</span>,<span class="math inline">\(G ( A ) = \int_a^A g \mathrm{ d }
x\)</span>有界,则<span class="math inline">\(\int_a^{ + \infty } fg
\mathrm{ d } x\)</span>收敛.</p></li>
<li><p>Abel判别法:如果<span class="math inline">\(f\)</span>有界,<span class="math inline">\(\int_a^{ \infty } g \mathrm{ d }
x\)</span>收敛,则<span class="math inline">\(\int_a^{ + \infty } fg
\mathrm{ d } x\)</span>收敛.</p></li>
</ol>
<p>用第二积分中值定理,就有<span class="math inline">\(\int_A^B f g
\mathrm{ d } x = f ( A ) \int_A^\xi g \mathrm{ d } x + f ( B ) \int_{
\xi }^B g \mathrm{ d }
x\)</span>.用柯西收敛原理则上述两条均为显然.结论当然可以推广到瑕积分上.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f\)</span>在<span class="math inline">\(( - \infty , + \infty )\)</span>上内闭可积,且<span class="math inline">\(f ( + \infty ) = A , f ( - \infty ) =
B\)</span>,对于<span class="math inline">\(a &gt; 0\)</span>,求证<span class="math inline">\(\int_{ - \infty }^{ + \infty } \left ( f ( x + a )
- f ( x ) \right ) \mathrm{ d } x\)</span>收敛并求其值.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^{ C } \left ( f ( x + a ) - f ( x ) \right ) \mathrm{ d } x &amp;
= \int_{ a }^{ C + a } f ( x ) \mathrm{ d } x - \int_0^C f ( x )
\mathrm{ d } x \\
&amp; = \int_{ C }^{ C + a } f ( x ) \mathrm{ d } x - \int_0^a f ( x )
\mathrm{ d } x \\
&amp; \to aA - \int_0^a f ( x ) \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>另一侧同理为:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ - C }^{ 0 } \left ( f ( x + a ) - f ( x ) \right ) \mathrm{ d } x
&amp; = \int_{ - C + a }^{ a } f ( x ) \mathrm{ d } x - \int_{ - C }^0 f
( x ) \mathrm{ d } x \\
&amp; = - \int_{ - C }^{ - C + a } f ( x ) \mathrm{ d } x + \int_0^a f (
x ) \mathrm{ d } x \\
&amp; \to - aB + \int_0^a f ( x ) \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>于是答案是<span class="math inline">\(a ( A - B )\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:</p>
<p><span class="math display">\[
\int_{ 1 }^{ + \infty } \frac{ \mathrm{ d } x }{ x^p } = \begin{cases}
\lt \infty &amp; p \gt 1 \\
\infty &amp; p \leq 1
\end{cases}
\]</span></p>
<p>显然.</p>
<h6><span id="example3">Example3</span></h6>
<p>求证:<span class="math inline">\(\int_a^{ + \infty } \frac{ \sin^2 x
}{ x^2 } \mathrm{ d } x\)</span>收敛.</p>
<p>原因是由比较原理,所以<span class="math inline">\(0 \leq \frac{ \sin^2
x }{ x^2 } \leq \frac{ 1 }{ x^2 }\)</span>,立刻知其收敛性.</p>
<h6><span id="example4">Example4</span></h6>
<p>判断<span class="math inline">\(\int_0^{ + \infty } \frac{ x \mathrm{
d } x }{ 1 + x^4 \sin^2 x }\)</span>的收敛性.</p>
<p>考虑取<span class="math inline">\(F ( A ) = \int_0^A \frac{ x
\mathrm{ d } x }{ 1 + x^4 \sin^2 x }\)</span>,接下来考虑<span class="math inline">\(F ( n \pi ) = \sum_{ k = 1 }^n
U_k\)</span>,其中<span class="math inline">\(U_k = \int_{ ( k - 1 ) \pi
}^{ k \pi } \frac{ x \mathrm{ d } x }{ 1 + x^4 \sin^2 x }\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
U_k &amp; = \int_{ ( k - 1 ) \pi }^{ k \pi } \frac{ x \mathrm{ d } x }{
1 + x^4 \sin^2 x } \\
&amp; \geq \int_{ ( k - 1 ) \pi }^{ k \pi } \frac{ x \mathrm{ d } x }{ 1
+ ( k \pi )^4 \sin^2 x } \\
&amp; \geq 2 ( k - 1 ) \pi \int_{ 0 }^{ \frac{ \pi }{ 2 } } \frac{ x
\mathrm{ d } x }{ 1 + ( k \pi )^4 ( \sin x )^2 } \\
&amp; \geq 2 ( k - 1 ) \pi \int_{ 0 }^{ \frac{ \pi }{ 2 } } \frac{ x
\mathrm{ d } x }{ 1 + ( k \pi )^4 x^2 } \\
&amp; = \frac{ 2 ( k - 1 ) \pi }{ k^2 \pi^2 } \arctan ( k^2 \pi^2 x )
|_0^{ \frac{ \pi }{ 2 } } \\
&amp; \geq \frac{ 2 ( k - 1 ) \pi }{ k^2 \pi^2 } \arctan ( \frac{ \pi^3
}{ 2 } ) \\
&amp; = O ( \frac{ 1 }{ k } )
\end{aligned}
\]</span></p>
<p>这就证完了,必然发散.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(f : ( - \infty , + \infty ) \to \mathbb{
R }\)</span>且内闭可积,<span class="math inline">\(p &gt;
0\)</span>,并且<span class="math inline">\(\int_{ - \infty }^{ + \infty
} | f |^p \mathrm{ d } x &lt; \infty\)</span>,求证<span class="math inline">\(\lim_{ h \to 0 } \int_{ - \infty }^{ + \infty }
\left | f ( x + h ) - f ( x ) \right |^p \mathrm{ d }
x\)</span>收敛.</p>
<p>既然<span class="math inline">\(\int_{ - \infty }^{ + \infty } | f
|^p \mathrm{ d } x &lt; \infty\)</span>,那么一定存在一个足够大的<span class="math inline">\(A\)</span>,使得<span class="math inline">\(\int_{
A }^{ + \infty } | f |^p \mathrm{ d }
x\)</span>足够小,不妨取足够大的<span class="math inline">\(A &gt;
0\)</span>使得<span class="math inline">\(\int_{ A - 1 }^{ + \infty } |
f |^p \mathrm{ d } x &lt; \epsilon_1\)</span>.</p>
<p>事实上考虑<span class="math inline">\(| u + v | \leq | u | + | v |
\leq 2 \max ( | u | , | v | )\)</span>,那么<span class="math inline">\(|
u + v |^p \leq 2^p ( | u |^p + | v |^p )\)</span>,取<span class="math inline">\(| h | &lt; 1\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ A }^{ + \infty } \left | f ( x + h ) - f ( x ) \right |^p
\mathrm{ d } x \\
\leq &amp; 2^p \int_{ A }^{ + \infty } | f ( x + h ) |^p \mathrm{ d } x
+ 2^p \int_{ A }^{ + \infty } | f ( x ) |^p \mathrm{ d } x \\
= &amp; 2^p \int_{ A + h }^{ + \infty } | f ( x ) |^p \mathrm{ d } x +
2^p \int_{ A }^{ + \infty } | f ( x ) |^p \mathrm{ d } x \\
\leq &amp; 2^{ p + 1 } \int_{ A - 1 }^{ + \infty } | f |^p \mathrm{ d }
x \\
\leq &amp; 2^{ p + 1 } \epsilon_1
\end{aligned}
\]</span></p>
<p>同理,另一侧也可以放掉.现在的问题在于<span class="math inline">\(( - A
+ 1 , A - 1 )\)</span>中间这一段.</p>
<p>考虑用一个线性函数逼近,做分划<span class="math inline">\(\Delta : - A
+ 1 = x_0 &lt; \cdots &lt; x_n = A -
1\)</span>,取线性函数逼近,策略为<span class="math inline">\(x \in [ x_{
k - 1 } , x_k ]\)</span>的时候<span class="math inline">\(g ( x ) =
\frac{ f ( x_k ) - f ( x_{ k - 1 } ) }{ x_k - x_{ k - 1 } } ( x - x_{ k
- 1 } ) + f ( x_{ k - 1 } )\)</span>.接下来考虑对于每一段,设<span class="math inline">\(M_k = \sup_{ [ x_{ k - 1 } , x_k ] } f , m_k =
\inf_{ [ x_{ k - 1 } , x_k ] } f\)</span>,则每一段可以被控制为<span class="math inline">\(M_k -
m_k\)</span>.我们早在之前就提过黎曼可积的函数可被线性函数逼近,然而疑问是这种逼近能否在<span class="math inline">\(p\)</span>次方意义下满足,于是取足够小的划分使得<span class="math inline">\(\sum_{ k = 1 }^n ( M_k - m_k ) \Delta x_k &lt;
\epsilon_2^2\)</span>.</p>
<p>接下来常规分治,取<span class="math inline">\(C = \{ 1 \leq k \leq n |
M_k - m_k \geq \epsilon_2 \}\)</span>而<span class="math inline">\(B =
\{ 1 \leq k \leq n | M_k - m_k &lt; \epsilon_2 \}\)</span>.见到<span class="math inline">\(\sum_{ k \in C } \Delta x_k &lt;
\epsilon_2\)</span>.不妨设<span class="math inline">\(M = \sup_{ [ - A +
1 , A - 1 ] } f , m = \inf_{ [ - A + 1 , A - 1 ] } f\)</span>立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ - A + 1 }^{ A - 1 } \left | f - g \right |^p \mathrm{ d } x
\\
\leq &amp; \sum_{ k } | M_k - m_k |^p \Delta x_k \\
= &amp; \sum_{ k \in C } | M_k - m_k |^p \Delta x_k + \sum_{ k \in B } |
M_k - m_k |^p \Delta x_k \\
\leq &amp; | M - m |^p \epsilon_2 + \epsilon_2^p ( 2 A - 2 )
\end{aligned}
\]</span></p>
<p>这样这里就被限制住了,而考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ - \infty }^{ + \infty } \left | f ( x + h ) - f ( x )
\right |^p \mathrm{ d } x \\
\leq &amp; \int_{ - \infty }^{ + \infty } 3^p \left ( \left | f ( x + h
) - g ( x + h ) \right |^p + \left | g ( x + h ) - g ( x ) \right |^p +
\left | f ( x ) - g ( x ) \right |^p \right ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前后两项都能被上述控制住,只剩中间的<span class="math inline">\(| g (
x + h ) - g ( x ) |^p\)</span>是<span class="math inline">\(O ( h^p
)\)</span>的,只需调整<span class="math inline">\(h\)</span>就能控制住.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证:<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x } \mathrm{ d } x\)</span>是条件收敛的.</p>
<p>用DA判别法,取<span class="math inline">\(f = \frac{ 1 }{ x
}\)</span>当然趋近于<span class="math inline">\(0\)</span>,而<span class="math inline">\(| \int_1^A \sin x \mathrm{ d } x | \leq
2\)</span>,于是收敛.</p>
<p>那接下来就要证明它并非绝对收敛.只需考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_1^{ + \infty } \frac{ | \sin x | }{ x } \mathrm{ d } x \\
\geq &amp; \int_1^{ + \infty } \frac{ \sin^2 x }{ x } \mathrm{ d } x \\
= &amp; \int_1^{ + \infty } \frac{ 1 - \cos^2 x }{ x } \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>当然并不绝对收敛.</p>
<p>事实上还可以直接求出来这个积分的值.</p>
<p>接下来考虑<span class="math inline">\(f ( x ) = \begin{cases}0 &amp;
x = 0 \\ \frac{ 1 }{ x } - \frac{ 1 }{ 2 \sin \frac{ x }{ 2 } } &amp; x
\in [ - \pi , \pi ] \setminus \{ 0
\}\end{cases}\)</span>.只需泰勒展开就知道它是解析的.回忆到黎曼引理:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ \infty } \frac{ \sin x }{ x } \mathrm{ d } x \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ ( n + \frac{ 1 }{ 2 } ) \pi
} \frac{ \sin x }{ x } \mathrm{ d } x \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \frac{ \sin ( ( n +
\frac{ 1 }{ 2 } ) t ) }{ t } \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \left ( f ( t ) +
\frac{ 1 }{ 2 \sin \frac{ t }{ 2 } } \right ) \sin ( ( n + \frac{ 1 }{ 2
} ) t ) \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \frac{ 1 }{ 2 \sin
\frac{ t }{ 2 } } \sin ( ( n + \frac{ 1 }{ 2 } ) t ) \mathrm{ d } t \\
= &amp; \lim_{ n \to + \infty } \int_{ 0 }^{ \pi } \left ( \frac{ 1 }{ 2
} + \sum_{ k = 1 }^n \cos ( kt ) \right ) \mathrm{ d } t \\
= &amp; \frac{ \pi }{ 2 }
\end{aligned}
\]</span></p>
<h6><span id="example7">Example7</span></h6>
<p>给定<span class="math inline">\(f \in C [ 0 , + \infty
]\)</span>,<span class="math inline">\(\int_0^{ + \infty } f^2 \mathrm{
d } x &lt; + \infty , f ( 0 ) = 0\)</span>,取<span class="math inline">\(g ( x ) = \int_0^x f ( t ) \mathrm{ d }
t\)</span>,求证:<span class="math inline">\(\int_0^{ + \infty } \frac{
g^2 ( x ) }{ x^2 } \mathrm{ d } x \leq 4 \int_0^{ + \infty } f^2
\mathrm{ d } x\)</span>以证明前者存在.</p>
<p>当然是分部积分,用洛必达法则知道<span class="math inline">\(\lim_{ x
\to 0 } \frac{ g }{ x } \to 0\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^A \frac{ g^2 }{ x^2 } \mathrm{ d } x &amp; = \int_0^A g^2
\mathrm{ d } ( - \frac{ 1 }{ x } ) \\
&amp; = - \frac{ g^2 ( x ) }{ x } |_0^A + \int_0^A \frac{ 2 gf }{ x }
\mathrm{ d } x \\
&amp; = - \frac{ g^2 ( A ) }{ A } + 2 \int_0^A \frac{ g }{ x } f
\mathrm{ d } x \\
&amp; \leq 2 ( \int_0^A \frac{ g^2 }{ x^2 } \mathrm{ d } x )^{ \frac{ 1
}{ 2 } } ( \int_0^A f^2 \mathrm{ d } x )^{ \frac{ 1 }{ 2 } }
\end{aligned}
\]</span></p>
<p>整理一下就做完了.</p>
<h6><span id="example8欧拉积分">Example8(欧拉积分)</span></h6>
<p>求<span class="math inline">\(\int_0^{ + \infty } \frac{ x^{ p - 1 }
}{ 1 + x } \mathrm{ d } x , 0 &lt; p &lt; 1\)</span>的收敛性和值.</p>
<p>考虑<span class="math inline">\(\frac{ x^{ p - 1 } }{ 1 + x
}\)</span>在<span class="math inline">\(x \to
0\)</span>的时候趋近于<span class="math inline">\(x^{ p - 1
}\)</span>,而在<span class="math inline">\(x \to
\infty\)</span>的时候趋近于<span class="math inline">\(x^{ p - 2
}\)</span>,因此绝对收敛.</p>
<p>难点在于把这个东西求出来.接下来将采取一些不严谨的说法.</p>
<p>考虑<span class="math inline">\(0 \leq x &lt;
1\)</span>的时候,有:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ x^{ p - 1 } }{ 1 + x } &amp; = x^{ p - 1 } \sum_{ j = 0 }^\infty
( - x )^j \\
&amp; = \sum_{ j = 0 } ( - 1 )^j x^{ p + j - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>暂时抛开多余的思量,两边做积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^1 \frac{ x^{ p - 1 } }{ 1 + x } \mathrm{ d } x &amp; = \sum_{ j =
0 } ( - 1 )^j \int_0^1 x^{ p + j - 1 } \mathrm{ d } x \\
&amp; = \sum_{ j = 0 } ( - 1 )^j \frac{ 1 }{ p + j }
\end{aligned}
\]</span></p>
<p>另一边,其实只需换元,可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_1^{ + \infty } \frac{ x^{ p - 1 } }{ 1 + x } \mathrm{ d } x
\\
= &amp; \int_0^1 \frac{ t^{ 1 - p } }{ 1 + t^{ - 1 } } \frac{ \mathrm{ d
} t }{ t^2 } \\
= &amp; \int_0^1 \frac{ t^{ - p } }{ 1 + t } \mathrm{ d } t \\
= &amp; \int_0^1 \frac{ t^{ 1 - p - 1 } }{ 1 + t } \mathrm{ d } t \\
= &amp; \sum_{ j = 0 }^{ \infty } ( - 1 )^j \frac{ 1 }{ 1 - p + j } \\
= &amp; \sum_{ j = 0 }^{ \infty } ( - 1 )^{ j + 1 } \frac{ 1 }{ p - ( j
+ 1 ) } \\
= &amp; \sum_{ j = 1 }^{ \infty } ( - 1 )^{ j } \frac{ 1 }{ p - j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>结合起来,答案当然就是<span class="math inline">\(\sum_{ j = - \infty
}^{ + \infty } \frac{ ( - 1 )^j }{ p + j }\)</span>.</p>
<p>我们暂且断言上面那个无穷级数等于<span class="math inline">\(\frac{
\pi }{ \sin ( p \pi ) }\)</span>,原因是我们权且承认下述级数是正确的:</p>
<p><span class="math display">\[
\frac{ 1 }{ \sin t } = \sum_{ j = - \infty }^{ + \infty } \frac{ ( - 1
)^j }{ p + j \pi }
\]</span></p>
<h6><span id="example9frullani积分">Example9(Frullani积分)</span></h6>
<p>当<span class="math inline">\(f \in C [ 0 , + \infty
)\)</span>,且<span class="math inline">\(\int_0^{ + \infty } \frac{ f (
x ) }{ x } \mathrm{ d } x\)</span>收敛,求证<span class="math inline">\(\int_0^{ + \infty } \frac{ f ( ax ) - f ( bx ) }{
x } \mathrm{ d } x = f ( 0 ) \ln \frac{ b }{ a }\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_A^{ B } \frac{ f ( ax ) - f ( bx ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ aA }^{ aB } \frac{ f ( x ) }{ x } \mathrm{ d } x - \int_{
bA }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ aA }^{ bA } \frac{ f ( x ) }{ x } \mathrm{ d } x - \int_{
aB }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\
= &amp; \int_{ a }^{ b } \frac{ f ( Ax ) }{ x } \mathrm{ d } x - \int_{
aB }^{ bB } \frac{ f ( x ) }{ x } \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前者当<span class="math inline">\(A \to
0\)</span>的时候当然转化为<span class="math inline">\(\int_{ a }^{ b }
\frac{ f ( 0 ) }{ x } \mathrm{ d }
x\)</span>,而后者用柯西判准知道趋近于<span class="math inline">\(0\)</span>,立刻完事.</p>
<h6><span id="example10">Example10</span></h6>
<p>求<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } } \ln (
\sin x ) \mathrm{ d } x\)</span>.</p>
<p>考虑<span class="math inline">\(x \to 0\)</span>的时候,<span class="math inline">\(\ln ( \sin x ) \sim \ln x\)</span>,而<span class="math inline">\(\int \ln x = x \ln x -
x\)</span>,因此是绝对收敛的.</p>
<p>那怎么求这个积分呢?考虑一些对称技巧,立刻有:</p>
$$
<span class="math display">\[\begin{aligned}
I &amp; = \int_0^{ \frac{ \pi }{ 2 } } \ln ( \sin x ) \mathrm{ d } x \\
&amp; = \int_{ \frac{ \pi }{ 2 } }^{ \pi } \ln ( \sin x ) \mathrm{ d } x
\\
&amp; = \int_{ 0 }^{ \frac{ \pi }{ 2 } } \ln ( \cos x ) \mathrm{ d } x
\\

\end{aligned}\]</span>
<p>$$</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
I &amp; = \frac{ 1 }{ 2 } \int_0^\pi \ln ( \sin x ) \mathrm{ d } x \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \ln ( \sin 2 t ) \mathrm{ d } t \\
&amp; = \int_0^{ \frac{ \pi }{ 2 } } \left ( \ln 2 + \ln ( \sin t ) +
\ln ( \cos t ) \right ) \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } \ln 2 + 2 I
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(I = - \frac{ \pi }{ 2 } \ln
2\)</span>.</p>
<h6><span id="example11">Example11</span></h6>
<p>讨论<span class="math inline">\(\int_0^1 \frac{ \ln x }{ x^{ \alpha }
} , \alpha &gt; 0\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(x \in ( 0 , 1 ]\)</span>的时候,<span class="math inline">\(\frac{ \ln x }{ x^{ \alpha } } \leq
0\)</span>,因此其收敛性当然等价于绝对收敛性.取<span class="math inline">\(x \to 0\)</span>的部分,而考虑:</p>
<p>当<span class="math inline">\(0 &lt; \alpha &lt;
1\)</span>,任取一个足够小的<span class="math inline">\(\delta &gt;
0\)</span>使得<span class="math inline">\(0 &lt; \alpha + \delta &lt;
1\)</span>,都可以取足够逼近的<span class="math inline">\(x \to
0\)</span>使得<span class="math inline">\(| \frac{ \ln x }{ x^{ \alpha }
} | &lt; \frac{ 1 }{ x^{ \alpha + \delta }
}\)</span>.于是此时绝对收敛.反之,当<span class="math inline">\(\alpha
\geq 1\)</span>的时候,<span class="math inline">\(| \frac{ \ln x }{
x^\alpha } | &gt; \frac{ 1 }{ x }\)</span>,此时发散.</p>
<h6><span id="example12">Example12</span></h6>
<p>讨论<span class="math inline">\(p , q &gt; 0\)</span>,<span class="math inline">\(\int_2^{ + \infty } \frac{ \mathrm{ d } x }{ x^p
\ln^q x }\)</span>的收敛性.</p>
<p>当<span class="math inline">\(p &gt; 1\)</span>的时候,显然<span class="math inline">\(\frac{ 1 }{ x^p \ln^q x } &lt; \frac{ 1 }{ x^p
}\)</span>,因此当然绝对收敛.</p>
<p>当<span class="math inline">\(p &lt;
1\)</span>的时候,同Example11,只需放掉<span class="math inline">\(\ln
x\)</span>就行,因此是发散的.</p>
<p>当<span class="math inline">\(p =
1\)</span>的时候,估计出了点问题,此时做换元<span class="math inline">\(t
= \ln x\)</span>,则原式变为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ \ln 2 }^{ + \infty } e^{ - t } e^{ t } \frac{ 1 }{ t^q }
\mathrm{ d } t \\
= &amp; \int_{ \ln 2 }^{ + \infty } \frac{ 1 }{ t^q } \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以当<span class="math inline">\(q &gt; 1\)</span>的时候收敛,当<span class="math inline">\(q \leq 1\)</span>的时候发散.</p>
<h6><span id="example13">Example13</span></h6>
<p>讨论<span class="math inline">\(I = \int_0^{ \frac{ \pi }{ 2 } }
\frac{ \sin x }{ x^p } \mathrm{ d } x\)</span>的收敛性.</p>
<p>设<span class="math inline">\(f = \frac{ \sin x }{ x
}\)</span>,容易见到<span class="math inline">\(f\)</span>在<span class="math inline">\(( 0 , \frac{ \pi }{ 2 }
)\)</span>上是单调递减的,那就应当有:</p>
<p><span class="math display">\[
\frac{ 2 }{ \pi } \frac{ 1 }{ x^{ p - 1 } } \leq \frac{ \sin x }{ x^p }
= \frac{ \sin x }{ x } \frac{ 1 }{ x^{ p - 1 } } \leq \frac{ 1 }{ x^{ p
- 1 } }
\]</span></p>
<p>因此其收敛性等价于<span class="math inline">\(\int_{ 0 }^{ \frac{ \pi
}{ 2 } } \frac{ 1 }{ x^{ p - 1 } }\)</span>的收敛性,当<span class="math inline">\(p &lt; 2\)</span>时收敛.</p>
<h6><span id="example14">Example14</span></h6>
<p>设<span class="math inline">\(f \in C^2 [ a , + \infty
)\)</span>,若<span class="math inline">\(\int_a^{ + \infty } f^2 ( x )
\mathrm{ d } x &lt; + \infty , \int_a^{ + \infty } ( f &#39; &#39; )^2 (
x ) \mathrm{ d } x &lt; + \infty\)</span>,求证<span class="math inline">\(\int_a^{ + \infty } ( f &#39; )^2 ( x ) \mathrm{ d
} x &lt; + \infty\)</span>.</p>
<p>此时考虑做分部积分,当然有:</p>
$$
<span class="math display">\[\begin{aligned}
\int_a^x f ( t ) f &#39; &#39; ( t ) \mathrm{ d } t &amp; = f ( x ) f
&#39; ( x ) - f ( a ) f &#39; ( a ) - \int_a^x ( f &#39; ( t ) )^2
\mathrm{ d } t \\
f ( x ) f &#39; ( x ) &amp; = f ( a ) f &#39; ( a ) + \int_a^x f ( t ) f
&#39; &#39; ( t ) \mathrm{ d } t + \int_a^x ( f &#39; ( t ) )^2 \mathrm{
d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时回忆到柯西不等式:</p>
<p><span class="math display">\[
( \int_a^x f ( t ) f &#39; &#39; ( t ) \mathrm{ d } t ) \leq ( \int_a^x
f^2 ( t ) \mathrm{ d } t ) ( \int_a^x ( f &#39; &#39; ( t ) )^2 \mathrm{
d } t )
\]</span></p>
<p>因此这一项被控制住了,于是我们知道<span class="math inline">\(f ( x )
f &#39; ( x )\)</span>和<span class="math inline">\(\int_a^x ( f &#39; (
t ) )^2 \mathrm{ d } t\)</span>收敛性相同.</p>
<p>接下来反证原结论,假设后者并不收敛而是趋近<span class="math inline">\(+ \infty\)</span>.那<span class="math inline">\(f
( x ) f &#39; ( x ) \to + \infty\)</span>,对其做积分,则:</p>
<p><span class="math display">\[
\int_a^{ + \infty } f ( x ) f &#39; ( x ) \mathrm{ d } x = \int_a^{ +
\infty } f ( x ) \mathrm{ d } f ( x ) = f^2 ( x ) - f^2 ( a )
\]</span></p>
<p>因此<span class="math inline">\(f^2 ( x ) \to +
\infty\)</span>,这当然与<span class="math inline">\(\int_a^{ + \infty }
f^2 ( x ) \mathrm{ d } x &lt; + \infty\)</span>相违背.</p>
<h6><span id="example15">Example15</span></h6>
<p>判断<span class="math inline">\(\int_1^{ + \infty } \tan \left (
\cfrac{ \sin x }{ x } \right ) \mathrm{ d } x\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x } \mathrm{ d } x\)</span>当然是收敛的,而对<span class="math inline">\(\tan \frac{ \sin x }{ x
}\)</span>做泰勒展开应该和<span class="math inline">\(\frac{ \sin x }{ x
}\)</span>同阶,于是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_1^{ + \infty } \tan \left ( \cfrac{ \sin x }{ x } \right )
\mathrm{ d } x \\
= &amp; \int_1^{ + \infty } \frac{ \sin x }{ x } \mathrm{ d } x +
\int_1^{ + \infty } \left ( \tan \left ( \cfrac{ \sin x }{ x } \right )
- \frac{ \sin x }{ x } \right ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>前半部分当然收敛,后半部分取绝对值放缩后是<span class="math inline">\(O ( \frac{ 1 }{ x^2 } )\)</span>的,当然也收敛.</p>
<h6><span id="example16">Example16</span></h6>
<p>讨论<span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{
x^p } \arctan x \mathrm{ d } x , p &gt; 0\)</span>的收敛性.</p>
<p><span class="math inline">\(\int_1^{ + \infty } \frac{ \sin x }{ x^p
} \mathrm{ d } x\)</span>收敛,而<span class="math inline">\(\arctan
x\)</span>单调有界,立刻知道收敛.</p>
<h6><span id="example17">Example17</span></h6>
<p>讨论<span class="math inline">\(\int_2^{ + \infty } \frac{ \cos
\sqrt{ x } }{ x^p \ln x } \mathrm{ d } x\)</span>的收敛性.</p>
<p>当然先做换元<span class="math inline">\(t = \sqrt{ x
}\)</span>,那么原式变成:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ \sqrt{ 2 } }^{ + \infty } \frac{ 2 t \cos t \mathrm{ d } t
}{ t^{ 2 p } \ln t^2 } \\
= &amp; \int_{ \sqrt{ 2 } }^{ + \infty } \frac{ \cos t \mathrm{ d } t }{
t^{ 2 p - 1 } \ln t } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(2 p - 1 &gt; 1 , p &gt;
1\)</span>的时候当然绝对收敛,而<span class="math inline">\(0 \leq 2 p -
1 \leq 1\)</span>的时候用DA判准知道收敛,<span class="math inline">\(2 p
- 1 &lt; 0\)</span>的时候当然发散.</p>
<h6><span id="example18磨光核函数">Example18(磨光核函数)</span></h6>
<p>构造一个<span class="math inline">\(C^{ \infty }\)</span>的函数<span class="math inline">\(g ( x )\)</span>,满足当<span class="math inline">\(x \leq 0\)</span>的时候,<span class="math inline">\(g ( x ) = 0\)</span>;而当<span class="math inline">\(x \geq 1\)</span>的时候,<span class="math inline">\(g ( x ) =
1\)</span>.也就是你要造一个函数把两段直线焊接起来.</p>
<p>考虑<span class="math inline">\(h ( x ) = \begin{cases}e^{ - \frac{ 1
}{ x^2 } } &amp; x \ne 0 \\ 0 &amp; x = 0\end{cases}\)</span>.这个<span class="math inline">\(h ( x )\)</span>容易检验是<span class="math inline">\(C^{ \infty }\)</span>的,只需看<span class="math inline">\(0\)</span>点处的可导性即可.</p>
<p>取<span class="math inline">\(H ( x ) = \int_{ - \infty }^x h ( t ) h
( 1 - t ) \mathrm{ d } t\)</span>.容易见到这函数在<span class="math inline">\(0\)</span>处和<span class="math inline">\(1\)</span>处都无穷阶可导.稍微乘下常数就可以搞定.</p>
<h6><span id="example19">Example19</span></h6>
<p><span class="math inline">\(\int_0^{ + \inf } f ( x ) \mathrm{ d }
x\)</span>收敛,<span class="math inline">\(xf ( x
)\)</span>单调,求证:<span class="math inline">\(\lim_{ x \to \inf } xf (
x ) \ln x = 0\)</span>.</p>
<p>首先容易证明<span class="math inline">\(xf ( x
)\)</span>单调递减趋于<span class="math inline">\(0\)</span>.那么:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_{ x_0 }^{ x_0^2 } f ( x ) \mathrm{ d } x \\
= &amp; \int_{ x_0 }^{ x_0^2 } f ( x ) \frac{ x }{ x } \mathrm{ d } x \\
= &amp; \int_{ x_0 }^{ x_0^2 } xf ( x ) \mathrm{ d } \ln x \\
\geq &amp; x_0^2 f ( x_0^2 ) \ln x_0 \\
= &amp; \frac{ 1 }{ 2 } x_0^2 f ( x_0^2 ) \ln x_0^2
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(x_0 \to
\inf\)</span>用柯西准则证毕.</p>
<h6><span id="example20">Example20</span></h6>
<p>求证:当<span class="math inline">\(\int_a^b | f | &lt;
\infty\)</span>的时候,黎曼引理仍然成立.</p>
<p>回忆到黎曼引理要求<span class="math inline">\(f \in R [ a , b
]\)</span>,但这里的确可以推广,原因是瑕积分肯定只有有限个瑕点(有无限个瑕点能立刻证明发散),只需要用足够小的区间把这有限个瑕点盖住,用柯西准则就可以证明这部分很小,而外面的部分当然是正常的黎曼引理.</p>
<h4><span id="rs积分">RS积分</span></h4>
<p>设<span class="math inline">\(\alpha ( x ) : [ a , b ] \to \mathbb{ R
}\)</span>是一个单调不减的函数,对于有界函数<span class="math inline">\(f
( x ) : [ a , b ] \to \mathbb{ R }\)</span>,考虑一个分划<span class="math inline">\(P : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>,定义<span class="math inline">\(\Delta \alpha_k = \alpha (
x_k ) - \alpha ( x_{ k - 1 } ) \geq 0\)</span>,并定义<span class="math inline">\(M_k = \sup_{ [ x_{ k - 1 } , x_k ] } f ( x ) , m_k
= \inf_{ [ x_{ k - 1 } , x_k ] } f ( x
)\)</span>.在此基础上定义<strong>上和</strong><span class="math inline">\(U ( P , f , \alpha ) = \sum_{ k = 1 }^n M_k \Delta
\alpha_k\)</span>,同理定义<strong>下和</strong><span class="math inline">\(L ( P , f , \alpha ) = \sum_{ k = 1 }^n m_k \Delta
\alpha_k\)</span>.定义<strong>上积分</strong><span class="math inline">\(\overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \inf_P{ U ( P , f , \alpha )
}\)</span>,同理定义<strong>下积分</strong><span class="math inline">\(\underline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \inf_P{ L ( P , f , \alpha ) }\)</span>.那么如果有以下<span class="math inline">\(\overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha = \underline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha\)</span>,称<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上关于<span class="math inline">\(\alpha\)</span><strong>RS可积</strong>,记作<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,而将此值称作<span class="math inline">\(f\)</span>关于<span class="math inline">\(\alpha\)</span>的RS积分,记作<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } \alpha\)</span>.</p>
<p>类比黎曼积分那套理论,应当有以下显而易见的性质:</p>
<ol type="1">
<li><p>分划<span class="math inline">\(P^*\)</span>如果是<span class="math inline">\(P\)</span>的加密,那么<span class="math inline">\(L
( P , f , \alpha ) \leq L ( P^* , f , \alpha ) , U ( P , f , \alpha )
\geq U ( P^* , f , \alpha )\)</span>.</p></li>
<li><p><span class="math inline">\(L ( P_1 , f , \alpha ) \leq U ( P_2 ,
f , \alpha )\)</span>.</p></li>
<li><p><span class="math inline">\(\underline{ \int_{ a }^b } f ( x )
\mathrm{ d } \alpha \leq \overline{ \int_{ a }^b } f ( x ) \mathrm{ d }
\alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R
}_\alpha\)</span>,其充要条件是<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,存在分划<span class="math inline">\(P\)</span>使得<span class="math inline">\(0 \leq U
( P , f , \alpha ) - L ( P , f , \alpha ) &lt;
\epsilon\)</span>.</p></li>
</ol>
<p>接下来考虑证明一些性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(f_1 + f_2 \in{ R }_\alpha [ a ,
b ]\)</span>,并且<span class="math inline">\(\int_a^b ( f_1 + f_2 )
\mathrm{ d } \alpha = \int_a^b f_1 \mathrm{ d } \alpha + \int_a^b f_2
\mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(cf \in{ R }_\alpha [ a , b
]\)</span>,并且<span class="math inline">\(\int_a^b ( cf ) \mathrm{ d }
\alpha = c \int_a^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b ] ,
f_1 \leq f_2\)</span>,则<span class="math inline">\(\int_a^b f_1
\mathrm{ d } \alpha \leq \int_a^b f_2 \mathrm{ d }
\alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , c \in [
a , b ]\)</span>,那么<span class="math inline">\(f \in{ R }_\alpha [ a ,
c ] , f \in{ R }_\alpha [ c , b ]\)</span>,且<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^c f
\mathrm{ d } \alpha + \int_c^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , | f |
\leq M\)</span>,则<span class="math inline">\(| \int_a^b f \mathrm{ d }
\alpha | \leq M \left ( \alpha ( b ) - \alpha ( a ) \right
)\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_{ \alpha_1 } [ a , b
]\)</span>并且<span class="math inline">\(f \in{ R }_{ \alpha_2 } [ a ,
b ]\)</span>,则<span class="math inline">\(f \in{ R }_{ \alpha_1 +
\alpha_2 } [ a , b ]\)</span>,并且<span class="math inline">\(\int_a^b f
\mathrm{ d } ( \alpha_1 + \alpha_2 ) = \int_a^b f \mathrm{ d } \alpha_1
+ \int_a^b f \mathrm{ d } \alpha_2\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , c &gt;
0\)</span>.则<span class="math inline">\(f \in{ R }_{ c \alpha } [ a , b
]\)</span>,并且<span class="math inline">\(\int_a^b f \mathrm{ d } ( c
\alpha ) = c \int_a^b f \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b ] , m \leq
f \leq M , g \in C [ m , M ]\)</span>.则<span class="math inline">\(g (
f ( x ) ) \in{ R }_\alpha [ a , b ]\)</span>.</p></li>
<li><p><span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(| f | \in{ R }_\alpha [ a , b
]\)</span>,且<span class="math inline">\(| \int_a^b f \mathrm{ d }
\alpha | \leq \int_a^b | f | \mathrm{ d } \alpha\)</span>.</p></li>
<li><p><span class="math inline">\(f_1 , f_2 \in{ R }_\alpha [ a , b
]\)</span>,则<span class="math inline">\(f_1 f_2 \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>如果极限<span class="math inline">\(\lim_{ \lambda ( P ) \to 0 }
( \sum f ( t_k ) \Delta \alpha_k ) , t_k \in [ x_{ k - 1 } , x_k
]\)</span>存在,则<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>并且其RS积分就是上述极限.然而,逆命题未必成立.</p></li>
</ol>
<p>对于(1),考虑对于分划<span class="math inline">\(P_1 ,
P_2\)</span>而言:</p>
<p><span class="math display">\[
\begin{aligned}
L ( P_1 , f_1 , \alpha ) + L ( P_2 , f_2 , \alpha ) &amp; \leq L ( P_1
\cup P_2 , f_1 , \alpha ) + L ( P_1 \cup P_2 , f_2 , \alpha ) \\
&amp; \leq L ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) \\
&amp; \leq U ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) \\
&amp; \leq U ( P_1 \cup P_2 , f_1 , \alpha ) + U ( P_1 \cup P_2 , f_2 ,
\alpha ) \leq U ( P_1 , f_1 , \alpha ) + U ( P_2 , f_2 , \alpha )
\end{aligned}
\]</span></p>
<p>对此式子两边同取上下确界可以证明<span class="math inline">\(\forall
\epsilon &gt; 0 , U ( P_1 \cup P_2 , f_1 + f_2 , \alpha ) - L ( P_1 \cup
P_2 , f_1 + f_2 , \alpha ) &lt; \epsilon\)</span>,即可得证(1).</p>
<p>对于(2),显然<span class="math inline">\(U ( P , cf , \alpha ) = cU (
P , f , \alpha )\)</span>,下和同理,于是立即得证.</p>
<p>对于(3),由(1),显然<span class="math inline">\(f_2 \geq
f_1\)</span>时,<span class="math inline">\(\int_a^b ( f_2 - f_1 )
\mathrm{ d } \alpha \geq 0\)</span>,于是<span class="math inline">\(\int_a^b f_2 \mathrm{ d } \alpha \geq \int_a^b f_1
\mathrm{ d } \alpha\)</span>.</p>
<p>对于(4),考虑既然<span class="math inline">\(f \in R_\alpha [ a , b
]\)</span>,那么<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,都应该<span class="math inline">\(\exists P\)</span>使得<span class="math inline">\(U_{ [ a , b ] } ( P , f , \alpha ) - L_{ [ a , b ]
} ( P , f , \alpha ) &lt; \epsilon\)</span>,而令<span class="math inline">\(P &#39; = P \cup \{ c \}\)</span>,也就是将<span class="math inline">\(c\)</span>强行作为一个分点,上式仍然成立,而可以将<span class="math inline">\(P &#39;\)</span>拆分为两个部分,不妨记作<span class="math inline">\(P_1 , P_2\)</span>,应该有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; U_{ [ a , b ] } ( P &#39; , f , \alpha ) - L_{ [ a , b ] } ( P
&#39; , f , \alpha ) \\
= &amp; U_{ [ a , c ] } ( P_1 , f , \alpha ) - L_{ [ a , c ] } ( P_1 , f
, \alpha ) + U_{ [ c , b ] } ( P_2 , f , \alpha ) - L_{ [ c , b ] } (
P_2 , f , \alpha ) &lt; \epsilon
\end{aligned}
\]</span></p>
<p>此二项均为正,因此分别<span class="math inline">\(&lt;
\epsilon\)</span>,那也就说明了<span class="math inline">\(f \in R_\alpha
[ a , c ]\)</span>且<span class="math inline">\(f \in R_\alpha [ c , b
]\)</span>,并且仍然是钦定<span class="math inline">\(c\)</span>为分点就可以见到<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^c f
\mathrm{ d } \alpha + \int_c^b f \mathrm{ d } \alpha\)</span>.</p>
<p>对于(5),由(3)可以得知:</p>
<p><span class="math display">\[
- \int_a^b M \mathrm{ d } \alpha \leq \int_a^b f \mathrm{ d } \alpha
\leq \int_a^b M \mathrm{ d } \alpha
\]</span></p>
<p>而由定义立刻见到<span class="math inline">\(\int_a^b M \mathrm{ d }
\alpha = M ( \alpha ( b ) - \alpha ( a ) )\)</span>.</p>
<p>对于(6),考虑<span class="math inline">\(\Delta ( \alpha_1 + \alpha_2
)_k = \Delta \alpha_1 + \Delta \alpha_2\)</span>,因此<span class="math inline">\(U ( P , f , \alpha_1 + \alpha_2 ) = U ( P , f ,
\alpha_1 ) + U ( P , f , \alpha_2 )\)</span>.因此证明与(4)无异.</p>
<p>对于(7),只需考虑<span class="math inline">\(\Delta ( c \alpha ) = c
\Delta \alpha\)</span>,于是<span class="math inline">\(U ( P , f , c
\alpha ) = cU ( P , f , \alpha )\)</span>,于是证明与(2)无异.</p>
<p>考虑(8)的证明,由于<span class="math inline">\(g\)</span>是闭区间上的连续函数,立刻知道其一致连续.也就是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists 0 &lt; \delta
&lt; \epsilon\)</span>,使得<span class="math inline">\(| s - t | &lt;
\delta\)</span>时一定有<span class="math inline">\(| g ( s ) - g ( t ) |
&lt; \epsilon\)</span>.接下来考虑由于<span class="math inline">\(f \in
R_\alpha [ a , b ]\)</span>,应当可以取一组划分<span class="math inline">\(P : a = x_0 &lt; \cdots &lt; x_n =
b\)</span>,使得<span class="math inline">\(U ( P , f , \alpha ) - L ( P
, f , \alpha ) &lt; \delta^2\)</span>.考虑将划分分为两类:<span class="math inline">\(A = \{ 1 \leq k \leq n \mid M_k - m_k &lt; \delta
\}\)</span>和<span class="math inline">\(B = \{ 1 \leq k \leq n \mid M_k
- m_k \geq \delta
\}\)</span>.这个思路就会和根号分治很像.那接下来考虑定义<span class="math inline">\(M_k^* = \sup_{ [ x_{ k - 1 } , x_k ] } g ( f ( x )
) , m_k^* = \inf_{ [ x_{ k - 1 } , x_k ] } g ( f ( x ) )\)</span>.</p>
<p>那这就会使得当<span class="math inline">\(k \in
A\)</span>的时候,由于<span class="math inline">\(g\)</span>的一致连续性,立刻可以知道<span class="math inline">\(M_k^* - m_k^* \leq \epsilon\)</span>.而当<span class="math inline">\(k \in B\)</span>的时候,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\delta \sum_{ k \in B } \Delta \alpha_k &amp; \leq \sum_{ k \in B } (
M_k - m_k ) \Delta \alpha_k \\
&amp; = U ( P , f , \alpha ) - L ( P , f , \alpha ) &lt; \delta^2
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(\sum_{ k \in B } \Delta \alpha_k &lt;
\delta\)</span>.如此一来:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; U ( P , g \circ f , \alpha ) - L ( P , g \circ f , \alpha ) \\
= &amp; \sum_{ k \in A } ( M_k^* - m_k^* ) \Delta \alpha_k + \sum_{ k
\in B } ( M_k^* - m_k^* ) \Delta \alpha_k \\
&lt; &amp; \epsilon ( \alpha ( b ) - \alpha ( a ) ) + 2 ( \sup | g | )
\delta \\
&lt; &amp; \epsilon \left ( \alpha ( b ) - \alpha ( a ) + 2 \sup | g |
\right )
\end{aligned}
\]</span></p>
<p>这样就证毕了.</p>
<p>考虑(9)的证明,首先由(8)知道<span class="math inline">\(| f | \in{ R
}_\alpha [ a , b ]\)</span>.而我们可以说存在<span class="math inline">\(c = \pm 1\)</span>,使得<span class="math inline">\(| \int_a^b f \mathrm{ d } \alpha | = c ( \int_a^b
f \mathrm{ d } \alpha )\)</span>.而<span class="math inline">\(cf ( x )
\leq | f ( x ) |\)</span>,由(3)的保序性得证.</p>
<p>考虑(10)的证明,嵌套函数<span class="math inline">\(g =
x^2\)</span>并利用(9),则我们可以知道如果<span class="math inline">\(f
\in{ R }_\alpha [ a , b ]\)</span>,那么<span class="math inline">\(f^2
\in{ R }_\alpha [ a , b ]\)</span>.此时观察到<span class="math inline">\(4 f_1 f_2 = ( f_1 + f_2 )^2 - ( f_1 - f_2
)^2\)</span>,立即得证.</p>
<p>(11)的证明比较显然.(11)直接的逆命题的话有个反例是考虑<span class="math inline">\(f ( x ) = \begin{cases}1 &amp; x \geq 0 \\ 0 &amp;
x &lt; 0\end{cases} , \alpha ( x ) = \begin{cases}1 &amp; x &gt; 0 \\ 0
&amp; x \leq 0\end{cases}\)</span>.此时会发现<span class="math inline">\(x =
0\)</span>这个点取不取在分划里是重要的,只要不取在分划里,怎么加密也没有用.</p>
<p>接下来当然应当研究一下连续性对RS可积的意义.我们声明:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f \in C [ a , b
]\)</span>,则<span class="math inline">\(f \in{ R }_\alpha [ a , b
]\)</span>且对<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists \delta &gt; 0\)</span>,并且只要<span class="math inline">\(\lambda ( P ) &lt; \delta\)</span>,那么<span class="math inline">\(| \sum f ( t_k ) \Delta \alpha_k - \int_a^b f
\mathrm{ d } \alpha | &lt; \epsilon\)</span>,其中<span class="math inline">\(t_k \in [ x_{ k - 1 } , x_k ]\)</span>.</p></li>
<li><p>(1)中的条件如果改成<span class="math inline">\(f \in R_\alpha [ a
, b ] , \alpha \in C [ a , b ]\)</span>,结论仍然成立.</p></li>
<li><p>如果<span class="math inline">\(f\)</span>单调,但是<span class="math inline">\(\alpha\)</span>连续,则我们也能证明<span class="math inline">\(f_\alpha \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>作为(3)的推论,如果<span class="math inline">\(f\)</span>是有界变差函数,<span class="math inline">\(\alpha\)</span>连续,也能证明<span class="math inline">\(f_\alpha \in{ R }_\alpha [ a , b
]\)</span>.</p></li>
<li><p>如果<span class="math inline">\([ a , b
]\)</span>上的有界函数<span class="math inline">\(f\)</span>只有有限个间断点,并且<span class="math inline">\(f\)</span>和<span class="math inline">\(\alpha\)</span>的间断点集交集为空,则<span class="math inline">\(f \in R_\alpha [ a , b
]\)</span>.同时,(1)中的性质仍然成立.</p></li>
</ol>
<p>(1)的证明,考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,取<span class="math inline">\(\gamma &gt;
0\)</span>,使得<span class="math inline">\(\left ( \alpha ( b ) - \alpha
( a ) \right ) \gamma &lt; \epsilon\)</span>.此时,<span class="math inline">\(f\)</span>是闭区间上的连续函数,那它就一定是一致连续的函数.那么<span class="math inline">\(\exists \delta &gt; 0\)</span>,当<span class="math inline">\(| x - y | &lt; \delta\)</span>的时候,有<span class="math inline">\(| f ( x ) - f ( y ) | &lt;
\gamma\)</span>.此时只需考虑<span class="math inline">\(U ( P , f ,
\alpha ) - L ( P , f , \alpha ) &lt; \epsilon\)</span>就做完了.</p>
<p>(2)的证明,考虑既然<span class="math inline">\(f \in R_{ \alpha } [ a
, b ]\)</span>,因此一定存在一组分划<span class="math inline">\(P^*\)</span>使得<span class="math inline">\(U (
P^* , f , \alpha ) &lt; \int_a^b f \mathrm{ d } \alpha +
\epsilon\)</span>.</p>
<p>那么接下来对于任意一组分划<span class="math inline">\(P : a = x_0
&lt; \cdots &lt; x_m = b\)</span>,将其分为两组:一组是<span class="math inline">\(A = \{ k \mid \exists i , x_i^* \in ( x_{ k - 1 }
, x_k ) \}\)</span>,<span class="math inline">\(B = \{ 1 , 2 , \cdots ,
m \} \setminus A\)</span>.也即<span class="math inline">\(B\)</span>中的每个区间都被包含在<span class="math inline">\(P^*\)</span>的分划中.既然如此,在<span class="math inline">\(B\)</span>上的和的部分当然就要<span class="math inline">\(\leq U ( P^* , f , \alpha ) &lt; \int_a^b f
\mathrm{ d } \alpha + \epsilon\)</span>.只要我们能证明<span class="math inline">\(A\)</span>能被控制住即可.</p>
<p>而由于<span class="math inline">\(\alpha\)</span>连续,其在<span class="math inline">\([ a , b
]\)</span>上绝对连续,可以取足够小的分划使得<span class="math inline">\(\Delta \alpha\)</span>足够小.既然如此,<span class="math inline">\(\sum_{ k \in A } f ( t_k ) \Delta \alpha_k \leq nM
\max \{ \Delta \alpha_k \}\)</span>,其中<span class="math inline">\(M\)</span>是<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b
]\)</span>上的上界,这个立刻可以被<span class="math inline">\(\max \{
\Delta \alpha_k \}\)</span>控制住.</p>
<p>(3)的证明,不妨设<span class="math inline">\(f\)</span>单调不降,此时考虑取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\frac{
\alpha ( b ) - \alpha ( a ) }{ n } ( f ( b ) - f ( a ) ) &lt;
\epsilon\)</span>.那么由于<span class="math inline">\(\alpha\)</span>连续,所以其有介值性,可以通过选取划分使得<span class="math inline">\(\Delta \alpha_k \equiv \frac{ \alpha ( b ) -
\alpha ( a ) }{ n } ( f ( b ) - f ( a ) )\)</span>,那还是考虑<span class="math inline">\(U ( P , f , \alpha ) - L ( P , f , \alpha ) &lt;
\epsilon\)</span>即可.</p>
<p>(5)的证明相当平凡,只需用闭区间上的连续函数是一致连续处理间断点即可,在此略过.</p>
<p>于上述基础上进一步拓展,可以拓展到<span class="math inline">\(\alpha\)</span>是有界变差的情况.原因是有界变差函数可以表示为两个不降函数的差,不妨设<span class="math inline">\(\alpha ( x ) = \beta ( x ) - \gamma ( x
)\)</span>,则我们定义<span class="math inline">\(\int_a^b f \mathrm{ d }
\alpha = \int_a^b f \mathrm{ d } \beta - \int_a^b f \mathrm{ d }
\gamma\)</span>.</p>
<p>这个还要证明是良定的,原因是如果一个有界变差函数能表示成两种情形,有<span class="math inline">\(\beta_1 ( x ) - \gamma_1 ( x ) = \beta_2 ( x ) -
\gamma_2 ( x )\)</span>,那么<span class="math inline">\(\beta_1 ( x ) +
\gamma_2 ( x ) = \beta_2 ( x ) + \gamma_1 ( x
)\)</span>,这两边都是不降函数,那根据<span class="math inline">\(\alpha\)</span>部分可以加减的性质就完事了.</p>
<p>既然如此,对拓展的版本进一步寻找性质,不妨设<span class="math inline">\(V ( x ) = V_a^x \alpha\)</span>.</p>
<ol type="1">
<li><p><span class="math inline">\(f \in C [ a , b ]\)</span>且<span class="math inline">\(\alpha\)</span>是有界变差,或<span class="math inline">\(f , \alpha\)</span>都是有界变差且<span class="math inline">\(f\)</span>连续时,<span class="math inline">\(|
\int_a^b f \mathrm{ d } \alpha | \leq \int_a^b f \mathrm{ d }
V\)</span></p></li>
<li><p>作为(1)的推论,上述条件时,<span class="math inline">\(| \int_a^b f
\mathrm{ d } \alpha | \leq \sup | f | \times V_a^b
\alpha\)</span></p></li>
<li><p>(分部积分):当<span class="math inline">\(\alpha ,
f\)</span>都是有界变差,并且它们有一个是连续的时候,<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f \alpha \mid_a^b
- \int_a^b \alpha \mathrm{ d } f\)</span>.应当见到其实该定理只需要<span class="math inline">\(\alpha , f\)</span>有一个是连续就行.</p></li>
<li><p>(第一积分中值定理):<span class="math inline">\(f \in C [ a , b
]\)</span>且<span class="math inline">\(\alpha\)</span>不降,则<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f ( \xi ) \left (
\alpha ( b ) - \alpha ( a ) \right )\)</span>.</p></li>
<li><p>(第二积分中值定理):<span class="math inline">\(f\)</span>在<span class="math inline">\([ a , b ]\)</span>上单调,<span class="math inline">\(\alpha\)</span>是连续有界变差.则<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = f ( a ) \left (
\alpha ( \xi ) - \alpha ( a ) \right ) + f ( b ) \left ( \alpha ( b ) -
\alpha ( \xi ) \right )\)</span>.</p></li>
<li><p>(变量替换公式):如果<span class="math inline">\(f , g \in C [ a ,
b ]\)</span>并且<span class="math inline">\(g\)</span>严格增,取<span class="math inline">\(h = g^{ - 1 }\)</span>,<span class="math inline">\(c = g ( a ) , d = g ( b )\)</span>,那么<span class="math inline">\(\int_a^b f ( x ) \mathrm{ d } x = \int_c^d f ( h (
y ) ) \mathrm{ d } h ( y )\)</span>.</p></li>
<li><p>(和黎曼可积的关系):<span class="math inline">\(f \in R [ a , b
]\)</span>,<span class="math inline">\(\alpha\)</span>可导并且<span class="math inline">\(\alpha &#39; \in R [ a , b ]\)</span>,则<span class="math inline">\(f \in R_\alpha [ a , b ]\)</span>,且<span class="math inline">\(\int_a^b f \mathrm{ d } \alpha = \int_a^b f \alpha
&#39; \mathrm{ d } x\)</span></p></li>
</ol>
<p>考虑(1)的证明,由于此时已经可以使用求和来逼近,那不妨考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| S ( P , f , \alpha ) | &amp; = | \sum f ( t_k ) \Delta \alpha_k | \\
&amp; \leq | \sum f ( t_k ) | \cdot | \Delta \alpha_k | \\
&amp; \leq | \sum f ( t_k ) | \Delta V_k
\end{aligned}
\]</span></p>
<p>于是证毕.(2)自是(1)的推论.</p>
<p>(3)的话,当然是Abel求和,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S ( P , f , \alpha ) &amp; = \sum_{ k = 1 }^n f ( t_k ) ( \alpha ( x_k )
- \alpha ( x_{ k - 1 } ) ) \\
&amp; = f ( b ) \alpha ( b ) - f ( a ) \alpha ( a ) - \sum_{ k = 1 }^{ n
+ 1 } \alpha ( x_{ k - 1 } ) ( f ( t_k ) - f ( t_{ k - 1 } ) ) \\
&amp; = f \alpha |_a^b - S ( Q , \alpha , f )
\end{aligned}
\]</span></p>
<p>容易见到<span class="math inline">\(| P | \to 0\)</span>会导致<span class="math inline">\(| Q | \to 0\)</span>,便是显然.</p>
<p>考虑(4),由于<span class="math inline">\(f\)</span>是连续的,直接取<span class="math inline">\(f\)</span>的上下界并介值定理一下即是显然.</p>
<p>考虑(5),用分部积分公式,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f \mathrm{ d } \alpha &amp; = f ( b ) \alpha ( b ) - f ( a )
\alpha ( a ) - \int_a^b \alpha \mathrm{ d } f \\
&amp; = f ( b ) \alpha ( b ) - f ( a ) \alpha ( a ) - \alpha ( \xi ) ( f
( b ) - f ( a ) )
\end{aligned}
\]</span></p>
<p>整理一下即可.</p>
<p>考虑(6),由于连续性,因此对<span class="math inline">\(x\)</span>做的划分同样通过一个<span class="math inline">\(h\)</span>成为了新的一组划分,而且由于闭区间上的连续函数是一致连续的,这个划分当然也趋近于<span class="math inline">\(0\)</span>,立即见到成立.</p>
<p>对于(7),首先用介值定理得到<span class="math inline">\(\Delta \alpha_k
= \alpha &#39; ( \xi_k ) \Delta x_k\)</span>,那当然有:</p>
<p><span class="math display">\[
\begin{aligned}
S ( P , f , \alpha ) &amp; = \sum f ( t_k ) \Delta \alpha_k \\
&amp; = \sum f ( t_k ) \alpha &#39; ( t_k ) \Delta x_k + \sum f ( t_k )
( \alpha &#39; ( \xi_k ) - \alpha &#39; ( t_k ) ) \Delta x_k
\end{aligned}
\]</span></p>
<p>而后面那一项绝对值不超过<span class="math inline">\(| \sup f | \sum
\omega_{ \alpha &#39; }\)</span>,当然趋近于<span class="math inline">\(0\)</span>.</p>
<h3><span id="级数">级数</span></h3>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,定义<span class="math inline">\(S_n = \sum_{ k = 1 }^n a_k\)</span>.如果<span class="math inline">\(\lim_{ n \to \infty }
S_n\)</span>存在,则称级数<span class="math inline">\(\sum_{ k = 1 }^{
\infty } a_n\)</span><strong>收敛</strong>,记作<span class="math inline">\(S = \sum_{ k }^{ \infty }
a_n\)</span>,否则如若上述极限不存在,称其<strong>发散</strong>.</p>
<p>容易见到以下性质显然成立,然而逆命题并不总是成立:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum^{ + \infty } a_n = A , \sum^{ +
\infty } b_n = B\)</span>,则<span class="math inline">\(\sum^{ + \infty
} ( a_n + b_n ) = A + B\)</span>.</p></li>
<li><p><span class="math inline">\(\sum^{ + \infty } a_n =
A\)</span>,则<span class="math inline">\(\sum^{ + \infty } c a_n =
cA\)</span>.</p></li>
<li><p>结合律:<span class="math inline">\(\sum^{ + \infty } a_n =
A\)</span>,若<span class="math inline">\(\{ n_k
\}\)</span>是递增正整数序列且<span class="math inline">\(n_0 =
1\)</span>,设<span class="math inline">\(C_k = \sum_{ n = n_{ k - 1 }
}^{ n_k - 1 } a_n\)</span>,则<span class="math inline">\(\sum_k^{ +
\infty } C_k = A\)</span>.</p></li>
</ol>
<p>(1)(2)显然,(3)当然是因为原数列收敛立刻能推出其子列收敛.</p>
<p>如果<span class="math inline">\(\sum | a_n | &lt;
\infty\)</span>,则称此级数<strong>绝对收敛</strong>.考虑<span class="math inline">\(a_n = | a_n | - ( | a_n | - a_n
)\)</span>,前后两者都是正项数列而且<span class="math inline">\(| a_n | -
a_n \leq 2 | a_n
|\)</span>,所以绝对收敛当然能推出收敛,而反之不可.将收敛但不绝对收敛的级数称作<strong>条件收敛</strong>.绝对收敛的两个级数之和当然也绝对收敛,乘一个系数后也绝对收敛.</p>
<p>我们有<strong>柯西收敛原理</strong>:<span class="math inline">\(\sum
a_n\)</span>收敛的充要条件是<span class="math inline">\(\forall \epsilon
&gt; 0\)</span>,<span class="math inline">\(\exists N &gt; 0 , \forall m
&gt; n \geq N\)</span>,<span class="math inline">\(| \sum_{ k = n }^m
a_k | &lt; \epsilon\)</span>.用柯西准则立刻见到如若<span class="math inline">\(\lim_{ n \to \infty } S_n\)</span>收敛则必有<span class="math inline">\(\lim_{ n \to \infty } a_n =
0\)</span>.但反命题当然不成立.这是相当重要的,正是因为<span class="math inline">\(\lim_{ n \to \infty } a_n =
0\)</span>,所以我们才总能使用泰勒展开等手段进行估计和放缩.</p>
<p>再还有Abel-Dirichlet判别法,设<span class="math inline">\(a_n\)</span>单调,<span class="math inline">\(B_n =
\sum_{ k = 1 }^n b_k\)</span>,<span class="math inline">\(B_n\)</span>有界,<span class="math inline">\(| B_n
| \leq M\)</span>:</p>
<ol type="1">
<li><p>引理:<span class="math inline">\(| \sum_{ k = 1 }^n a_k b_k |
\leq M ( | a_1 | + 2 | a_n | ) \leq 2 M ( | a_1 | + | a_n |
)\)</span>.</p></li>
<li><p>Dirichlet判别法:若<span class="math inline">\(a_n \to
0\)</span>,<span class="math inline">\(B_n\)</span>有界,则<span class="math inline">\(\sum a_k b_k\)</span>收敛.</p></li>
<li><p>Abel判别法:若<span class="math inline">\(B_n\)</span>收敛,<span class="math inline">\(a_n\)</span>有界,则<span class="math inline">\(\sum a_k b_k\)</span>收敛.</p></li>
</ol>
<p>(1)的话当然只需使用Abel变换,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 1 }^n a_k b_k &amp; = \sum_{ k = 1 }^n a_k ( B_k - B_{ k - 1
} ) \\
&amp; = a_n B_n + \sum_{ k = 1 }^{ n - 1 } ( a_k - a_{ k + 1 } ) B_k
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n a_k b_k | \\
\leq &amp; | a_n B_n | + \sum_{ k = 1 }^{ n - 1 } | a_k - a_{ k + 1 } |
\cdot | B_k | \\
\leq &amp; M ( | a_1 - a_n | + | a_n | ) \\
\leq &amp; M ( | a_1 | + 2 | a_n | )
\end{aligned}
\]</span></p>
<p>(2)(3)的话用柯西判准,考虑任意一段求和<span class="math inline">\(|
B_{ n + p } - B_{ n - 1 } | \leq 2 M\)</span>,于是:</p>
<p><span class="math display">\[
| \sum_{ k = n }^{ n + p } a_k b_k | \leq 2 M ( | a_n | + 2 | a_{ n + p
} | )
\]</span></p>
<p>则属显然.</p>
<p>DA判别法的一个推论是,对于<span class="math inline">\(\sum
b_k\)</span>和<span class="math inline">\(\sum
c_k\)</span>来说,如果<span class="math inline">\(\frac{ b_k }{ c_k
}\)</span>单调有界且不趋于<span class="math inline">\(0\)</span>,那么它们敛散性相同.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( nx ) }{ n
}\)</span>的收敛性.</p>
<p>首先当<span class="math inline">\(x = 2 k
\pi\)</span>的时候当然收敛,否则使用DA判别法,考虑证明<span class="math inline">\(\sum \sin ( nx )\)</span>有界.</p>
<p>用积化和差,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| \sum_{ k = 1 }^n \sin ( kx ) | &amp; = \left | \frac{ \sum 2 \sin
\frac{ x }{ 2 } \sin ( kx ) }{ 2 \sin ( \frac{ x }{ 2 } ) } \right | \\
&amp; = \left | \frac{ \sum \cos ( k - \frac{ 1 }{ 2 } ) x - \cos ( k +
\frac{ 1 }{ 2 } ) x }{ 2 \sin ( \frac{ x }{ 2 } ) } \right | \\
&amp; \leq \frac{ 1 }{ | \sin \frac{ x }{ 2 } | }
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>能不能进一步把上面的这个级数求出来呢?考虑欧拉公式,令<span class="math inline">\(z = e^{ ix }\)</span>,知道<span class="math inline">\(e^{ inx } = \cos ( nx ) + i \sin ( nx
)\)</span>,所以<span class="math inline">\(\sum \frac{ z^n }{ n } = -
\ln ( 1 - z )\)</span>的虚部就是所求.</p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
- \ln ( 1 - z ) &amp; = - \ln ( 1 - \cos x - i \sin x ) \\
&amp; = - \ln \left ( 2 ( \sin \frac{ x }{ 2 } ) ( \sin \frac{ x }{ 2 }
- i \cos \frac{ x }{ 2 } ) \right ) \\
&amp; = - \ln \left ( 2 ( \sin \frac{ x }{ 2 } ) e^{ \frac{ x - \pi }{ 2
} i } \right ) \\
&amp; = - \ln ( 2 \sin \frac{ x }{ 2 } ) + \frac{ \pi - x }{ 2 } i
\end{aligned}
\]</span></p>
<p>这就顺便解决了<span class="math inline">\(\sum \frac{ \cos ( nx ) }{
n }\)</span>的情况.</p>
<h6><span id="example2">Example2</span></h6>
<p>判断<span class="math inline">\(\sum \frac{ ( - 1 )^n }{ n^p + ( - 1
)^n } , p &gt; 0\)</span>的收敛性.</p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ ( - 1 )^n }{ n^p + ( - 1 )^n } \\
= &amp; \frac{ ( - 1 )^n }{ n^p } \frac{ 1 }{ 1 + \frac{ ( - 1 )^n }{
n^p } } \\
= &amp; \frac{ ( - 1 )^n }{ n^p } \frac{ 1 - \frac{ ( - 1 )^n }{ n^p }
}{ 1 - \frac{ 1 }{ n^{ 2 p } } } \\
= &amp; \frac{ ( - 1 )^n }{ n^p - \frac{ 1 }{ n^p } } - \frac{ 1 }{ n^{
2 p } - 1 }
\end{aligned}
\]</span></p>
<p>前半部分当然收敛,于是<span class="math inline">\(p \leq \frac{ 1 }{ 2
}\)</span>的时候发散,<span class="math inline">\(\frac{ 1 }{ 2 } &lt; p
\leq 1\)</span>的时候条件收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( \frac{ n \pi }{ 4 }
) }{ n^p + \sin ( \frac{ n \pi }{ 4 } ) }\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p + \sin ( \frac{ n \pi
}{ 4 } ) } \\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } \frac{ 1 }{ 1 +
\frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } } \\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } \left ( 1 - \frac{
\sin ( \frac{ n \pi }{ 4 } ) }{ n^p } + o ( \frac{ 1 }{ n^p } ) \right )
\\
= &amp; \frac{ \sin ( \frac{ n \pi }{ 4 } ) }{ n^p } - \frac{ \sin^2 (
\frac{ n \pi }{ 4 } ) }{ n^{ 2 p } } + o ( \frac{ 1 }{ n^{ 2 p } } )
\end{aligned}
\]</span></p>
<p>见到应该是<span class="math inline">\(p \leq \frac{ 1 }{ 2
}\)</span>发散,<span class="math inline">\(\frac{ 1 }{ 2 } &lt; p \leq
1\)</span>的时候条件收敛,<span class="math inline">\(p &gt;
1\)</span>的时候绝对收敛.</p>
<h4><span id="正项级数">正项级数</span></h4>
<ol type="1">
<li><p>当<span class="math inline">\(a_n \geq 0\)</span>的时候,<span class="math inline">\(S_n\)</span>有界<span class="math inline">\(\Leftrightarrow\)</span>S_n</p></li>
<li><p>当<span class="math inline">\(0 \leq a_n \leq
b_n\)</span>,若<span class="math inline">\(\sum^{ + \infty } b_n &lt;
\infty\)</span>,则<span class="math inline">\(\sum^{ + \infty } a_n &lt;
\infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n , b_n &gt; 0\)</span>,则若<span class="math inline">\(\varlimsup_{ n \to \infty } \frac{ a_n }{ b_n }
&lt; \infty\)</span>,则<span class="math inline">\(\sum^{ + \infty } b_n
&lt; \infty \Rightarrow \sum^{ + \infty } a_n &lt;
\infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n , b_n &gt; 0\)</span>,则若<span class="math inline">\(\varliminf_{ n \to \infty } \frac{ a_n }{ b_n }
&gt; 0\)</span>,则<span class="math inline">\(\sum^{ + \infty } b_n =
\infty \Rightarrow \sum^{ + \infty } a_n = \infty\)</span>.</p></li>
<li><p>若<span class="math inline">\(a_n\)</span>单调递减趋近于<span class="math inline">\(0\)</span>.则<span class="math inline">\(\sum^{ +
\infty }_n a_n &lt; \infty \Leftrightarrow \sum_{ k }^{ + \infty } 2^k
a_{ 2^k } &lt; \infty\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ k = 1 }^{ + \infty } \frac{ 1
}{ n^p }\)</span>,当<span class="math inline">\(p \leq
1\)</span>的时候发散,而当<span class="math inline">\(p &gt;
1\)</span>的时候收敛.</p></li>
<li><p><span class="math inline">\(\sum_{ k = 2 }^{ + \infty } \frac{ 1
}{ n \ln^p n }\)</span>,当<span class="math inline">\(p \leq
1\)</span>的时候发散,而当<span class="math inline">\(p &gt;
1\)</span>的时候收敛.</p></li>
<li><p>设单调递减连续正函数<span class="math inline">\(f ( x
)\)</span>满足<span class="math inline">\(a_n = f ( n )\)</span>,则<span class="math inline">\(\sum_{ k = 1 }^{ + \infty } a_k &lt; \infty
\Leftrightarrow \int_1^{ + \infty } f ( x ) \mathrm{ d } x &lt;
\infty\)</span>.</p></li>
<li><p>比值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(\varlimsup_{ n \to \infty }
\frac{ a_{ n + 1 } }{ a_n } &lt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt; \infty\)</span>.</p></li>
<li><p>比值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(\varliminf_{ n \to \infty }
\frac{ a_{ n + 1 } }{ a_n } &gt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
<li><p>根值判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,设<span class="math inline">\(l = \varlimsup_{ n \to \infty }
( a_n )^{ \frac{ 1 }{ n } }\)</span>,如果<span class="math inline">\(l
&lt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt;
\infty\)</span>;若<span class="math inline">\(l &gt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
<li><p>对于<span class="math inline">\(a_n &gt; 0\)</span>,如果<span class="math inline">\(\varliminf_{ n \to \infty } n \ln \frac{ a_n }{
a_{ n + 1 } } &gt; 1\)</span>,则<span class="math inline">\(\sum a_n
&lt; \infty\)</span>.</p></li>
<li><p>对于<span class="math inline">\(a_n &gt; 0\)</span>,如果<span class="math inline">\(\varlimsup_{ n \to \infty } n \ln \frac{ a_n }{
a_{ n + 1 } } &lt; 1\)</span>,则<span class="math inline">\(\sum a_n =
\infty\)</span>.</p></li>
<li><p>拉贝判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,若<span class="math inline">\(\varliminf_{ n \to \infty } n (
\frac{ a_n }{ a_{ n + 1 } } - 1 ) &gt; 1\)</span>,则<span class="math inline">\(\sum a_n &lt; \infty\)</span>.</p></li>
<li><p>拉贝判别法:对于<span class="math inline">\(a_n &gt;
0\)</span>,若<span class="math inline">\(\varlimsup_{ n \to \infty } n (
\frac{ a_n }{ a_{ n + 1 } } - 1 ) &lt; 1\)</span>,则<span class="math inline">\(\sum a_n = \infty\)</span>.</p></li>
</ol>
<p>(1)当然是单调收敛准则.(2)只是(1)的推论.</p>
<p>(3)(4)只需套用定义即可.</p>
<p>(5)的话,不妨设<span class="math inline">\(S_n = \sum_{ k = 1 }^n
a_k\)</span>而<span class="math inline">\(T_n = \sum_{ k = 1 }^n 2^k a_{
2^k }\)</span>考虑当<span class="math inline">\(2^k \leq
n\)</span>的时候,有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; \geq \sum_{ j = 1 }^{ 2^k } a_j \\
&amp; = a_1 + \sum_{ j = 0 }^{ k - 1 } \sum_{ i = 2^j + 1 }^{ 2^{ j + 1
} } a_i \\
&amp; \geq \frac{ 1 }{ 2 } T_k
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(n &lt; 2^{ k + 1
}\)</span>的时候,则有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; \leq \sum_{ j = 1 }^{ 2^k } a_j \\
&amp; = \sum_{ j = 0 }^{ k - 1 } \sum_{ i = 2^j }^{ 2^{ j + 1 } - 1 }
a_i \\
&amp; \leq T_k
\end{aligned}
\]</span></p>
<p>(6)的话,首先<span class="math inline">\(p \leq 1\)</span>的时候<span class="math inline">\(\frac{ 1 }{ n^p } \geq \frac{ 1 }{ n
}\)</span>于是显然,而当<span class="math inline">\(p &gt;
1\)</span>的时候,考虑用(5),观察<span class="math inline">\(\sum 2^k
\frac{ 1 }{ 2^{ pk } } = \sum 2^{ ( 1 - p ) k }\)</span>,当然收敛.</p>
<p>(7)的话亦然考虑(5),等价于<span class="math inline">\(\sum 2^k \frac{
1 }{ 2^k k^p \ln^p 2 } = \sum \frac{ 1 }{ k^p \ln^p 2
}\)</span>,等价于(6)了.这个结论还可以推广到<span class="math inline">\(\sum \frac{ 1 }{ n \ln n ( \ln \ln n )^p
}\)</span>,总之都是类似的做法,结论也类似.</p>
<p>(8)的证明只需考虑:</p>
<p><span class="math display">\[
a_{ n + 1 } = f ( n + 1 ) \leq \int_n^{ n + 1 } f ( t ) \mathrm{ d } t
\leq f ( n ) = a_n
\]</span></p>
<p>立刻证毕.</p>
<p>而且这个估计还可以更精细,事实上我们可以证明下列极限总是存在:</p>
<p><span class="math display">\[
\lim_{ n \to \infty } ( \sum_{ k = m }^n f ( k ) - \int_m^n f ( x )
\mathrm{ d } x ) = \alpha
\]</span></p>
<p>而且还满足<span class="math inline">\(0 \leq \alpha \leq f ( m
)\)</span>.</p>
<p>考虑固定<span class="math inline">\(m\)</span>,设<span class="math inline">\(g ( n ) = \sum_{ k = m }^n f ( k ) - \int_m^n f (
x ) \mathrm{ d }
x\)</span>,用单调收敛准则,我们先证明它单调递减且有下界,注意到:</p>
<p><span class="math display">\[
g ( n ) - g ( n + 1 ) = - f ( n + 1 ) + \int_{ n }^{ n + 1 } f ( x )
\mathrm{ d } x \geq 0
\]</span></p>
<p>这就证明了其单调递减,而又有:</p>
<p><span class="math display">\[
g ( n ) = \sum_{ k = m }^{ n - 1 } \left ( f ( k ) - \int_{ k }^{ k + 1
} f ( x ) \mathrm{ d } x \right ) + f ( n ) \geq f ( n ) \geq 0
\]</span></p>
<p>因此有下界.同时注意到<span class="math inline">\(g ( m ) = f ( m
)\)</span>,因此总有<span class="math inline">\(0 \leq \alpha \leq f ( m
)\)</span>成立.</p>
<p>不仅如此,如果<span class="math inline">\(f ( n )\)</span>还满足<span class="math inline">\(\lim_{ x \to \infty } f ( x ) =
0\)</span>,我们还可以把这个极限收敛的速度求出来.我们有:</p>
<p><span class="math display">\[
| \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x - \alpha |
\leq f ( n )
\]</span></p>
<p>干脆令<span class="math inline">\(l &gt;
n\)</span>,考虑LHS应该是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x -
\alpha \\
= &amp; \sum_{ k = m }^n f ( k ) - \int_m^n f ( x ) \mathrm{ d } x -
\left ( \lim_{ l \to \infty } ( \sum_{ k = m }^l f ( k ) - \int_m^l f (
x ) \mathrm{ d } x ) \right ) \\
= &amp; \lim_{ l \to \infty } \left ( \int_n^l f ( x ) \mathrm{ d } x -
\sum_{ k = n + 1 }^l f ( k ) \right ) \\
= &amp; \lim_{ l \to \infty } \left ( \sum_{ k = n + 1 }^l ( \int_{ k -
1 }^k f ( k ) \mathrm{ d } x - f ( k ) ) \right ) \\
\leq &amp; \lim_{ l \to \infty } \left ( \sum_{ k = n + 1 }^l ( f ( k -
1 ) - f ( k ) ) \right ) \\
\leq &amp; f ( n )
\end{aligned}
\]</span></p>
<p>而上式换个方向放缩就可以知道<span class="math inline">\(\geq
0\)</span>,这就搞定.</p>
<p>(9)(10)类似(3)(4),用等比数列控制住即可.</p>
<p>(11)的话,如若<span class="math inline">\(l = \varlimsup_{ n \to
\infty } ( a_n )^{ \frac{ 1 }{ n } }\)</span>.</p>
<p>当<span class="math inline">\(l &lt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(l + \epsilon &lt; 1\)</span>,则<span class="math inline">\(\exists N_0 &gt; 0\)</span>,<span class="math inline">\(\forall n \geq N_0\)</span>,<span class="math inline">\(( a_n )^{ \frac{ 1 }{ n } } &lt; l +
\epsilon\)</span>,意味着<span class="math inline">\(a_n &lt; ( l +
\epsilon )^n\)</span>,立刻见到其收敛.</p>
<p>当<span class="math inline">\(l &gt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(l - \epsilon &gt;
1\)</span>,则存在原数列的一个无穷子列<span class="math inline">\(\{ n_k
\}\)</span>,使得<span class="math inline">\(a_{ n_k } &gt; ( l -
\epsilon )^{ n_k } \to \infty\)</span>,当然发散.</p>
<p>而注意到根据Stolz定理:</p>
<p><span class="math display">\[
\varliminf \frac{ a_{ n + 1 } }{ a_n } \leq \varliminf \sqrt[n]{ a_n }
\leq \varlimsup \sqrt[n]{ a_n } \leq \varlimsup \frac{ a_{ n + 1 } }{
a_n }
\]</span></p>
<p>这就意味着根值判别法理论上严格强于比值判别法.</p>
<p>(12)(13)的证明,考虑当<span class="math inline">\(l = \varliminf_{ n
\to \infty } n \ln \frac{ a_n }{ a_{ n + 1 } } &gt;
1\)</span>的时候,取<span class="math inline">\(\epsilon &gt; 0 , p = l -
\epsilon &gt; 1\)</span>,那么就有<span class="math inline">\(\exists N_0
&gt; 0 , \forall n \geq N_0\)</span>,都有:</p>
<p><span class="math display">\[
\begin{aligned}
n \ln \frac{ a_n }{ a_{ n + 1 } } &amp; &gt; p \\
\frac{ a_n }{ a_{ n + 1 } } &amp; &gt; e^{ \frac{ p }{ n } } &gt; \left
( ( 1 + \frac{ 1 }{ n } )^n \right )^{ \frac{ p }{ n } } \\
\frac{ a_{ n + 1 } }{ a_n } &amp; &lt; \cfrac{ \frac{ 1 }{ ( n + 1 )^p }
}{ \frac{ 1 }{ n^p } }
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(b_n = \frac{ 1 }{ n^p
}\)</span>,由上见到<span class="math inline">\(a_n &lt; \frac{ a_{ N_0 }
}{ b_{ N_0 } } b_n\)</span>,这就控制住了.(13)同理.控制<span class="math inline">\(e\)</span>的时候改用不等式<span class="math inline">\(e &lt; ( 1 + \frac{ 1 }{ n - 1 }
)^n\)</span>即可.</p>
<p>(14)(15)仍然类似,设<span class="math inline">\(b_n = n ( \frac{ a_n
}{ a_{ n + 1 } } - 1 )\)</span>.</p>
<p>当<span class="math inline">\(l = \varliminf_{ n \to \infty } b_n
&gt; 1\)</span>的时候,取<span class="math inline">\(\epsilon &gt;
0\)</span>,<span class="math inline">\(l - \epsilon &gt;
1\)</span>,则<span class="math inline">\(\exists N_0 &gt; 0 , \forall n
\geq N_0\)</span>,<span class="math inline">\(b_n &gt; l - \epsilon = l
&#39;\)</span>.而:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ a_n }{ a_{ n + 1 } } &amp; = 1 + \frac{ b_n }{ n } \\
\ln \frac{ a_n }{ a_{ n + 1 } } &amp; = \ln ( 1 + \frac{ b_n }{ n } )
&gt; \ln ( 1 + \frac{ l &#39; }{ n } ) \\
\varliminf n \ln \frac{ a_n }{ a_{ n + 1 } } &amp; \geq \varliminf \ln (
1 + \frac{ l &#39; }{ n } )^{ n } = l &#39; &gt; 1
\end{aligned}
\]</span></p>
<p>这就做完了.(15)同理.</p>
<h6><span id="example1">Example1</span></h6>
<p>斐波那契数列<span class="math inline">\(f_0 = 0 , f_1 =
1\)</span>,求<span class="math inline">\(\sum \frac{ 1 }{ f_k
}\)</span>的收敛性.</p>
<p>考虑<span class="math inline">\(f_{ n - 1 } \leq 2 f_{ n - 2
}\)</span>,所以<span class="math inline">\(f_n = f_{ n - 1 } + f_{ n - 2
} \geq \frac{ 3 }{ 2 } f_{ n - 1 } \geq ( \frac{ 3 }{ 2 } )^{ n - 1
}\)</span>.这就做完了.</p>
<h6><span id="example2">Example2</span></h6>
<p>假设<span class="math inline">\(0 &lt;
a_n\)</span>单调递增且有界,求证:<span class="math inline">\(\sum ( 1 -
\frac{ a_k }{ a_{ k + 1 } } ) &lt; \infty\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum ( 1 - \frac{ a_k }{ a_{ k + 1 } } ) \\
= &amp; \sum{ a_k } ( \frac{ 1 }{ a_k } - \frac{ 1 }{ a_{ k + 1 } } ) \\
\leq &amp; \sup{ a } \sum ( \frac{ 1 }{ a_k } - \frac{ 1 }{ a_{ k + 1 }
} ) \\
\leq &amp; \frac{ \sup{ a } }{ a_1 }
\end{aligned}
\]</span></p>
<h6><span id="example3">Example3</span></h6>
<p>求<span class="math inline">\(\sum \frac{ 1 }{ n^p - n^q } , p &gt; q
&gt; 0\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{ n \to \infty } \cfrac{
\frac{ 1 }{ n^p - n^q } }{ \frac{ 1 }{ n^p } } = 1\)</span>,所以<span class="math inline">\(p \leq 1\)</span>的时候发散,<span class="math inline">\(p &gt; 1\)</span>的时候收敛.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum \sin \frac{ 1 }{ n^2
}\)</span>的收敛性.</p>
<p>直接考虑<span class="math inline">\(\lim_{ n \to \infty } \cfrac{
\sin \frac{ 1 }{ n^2 } }{ \frac{ 1 }{ n^2 } } = 1\)</span>,所以收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p><span class="math inline">\(a_n = ( 1 - \sqrt[3]{ \frac{ n - 1 }{ n +
1 } } )^p , p &gt; 0\)</span>,讨论<span class="math inline">\(\sum
a_n\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[3]{ \frac{ n - 1 }{ n + 1 } } &amp; = ( 1 - \frac{ 1 }{ n } )^{
\frac{ 1 }{ 3 } } ( 1 + \frac{ 1 }{ n } )^{ - \frac{ 1 }{ 3 } } \\
&amp; = ( 1 - \frac{ 1 }{ 3 n } + O ( \frac{ 1 }{ n^2 } ) ) ( 1 - \frac{
1 }{ 3 n } + O ( \frac{ 1 }{ n^2 } ) ) \\
&amp; = 1 - \frac{ 2 }{ 3 n } + O ( \frac{ 1 }{ n^2 } )
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(a_n\)</span>和<span class="math inline">\(\frac{ 1 }{ n^p }\)</span>同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求<span class="math inline">\(S_n = \sum_{ k = 1 }^n \frac{ 1 }{
\sqrt{ k } } - 2 \sqrt{ n }\)</span>的敛散性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_{ n + 1 } &amp; = S_{ n + 1 } - S_n \\
&amp; = \frac{ 1 }{ \sqrt{ n + 1 } } - 2 \sqrt{ n + 1 } + 2 \sqrt{ n }
\\
&amp; = \frac{ 1 }{ \sqrt{ n + 1 } } - \frac{ 2 }{ \sqrt{ n + 1 } +
\sqrt{ n } } \\
&amp; = \frac{ \sqrt{ n } - \sqrt{ n + 1 } }{ \sqrt{ n + 1 } ( \sqrt{ n
+ 1 } + \sqrt{ n } ) } \\
&amp; = \frac{ - 1 }{ \sqrt{ n + 1 } ( \sqrt{ n + 1 } + \sqrt{ n } )^2 }
= O ( - n^{ - \frac{ 3 }{ 2 } } )
\end{aligned}
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example7">Example7</span></h6>
<p>求<span class="math inline">\(a_n = \frac{ 1 }{ \sqrt{ n } } - \sqrt{
\ln ( 1 + \frac{ 1 }{ n } ) }\)</span>的级数和收敛性.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \sqrt{ n } } - \sqrt{ \ln ( 1 + \frac{ 1 }{ n }
) } \\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \sqrt{ \frac{ 1 }{ n } - \frac{ 1 }{
2 n^2 } + o ( \frac{ 1 }{ n^2 } ) } \\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \frac{ 1 }{ \sqrt{ n } } \left ( 1 -
\frac{ 1 }{ 2 n } + o ( \frac{ 1 }{ n } ) \right )^{ \frac{ 1 }{ 2 } }
\\
&amp; = \frac{ 1 }{ \sqrt{ n } } - \frac{ 1 }{ \sqrt{ n } } \left ( 1 -
\frac{ 1 }{ 4 n } + o ( \frac{ 1 }{ n } ) \right ) \\
&amp; = O ( n^{ - \frac{ 3 }{ 2 } } )
\end{aligned}
\]</span></p>
<p>所以收敛.</p>
<h6><span id="example8">Example8</span></h6>
<p>设<span class="math inline">\(\zeta ( a ) = \sum_{ k = 1 }^{ \infty }
\frac{ 1 }{ k^a }\)</span>,求<span class="math inline">\(\lim_{ \sigma
\to 0 + 0 } \sigma \zeta ( 1 + \sigma )\)</span>和<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \left ( \zeta ( 1 +
\sigma ) - \frac{ 1 }{ \sigma } \right )\)</span>.</p>
<p>取<span class="math inline">\(f ( x ) = \frac{ 1 }{ x^{ 1 + \sigma }
}\)</span>,设<span class="math inline">\(F ( x ) = \int_1^x f ( t )
\mathrm{ d } t\)</span>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = n + 1 }^{ \infty } a_k &amp; \leq F ( + \infty ) - F ( n )
\leq \sum_{ k = n }^{ \infty } a_k \\
F ( + \infty ) - F ( n + 1 ) &amp; \leq \sum_{ k = n + 1 }^{ \infty }
a_k \leq F ( + \infty ) - F ( n ) \\
\frac{ 1 }{ \sigma } \frac{ 1 }{ ( n + 1 )^\sigma } &amp; \leq \sum_{ k
= n + 1 }^{ \infty } a_k \leq \frac{ 1 }{ \sigma } \frac{ 1 }{ n^\sigma
} \\
\frac{ 1 }{ ( n + 1 )^\sigma } &amp; \leq \sigma \sum_{ k = n + 1 }^{
\infty } a_k \leq \frac{ 1 }{ n^\sigma }
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(n = 0\)</span>和<span class="math inline">\(n = 1\)</span>得到<span class="math inline">\(1
\leq \sigma \zeta ( 1 + \sigma ) \leq \sigma + 1\)</span>,于是<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \sigma \zeta ( 1 +
\sigma ) = 1\)</span>.</p>
<p>而同理,见到:</p>
<p><span class="math display">\[
\zeta ( 1 + \sigma ) = 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots +
\frac{ 1 }{ n^{ 1 + \sigma } } + \sum_{ k = n + 1 }^{ \infty } \frac{ 1
}{ k^{ 1 + \sigma } }
\]</span></p>
<p>而:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 +
\sigma } } + \frac{ 1 }{ \sigma } \frac{ 1 }{ ( n + 1 )^\sigma } \\
\leq &amp; \zeta ( 1 + \sigma ) \leq \\
1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 + \sigma
} } + \frac{ 1 }{ \sigma } \frac{ 1 }{ n^\sigma } \\

\end{aligned}\]</span>
<p>$$</p>
<p>用上述不等式:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 +
\sigma } } + \frac{ 1 }{ \sigma } \left ( \frac{ 1 }{ ( n + 1 )^\sigma }
- 1 \right ) \\
\leq &amp; \zeta ( 1 + \sigma ) - \frac{ 1 }{ \sigma } \leq \\
1 + \frac{ 1 }{ 2^{ 1 + \sigma } } + \cdots + \frac{ 1 }{ n^{ 1 + \sigma
} } + \frac{ 1 }{ \sigma } \left ( \frac{ 1 }{ n^\sigma } - 1 \right )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>两边对<span class="math inline">\(\sigma \to 0 +
0\)</span>取极限,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; 1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } - \ln ( n + 1 ) \\
\leq &amp; \varliminf_{ \sigma \to 0 + 0 } ( \zeta ( 1 + \sigma ) -
\frac{ 1 }{ \sigma } ) \leq \varlimsup_{ \sigma \to 0 + 0 } ( \zeta ( 1
+ \sigma ) - \frac{ 1 }{ \sigma } ) \leq \\
1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } - \ln ( n )
\end{aligned}
\]</span></p>
<p>两边对<span class="math inline">\(n\)</span>取极限得到<span class="math inline">\(\lim_{ \sigma \to 0 + 0 } \zeta ( 1 + \sigma ) -
\frac{ 1 }{ \sigma } = \gamma\)</span>.</p>
<h6><span id="example9">Example9</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,证明:若<span class="math inline">\(\varlimsup_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &lt; \frac{ 1 }{ e }\)</span>则收敛.若<span class="math inline">\(\varliminf_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &gt; \frac{ 1 }{ e }\)</span>则发散.</p>
<p>只证前者,则存在<span class="math inline">\(p &gt; 1\)</span>使得<span class="math inline">\(\varlimsup_{ n \to \infty } a_n^{ \frac{ 1 }{ \ln
n } } &lt; \frac{ 1 }{ e^p }\)</span>,两边取<span class="math inline">\(\ln\)</span>就做完了.</p>
<h6><span id="example10">Example10</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,证明:若<span class="math inline">\(\varliminf_{ n \to \infty } \cfrac{ \ln \frac{ 1
}{ a_n } }{ \ln n } &gt; 1\)</span>则收敛.若<span class="math inline">\(\varlimsup_{ n \to \infty } \cfrac{ \ln \frac{ 1
}{ a_n } }{ \ln n } &lt; 1\)</span>则发散.</p>
<p>只证前者,考虑前者等价于<span class="math inline">\(\varlimsup_{ n \to
\infty } \ln a_n^{ \frac{ 1 }{ \ln n } } &lt; -
1\)</span>,转化为Example9.</p>
<h6><span id="example11">Example11</span></h6>
<p>数列<span class="math inline">\(\{ a_n \}\)</span>恒正,数列<span class="math inline">\(b_n = \frac{ a_n }{ a_{ n + 1 } } - 1 - \frac{ 1
}{ n }\)</span>的部分和有界,求证<span class="math inline">\(\sum
a_n\)</span>发散.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ a_n }{ a_{ n + 1 } } &amp; = 1 + \frac{ 1 }{ n } + b_n \leq e^{
\frac{ 1 }{ n } + b_n } \\
\frac{ a_1 }{ a_{ n + 1 } } &amp; \leq e^{ \ln n + \gamma + M } = cn \\
a_n &amp; \geq \frac{ ca_1 }{ n }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h4><span id="交错级数">交错级数</span></h4>
<p>考虑<span class="math inline">\(\sum ( - 1 )^{ n - 1 }
a_n\)</span>,其中<span class="math inline">\(a_n &gt; 0\)</span>.</p>
<p>Leibniz定理:如果<span class="math inline">\(a_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>,则交错级数收敛.</p>
<p>考虑<span class="math inline">\(S_{ 2 n } = ( a_1 - a_2 ) + ( a_3 -
a_4 ) + \cdots\)</span>而<span class="math inline">\(S_{ 2 n + 1 } = a_1
- ( a_2 - a_3 ) - ( a_4 - a_5 ) - \cdots\)</span>,所以见到<span class="math inline">\(S_{ 2 n }\)</span>单调上升,<span class="math inline">\(S_{ 2 n + 1 }\)</span>单调下降.并且显然<span class="math inline">\(S_{ 2 n } &lt; S_{ 2 n + 1 }\)</span>.而且<span class="math inline">\(S_{ 2 n + 1 } - S_{ 2 n } = a_{ 2 n + 1 } \to
0\)</span>,所以二者均收敛且极限相同极限相同.</p>
<p>当然,这也只是DA判别法的一个特例.</p>
<p>Leibniz定理还可以如此理解:由于后面的项正负抵消,我们发现:</p>
<p><span class="math display">\[
| \sum_{ k = n }^\infty ( - 1 )^k a_k | \leq a_n \to 0
\]</span></p>
<p>也就是后面的交错都可以被首项控制住.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(\sum ( - 1 )^{ n } \frac{ \ln^2 n }{
n }\)</span>的收敛性.</p>
<p>取<span class="math inline">\(f ( x ) = \frac{ \ln^2 x }{ x
}\)</span>,则<span class="math inline">\(f &#39; = \frac{ 2 \ln x -
\ln^2 x }{ x^2 }\)</span>,显然当<span class="math inline">\(x\)</span>足够大的时候<span class="math inline">\(f &#39; ( x ) &lt; 0\)</span>且<span class="math inline">\(f ( + \infty ) = 0\)</span>,所以原式收敛.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(a_n &gt; 0\)</span>,求证:若<span class="math inline">\(\varliminf n ( \frac{ a_n }{ a_{ n + 1 } } - 1 )
&gt; 0\)</span>,则<span class="math inline">\(\sum ( - 1 )^n
a_n\)</span>收敛.</p>
<p>考虑<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(\exists \epsilon &gt; 0\)</span>,使得<span class="math inline">\(n ( \frac{ a_n }{ a_{ n + 1 } } - 1 ) &gt;
\epsilon\)</span>,也就是<span class="math inline">\(\frac{ a_{ n + 1 }
}{ a_n } &lt; \frac{ n }{ n + \epsilon } &lt; 1\)</span>,这就能证明<span class="math inline">\(a_n\)</span>单调递减.下面只需要证明<span class="math inline">\(\lim a_n = 0\)</span>即可.</p>
<p>而考虑取定<span class="math inline">\(N &gt; 0\)</span>,对于<span class="math inline">\(n \geq N\)</span>,有<span class="math inline">\(\frac{ a_n }{ a_N } = \prod_{ k = N }^{ n - 1 }
\frac{ a_{ k + 1 } }{ a_{ k } }\)</span>,<span class="math inline">\(a_N\)</span>是定死的,下面只需要证明后面那个乘积趋近于<span class="math inline">\(0\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \prod_{ k = N }^{ n - 1 } \frac{ a_{ k + 1 } }{ a_{ k } } \\
&lt; &amp; \prod_{ k = N }^{ n - 1 } \frac{ n }{ n + \epsilon } \\
= &amp; \prod_{ k = N }^{ n - 1 } \frac{ 1 }{ 1 + \frac{ \epsilon }{ n }
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \prod_{ k = N }^{ n - 1 } ( 1 + \frac{ \epsilon }{ n } ) \\
\geq &amp; 1 + \frac{ \epsilon }{ N } + \cdots + \frac{ \epsilon }{ n -
1 } \to \infty
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f ( x ) = \sum_{ n = 1 }^\infty \frac{
( - 1 )^{ n - 1 } }{ n^x } , x \in ( 0 , \infty )\)</span>,求<span class="math inline">\(\sup f\)</span>和<span class="math inline">\(\inf
f\)</span>.</p>
<p>首先显然能搞出<span class="math inline">\(f ( x ) \in C^\infty ( 0 ,
+ \infty
)\)</span>,原因是能证明其和其若干阶导数都内闭一致收敛(用DA判法).</p>
<p>首先交错级数的绝对值要<span class="math inline">\(\leq\)</span>首项,所以先猜<span class="math inline">\(\sup f = 1\)</span>.考虑:</p>
<p><span class="math display">\[
f ( x ) = 1 - \sum_{ n = 1 }^\infty \left ( \frac{ 1 }{ ( 2 n )^x } -
\frac{ 1 }{ ( 2 n + 1 )^x } \right )
\]</span></p>
<p>容易见到只要让<span class="math inline">\(x \to
\infty\)</span>那就逐项趋近于<span class="math inline">\(0\)</span>.</p>
<p>还有一个问题是<span class="math inline">\(\inf f\)</span>.考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n
+ 1 )^x } \\
= &amp; \sum_{ n = 1 }^\infty \int_{ 2 n }^{ 2 n + 1 } \frac{ x \mathrm{
d } t }{ t^{ x + 1 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里注意到我们积分的那几段都是<span class="math inline">\([ 2 n , 2 n
+ 1 ]\)</span>,我们可以把奇数段补上,因为<span class="math inline">\(x
&gt; 0\)</span>,所以补的那一段更大,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \int_{ 2 n }^{ 2 n + 1 } \frac{ x \mathrm{ d
} t }{ t^{ x + 1 } } \\
\leq &amp; \frac{ 1 }{ 2 } \int_1^{ + \infty } \frac{ \mathrm{ d } t }{
t^{ x + 1 } } = \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(f ( x ) = 1 - \sum_{ n = 1 }^\infty
\left ( \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n + 1 )^x } \right
)\)</span>,所以<span class="math inline">\(f ( x ) \geq \frac{ 1 }{ 2
}\)</span>.</p>
<p>接下来来证明其能取到,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } - \frac{ 1 }{ ( 2 n
+ 1 )^x } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } \left ( 1 - \frac{
1 }{ ( 1 + \frac{ 1 }{ 2 n } )^x } \right ) \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n )^x } \left ( \frac{ x
}{ 2 n } + O ( \frac{ x }{ n^2 } ) \right ) \\
= &amp; \frac{ x }{ 2^{ x + 1 } } \zeta ( x + 1 ) + xO ( 1 ) \\
\to &amp; \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>原因是<span class="math inline">\(\lim_{ x \to 0 + 0 } x \zeta ( x +
1 ) \to 1\)</span>,这个结论我们之前搞定过.</p>
<h4><span id="积分判别法">积分判别法</span></h4>
<p>取<span class="math inline">\(\omega_n = \sup_{ [ n , n + 1 ] } f -
\inf_{ [ n , n + 1 ] } f \geq 0\)</span>.我们声称若<span class="math inline">\(\sum \omega_n &lt; \infty\)</span>,则<span class="math inline">\(\int_1^{ \infty } f ( x ) \mathrm{ d }
x\)</span>与<span class="math inline">\(\sum f ( n
)\)</span>收敛性相同.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 1 }^n f_k - \int_1^{ n + 1 } f ( x ) \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } ( f ( k ) - f ( x ) ) \mathrm{
d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑证明右式绝对收敛,有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } | f ( k ) - f ( x ) | \mathrm{ d
} x \\
\leq &amp; \sum_{ k = 1 }^n \int_k^{ k + 1 } \omega_k \mathrm{ d } x \\
= &amp; \sum_{ k = 1 }^{ n + 1 } \omega_k
\end{aligned}
\]</span></p>
<p>这就证毕.</p>
<p>问题又来到如何搞定<span class="math inline">\(\sum \omega_n &lt;
\infty\)</span>的条件,其实只要有界变差就行了对吧,我们断言:如果<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f
&#39;\)</span>可积且<span class="math inline">\(\int_1^{ \infty } | f
&#39; | \mathrm{ d } x &lt; \infty\)</span>则<span class="math inline">\(\sum \omega_n &lt; \infty\)</span>.</p>
<p>对于<span class="math inline">\(\omega_n\)</span>,不妨<span class="math inline">\([ n , n + 1 ]\)</span>的上界在<span class="math inline">\(x_1\)</span>处取到,下界在<span class="math inline">\(x_2\)</span>处取到,于是:</p>
$$
<span class="math display">\[\begin{aligned}
\omega_n &amp; = f ( x_1 ) - f ( x_2 ) \\
&amp; = | \int_{ x_1 }^{ x_2 } f &#39; \mathrm{ d } x | \\
&amp; \leq | \int_{ x_1 }^{ x_2 } | f &#39; | \mathrm{ d } x | \\
&amp; \leq \int_{ n }^{ n + 1 } | f &#39; | \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是<span class="math inline">\(\sum \omega \leq \int_1^{ + \infty }
| f &#39; | \mathrm{ d } x\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum \frac{ \sin ( n^\alpha x ) }{
n^\beta }\)</span>的收敛性,其中<span class="math inline">\(\beta &gt;
\alpha &gt; 0 , \alpha + \beta &gt; 1\)</span>.</p>
<p>用积分判别法,考虑取<span class="math inline">\(f ( t ) = \frac{ \sin
( t^\alpha x ) }{ t^\beta }\)</span>,考虑:</p>
<p><span class="math display">\[
f &#39; ( t ) = \frac{ x \alpha t^{ \alpha - 1 + \beta } \cos ( t^\alpha
x ) - \beta t^{ \beta - 1 } \sin ( t^\alpha x ) }{ t^{ 2 \beta } }
\]</span></p>
<p>逐项观察,都是<span class="math inline">\(O ( \frac{ 1 }{ t^{ \beta -
\alpha + 1 } } )\)</span>级别,这样<span class="math inline">\(\int | f
&#39; | \mathrm{ d } t\)</span>就收敛了.</p>
<p>那就只需要看积分的收敛性,取<span class="math inline">\(s =
t^\alpha\)</span>考察:</p>
$$
<span class="math display">\[\begin{aligned}
\int_1^{ \infty } f ( t ) \mathrm{ d } t &amp; = \int_1^{ \infty }
\frac{ \sin ( t^\alpha x ) }{ t^\beta } \mathrm{ d } t \\
&amp; = \int_1^{ \infty } \frac{ \sin ( s x ) \frac{ 1 }{ \alpha } s^{
\frac{ 1 }{ \alpha } - 1 } }{ s^\frac{ \beta }{ \alpha } } \mathrm{ d }
s \\
&amp; = \int_1^{ \infty } \frac{ \sin ( s x ) }{ \alpha s^\frac{ \beta +
\alpha - 1 }{ \alpha } } \mathrm{ d } s \\

\end{aligned}\]</span>
<p>$$</p>
<p>后者用DA判法知道收敛.</p>
<h4><span id="级数的交换顺序">级数的交换顺序</span></h4>
<p>定义<span class="math inline">\(\mathbb{ N
}_+\)</span>的一个重排<span class="math inline">\(f : \mathbb{ N }_+ \to
\mathbb{ N }_+\)</span>,当且仅当<span class="math inline">\(f ( 1 ) , f
( 2 ) , \cdots\)</span>这个数列中,每个正整数都恰好出现一次.</p>
<p>我们声称正项级数满足:<span class="math inline">\(\sum a_n = \sum a_{
f ( n ) }\)</span>.</p>
<p>如何证明呢?</p>
<p>当<span class="math inline">\(\sum a_n &lt;
\infty\)</span>的时候,考虑设<span class="math inline">\(A_n = \sum_{ k =
1 }^n a_k , B_n = \sum_{ k = 1 }^n a_{ f ( k ) }\)</span>.考虑取<span class="math inline">\(N_n = \max_{ 1 \leq k \leq n } f ( k
)\)</span>,那就有:</p>
<p><span class="math display">\[
B_n = \sum_{ k = 1 }^n a_{ f ( k ) } \leq A_{ N_n } \leq \sum_{ 1 }^{
\infty } a_n
\]</span></p>
<p>于是<span class="math inline">\(B_n\)</span>当然是收敛的,并且<span class="math inline">\(\sum a_{ f ( n ) } \leq \sum
a_n\)</span>,而如果<span class="math inline">\(a_{ f ( n )
}\)</span>是<span class="math inline">\(a_n\)</span>的重排,那么反之,<span class="math inline">\(a_n\)</span>是<span class="math inline">\(a_{ f (
n ) }\)</span>的重排,于是<span class="math inline">\(\sum a_{ f ( n ) }
\geq \sum a_n\)</span>,这就证明了二者相同.</p>
<p>既如此,如果<span class="math inline">\(\sum
a_n\)</span>发散的时候,就可以反证法证明<span class="math inline">\(\sum
a_{ f ( n ) }\)</span>不可能收敛.这样就完成了证明.</p>
<p>下面我们证明,如果<span class="math inline">\(\sum
a_n\)</span>绝对收敛,换言之<span class="math inline">\(\sum | a_n | &lt;
\infty\)</span>,那么仍有<span class="math inline">\(\sum a_n = \sum a_{
f ( n ) }\)</span>.</p>
<p>考虑取<span class="math inline">\(a_n^+ = \frac{ | a_n | + a_n }{ 2 }
, a_n^- = \frac{ | a_n | - a_n }{ 2 }\)</span>.那考虑<span class="math inline">\(0 \leq a_n^+ \leq | a_n | , 0 \leq a_n^- \leq |
a_n |\)</span>,所以它们当然都绝对收敛,那当然有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum a_n &amp; = \sum ( a_n^+ - a_n^- ) \\
&amp; = ( \sum a_n^+ ) - ( \sum a_n^- )
\end{aligned}
\]</span></p>
<p>而后者当然可以随意重排.</p>
<p>那么对于条件收敛呢?我们有<strong>黎曼重排定理</strong>:如果<span class="math inline">\(\sum a_n\)</span>条件收敛,则<span class="math inline">\(\forall B \leq A\)</span>,其中<span class="math inline">\(A , B \in \mathbb{ R } \cup \{ \pm \infty
\}\)</span>,则存在重排<span class="math inline">\(f\)</span>,令<span class="math inline">\(S_n = \sum_{ k = 1 }^n a_{ f ( k )
}\)</span>,有:</p>
<p><span class="math display">\[
\varliminf S_n = B , \varlimsup S_n = A
\]</span></p>
<p>为证明此,考虑设<span class="math inline">\(I_+ = \{ n \in \mathbb{ N
}_+ \mid a_n \geq 0 \} = \{ n_1 &lt; n_2 \cdots \}\)</span>,<span class="math inline">\(I_-\)</span>类似设出.</p>
<p>容易见到首先<span class="math inline">\(\lim a_n \to
0\)</span>,并且<span class="math inline">\(\sum_{ n \in I_+ } a_n = +
\infty , \sum_{ n \in I_- } a_n = - \infty\)</span>.</p>
<p>考虑先从<span class="math inline">\(I_+\)</span>里取数,然后不断加加加加加直到超过<span class="math inline">\(A\)</span>,由于正的部分相加是正无穷,这当然能做到,然后就继续从<span class="math inline">\(I_-\)</span>里取数开始回退,退退退退到<span class="math inline">\(B\)</span>之下,再重复上述过程.由于<span class="math inline">\(a_n \to 0\)</span>,这玩意当然会满足条件.</p>
<p>那么如果<span class="math inline">\(A\)</span>是正无穷呢?那没关系,我就每次加数的时候变化<span class="math inline">\(A\)</span>,第一次个循环令<span class="math inline">\(A = 1\)</span>,第二次令<span class="math inline">\(A =
2\)</span>,以此类推.由此见上述命题的合理性.而且具体的论证过程只需要对这上面写抽象语言就行.</p>
<p>可是,难道一般的级数就真的不能交换顺序了嘛?事实上使用柯西准则,我们可以证明如果重排是局部的,或者说<span class="math inline">\(\exists M &gt; 0 , \forall n , | n - f ( n ) |
\leq M &lt;
\infty\)</span>,换言之交换的距离有上界,那交换后敛散性不变.</p>
<p>这个怎么证明呢?首先如果原级数收敛的话,用柯西准则,因为通项趋于<span class="math inline">\(0\)</span>,所以往外扩张适当有界长度(实际上就是<span class="math inline">\(M\)</span>)应当无影响.如果原级数发散的话,如果通项还是不趋于<span class="math inline">\(0\)</span>那当然还是完蛋,否则的话还可以用上面的证明.这就证毕了.</p>
<h6><span id="example">Example</span></h6>
<p><span class="math inline">\(a_n &gt; 0\)</span>,当<span class="math inline">\(\sum \frac{ 1 }{ a_n } &lt;
\infty\)</span>的时候,求证<span class="math inline">\(\sum \frac{ n }{
\sum_{ k = 1 }^n a_k } &lt; \infty\)</span>.</p>
<p>首先考虑<span class="math inline">\(\{ a_n
\}\)</span>单增的情况,如果不单增的话,可以直接对其进行排序.</p>
<p>考虑<span class="math inline">\(\frac{ 2 n }{ \sum_{ k = 1 }^{ 2 n }
a_k } &lt; \frac{ 2 n }{ na_n } = \frac{ 2 }{ a_n }\)</span>,同理<span class="math inline">\(\frac{ 2 n - 1 }{ \sum_{ k = 1 }^{ 2 n } a_k }
&lt; \frac{ 2 n - 1 }{ na_n } &lt; \frac{ 2 }{ a_n
}\)</span>,于是证毕.</p>
<h4><span id="级数的乘法">级数的乘法</span></h4>
<p>考虑<span class="math inline">\(( \sum a_j ) ( \sum b_k ) = \sum a_j
b_k\)</span>,首要的问题在于如何指定后者的求和顺序.</p>
<p>柯西策略是,考虑取<span class="math inline">\(c_n = \sum_{ j + k = n +
1 } a_j b_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum
c_n\)</span>.此好处是可以求解生成函数乘积,<span class="math inline">\((
\sum a_j x^j ) ( \sum b_k x^k )\)</span>.</p>
<p>矩形策略是,考虑取<span class="math inline">\(c_n = \sum_{ \max ( j ,
k ) = n } a_j b_k\)</span>,然后取原式顺序为<span class="math inline">\(\sum c_n\)</span>.此好处是它的求和天然是<span class="math inline">\(( \sum_{ j = 1 }^n a_j ) ( \sum_{ k = 1 }^n b_k
)\)</span>的极限.所以此方法天然有如果<span class="math inline">\(\sum
a_j = A , \sum b_k = B\)</span>,则<span class="math inline">\(\sum c =
AB\)</span>.</p>
<p>接下来我们证明,如果<span class="math inline">\(\sum a\)</span>和<span class="math inline">\(\sum
b\)</span>都绝对收敛,那它们的乘积任意排列都是相等的.换言之只要双重指标集合<span class="math inline">\(\{ ( j_i , k_i ) \} = \{ ( j , k )
\}\)</span>那就都收敛于同一值.</p>
<p>证明策略类似,取<span class="math inline">\(N_n = \max_{ 1 \leq i \leq
n } ( j_i , k_i )\)</span>,那么当然有:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n | a_{ j_i } b_{ k_i } | \leq ( \sum_{ j = 1 }^{ N_n } |
a_{ j } | ) ( \sum_{ k = 1 }^{ N_n } | b_{ k } | )
\]</span></p>
<p>那当然就绝对收敛,再类似之前的可以证明其与顺序无关,这个时候用矩形策略就可以知道最终就收敛于<span class="math inline">\(( \sum a ) ( \sum b )\)</span>.</p>
<p>如果是条件收敛,矩形和当然没问题,仍然收敛,难点当然在于柯西和何时收敛?我们声称:如果<span class="math inline">\(\sum a_n\)</span>收敛,<span class="math inline">\(\sum | b_n | &lt;
\infty\)</span>,也就是一个收敛一个绝对收敛,我们就能推出柯西和是收敛的而且就等于矩形和.</p>
<p>考虑设矩形法的<span class="math inline">\(u_k = \sum_{ \max ( i , j )
= k } a_i b_j\)</span>,柯西法的<span class="math inline">\(c_k = \sum_{
i + j = k + 1 } a_i b_j\)</span>,考虑求:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n u_k - c_k | \\
= &amp; | \sum_{ i_j &gt; n + 1 , i \leq n , j \leq n } a_i b_j | \\
\leq &amp; \sum_{ i = 2 }^n | b_i | | \sum_{ j = n - i + 2 }^n a_j | \\
= &amp; \sum_{ i = 2 }^N | b_i | | \sum_{ j = n - i + 2 }^n a_j | +
\sum_{ i = N + 1 }^n | b_i | | \sum_{ j = n - i + 2 }^n a_j |
\end{aligned}
\]</span></p>
<p>接下来用柯西收敛原理,先取<span class="math inline">\(N\)</span>,只要<span class="math inline">\(N\)</span>足够大,由于<span class="math inline">\(|
\sum_{ j = n - i + 2 }^n a_j |\)</span>当然是有界的,因为<span class="math inline">\(\sum a\)</span>收敛,只要<span class="math inline">\(N\)</span>足够大,不管<span class="math inline">\(n\)</span>如何,<span class="math inline">\(\sum_{
i = N + 1 }^n | b_i
|\)</span>用柯西收敛原理就足够小.这样后半项就解决了.</p>
<p>前半项同理,在<span class="math inline">\(N\)</span>取定的时候<span class="math inline">\(\sum_{ i = 2 }^N | b_i
|\)</span>就取定有界了.而只要在此基础上使得<span class="math inline">\(n\)</span>尽可能大,<span class="math inline">\(|
\sum_{ j = n - i + 2 }^n a_j
|\)</span>用柯西收敛原理就控制住了,于是整体就很小.那就证明了此时柯西和恰好就是矩形和.</p>
<p>一般的柯西和没有这么好的结论,但其实证明可以类似上面,具体地,我们取<span class="math inline">\(A_n = \sum_{ k = 1 }^n a_k , B_n = \sum_{ k = 1
}^n b_k\)</span>并且<span class="math inline">\(\lim A , \lim
B\)</span>都存在,取柯西和<span class="math inline">\(c_n = \sum_{ k = 1
}^n a_k b_{ n - k + 1 }\)</span>,我们断言<span class="math inline">\(C_n
= \sum_{ k = 1 }^n c_k\)</span>收敛当且仅当极限<span class="math inline">\(\lim_{ n \to \infty } \sum_{ k = 1 }^n a_k \sum_{
j = n - k + 1 }^n b_j\)</span>存在.</p>
<p>原因是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n a_k \sum_{ j = n - k + 1 }^n b_j \\
= &amp; \sum_{ k = 1 }^n a_k ( B_n - B_{ n - k } ) \\
= &amp; B_n A_n - ( \sum_{ k = 1 }^{ n - 1 } a_k B_{ n - k } ) \\
= &amp; B_n A_n - C_{ n - 1 }
\end{aligned}
\]</span></p>
<p>这就证毕,而且当然见到只有上述极限为<span class="math inline">\(0\)</span>的时候,柯西和才会有<span class="math inline">\(\lim C = ( \lim A ) ( \lim B )\)</span>.</p>
<h4><span id="无穷乘积">无穷乘积</span></h4>
<p>对于数列<span class="math inline">\(\{ a_n \}\)</span>,设<span class="math inline">\(A_n = \prod_{ k = 1 }^n a_k\)</span>,若<span class="math inline">\(\lim_{ n \to \infty }
A_n\)</span>存在且非零,则称<span class="math inline">\(\prod_{ k = 1 }^{
+ \infty }
a_k\)</span>收敛.为什么这里要求非零呢?因为我们希望类似无穷和,这里去掉前有限项后,敛散性不变.这就要求我们最好判掉零的情况.如若其极限为<span class="math inline">\(0\)</span>,则仍称其发散,但有的时候发散到零也会有一些性质,到时我们会单独讨论.</p>
<p>既然如此,不妨设<span class="math inline">\(a_n \ne
0\)</span>.有以下性质:</p>
<ol type="1">
<li><p>若<span class="math inline">\(\prod a_n\)</span>收敛,则<span class="math inline">\(\lim a_n = 1\)</span>.既然如此,<span class="math inline">\(a_n\)</span>从某一项开始就满足<span class="math inline">\(a_n &gt; 0\)</span>.之后不妨干脆设<span class="math inline">\(a_n &gt; 0\)</span>.</p></li>
<li><p><span class="math inline">\(A_n\)</span>有非<span class="math inline">\(0\)</span>极限当且仅当<span class="math inline">\(\ln A_n\)</span>有极限.</p></li>
<li><p>柯西收敛准则:<span class="math inline">\(A_n\)</span>有非零极限的必要条件是<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall N
\leq n \leq m\)</span>,<span class="math inline">\(| 1 - \prod_{ k = n
}^m a_k | &lt; \epsilon\)</span>.特别地,如果<span class="math inline">\(\forall a_n \ne
0\)</span>,则上式为充要条件.</p></li>
</ol>
<p>(1)(2)显然.</p>
<p>(3)的话也比较显然.</p>
<p>总之,既然<span class="math inline">\(\lim a_n \to
1\)</span>,不妨干脆设其为<span class="math inline">\(1 +
a_n\)</span>,其中<span class="math inline">\(\lim a_n =
0\)</span>,从而原本要研究的<span class="math inline">\(\prod ( 1 + a_n
)\)</span>可以转为研究<span class="math inline">\(\sum \ln ( 1 + a_n
)\)</span>.</p>
<ol type="1">
<li><p>当<span class="math inline">\(a_n\)</span>定号的时候,<span class="math inline">\(\sum \ln ( 1 + a_n )\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.</p></li>
<li><p>当<span class="math inline">\(a_n\)</span>不定号的时候,若<span class="math inline">\(\sum a_n^2 &lt; \infty\)</span>,则<span class="math inline">\(\sum \ln ( 1 + a_n )\)</span>和<span class="math inline">\(\sum a_n\)</span>的敛散性相同.同理如若<span class="math inline">\(\sum
a_n^2\)</span>发散,则上述两个级数至少一个发散.</p></li>
<li><p><span class="math inline">\(\sum | \ln ( 1 + a_n )
|\)</span>和<span class="math inline">\(\sum | a_n
|\)</span>的敛散性相同.</p></li>
</ol>
<p>(1)是因为<span class="math inline">\(\lim \frac{ \ln ( 1 + a_n ) }{
a_n } = 1\)</span>.</p>
<p>(2)是因为<span class="math inline">\(a_n - \ln ( 1 + a_n
)\)</span>可以被<span class="math inline">\(a_n^2\)</span>控制住,原因是<span class="math inline">\(a_n \to 0\)</span>,换言之存在<span class="math inline">\(c_1 , c_2\)</span>使得<span class="math inline">\(c_1 x^2 &lt; a_n - \ln ( 1 + a_n ) &lt; c_2
x^2\)</span>,只需要对<span class="math inline">\(0\)</span>附近做个简单放缩.既然它们的差收敛,那它们当然敛散性相同.</p>
<p>(3)还是因为<span class="math inline">\(\lim \frac{ | \ln ( 1 + x ) |
}{ | x | } = 1\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(| x | &lt; 1\)</span>的时候,求<span class="math inline">\(\prod_{ k = 1 } ( 1 + x^{ 2^{ k - 1 } }
)\)</span>的极限.</p>
<p>容易见到<span class="math inline">\(A_n = \prod_{ k = 1 }^n ( 1 + x^{
2^{ k - 1 } } ) = \frac{ 1 - x^{ 2^n } }{ 1 - x
}\)</span>,这样自然就收敛了.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\prod_{ k = 1 } \cos \frac{ \varphi }{
2^k }\)</span>.</p>
<p>当<span class="math inline">\(\varphi \ne 0\)</span>的时候,考虑<span class="math inline">\(A_n = \prod_{ k = 1 }^n \cos \frac{ \varphi }{ 2^k
} = \frac{ \sin \varphi }{ 2^n \sin \frac{ \varphi }{ 2^n }
}\)</span>.虽然这里当<span class="math inline">\(\varphi = 2^k
\pi\)</span>的时候会有若干项分母为<span class="math inline">\(0\)</span>,但由于我们可以干脆去掉这前几项,而只看后几项分母均不为<span class="math inline">\(0\)</span>,当然收敛于<span class="math inline">\(\frac{ \sin \varphi }{ \varphi }\)</span>.</p>
<p>而<span class="math inline">\(\varphi =
0\)</span>的时候每一项都是<span class="math inline">\(1\)</span>,乘起来仍然收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑<span class="math inline">\(\Gamma ( x ) = \frac{ 1 }{ x }
\prod_{ n = 1 }^{ \infty } \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 +
\frac{ x }{ n } }\)</span>敛散性,其中<span class="math inline">\(x \ne 0
, - 1 , - 2 , \cdots\)</span>.</p>
<p>直接泰勒展开,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 + \frac{ x }{ n } } \\
= &amp; ( 1 + \frac{ x }{ n } + \frac{ x ( x - 1 ) }{ 2 n^2 } + o (
\frac{ 1 }{ n^2 } ) ) ( 1 - \frac{ x }{ n } + \frac{ x^2 }{ n^2 } + o (
\frac{ 1 }{ n^2 } ) ) \\
= &amp; 1 + \frac{ x ( x - 1 ) }{ 2 n^2 } + o ( \frac{ 1 }{ n^2 } )
\end{aligned}
\]</span></p>
<p>这就绝对收敛了.</p>
<p>而我们观察<span class="math inline">\(A_n\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
A_n &amp; = \frac{ 1 }{ x } \prod_{ k = 1 }^{ n } \frac{ ( \frac{ k + 1
}{ k } )^x }{ 1 + \frac{ x }{ k } } \\
&amp; = \frac{ ( n + 1 )^x }{ x ( 1 + \frac{ x }{ 1 } ) \cdots ( 1 +
\frac{ x }{ n } ) } \\
&amp; = ( \frac{ n + 1 }{ n } )^x \frac{ n ! n^x }{ x^{ \overline{ n + 1
} } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是见到:</p>
<p><span class="math display">\[
\frac{ \Gamma ( x + 1 ) }{ \Gamma ( x ) } = \lim_{ n \to \infty } \frac{
( n + 1 ) x }{ x + 1 + n } = x
\]</span></p>
<p>所以<span class="math inline">\(\Gamma ( x + 1 ) = x \Gamma ( x
)\)</span>,而且<span class="math inline">\(\Gamma ( 1 ) =
1\)</span>,所以<span class="math inline">\(\Gamma ( n ) = n
!\)</span>,这实际上是阶乘函数的一个推广.</p>
<p>而此时有<span class="math inline">\(\Gamma ( x + 1 ) = x \Gamma ( x )
= \prod_{ n = 1 }^\infty \frac{ ( 1 + \frac{ 1 }{ n } )^x }{ 1 + \frac{
x }{ n } }\)</span>.</p>
<p>而观察这个级数:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \prod_{ n = 1 }^\infty \frac{ e^{ \frac{ 1 }{ n } } }{ 1 + \frac{
1 }{ n } } \\
= &amp; \frac{ e^{ 1 + \frac{ 1 }{ 2 } + \cdots + \frac{ 1 }{ n } } }{ n
+ 1 } \\
= &amp; \frac{ e^{ \ln n + \gamma + c_n } }{ n + 1 } \to e^\gamma
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\gamma\)</span>是欧拉常数,误差项<span class="math inline">\(c_n = H_n - \ln n - \gamma \to 0\)</span>.</p>
<p>从而观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; e^{ \gamma x } \Gamma ( x + 1 ) \\
= &amp; \prod_{ n = 1 }^\infty \frac{ e^{ \frac{ x }{ n } } }{ 1 +
\frac{ x }{ n } }
\end{aligned}
\]</span></p>
<p>从而<span class="math inline">\(\frac{ 1 }{ \Gamma ( x + 1 ) } = e^{
\gamma x } \prod_{ n = 1 }^\infty ( 1 + \frac{ x }{ n } ) e^{ - \frac{ x
}{ n } }\)</span>.</p>
<p>在此基础上,如若设<span class="math inline">\(b_n = \frac{ n ! n^x }{
x^{ \overline{ n + 1 } } }\)</span>.容易见到<span class="math inline">\(\lim b_n = \lim A_n = \Gamma ( x
)\)</span>,而观察到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ b_{ n + 1 } }{ b_n } &amp; = \frac{ ( 1 + \frac{ 1 }{ n } )^{ x +
1 } }{ 1 + \frac{ x + 1 }{ n } } \\
&amp; = 1 + \frac{ x ( x + 1 ) }{ 2 n^2 } + o ( \frac{ 1 }{ n^2 } ) \\
&amp; \to 1
\end{aligned}
\]</span></p>
<p>而且如若<span class="math inline">\(x ( x + 1 ) &gt;
0\)</span>,并且取<span class="math inline">\(n\)</span>足够大,则上式大于<span class="math inline">\(1\)</span>,反之上式小于<span class="math inline">\(1\)</span>.因此当<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(b_n\)</span>单调有界(原因是其极限存在).</p>
<p>因此还可以得到结论:<span class="math inline">\(\sum \frac{ n ! a_n }{
x^{ \overline{ n + 1 } } }\)</span>和<span class="math inline">\(\sum
\frac{ a_n }{ n^x }\)</span>敛散性相同,其中<span class="math inline">\(x
\ne 0 , - 1 , - 2 , \cdots\)</span>.原因只是因为这俩的比值恰好是<span class="math inline">\(b_n\)</span>单调有界,根据DA判别法知道二者同敛散.</p>
<h6><span id="example4">Example4</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ ( nx )^n
}{ n ! }\)</span>的收敛性.</p>
<p>考虑:</p>
<p><span class="math display">\[
\frac{ a_{ n + 1 } }{ a_n } = ( \frac{ n + 1 }{ n } )^n x \to ex
\]</span></p>
<p>根据比值判法,当<span class="math inline">\(| x | &lt; \frac{ 1 }{ e
}\)</span>的时候绝对收敛,而当<span class="math inline">\(| x | &gt;
\frac{ 1 }{ e }\)</span>的时候发散,问题只在于<span class="math inline">\(| x | = \frac{ 1 }{ e }\)</span>的时候如何.</p>
<p>当<span class="math inline">\(x = \frac{ 1 }{ e
}\)</span>的时候,使用拉贝判法:</p>
<p><span class="math display">\[
\begin{aligned}
n ( \frac{ a_n }{ a_{ n + 1 } } - 1 ) &amp; = n ( ( 1 - \frac{ 1 }{ n +
1 } )^n e - 1 ) \\
&amp; = n ( e^{ n \ln ( 1 - \frac{ 1 }{ n + 1 } ) + 1 } - 1 ) \\
&amp; = n ( e^{ n ( - \frac{ 1 }{ n + 1 } - \frac{ 1 }{ 2 ( n + 1 )^2 }
+ o ( \frac{ 1 }{ n^2 } ) ) + 1 } - 1 ) \\
&amp; = n ( e^{ \frac{ 1 }{ n + 1 } - \frac{ n }{ 2 ( n + 1 )^2 } + o (
\frac{ 1 }{ n } ) } - 1 ) \\
&amp; = n ( \frac{ 1 }{ n + 1 } - \frac{ n }{ 2 ( n + 1 )^2 } + o (
\frac{ 1 }{ n } ) ) \\
&amp; \to \frac{ 1 }{ 2 } &lt; 1
\end{aligned}
\]</span></p>
<p>所以发散.</p>
<p>当<span class="math inline">\(x = - \frac{ 1 }{ e
}\)</span>的时候,使用DA判法:应当见到<span class="math inline">\(a_n = (
- 1 )^n | a_n |\)</span>,此时<span class="math inline">\(| a_n
|\)</span>单调递减且趋于<span class="math inline">\(0\)</span>,用DA判法知道其收敛.</p>
<p>所以条件收敛.</p>
<h6><span id="example5">Example5</span></h6>
<p>求证<span class="math inline">\(\sum a_n ( x^2 - 1 ) ( x^2 - 2^2 )
\cdots ( x^2 - n^2 )\)</span>对<span class="math inline">\(\forall x
\notin \mathbb{ Z }\)</span>,其都有相同的敛散性.就是对于一个确定的<span class="math inline">\(\{ a_n \}\)</span>,对所有的<span class="math inline">\(x\)</span>,要么都收敛,要么都发散.</p>
<p>考虑设<span class="math inline">\(f_n ( x ) = ( x^2 - 1 ) ( x^2 - 2^2
) \cdots ( x^2 - n^2 )\)</span>,观察到:</p>
<p><span class="math display">\[
\frac{ f_n ( x ) }{ f_n ( x_0 ) } = \frac{ ( x^2 - 1 ) ( x^2 - 2^2 )
\cdots ( x^2 - n^2 ) }{ ( x_0^2 - 1 ) ( x_0^2 - 2^2 ) \cdots ( x_0^2 -
n^2 ) }
\]</span></p>
<p>这当然是个无穷乘积,观察到<span class="math inline">\(\frac{ x^2 - n^2
}{ x_0^2 - n^2 } = 1 + \frac{ x^2 - x_0^2 }{ x_0^2 - n^2 } = 1 + O (
\frac{ 1 }{ n^2 } )\)</span>,所以<span class="math inline">\(\lim_{ n
\to \infty } \frac{ f_n ( x ) }{ f_n ( x_0 ) }\)</span>存在且非零.</p>
<p>而且,当<span class="math inline">\(n\)</span>足够大的时候,或者更进一步说<span class="math inline">\(| n | &gt; \max ( | x | , | x_0 |
)\)</span>的时候<span class="math inline">\(\frac{ f_n ( x ) }{ f_n (
x_0 ) }\)</span>当然就定号了,而且<span class="math inline">\(\frac{ x^2
- n^2 }{ x_0^2 - n^2 } = 1 + \frac{ x^2 - x_0^2 }{ x_0^2 - n^2
}\)</span>,其与<span class="math inline">\(1\)</span>比较只取决于<span class="math inline">\(x^2 - x_0^2\)</span>,这就意味着<span class="math inline">\(\frac{ f_n ( x ) }{ f_n ( x_0 ) }\)</span>在<span class="math inline">\(n\)</span>足够大的时候是单调有界非零的,于是DA判法知道同敛散.</p>
<h6><span id="example6">Example6</span></h6>
<p>求证<span class="math inline">\(\sin x = x \prod_{ k = 1 }^{ \infty }
( 1 - \frac{ x^2 }{ k^2 \pi^2 } )\)</span>.</p>
<p>先看<span class="math inline">\(\sin x =
0\)</span>的根,假设其根为<span class="math inline">\(u +
iv\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sin x &amp; = \frac{ e^{ ix } - e^{ - ix } }{ 2 i } = 0 \\
e^{ 2 ix } &amp; = 1 \\
e^{ 2 iu - 2 v } &amp; = 1 \\
| e^{ 2 iu - 2 v } | &amp; = 1 \\
e^{ - 2 v } &amp; = 1 \\
v &amp; = 0
\end{aligned}
\]</span></p>
<p>所以其只有实根,用多项式理论知道如若<span class="math inline">\(\sin
x\)</span>的根只有<span class="math inline">\(2 k
\pi\)</span>,应该有:</p>
<p><span class="math display">\[
\sin x = cx \prod_{ k = 1 }^{ \infty } ( 1 - \frac{ x^2 }{ k^2 \pi^2 } )
\]</span></p>
<p>容易见到这个无穷乘积的确收敛,而<span class="math inline">\(x \to
0\)</span>的时候<span class="math inline">\(\frac{ \sin x }{ x } =
1\)</span>,所以<span class="math inline">\(c = 1\)</span>.</p>
<p>那么考虑<span class="math inline">\(\sin x\)</span>的泰勒展开,有:</p>
<p><span class="math display">\[
\begin{aligned}
1 - \frac{ x^2 }{ 6 } + \cdots &amp; = \prod_{ k = 1 } ( 1 - \frac{ x^2
}{ k^2 \pi^2 } ) \\
&amp; = 1 - ( \frac{ 1 }{ \pi^2 } \sum_k \frac{ 1 }{ k^2 } ) x^2 +
\cdots
\end{aligned}
\]</span></p>
<p>这就能知道<span class="math inline">\(\sum_{ k = 1 }^\infty \frac{ 1
}{ k^2 } = \frac{ \pi^2 }{ 6 }\)</span>.</p>
<p>然而上述的多项式理论还是太过粗糙,下面提供一种更加严谨的证明:</p>
<p>我们有欧拉公式:</p>
$$
<span class="math display">\[\begin{aligned}
( \cos x + i \sin x )^{ 2 n + 1 } &amp; = \cos ( 2 n + 1 ) x + i \sin (
2 n + 1 ) x \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而左侧可以使用二项式定理展开,有:</p>
<p><span class="math display">\[
( \cos x + i \sin x )^{ 2 n + 1 } = \sum \binom{ 2 n + 1 }{ k } \cos^k x
( i \sin x )^{ 2 n + 1 - k }
\]</span></p>
<p>容易见到为了贡献虚部,<span class="math inline">\(k\)</span>必须是偶数,那此时<span class="math inline">\(\cos^k x = ( 1 - \sin^2 x )^{ \frac{ k }{ 2 }
}\)</span>,总之,我们发现应该存在一个<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(P_n\)</span>,使得:</p>
$$
<span class="math display">\[\begin{aligned}
\sin ( 2 n + 1 ) x &amp; = ( \sin x ) P_n ( \sin^2 x ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个多项式的根应该怎么取呢?考虑当<span class="math inline">\(\varphi_k = \frac{ k \pi }{ 2 n + 1 } , 1 \leq k
\leq n\)</span>的时候,左侧为<span class="math inline">\(0\)</span>,而右侧<span class="math inline">\(\sin
\varphi_k\)</span>不该为<span class="math inline">\(0\)</span>,更进一步地,<span class="math inline">\(\sin^2
\varphi_k\)</span>两两不同,这就知道它们确实是<span class="math inline">\(P_n\)</span>的<span class="math inline">\(n\)</span>个根.同时见到<span class="math inline">\(P ( 0 ) = \lim_{ x \to 0 } P_n ( \sin^2 x ) = 2 n
+ 1\)</span>,从而我们已经能唯一确定这个有限项多项式<span class="math inline">\(P_n ( x ) = ( 2 n + 1 ) \prod_{ k = 1 }^n ( 1 -
\frac{ x }{ \sin^2 \varphi_k } )\)</span>.</p>
<p>接下来,将原本上式中的<span class="math inline">\(x\)</span>换成<span class="math inline">\(\frac{ x }{ 2 n + 1 }\)</span>,我们就能得到:</p>
<p><span class="math display">\[
\sin x = ( 2 n + 1 ) \sin ( \frac{ x }{ 2 n + 1 } ) \prod_{ k = 1 }^n (
1 - \frac{ \sin^2 \frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } )
\]</span></p>
<p>这里已经十分接近我们想要的答案了,但是这个项数和<span class="math inline">\(n\)</span>一起增大,策略当然是大小步极限,考虑取:</p>
$$
<span class="math display">\[\begin{aligned}
U_m &amp; = ( 2 n + 1 ) \sin \frac{ x }{ 2 n + 1 } \prod_{ k = 1 }^m ( 1
- \frac{ \sin^2 \frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\
V_m &amp; = \prod_{ k = m + 1 }^n ( 1 - \frac{ \sin^2 \frac{ x }{ 2 n +
1 } }{ \sin^2 \varphi_k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>取定<span class="math inline">\(m\)</span>,当然总能取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(U_m \to
x \prod_{ k = 1 }^m ( 1 - \frac{ x^2 }{ k^2 \pi^2 } )\)</span>.</p>
<p>而用柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,如果能证明<span class="math inline">\(V_m \to 1\)</span>就完事了.我们考虑:</p>
$$
<span class="math display">\[\begin{aligned}
1 &amp; \geq V_m \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ \sin^2
\frac{ x }{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而回忆到当<span class="math inline">\(\sin^2 x \leq
x^2\)</span>恒成立,在<span class="math inline">\(x \in [ 0 , \frac{ \pi
}{ 2 } ]\)</span>的时候,<span class="math inline">\(\sin x \geq \frac{ 2
}{ \pi } x\)</span>也成立,所以:</p>
$$
<span class="math display">\[\begin{aligned}
V_m &amp; \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ \sin^2 \frac{ x
}{ 2 n + 1 } }{ \sin^2 \varphi_k } ) \\
&amp; \geq \prod_{ k = m + 1 }^\infty ( 1 - \frac{ x^2 }{ 4 k^2 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时回忆到<span class="math inline">\(\prod_{ k = 1 }^\infty ( 1 -
\frac{ x^2 }{ 4 k^2 } )\)</span>是收敛的,所以由柯西准则,当<span class="math inline">\(m\)</span>足够大的时候,<span class="math inline">\(\prod_{ k = m + 1 }^\infty ( 1 - \frac{ x^2 }{ 4
k^2 } )\)</span>趋近于<span class="math inline">\(1\)</span>,这就证毕了.</p>
<h3><span id="函数项数列">函数项数列</span></h3>
<p>也就是每一项都是一个函数的数列,假设定义域在<span class="math inline">\(I \subseteq \mathbb{ R }\)</span>上,写作<span class="math inline">\(\{ f_n ( x ) \}\)</span>.此时对于一个固定的<span class="math inline">\(x_0 \in I\)</span>,则<span class="math inline">\(\{ f_n ( x_0 )
\}\)</span>就是一个普通的数列.当然不一定<span class="math inline">\(I\)</span>中的每一个<span class="math inline">\(x_0\)</span>都收敛,我们将<strong>收敛点</strong>的集合称为函数项级数的<strong>收敛域</strong>,其它的点称为<strong>发散点</strong>,发散点组成的集合称为<strong>发散域</strong>.</p>
<p>对于收敛域,直接记<span class="math inline">\(f ( x ) = \lim_{ n \to
\infty } f_n ( x )\)</span>,我们将这里的<span class="math inline">\(f (
x
)\)</span>就是这个函数列的<strong>极限函数</strong>.既然有了极限就可以定义级数,也就是可以定义<span class="math inline">\(S_n = \sum_{ k = 1 }^n f_k ( x
)\)</span>,然后取其极限拿到<span class="math inline">\(\sum_{ k = 1
}^\infty f_n ( x ) = S ( x )\)</span>.</p>
<p>我们要解决的问题大概有以下三个:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(f_n\)</span>均是连续的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>连续.也就是两层极限什么时候可以交换顺序.</p></li>
<li><p>如果<span class="math inline">\(f_n\)</span>均是黎曼可积的,那么要求什么条件,可以满足<span class="math inline">\(f\)</span>黎曼可积并且<span class="math inline">\(\lim \int f_n = \int
f\)</span>,也就是极限和积分什么时候可以交换顺序.</p></li>
<li><p>如果<span class="math inline">\(f_n\)</span>均可导,那么什么时候<span class="math inline">\(f\)</span>也可导,并且<span class="math inline">\(\lim f_n &#39; = f
&#39;\)</span>,也就是极限和导数什么时候可以交换顺序.</p></li>
</ol>
<p>如果不加条件,上述三条全都是不满足的,下述Example会给出若干例子.</p>
<h6><span id="example1">Example1</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = x^n , x \in [ 0 , 1
]\)</span>,求其极限函数.</p>
<p>显然<span class="math inline">\(f ( x ) = \begin{cases}1 &amp; x = 1
\\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,由此可以见到,连续函数的极限函数不一定连续.</p>
<h6><span id="example2">Example2</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = \begin{cases}1 &amp; ( n !
) x \in \mathbb{ Z } \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,求其极限函数.</p>
<p>显然是迪利克雷函数.</p>
<p>则<span class="math inline">\(f_n ( x
)\)</span>只有有限个间断点,容易见到其黎曼可积,然而迪利克雷函数并不黎曼可积.可积函数的极限函数不一定可积.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = nx ( 1 - x^2 )^n , x \in [
0 , 1 ]\)</span>,求其极限函数.</p>
<p>容易见到<span class="math inline">\(\lim f_n ( x ) =
0\)</span>,也就是这个函数处处收敛到<span class="math inline">\(0\)</span>.</p>
<p>然而,对其求积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^1 f_n ( x ) \mathrm{ d } x &amp; = \int_0^1 nx ( 1 - x^2 )^n
\mathrm{ d } x \\
&amp; = - \frac{ n }{ 2 } \int_0^1 ( 1 - x^2 )^n \mathrm{ d } ( 1 - x^2
) \\
&amp; = - \frac{ n }{ 2 ( n + 1 ) } ( 1 - x^2 )^{ n + 1 } |_0^1 \\
&amp; = \frac{ n }{ 2 ( n + 1 ) } \to \frac{ 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>由此见到,极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example4">Example4</span></h6>
<p>考虑<span class="math inline">\(f_n ( x ) = \begin{cases}2 n^2 x \\ x
\in [ 0 , \frac{ 1 }{ 2 n } ] \\ 2 n^2 ( x - \frac{ 1 }{ n } ) &amp; x
\in ( \frac{ 1 }{ 2 n } , \frac{ 1 }{ n } ] \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,也就是这个函数在<span class="math inline">\(\frac{
1 }{ 2 n }\)</span>处高度为<span class="math inline">\(n\)</span>,底长为<span class="math inline">\(\frac{ 1 }{ n
}\)</span>的一个小三角形.求其极限函数.</p>
<p>对于每一个点,这个函数当然逐点收敛于<span class="math inline">\(0\)</span>.然而也可以见到,这个函数的积分对于每一个<span class="math inline">\(n\)</span>来说都是<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>再次说明了极限函数的积分不一定等于积分的极限.极限和积分不一定可交换.</p>
<h6><span id="example5">Example5</span></h6>
<p>考虑<span class="math inline">\(f_n ( x ) = \frac{ \sin ( nx ) }{
\sqrt{ n } }\)</span>,求其极限函数.</p>
<p>当然逐点收敛于<span class="math inline">\(0\)</span>,然而观察到<span class="math inline">\(f_n &#39; ( x ) = \sqrt{ n } \cos
nx\)</span>,<span class="math inline">\(f &#39; ( x ) =
0\)</span>.因此,光滑函数列的导数的极限又不一定等于极限的导数.</p>
<h4><span id="一致收敛">一致收敛</span></h4>
<p>我们称一列函数<span class="math inline">\(\{ f_n ( x )
\}\)</span>是<strong>一致收敛</strong>到<span class="math inline">\(f (
x )\)</span>,当且仅当<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N = N ( \epsilon
)\)</span>,使得当<span class="math inline">\(n \geq
N\)</span>的时候,<span class="math inline">\(| f ( x ) - f_n ( x ) |
&lt; \epsilon , \forall x \in I\)</span>.注意这里的<span class="math inline">\(N\)</span>不取决于<span class="math inline">\(x\)</span>的选取,这就是和极限不同的地方,一致收敛要求整个函数都在逐步地贴向最终的函数.此时,记<span class="math inline">\(f_n ( x ) \rightrightarrows f ( x
)\)</span>.还可以定义<strong>内闭一致收敛</strong>的概念,也就是对于一个<span class="math inline">\(I\)</span>的任意的子紧集(在<span class="math inline">\(\mathbb{ R
}\)</span>上表现为有界闭集)都一致收敛.</p>
<p>一致收敛的等价定义当然是,取<span class="math inline">\(M_n = \sup_{ x
\in I } | f_n ( x ) - f ( x ) |\)</span>,那么一致收敛等价于<span class="math inline">\(\lim M_n = 0\)</span>.</p>
<p>一致收敛强大的地方在于,对于收敛来说,是取定了<span class="math inline">\(x\)</span>再挪动<span class="math inline">\(n\)</span>,因此<span class="math inline">\(n\)</span>可以控制<span class="math inline">\(x\)</span>.然而,一致收敛要求先取定<span class="math inline">\(n\)</span>再挪动<span class="math inline">\(x\)</span>.这种天然的交换能力赋予了一致收敛的强大.另外还容易见到,当<span class="math inline">\(I\)</span>的点集是有限的时候,一定一致收敛.</p>
<p>我们还可以定义<strong>一致有界</strong>的概念,当存在一个上界<span class="math inline">\(M\)</span>,使得<span class="math inline">\(\forall
n , | f_n | \leq
M\)</span>恒成立.显然,如果一个函数列一致有界,则极限函数肯定有界.</p>
<p>另外,我们可以见到,如果<span class="math inline">\(f_n
\rightrightarrows f\)</span>,那么如果<span class="math inline">\(f\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.反之,如果<span class="math inline">\(f_n\)</span>有界,则<span class="math inline">\(f_n\)</span>一致有界.</p>
<p>考虑前者,是因为:</p>
<p><span class="math display">\[
| f_n | \leq | f_n - f | + | f |
\]</span></p>
<p>这俩当然是有界的.</p>
<p>对于后者,考虑反证,假设<span class="math inline">\(f\)</span>无界(因为如果有界则前者即可推出),那么:</p>
<p><span class="math display">\[
| f | \leq | f - f_n | + | f_n |
\]</span></p>
<p>由于<span class="math inline">\(| f - f_n
|\)</span>必然需要有界,因此前者无界,后者无论对于哪个<span class="math inline">\(n\)</span>来说,必然也得无界.</p>
<p>我们有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(f_n \rightrightarrows f , g_n
\rightrightarrows g , x \in I\)</span>,则<span class="math inline">\(c_1
f_n + c_2 g_n \rightrightarrows c_1 f + c_2 g , x \in
I\)</span>.</p></li>
<li><p><span class="math inline">\(f_n \rightrightarrows f , g_n
\rightrightarrows g , x \in I\)</span>,而且<span class="math inline">\(f
, g\)</span>有界,则<span class="math inline">\(f_n g_n \rightrightarrows
fg , x \in I\)</span>.</p></li>
<li><p>如果<span class="math inline">\(x \in I\)</span>的时候<span class="math inline">\(f_n \rightrightarrows f\)</span>,<span class="math inline">\(x \in J\)</span>的时候也<span class="math inline">\(f_n \rightrightarrows f\)</span>,则当<span class="math inline">\(x \in I \cup J\)</span>的时候也有<span class="math inline">\(f_n \rightrightarrows f\)</span>.</p></li>
</ol>
<p>对于(1),考虑令<span class="math inline">\(M_{ n } = \sup | f_n - f |
, K_n = \sup | g_n - g |\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | ( c_1 f_n + c_2 g_n ) - ( c_1 f + c_2 g ) | \\
\leq &amp; | c_1 | M_n + | c_2 | K_n \to 0
\end{aligned}
\]</span></p>
<p>立刻证毕.</p>
<p>对于(2),经典的做法:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n g_n - fg | \\
= &amp; | f_n ( g_n - g ) + g ( f_n - f ) | \\
\leq &amp; | f_n | \cdot | g_n - g | + | g | \cdot | f_n - f |
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(| f_n |\)</span>一致有界,<span class="math inline">\(| g_n |\)</span>一致有界得到<span class="math inline">\(| g |\)</span>有界,所以上式就被控制住了.</p>
<p>对于(3),只需要把两部分的<span class="math inline">\(\sup\)</span>分开算就可以见到仍能被控制住.</p>
<p>这里也有<strong>柯西准则</strong>:对于一列函数<span class="math inline">\(\{ f_n \}\)</span>,其一致收敛的充要条件是,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n ,
m \geq N , | f_n ( x ) - f_m ( x ) | &lt; \epsilon\)</span>.</p>
<p>必要性显然,只证充分性,对于此时固定一个确定的<span class="math inline">\(x\)</span>,那么<span class="math inline">\(\{ f_n
( x ) \}\)</span>就是一个柯西列且存在极限.逐点取极限就可以拿到<span class="math inline">\(f ( x ) = \lim_{ n \to \infty } f_n ( x
)\)</span>.而<span class="math inline">\(| f_n ( x ) - f_m ( x ) | &lt;
\epsilon\)</span>中只需要让<span class="math inline">\(m \to
\infty\)</span>就拿到了<span class="math inline">\(| f_n ( x ) - f ( x )
| \leq \epsilon\)</span>,这恰好是一致收敛的定义.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(f_n ( x ) = \frac{ x }{ 1 + n^2 x^2
}\)</span>一致收敛.</p>
<p>当然处处收敛于<span class="math inline">\(0\)</span>了,考虑用均值不等式,有<span class="math inline">\(| f_n ( x ) | \leq \frac{ | x | }{ 2 n | x | } =
\frac{ 1 }{ 2 n }\)</span>,这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:<span class="math inline">\(f_n ( x ) = x^n , x \in [ 0 , 1
)\)</span>并不一致收敛.</p>
<p>当然处处收敛到<span class="math inline">\(0\)</span>,但是<span class="math inline">\(\sup f_n ( x ) = 1\)</span>,所以并不一致收敛.</p>
<h6><span id="example3">Example3</span></h6>
<p>取<span class="math inline">\(f_n ( x ) = \frac{ 1 }{ n } , g_n ( x )
= x , x \in ( 0 , + \infty )\)</span>,容易见到<span class="math inline">\(f_n \rightrightarrows 0 , g_n \rightrightarrows
x\)</span>.而且<span class="math inline">\(f_n ( x
)\)</span>当然一致有界.然而,<span class="math inline">\(f_n g_n \not
\rightrightarrows 0\)</span>.</p>
<h6><span id="example4">Example4</span></h6>
<p>当<span class="math inline">\(g \in C [ 0 , 1 ] , g ( 1 ) =
0\)</span>,求证:<span class="math inline">\(f_n ( x ) = g ( x ) x^n
\rightrightarrows 0\)</span>.</p>
<p>由于<span class="math inline">\(g\)</span>在闭区间上连续,则其必然在闭区间上一致连续.因此<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,取<span class="math inline">\(\delta \in ( 0 , 1 )\)</span>,使得<span class="math inline">\(x \in [ \delta , 1 ]\)</span>的时候,<span class="math inline">\(| g ( x ) | &lt; \epsilon\)</span>,而取<span class="math inline">\(M = \sup_{ [ 0 , 1 ] } | g |\)</span>,那么<span class="math inline">\(| f_n ( x ) | \leq M \delta^n +
\epsilon\)</span>,注意这里的<span class="math inline">\(\delta\)</span>不取决于<span class="math inline">\(n\)</span>的选取这就搞定.</p>
<h6><span id="example5">Example5</span></h6>
<p>设<span class="math inline">\(f_n ( x ) = n \left ( \sqrt{ x + \frac{
1 }{ n } } - \sqrt{ x } \right ) , x \in ( 0 , + \infty
)\)</span>,判断其收敛性.</p>
<p>容易发现<span class="math inline">\(f_n ( x ) = \frac{ 1 }{ \sqrt{ x
+ \frac{ 1 }{ n } } + \sqrt{ x } } \to \frac{ 1 }{ 2 \sqrt{ x }
}\)</span>,因此其收敛.问题在于判断其是否一致收敛.</p>
<p>观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - \frac{ 1 }{ 2 \sqrt{ x } } | \\
= &amp; \frac{ \sqrt{ x + \frac{ 1 }{ n } } - \sqrt{ x } }{ 2 \sqrt{ x }
\left ( \sqrt{ x + \frac{ 1 }{ n } } + \sqrt{ x } \right ) } \\
= &amp; \frac{ 1 }{ 2 n \sqrt{ x } \left ( \sqrt{ x + \frac{ 1 }{ n } }
+ \sqrt{ x } \right )^2 }
\end{aligned}
\]</span></p>
<p>一个策略是直接对此式子求导,但也可以采取另一种分析策略,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt{ x + \frac{ 1 }{ n } } &amp; = \sqrt{ x } \left ( 1 + \frac{ 1 }{
nx } \right )^{ \frac{ 1 }{ 2 } } \\
&amp; = \sqrt{ x } \left ( 1 + \frac{ 1 }{ 2 nx } + O ( \frac{ 1 }{ n^2
} ) \right )
\end{aligned}
\]</span></p>
<p>所以当<span class="math inline">\(x\)</span>足够小的时候可能会出问题,直接取<span class="math inline">\(x = \frac{ 1 }{ n }\)</span>,误差为:</p>
<p><span class="math display">\[
\frac{ 1 }{ 2 \sqrt{ n } \left ( \frac{ 1 + \sqrt{ 2 } }{ \sqrt{ n } }
\right )^2 } = O ( \sqrt{ n } )
\]</span></p>
<p>这就证明了并非一致收敛.</p>
<h6><span id="example6">Example6</span></h6>
<p><span class="math inline">\([ 0 , 1 ]\)</span>上的<span class="math inline">\(f_n ( x )\)</span>满足<span class="math inline">\(\exists L &gt; 0 , \forall x \ne y , | f_n ( x ) -
f_n ( y ) | \leq L | x - y |\)</span>.并且<span class="math inline">\(\forall x \in [ 0 , 1 ] , f_n ( x ) \to f ( x
)\)</span>.求证:<span class="math inline">\(f_n ( x ) \rightrightarrows
f ( x )\)</span>.也就是:一致李氏连续的收敛函数列一定一致收敛.</p>
<p>李氏连续意味着我们可以用控制自变量的方式控制因变量.回忆到定义在有限集上的收敛函数列一定是一致收敛的.因此我们选择在数轴上打足够密的点来控制.</p>
<p>具体地,<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,我们将<span class="math inline">\([ 0 , 1
]\)</span>拆为长度不超过<span class="math inline">\(\frac{ \epsilon }{ 3
L }\)</span>的小区间.假设分点是<span class="math inline">\(x_1 , \cdots
, x_K\)</span>.这当然对于一个<span class="math inline">\(\epsilon\)</span>来说是有限个点,我们可以让它们同时趋近于一致收敛,用柯西准则,也就是拿到一个<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n , m \geq N\)</span>,<span class="math inline">\(| f_n ( x_i ) - f_m (
x_i ) | &lt; \frac{ \epsilon }{ 3 }\)</span>.</p>
<p>现在<span class="math inline">\(\forall x \in [ 0 , 1 ] , \exists x_i
, | x - x_i | &lt; \frac{ \epsilon }{ 3 L }\)</span>.于是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f_m ( x ) | \\
\leq &amp; | f_n ( x ) - f_n ( x_i ) | + | f_n ( x_i ) - f_m ( x_i ) | +
| f_m ( x_i ) - f_m ( x ) | \\
&lt; &amp; \epsilon
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h4><span id="函数项级数">函数项级数</span></h4>
<p>函数项级数上也有柯西准则,也就是函数项级数的一致收敛性等价于<span class="math inline">\(\forall \epsilon , \exists N , \forall n , m \geq
N , | \sum_{ k = n }^m f_k ( x ) | &lt; \epsilon , \forall x \in
I\)</span>.</p>
<p>还可以在这里定义<strong>绝对收敛</strong>:也就是<span class="math inline">\(\sum | f_n ( x )
|\)</span>收敛.当然仍有绝对收敛推收敛.如果<span class="math inline">\(\sum | f_n ( x )
|\)</span>还一致收敛,则称原级数<strong>绝对一致收敛</strong>.注意,这里的绝对一致收敛是定义在<span class="math inline">\(| f_n
|\)</span>的基础上.也就是说,一个函数既绝对收敛,又一致收敛,但它可能并不绝对一致收敛.然而反之是成立的,如果一个函数绝对一致收敛,可以推出它一致收敛,原因是<span class="math inline">\(\sum | f_n | \geq | \sum f_n
|\)</span>,用柯西准则就可以得知.</p>
<p>另外,用柯西准则可以见到如果<span class="math inline">\(\sum f_n
\rightrightarrows f\)</span>,那么<span class="math inline">\(f_n ( x )
\rightrightarrows 0\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑函数项级数<span class="math inline">\(\sum ( - x )^n ( 1 - x ) ,
x \in [ 0 , 1 ]\)</span>.</p>
<p>直接考虑其余项,<span class="math inline">\(R_n ( x ) = \sum_{ k = n +
1 }^\infty ( - x )^k ( 1 - x ) = \frac{ ( - x )^{ n + 1 } ( 1 - x ) }{ 1
+ x }\)</span>.此时考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| R_n | &amp; \leq x^{ n + 1 } ( 1 - x ) \\
&amp; = \frac{ 1 }{ n + 1 } ( n + 1 ) ( 1 - x ) x^{ n + 1 } \\
&amp; \leq \frac{ 1 }{ n + 1 } ( \frac{ n + 1 }{ n + 2 } )^{ n + 2 } \\
&amp; \leq \frac{ 1 }{ n + 1 } \to 0
\end{aligned}
\]</span></p>
<p>所以该级数一致收敛.</p>
<p>那么是否绝对收敛呢?考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k = 1 }^n | ( - x )^n ( 1 - x ) | \\
= &amp; \sum_{ k = 1 }^n ( x^k - x^{ k + 1 } ) \\
= &amp; x - x^{ n + 1 }
\end{aligned}
\]</span></p>
<p>所以当然也绝对收敛到<span class="math inline">\(\begin{cases}x &amp;
x \in [ 0 , 1 ) \\ 0 &amp; x = 1\end{cases}\)</span>.</p>
<p>可是,它并不是绝对一致收敛的.考虑<span class="math inline">\(\sup_{ [
0 , 1 ) } | S ( x ) - S_n ( x ) | = \sup_{ [ 0 , 1 ) } | x^{ n + 1 } | =
1\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum \left ( \cos \frac{ \pi x }{ n }
\right )^{ n^3 }\)</span>的收敛域.</p>
<p>不妨设<span class="math inline">\(u_n ( x ) = \left ( \cos \frac{ \pi
x }{ n } \right )^{ n^3 }\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sqrt[n]{ u_n ( x ) } &amp; = \left ( \cos \frac{ \pi x }{ n } \right
)^{ n^2 } \\
&amp; = \left ( 1 - \frac{ \pi^2 x^2 }{ 2 n^2 } + O ( \frac{ 1 }{ n^4 }
) \right )^{ n^2 } \\
&amp; = \exp ( n^2 \ln \left ( 1 - \frac{ \pi^2 x^2 }{ 2 n^2 } + O (
\frac{ 1 }{ n^4 } ) \right ) ) \\
&amp; = \exp ( n^2 \left ( - \frac{ \pi^2 x^2 }{ 2 n^2 } + O ( \frac{ 1
}{ n^4 } ) \right ) ) \\
&amp; = \exp ( - \frac{ \pi^2 x^2 }{ 2 } + O ( \frac{ 1 }{ n^2 } ) ) \\
&amp; \to e^{ - \frac{ \pi^2 x^2 }{ 2 } }
\end{aligned}
\]</span></p>
<p>所以最后模拟成了一个等比数列,那收敛域就是<span class="math inline">\(\mathbb{ R } \setminus \{ 0 \}\)</span>.</p>
<h5><span id="m判别法">M判别法</span></h5>
<p>若<span class="math inline">\(| f_n ( x ) | \leq a_n , x \in
I\)</span>,如果<span class="math inline">\(\sum a_n &lt;
\infty\)</span>,则<span class="math inline">\(\sum f_n ( x
)\)</span>绝对一致收敛.</p>
<p>证明的话,考虑用一般级数可以拿到<span class="math inline">\(\forall
\epsilon &gt; 0 , \exists N , \forall n , m \geq N , \sum_{ k = n }^m |
a_n | &lt; \epsilon\)</span>,但又有<span class="math inline">\(\forall x
\in I , \sum_{ k = n }^m | f_n ( x ) | \leq \sum_{ k = n }^m
a_k\)</span>,这就知道其绝对一致收敛.</p>
<h5><span id="da判别法">DA判别法</span></h5>
<p>假设<span class="math inline">\(\{ a_n ( x ) \} , \{ b_n ( x )
\}\)</span>是两个函数列.对于任意固定的<span class="math inline">\(x \in
I\)</span>,<span class="math inline">\(\{ a_n ( x )
\}\)</span>是一个单调数列.注意这里其实不要求大家都递增或递减,只要对于每一个点都是单调的.而取<span class="math inline">\(B_n ( x ) = \sum_{ k = 1 }^n b_k ( x
)\)</span>.则当:</p>
<ol type="1">
<li><p>Dirichlet判别法:当<span class="math inline">\(a_n ( x )
\rightrightarrows 0\)</span>,<span class="math inline">\(B_n ( x
)\)</span>一致有界时,则<span class="math inline">\(\sum a_n
b_n\)</span>一致收敛.</p></li>
<li><p>Able判别法:当<span class="math inline">\(\{ a_n ( x )
\}\)</span>一致有界,<span class="math inline">\(B_n ( x
)\)</span>一致收敛时,则<span class="math inline">\(\sum a_n
b_n\)</span>一致收敛.</p></li>
</ol>
<p>证明和级数部分完全一样,只需要对于任意的<span class="math inline">\(x\)</span>都这么搞即可:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + p } a_k ( x ) b_k ( x ) | \\
= &amp; | \sum_{ k = n + 1 }^{ n + p } a_k ( x ) ( B_{ k } ( x ) - B_{ k
- 1 } ( x ) ) | \\
= &amp; | a_{ n + p } B_{ n + p } ( x ) + \sum_{ k = n + 1 }^{ n + p - 1
} ( a_k ( x ) - a_{ k + 1 } ( x ) ) B_k ( x ) | \\
\leq &amp; M ( a_{ n + 1 } ( x ) + 2 a_{ n + p } ( x ) )
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(M = \sup_{ 1 \leq i \leq p } \{ |
\sum_{ k = n + 1 }^{ n + i } b_k ( x ) | \}\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(b_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>的时候,求证:<span class="math inline">\(\sum_{ k = 1 }^\infty b_n \sin ( nx ) , x \in
\mathbb{ R }\)</span>一致收敛的充要条件是<span class="math inline">\(b_n
= o ( \frac{ 1 }{ n } )\)</span>.</p>
<p>先证必要性,设<span class="math inline">\(S_{ n , p } = \sum_{ k = n
}^p b_k \sin ( kx )\)</span>.由柯西原理,<span class="math inline">\(\forall \epsilon &gt; 0 , \exists N , \forall n ,
p \geq N , | S_{ n , p } | &lt; \epsilon\)</span>.此时取<span class="math inline">\(p = 2 n - 1 , x = \frac{ \pi }{ 4 n
}\)</span>,此时当<span class="math inline">\(n \leq k \leq
p\)</span>的时候,<span class="math inline">\(\sin ( k \pi ) &gt; \sin
\frac{ \pi }{ 4 }\)</span>,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\epsilon &amp; &gt; | S_{ n , p } ( x ) | \\
&amp; &gt; nb_{ 2 n } \sin \frac{ \pi }{ 4 } = \frac{ \sqrt{ 2 } }{ 2 }
n b_{ 2 n }
\end{aligned}
\]</span></p>
<p>这就搞定了<span class="math inline">\(b_{ 2 n } = o ( \frac{ 1 }{ n }
)\)</span>,又因为<span class="math inline">\(b_n\)</span>是单调下降的,那当然搞定了.</p>
<p>再证充分性,只要证明在<span class="math inline">\([ 0 , \pi
]\)</span>上一致收敛,由于<span class="math inline">\(\sin ( nx
)\)</span>是奇函数,那么在<span class="math inline">\([ - \pi , 0
]\)</span>上当然也一致收敛,那就搞定了.</p>
<p>设<span class="math inline">\(\mu_n = \max_{ m \geq n }{ mb_m
}\)</span>,注意到<span class="math inline">\(\mu_n\)</span>单调下降趋近于<span class="math inline">\(0\)</span>.下面开始讨论:</p>
<p>当<span class="math inline">\(x \in [ 0 , \frac{ \pi }{ p }
]\)</span>的时候,此时<span class="math inline">\(S_{ n , p
}\)</span>中的每一项都同号.自然有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = n }^p b_k \sin ( kx ) &amp; \leq \sum_{ k = n }^p b_k kx \\
&amp; \leq \frac{ \pi }{ p } \sum_{ k = n }^p b_k k \\
&amp; \leq \frac{ \pi }{ p } ( p - n ) \mu_n \\
&amp; \leq \pi \mu_n
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>当<span class="math inline">\(x \in [ \frac{ \pi }{ n } , \pi
]\)</span>的时候,和差化积公式给出:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = 1 }^n \sin ( kx ) | \\
= &amp; \left | \frac{ \cos ( k - \frac{ 1 }{ 2 } ) x - \cos ( k +
\frac{ 1 }{ 2 } ) }{ 2 \sin \frac{ x }{ 2 } } \right | \\
\leq &amp; \frac{ 1 }{ | \sin \frac{ x }{ 2 } | } \\
&lt; &amp; n
\end{aligned}
\]</span></p>
<p>原因是当<span class="math inline">\(\frac{ x }{ 2 } \leq \frac{ \pi
}{ 2 }\)</span>的时候,<span class="math inline">\(\sin \frac{ x }{ 2 }
\geq \frac{ 2 }{ \pi } \frac{ x }{ 2 } \geq n\)</span>.</p>
<p>回忆到Abel变换给出<span class="math inline">\(| S_{ n , p } | \leq n
( 2 b_n + b_p ) &lt; 3 nb_n \to 0\)</span>.这就搞定.</p>
<p>当<span class="math inline">\(x \in ( \frac{ \pi }{ p } , \frac{ \pi
}{ n } )\)</span>的时候,取<span class="math inline">\(m = \lfloor \frac{
\pi }{ x } \rfloor \leq \frac{ \pi }{ x }\)</span>.那我们就有:<span class="math inline">\(\frac{ \pi }{ m + 1 } \leq x \leq \frac{ \pi }{ m
}\)</span>.</p>
<p>当<span class="math inline">\(k \in [ n , m ]\)</span>的时候,<span class="math inline">\(kx \leq \pi\)</span>,那<span class="math inline">\(\sin ( kx ) \leq
kx\)</span>就成立,那么和上面一样:</p>
<p><span class="math display">\[
| S_{ n , m } | \leq \pi \mu_n
\]</span></p>
<p>当<span class="math inline">\(k \in [ m + 1 , p
]\)</span>的时候,此时<span class="math inline">\(\frac{ 1 }{ | \sin
\frac{ x }{ 2 } | } \geq \frac{ 1 }{ m + 1 }\)</span>,因此:</p>
<p><span class="math display">\[
| S_{ m + 1 , p } | \leq ( m + 1 ) ( 2 b_{ m + 1 } + b_p ) &lt; 3 \mu_{
m + 1 }
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
| S_{ n , p } | \leq | S_{ n , m } | + | S_{ m + 1 , p } | &lt; \pi
\mu_n + 3 \mu_{ m + 1 }
\]</span></p>
<p>这就搞定.</p>
<h4><span id="连续性">连续性</span></h4>
<p>我们还可以定义<strong>等度连续</strong>的概念:我们说<span class="math inline">\(f_n\)</span>等度连续,当<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt;
0\)</span>,使得<span class="math inline">\(\forall x ,
y\)</span>,若<span class="math inline">\(| x - y | &lt;
\delta\)</span>,则<span class="math inline">\(\forall n , | f_n ( x ) -
f_n ( y ) | &lt;
\epsilon\)</span>.其实就是某种一致(函数列)的一致(定义域上)连续.</p>
<p>我们可以证明:如果<span class="math inline">\(f_n ( x ) \in C [ a , b
]\)</span>,而且其等度连续,则如果<span class="math inline">\(\lim_{ n \to
\infty } f_n ( x ) = f ( x ) , x \in [ a , b ]\)</span>,则<span class="math inline">\(f_n \rightrightarrows f , x \in [ a , b
]\)</span>.</p>
<p>证明与前述Example6证明一致李氏连续类似,事实上Example6是这个的一个推论.我们取定<span class="math inline">\(\delta\)</span>,使得<span class="math inline">\(|
x - y | &lt; \delta\)</span>时一定有<span class="math inline">\(\forall
n , | f_n ( x ) - f_n ( y ) | &lt; \frac{ \epsilon }{ 3
}\)</span>,此时再令<span class="math inline">\(n \to
\infty\)</span>,就有<span class="math inline">\(| f ( x ) - f ( y ) |
\leq \frac{ \epsilon }{ 3 }\)</span>,再取一个分划<span class="math inline">\(\Delta : a = x_0 &lt; \cdots &lt; x_m =
b\)</span>并要求<span class="math inline">\(\lambda ( \Delta ) &lt;
\delta\)</span>.</p>
<p>自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| f_n ( x ) - f ( x ) | &amp; \leq | f_n ( x ) - f_n ( x_i ) | + | f_n (
x_i ) - f ( x_i ) | + | f ( x_i ) - f ( x ) | \\
&amp; \leq \epsilon
\end{aligned}
\]</span></p>
<p>原因仍是有限点集上的收敛一定是一致收敛.</p>
<p>下面要探索的就是一致连续是否保持了原函数项级数的作用.</p>
<p>先看一个引理:当<span class="math inline">\(x_0 \in [ a , b
]\)</span>的时候,如若当<span class="math inline">\(x \in [ a , b ]
\setminus \{ x_0 \}\)</span>,<span class="math inline">\(f_n ( x )
\rightrightarrows f ( x )\)</span>,已知<span class="math inline">\(\lim_{ x \to x_0 } f_n ( x ) =
\alpha_n\)</span>存在.则<span class="math inline">\(\lim_{ n \to \infty
} \alpha_n\)</span>存在而且<span class="math inline">\(\lim_{ x \to x_0
} f ( x ) = \lim_{ n \to \infty } \alpha_n\)</span>.换言之,<span class="math inline">\(\lim_{ x \to x_0 } \lim_{ n \to \infty } f_n ( x )
= \lim_{ n \to \infty } \lim_{ x \to x_0 } f_n ( x )\)</span>.</p>
<p>证明的话,首先要证明<span class="math inline">\(\lim_{ n \to \infty }
\alpha_n\)</span>存在,考虑<span class="math inline">\(\forall \epsilon
&gt; 0 , \exists N , \forall n , m \geq N\)</span>,有<span class="math inline">\(| f_n ( x ) - f_m ( x ) | &lt; \frac{ \epsilon }{
3 }\)</span>,取极限知道<span class="math inline">\(| \alpha_n - \alpha_m
| \leq \frac{ \epsilon }{ 3 }\)</span>,这说明<span class="math inline">\(\{ \alpha_n
\}\)</span>是柯西列,当然收敛.不妨设<span class="math inline">\(\alpha =
\lim_{ n \to \infty } \alpha_n\)</span>.</p>
<p>此时有:</p>
<p><span class="math display">\[
| f ( x ) - \alpha | \leq | f ( x ) - f_N ( x ) | + | f_N ( x ) -
\alpha_N | + | \alpha_N - \alpha |
\]</span></p>
<p>两边一取极限使得<span class="math inline">\(x \to
x_0\)</span>,立刻见到<span class="math inline">\(| f ( x ) - \alpha |
&lt;
\epsilon\)</span>.这已经能看出一致连续的强大了.正是因为一致连续可以先固定<span class="math inline">\(N\)</span>,我们才可以在这里对<span class="math inline">\(x \to
x_0\)</span>取极限.所以这里有一个天然的可交换性.</p>
<p>这个引理的一个推论是:如果<span class="math inline">\(f_n
\rightrightarrows f , x \in [ a , b ]\)</span>,则对于<span class="math inline">\(x_0 \in [ a , b ]\)</span>,如果<span class="math inline">\(f_n ( x )\)</span>在<span class="math inline">\(x_0\)</span>处连续,则<span class="math inline">\(f\)</span>也在<span class="math inline">\(x_0\)</span>处连续.原因是既然连续,则<span class="math inline">\(\alpha_n = \lim_{ x \to x_0 } f_n ( x ) = f_n (
x_0 )\)</span>,所以<span class="math inline">\(\lim_{ x \to x_0 } f ( x
) = \lim_{ n \to \infty } f_n ( x_0 ) = f ( x_0
)\)</span>.这就说明在<span class="math inline">\(x_0\)</span>处连续.更有推论:如果<span class="math inline">\(f_n \in C [ a , b ] , f_n \rightrightarrows
f\)</span>,则<span class="math inline">\(f \in C [ a , b
]\)</span>.从而还可以见到,如果一串连续函数收敛到一个不连续函数,那这肯定也不是一致收敛的.</p>
<p>那么反过来,如果连续函数列收敛到连续函数,能不能推出一致收敛呢?我们事实上有<strong>迪尼定理</strong>:如果<span class="math inline">\(f_n ( x ) \in C [ a , b ]\)</span>,当<span class="math inline">\(n &lt; m\)</span>的时候,<span class="math inline">\(\forall x \in [ a , b ] , f_n ( x ) \leq f_m ( x
)\)</span>,此时如若<span class="math inline">\(f_n \rightarrow
f\)</span>,而且<span class="math inline">\(f \in C [ a , b
]\)</span>,则<span class="math inline">\(f_n \rightrightarrows
f\)</span>.也就是只要有一定的单调性,我们就可以说一致连续是连续函数列收敛到连续函数的充要条件.</p>
<p>取<span class="math inline">\(R_n ( x ) = f ( x ) - f_n ( x ) \geq
0\)</span>,注意到<span class="math inline">\(\lim_{ n \to \infty } R ( x
) = 0\)</span>而且<span class="math inline">\(R_n ( x
)\)</span>连续且逐点随<span class="math inline">\(n\)</span>单调递减,则必有<span class="math inline">\(R_n \to 0\)</span>.如果我们能证明<span class="math inline">\(R_n ( x ) \rightrightarrows
0\)</span>,那就万事大吉.不妨设<span class="math inline">\(M_n = \max_{ x
\in [ a , b ] } R_n ( x ) = R_n ( x_n )\)</span>,那么只要证明<span class="math inline">\(M_n \to 0\)</span>就可以搞定一致收敛.然而<span class="math inline">\(M_n\)</span>本身是单调下降的.反证,如果<span class="math inline">\(\lim_{ n \to \infty } M_n = c &gt;
0\)</span>,此时观察<span class="math inline">\(x_n \in [ a , b
]\)</span>,既然如此,<span class="math inline">\(\{ x_n
\}\)</span>必定有收敛子列,任取一个收敛子列<span class="math inline">\(\{
x_{ n_k } \}\)</span>并假设其收敛到<span class="math inline">\(x_0\)</span>,接下来看:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \lim_{ m \to \infty } R_m ( x_0 ) \\
= &amp; \lim_{ m \to \infty } \lim_{ x_{ n_k } \to x_0 } R_m ( x_{ n_k }
) \\
\geq &amp; \lim_{ m \to \infty } \lim_{ n_k &gt; m , x_{ n_k } \to x_0 }
R_{ n_k } ( x_{ n_k } ) \\
= &amp; \lim_{ x_{ n_k } \to x_0 } R_{ n_k } ( x_{ n_k } ) &gt; 0
\end{aligned}
\]</span></p>
<p>可这就出事了.于是矛盾,反证成立.</p>
<p>迪尼定理的一个推论是如果<span class="math inline">\(f_n ( x ) \geq
0\)</span>,那么此时<span class="math inline">\(S_n ( x ) = \sum_k^n f (
x )\)</span>就是逐点单调的了.因此我们可以看到此时<span class="math inline">\(\sum f_n\)</span>一致收敛性也就等价于其连续性.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(f_n \geq 0\)</span>,而且<span class="math inline">\(\forall n , f_n\)</span>单增的时候,如若<span class="math inline">\(\sum f_n ( x ) \leq M , \forall x \in [ a , b
)\)</span>.求证此时<span class="math inline">\(\lim_{ x \to b - 0 }
\sum_{ n = 1 }^\infty f_n ( x ) = \sum_{ n = 1 }^\infty f_n ( b - 0
)\)</span>.</p>
<p>设<span class="math inline">\(S_n = \sum_k^n f_k ( x
)\)</span>,取定<span class="math inline">\(m\)</span>,此时<span class="math inline">\(\forall x \in [ a , b )\)</span>,<span class="math inline">\(S ( x ) \geq S_m ( x )\)</span>.令<span class="math inline">\(x \to b - 0\)</span>,自然有<span class="math inline">\(\sum_{ n = 1 }^m f_n ( b - 0 ) \leq \lim_{ x \to b
- 0 } S ( x )\)</span>.直接令<span class="math inline">\(S ( b - 0 ) =
\lim_{ x \to b - 0 } S ( x )\)</span>,这个极限存在,原因是<span class="math inline">\(S ( x )\)</span>是单调的.从而取极限得到<span class="math inline">\(\sum_{ n = 1 }^\infty f_n ( b - 0 ) \leq S ( b - 0
)\)</span>.</p>
<p>接下来另一个方向,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^m f_n ( x ) &amp; \leq \sum_{ n = 1 }^m f_n ( b - 0 )
\leq \sum_{ n = 1 }^\infty f_n ( b - 0 ) \\
S ( x ) &amp; \leq \sum_{ n = 1 }^\infty f_n ( b - 0 ) \\
S ( b - 0 ) &amp; \leq \sum_{ n = 1 }^\infty f_n ( b - 0 )
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example2">Example2</span></h6>
<p><span class="math inline">\(f_n\)</span>在<span class="math inline">\([ a , b ]\)</span>上可微而且<span class="math inline">\(f_n &#39; \in R [ a , b ]\)</span>,若<span class="math inline">\(\forall x \in [ a , b ] , \forall n , | \sum_{ k =
1 }^n f_k &#39; ( x ) | \leq M\)</span>,<span class="math inline">\(\sum
f_n ( x )\)</span>在<span class="math inline">\([ a , b
]\)</span>上收敛.求证其在<span class="math inline">\([ a , b
]\)</span>上一致收敛.</p>
<p>容易观察到<span class="math inline">\(\sum f_n ( x
)\)</span>一致李氏连续,用之前等度连续的结论就可以做掉.</p>
<h4><span id="可积性">可积性</span></h4>
<p>如果<span class="math inline">\(f_n \in R [ a , b ] , f_n
\rightrightarrows f\)</span>,则我们声明<span class="math inline">\(f \in
R [ a , b ]\)</span>且<span class="math inline">\(\int_a^b f \mathrm{ d
} x = \lim_{ n \to \infty } \int_a^b f_n \mathrm{ d } x\)</span>.</p>
<p>考虑证明,首先<span class="math inline">\(f_n\)</span>是有界的,又因为一致收敛,所以能推出<span class="math inline">\(f\)</span>也是有界的.</p>
<p>一个想法是使用勒贝格定理.直接取<span class="math inline">\(K_n\)</span>是<span class="math inline">\(f_n\)</span>的间断点集,立刻得到<span class="math inline">\(K_n\)</span>是零测集.接下来令<span class="math inline">\(K = \bigcup K_n\)</span>,那<span class="math inline">\(K\)</span>还是零测集(可数个零测集的并),此时对于<span class="math inline">\(\forall x \in [ a , b ] \setminus K\)</span>,<span class="math inline">\(\forall n , f_n\)</span>都在<span class="math inline">\(x\)</span>处连续,那<span class="math inline">\(f\)</span>肯定也在<span class="math inline">\(x\)</span>处连续,所以<span class="math inline">\(f\)</span>的间断点集就一定被包含于零测集<span class="math inline">\(K\)</span>,所以黎曼可积.</p>
<p>接下来的问题是是否积分相等,取<span class="math inline">\(M_n = \sup_{
[ a , b ] } | f - f_n |\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f \mathrm{ d } x - \int_a^b f_n \mathrm{ d } x | \\
\leq &amp; \int_a^b | f - f_n | \mathrm{ d } x \\
\leq &amp; \int_a^b M_n \mathrm{ d } x \\
= &amp; M_n ( b - a ) \to 0
\end{aligned}
\]</span></p>
<p>这就搞定.然而注意到这里需要依赖于<span class="math inline">\(b -
a\)</span>的有界性.</p>
<p>另一个策略是直接用分划达布和证明<span class="math inline">\(f \in R [
a , b ]\)</span>.不妨设<span class="math inline">\(| f_n | \leq M , | f
| \leq M\)</span>.则<span class="math inline">\(\forall \epsilon &gt; 0
, \exists n\)</span>,<span class="math inline">\(| f_n ( x ) - f ( x ) |
&lt; \epsilon\)</span>.由于<span class="math inline">\(f_n ( x ) \in R [
a , b ]\)</span>,可以取定分划<span class="math inline">\(\Delta : a =
x_0 &lt; \cdots &lt; x_p = b\)</span>,使得<span class="math inline">\(\sum ( M_i - m_i ) \Delta x_i &lt;
\epsilon\)</span>.</p>
<p>于此,我们取<span class="math inline">\(\bar{ M }_i = \sup_{ [ x_{ i -
1 } , x_i ] } f ( x ) , \bar{ m }_i\)</span>同理.观察到<span class="math inline">\(\forall x \in [ x_{ i - 1 } , x_i ] , f ( x ) \leq
f_n ( x ) + \epsilon \leq M_i + \epsilon\)</span>,所以一定有<span class="math inline">\(\bar{ M }_i \leq M_i + \epsilon\)</span>.对于<span class="math inline">\(\bar{ m }_i\)</span>同理.此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum ( \bar{ M }_i - \bar{ m }_i ) \Delta x_i \\
\leq &amp; \sum ( M_i - m_i ) \Delta x_i + 2 \epsilon ( b - a ) \\
\leq &amp; \epsilon ( 1 + 2 ( b - a ) )
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>事实上这个结论可以更强,可以放弃一致收敛的条件.我们有<strong>控制收敛定理</strong>:假设<span class="math inline">\(f_n \in R [ a , b
]\)</span>,而且它们一致有界,<span class="math inline">\(\forall n ,
\forall x \in [ a , b ] , | f_n | \leq M\)</span>.并且<span class="math inline">\(f ( x ) = \lim_{ n \to \infty } f_n ( x ) \in R [
a , b ]\)</span>,则<span class="math inline">\(\int_a^b f ( x ) \mathrm{
d } x = \lim_{ n \to \infty } \int_a^b f_n ( x ) \mathrm{ d }
x\)</span>.</p>
<p>为证明此,先引入一些相关的定义:</p>
<p>定义<strong>阶梯函数</strong>为分段常值函数,假设<span class="math inline">\(f \in R [ a , b
]\)</span>,则我们可以用阶梯函数逼近<span class="math inline">\(f\)</span>,具体而言,假设<span class="math inline">\(g\)</span>是阶梯函数,并且<span class="math inline">\(g \leq f\)</span>,那么我们可以将<span class="math inline">\(g\)</span>类似达布下和而分划够细,以使得<span class="math inline">\(\int_a^b f \mathrm{ d } x = \sup_{ g \leq f ,
\text{ g is a step function } } \{ \int_a^b g ( x ) \mathrm{ d } x
\}\)</span>.</p>
<p>定义<strong>初等集</strong>:有限个不交区间的并,可以见到其测度<span class="math inline">\(m ( E )\)</span>就是所有不交区间的长度之和.</p>
<p>定义<strong>闭初等集</strong>:有限个不交闭区间的并.</p>
<p>定义<strong>有界闭初等集列</strong>:<span class="math inline">\(A_n\)</span>是闭初等集.容易见到,如果<span class="math inline">\(A_n \ne \emptyset\)</span>,而且<span class="math inline">\(A_{ n + 1 } \subseteq A_n\)</span>,则<span class="math inline">\(\bigcap_{ n = 1 }^\infty A_n \ne
\emptyset\)</span>,证明的话只需类似区间套定理,每个<span class="math inline">\(A_n\)</span>内取一个点,这个点列是有界的,那它就一定有收敛子列,收敛到的那个点一定被含在每一个<span class="math inline">\(A_n\)</span>中.这就搞定.</p>
<p>不妨设<span class="math inline">\(A_n\)</span>是有界非空集列,满足<span class="math inline">\(A_{ n + 1 } \subseteq A_n , A_n \ne \emptyset ,
\bigcap_{ n = 1 }^\infty A_n = \emptyset\)</span>.此时定义<span class="math inline">\(\alpha_n = \sup \{ m ( E ) \mid E \subseteq A_n ,
\text{ E is a closed elementary set } \}\)</span>.我们下面证明<span class="math inline">\(\lim_{ n \to \infty } \alpha_n = 0\)</span>.</p>
<p>首先显然<span class="math inline">\(\alpha_n\)</span>单调递减.如若其不以<span class="math inline">\(0\)</span>为极限,则一定有正下界<span class="math inline">\(\alpha_n &gt; \delta &gt;
0\)</span>.我们可以取<span class="math inline">\(A_n\)</span>的闭初等子集<span class="math inline">\(E_n \subseteq A_n\)</span>满足<span class="math inline">\(m ( E_n ) &gt; \alpha_n - \frac{ \delta }{ 2^n
}\)</span>.</p>
<p>接下来定义<span class="math inline">\(H_n = \bigcap_{ k = 1 }^n
E_k\)</span>,这当然是初等集,此时见到<span class="math inline">\(H_{ n +
1 } \subseteq H_n\)</span>.接下来对<span class="math inline">\(A_n
\setminus H_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>,显然:</p>
<p><span class="math display">\[
\begin{aligned}
E &amp; = E \setminus H_n \\
&amp; = E \setminus ( \bigcap_{ k = 1 }^n E_k ) \\
&amp; = \bigcup_{ k = 1 }^n ( E \setminus E_k )
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(E \subseteq A_n \subseteq
A_k\)</span>,所以<span class="math inline">\(E_k\)</span>和<span class="math inline">\(E \setminus E_k\)</span>都是<span class="math inline">\(A_k\)</span>的初等子集.所以:</p>
<p><span class="math display">\[
\begin{aligned}
m ( E \setminus E_k ) + m ( E_k ) &amp; \leq \alpha_k \\
m ( E \setminus E_k ) &amp; \leq \frac{ \delta }{ 2^k }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(m ( E ) \leq
\delta\)</span>.如果<span class="math inline">\(H_n =
\emptyset\)</span>,那么<span class="math inline">\(m ( E ) =
\alpha_n\)</span>,这就不符.所以<span class="math inline">\(H_n \ne
\emptyset\)</span>,所以<span class="math inline">\(\bigcap_{ n = 1
}^\infty H_n \ne \emptyset\)</span>,所以<span class="math inline">\(\bigcap A_n \ne
\emptyset\)</span>.矛盾,这就证明了原本的结论.</p>
<p>接下来考虑<span class="math inline">\(f ( x ) - f_n ( x
)\)</span>,当没有一致连续的条件时,可能出现问题的地方在于有的地方两者不一定靠的足够近,想办法让这种地方所占的长度尽可能小就行.</p>
<p>对于<span class="math inline">\(\forall \epsilon &gt; 0 , A_n = \{ x
\in [ a , b ] \mid \exists j \geq n , | f_j ( x ) - f ( x ) | \geq
\epsilon \}\)</span>.容易见到<span class="math inline">\(A_{ n + 1 }
\subseteq A_n\)</span>,由于<span class="math inline">\(f_n \to
f\)</span>,所以<span class="math inline">\(\bigcap_{ n = 1 }^\infty A_n
= \emptyset\)</span>.引理告诉我们<span class="math inline">\(\alpha_n
\to 0\)</span>.既然如此,存在<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n \geq N\)</span>,<span class="math inline">\(A_n\)</span>的任意初等子集<span class="math inline">\(E\)</span>都有<span class="math inline">\(m ( E )
&lt; \epsilon\)</span>.取<span class="math inline">\(F = [ a , b ]
\setminus E\)</span>.这其实更像是取<span class="math inline">\([ a , b
]\)</span>的一个分划,因此如果我们在上面取阶梯函数的话,完全可以让阶梯函数所需的那个分划和这个分划并起来,从而完全由上述结果取到阶梯函数,此外我们的<span class="math inline">\(A_n \setminus E\)</span>的部分由于落在<span class="math inline">\(F\)</span>里而需要被<span class="math inline">\(\epsilon\)</span>控制.</p>
<p>此时取阶梯函数<span class="math inline">\(S ( x )\)</span>满足<span class="math inline">\(0 \leq S ( x ) \leq | f ( x ) - f_n ( x )
|\)</span>.这个时候看<span class="math inline">\(S ( x
)\)</span>的积分:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b S ( x ) \mathrm{ d } x &amp; = \int_E S ( x ) \mathrm{ d } x +
\int_F S ( x ) \mathrm{ d } x \\
&amp; \leq 2 M \epsilon + \epsilon ( b - a )
\end{aligned}
\]</span></p>
<p>这个对任意<span class="math inline">\(S ( x
)\)</span>都成立,由于我们之前说的阶梯函数的上界可以逼近原函数,所以这就意味着:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_a^b f_n ( x ) - f ( x ) \mathrm{ d } x | \\
\leq &amp; \int_a^b | f_n ( x ) - f ( x ) | \mathrm{ d } x \\
\leq &amp; 2 M \epsilon + \epsilon ( b - a )
\end{aligned}
\]</span></p>
<p>这就搞定.不过细心的读者也许会注意到一些问题,首先是这里用内测度逼近疑似有点神秘,然而如果用勒贝格测度的定义直接跑其实一眼就能看出来上面的结论.</p>
<p>还有另一个结论:假设<span class="math inline">\(f_n \in R [ a , b ] ,
| f_n | \leq M\)</span>,已知<span class="math inline">\(\lim_{ n \to
\infty } f_n ( x ) = f ( x )\)</span>存在(注意这里并不要求<span class="math inline">\(f ( x ) \in R [ a , b
]\)</span>),我们就可以证明<span class="math inline">\(\lim_{ n \to
\infty } \int_a^b f_n ( x ) \mathrm{ d } x\)</span>存在.</p>
<p>考虑<span class="math inline">\(| \int_a^b f_n \mathrm{ d } x | \leq
M ( b - a )\)</span>有界,所以其可以取上下极限操作.令<span class="math inline">\(\overline{ F } = \varlimsup_{ n \to \infty }
\int_a^b f_n \mathrm{ d } x , \underline{ F } = \varliminf_{ n \to
\infty } \int_a^b f_n \mathrm{ d }
x\)</span>.既然如此,就一定存在两列<span class="math inline">\(\{ n_k
\}\)</span>和<span class="math inline">\(\{ m_k \}\)</span>,使得<span class="math inline">\(\overline{ F } = \lim_{ k \to \infty } \int_a^b
f_{ n_k } \mathrm{ d } x , \underline{ F } = \lim_{ k \to \infty }
\int_a^b f_{ m_k } \mathrm{ d } x\)</span>.然而:</p>
<p><span class="math display">\[
\begin{aligned}
\overline{ F } - \underline{ F } &amp; = \lim_{ k \to \infty } \int_a^b
( f_{ n_k } - f_{ m_k } ) \mathrm{ d } x \\
&amp; = \int_a^b \lim_{ k \to \infty } ( f_{ n_k } - f_{ m_k } )
\mathrm{ d } x = 0
\end{aligned}
\]</span></p>
<p>这你就可以见到,我们其实可以把这个极限干脆定义成<span class="math inline">\(f\)</span>的积分.这实际上就是勒贝格积分.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:<span class="math inline">\(\int_0^1 \frac{ 1 }{ x^x } \mathrm{
d } x = \sum_{ n = 1 }^\infty \frac{ 1 }{ n^n }\)</span>.</p>
<p>展开:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ x^x } &amp; = e^{ - x \ln x } \\
&amp; = \sum_{ n \geq 0 } \frac{ ( - x \ln x )^n }{ n ! }
\end{aligned}
\]</span></p>
<p>容易证明这个函数项级数是一致收敛的,那我们就可以逐项积分,而且积分内可以做多少次分部积分都无所谓(反正是有限逼近无限).</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ 1 }{ x^x } \mathrm{ d } x \\
= &amp; \int_0^1 \sum_{ n \geq 0 } \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x \\
= &amp; \sum_{ n \geq 0 } \int_0^1 \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(x = e^{ - t }\)</span>,换元:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ n \geq 0 } \int_0^1 \frac{ ( - x \ln x )^n }{ n ! }
\mathrm{ d } x \\
= &amp; - \sum_{ n \geq 0 } \frac{ 1 }{ n ! } \int_0^{ + \infty } e^{ -
( n + 1 ) t } t^n \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^n \mathrm{ d } t \\
= &amp; \frac{ - 1 }{ n + 1 } \int_0^{ + \infty } t^n \mathrm{ d } e^{ -
( n + 1 ) t } \\
= &amp; \frac{ - 1 }{ n + 1 } \left ( e^{ - ( n + 1 ) t } t^{ n } |_0^{
+ \infty } - n \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^{ n - 1 }
\right ) \\
= &amp; \frac{ n }{ n + 1 } \int_0^{ + \infty } e^{ - ( n + 1 ) t } t^{
n - 1 } \\
= &amp; \cdots \\
= &amp; \frac{ n ! }{ ( n + 1 )^{ n } } \int_0^{ + \infty } e^{ - ( n +
1 ) t } \mathrm{ d } t \\
= &amp; - \frac{ n ! }{ ( n + 1 )^{ n + 1 } }
\end{aligned}
\]</span></p>
<p>和上面结合一下就证毕.</p>
<h6><span id="example2">Example2</span></h6>
<p>设函数列<span class="math inline">\(\{ f_n ( x )
\}\)</span>任意内闭可积,并且<span class="math inline">\(\{ f_n ( x )
\}\)</span>在<span class="math inline">\(\mathbb{ R
}\)</span>上一致收敛到<span class="math inline">\(f ( x
)\)</span>,再设存在函数<span class="math inline">\(g ( x
)\)</span>满足:</p>
<p><span class="math display">\[
| f_n ( x ) | \leq g ( x )
\]</span></p>
<p>并且<span class="math inline">\(\int_{ - \infty }^{ + \infty } g ( x
) \mathrm{ d } x &lt; + \infty\)</span>.求证下列积分收敛而且:</p>
<p><span class="math display">\[
\int_{ - \infty }^{ + \infty } f ( x ) \mathrm{ d } x = \lim_{ n \to
\infty } \int_{ - \infty }^{ + \infty } f_n ( x ) \mathrm{ d } x
\]</span></p>
<p>首先要证明<span class="math inline">\(\int_{ - \infty }^{ + \infty }
f ( x ) \mathrm{ d } x\)</span>收敛.只需观察到<span class="math inline">\(| f_n | \leq g\)</span>两遍取极限就可以拿到<span class="math inline">\(| f | \leq g\)</span>,所以绝对收敛.</p>
<p>接下来考虑如何证明相等,这里的问题在于虽然<span class="math inline">\(f ( x ) \rightrightarrows
f\)</span>,但是由于区间长度无限长,因此这个控制会被放大.于此我们的策略是考虑将区间分成三段:<span class="math inline">\([ - \infty , - A ] , [ - A , A ] , [ A , + \infty
]\)</span>,对于中间的部分用一致收敛控制住,对于前后的部分用柯西准则控制住.</p>
<p>具体而言,<span class="math inline">\(| f ( x ) - f_n ( x ) | \leq 2 g
( x )\)</span>取足够大的<span class="math inline">\(A\)</span>使得<span class="math inline">\(\int_{ A }^{ + \infty } g ( x ) \mathrm{ d } x
\leq \frac{ \epsilon }{ 6 }\)</span>以及<span class="math inline">\(\int_{ - \infty }^{ - A } g ( x ) \mathrm{ d } x
\leq \frac{ \epsilon }{ 6 }\)</span>,接下来考虑取足够大的<span class="math inline">\(n\)</span>使得在<span class="math inline">\([ - A
, A ]\)</span>上,<span class="math inline">\(| f_n ( x ) - f ( x ) |
&lt; \frac{ \epsilon }{ 6 A }\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ - \infty }^{ + \infty } f_n ( x ) - f ( x ) \mathrm{ d }
x | \\
\leq &amp; | \int_{ - A }^{ + A } f_n ( x ) - f ( x ) \mathrm{ d } x | +
| \int_{ - \infty }^{ - A } f_n ( x ) - f ( x ) \mathrm{ d } x | + |
\int_{ + A }^{ + \infty } f_n ( x ) - f ( x ) \mathrm{ d } x | \\
\leq &amp; 2 A \frac{ \epsilon }{ 6 A } + \frac{ \epsilon }{ 6 } \times
4 \\
= &amp; \epsilon
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h4><span id="可微性">可微性</span></h4>
<p>先看一个平凡的命题:假设<span class="math inline">\(f_n \in C^1 [ a ,
b ] , x_0 \in [ a , b ]\)</span>,已知<span class="math inline">\(\{ f_n
( x_0 ) \}\)</span>收敛,而且<span class="math inline">\(f_n &#39;
\rightrightarrows g\)</span>.则<span class="math inline">\(f_n
\rightrightarrows f\)</span>,其中<span class="math inline">\(f \in C^1 [
a , b ]\)</span>,并且恰好满足<span class="math inline">\(f &#39; =
g\)</span>.</p>
<p>考虑<span class="math inline">\(g ( x ) = \lim_{ n \to \infty } f_n
&#39; ( x ) , x \in [ a , b ]\)</span>当然能得到<span class="math inline">\(g ( x )\)</span>是连续函数.</p>
<p>接下来考虑NL公式给出:</p>
$$
<span class="math display">\[\begin{aligned}
f_n ( x ) &amp; = f_n ( x_0 ) + \int_{ x_0 }^x f &#39;_n ( t ) \mathrm{
d } t \\
\lim_{ n \to \infty } f_n ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0
) + \lim_{ n \to \infty } \int_{ x_0 }^x f &#39;_n ( t ) \mathrm{ d } t
\\
\lim_{ n \to \infty } f_n ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0
) + \int_{ x_0 }^x \lim_{ n \to \infty } f &#39;_n ( t ) \mathrm{ d } t
\\
f ( x ) &amp; = \lim_{ n \to \infty } f_n ( x_0 ) + \int_{ x_0 }^x g ( t
) \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就见到<span class="math inline">\(f_n \to f , f \in C^1 [ a , b
]\)</span>而且<span class="math inline">\(f &#39; =
g\)</span>.现在的问题是能否推出一致收敛<span class="math inline">\(f_n
\rightrightarrows f\)</span>.有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f ( x ) | \\
= &amp; | f_n ( x_0 ) + \int_{ x_0 }^x f_n &#39; ( t ) \mathrm{ d } t -
f ( x_0 ) - \int_{ x_0 }^x g ( t ) | \\
\leq &amp; | f_n ( x_0 ) - f ( x_0 ) | + | \int_{ x_0 }^x f_n &#39; ( t
) \mathrm{ d } t - \int_{ x_0 }^x g ( t ) | \\
\leq &amp; | f_n ( x_0 ) - f ( x_0 ) | + ( b - a ) \sup | f_n &#39; - g
|
\end{aligned}
\]</span></p>
<p>这就完事.</p>
<p>上述结果能不能加强呢?事实上有一个更一般的结果:假设对于一串连续函数<span class="math inline">\(f_n ( x ) \in C [ a , b ]\)</span>,已知<span class="math inline">\(\exists x_0 \in [ a , b ]\)</span>,<span class="math inline">\(\lim_{ n \to \infty } f_n ( x_0
)\)</span>存在.若对于<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists N &gt; 0 , \forall n , m
\geq N\)</span>,函数<span class="math inline">\(g ( x ) = f_n ( x ) -
f_m ( x )\)</span>的李氏常数<span class="math inline">\(&lt;
\epsilon\)</span>.则我们可以推出<span class="math inline">\(\{ f_n ( x )
\}\)</span>一致收敛,设<span class="math inline">\(f_n ( x )
\rightrightarrows f ( x )\)</span>,若对于某个<span class="math inline">\(x \in [ a , b ]\)</span>,如果<span class="math inline">\(f_n &#39; ( x )\)</span>恒存在,而且<span class="math inline">\(\lim_{ n \to \infty } f_n &#39; ( x
)\)</span>存在,则<span class="math inline">\(f &#39; ( x
)\)</span>存在而且<span class="math inline">\(f &#39; ( x ) = \lim_{ n
\to \infty } f_n &#39; ( x )\)</span>.</p>
<p>这个结论的正确性比较直观,就是用李氏连续的性质限制整个函数的波动.这个结论当然要严格强于原本的结论,因为闭区间上的可导函数自然是李氏连续函数,如若<span class="math inline">\(f_n &#39; ( x
)\)</span>一致连续,当然能推出上述的李氏连续性质,立刻得到原本结论.</p>
<p>下面考虑证明:<span class="math inline">\(\forall \epsilon &gt; 0 ,
\exists N , \forall n , m \geq N\)</span>,都有<span class="math inline">\(| f_n ( x_0 ) - f_m ( x_0 ) | &lt; \frac{ \epsilon
}{ 2 }\)</span>,并且<span class="math inline">\(f_n ( x ) - f_m ( x
)\)</span>的李氏常数<span class="math inline">\(&lt; \frac{ \epsilon }{
2 ( b - a ) }\)</span>.注意到此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | f_n ( x ) - f_m ( x ) | \\
\leq &amp; | f_n ( x ) - f_m ( x ) - ( f_n ( x_0 ) - f_m ( x_0 ) ) | + |
f_n ( x_0 ) - f_m ( x_0 ) | \\
&lt; &amp; \frac{ \epsilon }{ 2 ( b - a ) } | x - x_0 | + \frac{
\epsilon }{ 2 } \leq \epsilon
\end{aligned}
\]</span></p>
<p>这就证明了<span class="math inline">\(f_n\)</span>一致收敛,不妨设<span class="math inline">\(f_n \rightrightarrows f\)</span>.</p>
<p>接下来对于某个<span class="math inline">\(x \in [ a , b
]\)</span>,定义<span class="math inline">\(\varphi_n ( t ) = \frac{ f_n
( t ) - f_n ( x ) }{ t - x } , t \in [ a , b ] \setminus \{ x
\}\)</span>,并补定义<span class="math inline">\(\varphi ( t ) = \frac{ f
( t ) - f ( x ) }{ t - x } , t \in [ a , b ] \setminus \{ x
\}\)</span>.显然<span class="math inline">\(\varphi_n ( t ) \in C [ a ,
b ] \setminus \{ x \}\)</span></p>
<p>首先注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \varphi_n ( t ) - \varphi_m ( t ) | \\
= &amp; \frac{ 1 }{ | t - x | } | f_n ( t ) - f_m ( t ) - ( f_n ( x ) -
f_m ( x ) ) | \\
\leq &amp; \frac{ 1 }{ | t - x | } \frac{ \epsilon }{ 2 ( b - a ) } | t
- x | \\
= &amp; \frac{ \epsilon }{ 2 ( b - a ) }
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(\varphi_n ( t
)\)</span>一致收敛,而且容易见到<span class="math inline">\(\varphi_n
\rightrightarrows \varphi\)</span>.从而:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; ( x ) &amp; = \lim_{ t \to x } \varphi ( t ) \\
&amp; = \lim_{ t \to x } \lim_{ n \to \infty } \varphi_n ( t ) \\
&amp; = \lim_{ n \to \infty } \lim_{ t \to x } \varphi_n ( t ) \\
&amp; = \lim_{ n \to \infty } f_n &#39; ( x )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>容易发现上述的推论是可导函数列的收敛性质(并不需要<span class="math inline">\(C^1\)</span>).而且我们还可以推出一个推论:那就是导函数一致收敛到的函数也是导函数.</p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(\{ q_n \}\)</span>是<span class="math inline">\([ 0 , 1
]\)</span>中的全体有理数排成的数列.定义<span class="math inline">\(f ( x
) = \sum_{ n = 1 }^\infty \frac{ | x - q_n | }{ 3^n } , x \in [ 0 , 1
]\)</span>.</p>
<p>首先用大M判别法,注意到<span class="math inline">\(\frac{ | x - q_n |
}{ 3^n } \leq \frac{ 1 }{ 3^n
}\)</span>,而每一项都是连续的,所以总的<span class="math inline">\(f ( x
)\)</span>是连续函数,而且这个定义也是收敛的.而且对于<span class="math inline">\(x_0 \in [ 0 , 1 ] \setminus \mathbb{ Q
}\)</span>,<span class="math inline">\(f_n &#39; ( x_0
)\)</span>当然都是存在的,而且见到<span class="math inline">\(f_n &#39; (
x_0 ) = \sum_{ k = 1 }^n \frac{ \text{ sgn } ( x_0 - q_k ) }{ 3^k
}\)</span>,并且这个导数还足够小.因此立刻见到当<span class="math inline">\(n , m\)</span>足够大的时候,立刻见到<span class="math inline">\(f_n - f_m\)</span>的李氏常数可以尽可能小.</p>
<p>于是套用上面的结论可以知道<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\([ 0 , 1 ] \setminus \mathbb{ Q
}\)</span>处可导.那么其在<span class="math inline">\(\mathbb{ Q } \cap [
0 , 1 ]\)</span>上可导么?如若<span class="math inline">\(x \in \mathbb{
Q }\)</span>,不妨设<span class="math inline">\(x =
q_n\)</span>,则考虑<span class="math inline">\(f ( x ) = \frac{ | x -
q_n | }{ 3^n } + \sum_{ k \ne n } \frac{ | x - q_k | }{ 3^k
}\)</span>,前半部分在<span class="math inline">\(q_n\)</span>处不可导可后半部分在<span class="math inline">\(q_n\)</span>处可导,于是总和当然不可导.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f ( x ) = \sum_{ n = 1 }^\infty \frac{
\sin ( nx ) }{ n^3 }\)</span>,求其导函数.</p>
<p>观察到<span class="math inline">\(\sum_{ n = 1 }^\infty | ( \frac{
\sin ( nx ) }{ n^3 } ) &#39; | \leq \sum \frac{ 1 }{ n^2 } &lt;
\infty\)</span>,所以其导函数也绝对一致收敛.立刻能推出<span class="math inline">\(f \in C^1 ( - \infty , + \infty
)\)</span>,而且导函数就是逐项求导的<span class="math inline">\(f &#39; (
x ) = \sum_{ n = 1 }^\infty \frac{ \cos ( nx ) }{ n^2 }\)</span>.</p>
<h4><span id="部分应用">部分应用</span></h4>
<h5><span id="borel引理">Borel引理</span></h5>
<p>对任何一个实数列<span class="math inline">\(\{ a_n
\}\)</span>,都存在一个函数<span class="math inline">\(f ( x ) \in C^{
\infty } ( \mathbb{ R } )\)</span>,满足<span class="math inline">\(f^{ (
n ) } ( 0 ) = a_n\)</span>.</p>
<p>考虑造一个<span class="math inline">\(g ( x ) = \begin{cases}1 &amp;
0 \leq x \leq \frac{ 1 }{ 2 } \\ 0 &amp; x \geq
1\end{cases}\)</span>,其中中间少了一段用磨光核连起来.考虑造一个单调递增无界正数列<span class="math inline">\(\{ \lambda_n \}\)</span>,并取:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ n = 0 }^\infty \frac{ a_n x^n }{ n ! } g ( \lambda_n |
x | )
\]</span></p>
<p>这个的好处是什么呢?我们发现当<span class="math inline">\(\lambda_n |
x | \geq 1\)</span>,<span class="math inline">\(| x | \geq \frac{ 1 }{
\lambda_n }\)</span>的时候<span class="math inline">\(g ( \lambda_n | x
| ) = 0\)</span>,又因为<span class="math inline">\(\lambda_n\)</span>单调递增趋近于无穷,所以除了<span class="math inline">\(0\)</span>以外的所有点上都是有限和,因此全都收敛而且全都可导,所以<span class="math inline">\(f \in C^{ \infty } ( \mathbb{ R } \setminus \{ 0
\} )\)</span>.</p>
<p>考虑<span class="math inline">\(f_n ( x ) = \frac{ a_n x^n }{ n ! } g
( \lambda_n | x | )\)</span>,这个当然是<span class="math inline">\(C^{
\infty }\)</span>的.并且当然有<span class="math inline">\(f_n^{ ( n ) }
( 0 ) = a_n\)</span>.现在如果我们能搞定这个导数级数的收敛性就搞定了<span class="math inline">\(0\)</span>处的可导性了对吧.取<span class="math inline">\(M_k = \max_{ 0 \leq l \leq k } | g^{ ( l ) }
|\)</span>,当<span class="math inline">\(k \leq
n\)</span>的时候考虑:</p>
$$
<span class="math display">\[\begin{aligned}
| f_n^{ ( k ) } ( x ) | &amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0
}^k \left | \binom{ k }{ m } n^{ \underline{ k - m } } x^{ n - k + m }
g^{ ( m ) } ( \lambda_n | x | ) \lambda_n^m \right | \\
&amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \binom{ k }{
m } n^{ \underline{ k - m } } x^{ n - k + m } M_k \lambda_n^m \right |
\\

\end{aligned}\]</span>
<p>$$</p>
<p>注意这里的<span class="math inline">\(x\)</span>一定很小,<span class="math inline">\(| x | &lt; \frac{ 1 }{ \lambda_n
}\)</span>的时候上式才有意义,开始放缩:</p>
<p><span class="math display">\[
\begin{aligned}
| f_n^{ ( k ) } ( x ) | &amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0
}^k \left | \frac{ k ! }{ m ! ( k - m ) ! } n^{ \underline{ k - m } }
M_k \frac{ 1 }{ \lambda_n^{ n - k } } \right | \\
&amp; \leq \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \frac{ k !
}{ m ! ( k - m ) ! } n^{ \underline{ k - m } } M_k \frac{ 1 }{
\lambda_n^{ n - k } } \right | \\
&amp; = \frac{ | a_n | }{ n ! } \sum_{ m = 0 }^k \left | \frac{ k ! }{ m
! ( k - m ) ! } \frac{ n ! }{ ( n - k + m ) ! } M_k \frac{ 1 }{
\lambda_n^{ n - k } } \right | \\
&amp; \leq | a_n | M_k \frac{ 1 }{ \lambda_n^{ n - k } } k !
\end{aligned}
\]</span></p>
<p>显然只需取足够小的<span class="math inline">\(\lambda_n\)</span>就用大M判别法控制住了.</p>
<h5><span id="维尔斯特拉斯函数">维尔斯特拉斯函数</span></h5>
<p>考虑造一个处处连续处处不可导的函数,首先它应该在任何一个区间上都没有单调性(因为单调函数几乎处处可导).</p>
<p>首先造一个连续的<span class="math inline">\(2\)</span>周期函数<span class="math inline">\(h ( x ) = \begin{cases}x &amp; 0 \leq x \leq 1 \\
2 - x &amp; 1 \leq x \leq 2 \\ h ( x - 2 ) &amp; \text{ otherwise
}\end{cases}\)</span>.或者我们干脆定义<span class="math inline">\(h ( x
) = \sin ( \frac{ \pi }{ 2 } 4^n x
)\)</span>,这样这个函数更光滑一点,但对论证几乎没有区别.</p>
<p>考虑造<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^{ \infty }
( \frac{ 3 }{ 4 } )^n h ( 4^n x )\)</span>,注意到:</p>
<p><span class="math display">\[
f ( x ) \leq \sum ( \frac{ 3 }{ 4 } )^n &lt; \infty
\]</span></p>
<p>根据大M判别法,所以这个函数的确绝对一致收敛.那这个函数就确实继承了连续性.</p>
<p>首先有引理:如果<span class="math inline">\(f &#39; ( x_0
)\)</span>存在,而且<span class="math inline">\(\alpha_n \leq x_0 \leq
\beta_n , 0 &lt; \beta_n - \alpha_n \to 0\)</span>,则<span class="math inline">\(\lim_{ n \to \infty } \frac{ f ( \beta_n ) - f (
\alpha_n ) }{ \beta_n - \alpha_n } \to f &#39; ( x_0 )\)</span>.取<span class="math inline">\(\lambda_n = \frac{ \beta_n - x_0 }{ \beta_n -
\alpha_n }\)</span>,容易见到<span class="math inline">\(0 \leq \lambda_n
\leq 1\)</span>,见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ f ( \beta_n ) - f ( \alpha_n ) }{ \beta_n - \alpha_n } - f
&#39; ( x_0 ) \\
= &amp; \lambda_n ( \frac{ f ( \beta_n ) - f ( x_0 ) }{ \beta_n - x_0 }
- f &#39; ( x_0 ) ) + ( 1 - \lambda_n ) ( \frac{ \alpha_n - f ( x_0 ) }{
\alpha_n - x_0 } - f &#39; ( x_0 ) )
\end{aligned}
\]</span></p>
<p>容易见到趋近于<span class="math inline">\(0\)</span>.不过要简单判断一下<span class="math inline">\(\alpha_n = x_0\)</span>的情况.</p>
<p>既然如此,<span class="math inline">\(\forall x \in \mathbb{ R
}\)</span>,考虑定义<span class="math inline">\(\alpha_m = \frac{ \lfloor
4^m x \rfloor }{ 4^m } , \beta_m = \alpha_m + \frac{ 1 }{ 4^m
}\)</span>,容易见到<span class="math inline">\(\alpha_m \leq x &lt;
\beta_m\)</span>.并且当<span class="math inline">\(n \leq
m\)</span>的时候，<span class="math inline">\(( 4^n \alpha_m , 4^n
\beta_m )\)</span>上不存在整数.</p>
<p>见到:</p>
<p><span class="math display">\[
4^n ( \beta_m - \alpha_m ) = \begin{cases}
\in 4 \mathbb{ N } &amp; n &gt; m \\
1 &amp; n = m \\
&lt; 1 &amp; \text{ otherwise }
\end{cases}
\]</span></p>
<p>于是:</p>
<p><span class="math display">\[
| h ( 4^n \beta_m ) - h ( 4^n \alpha_m ) | = \begin{cases}
0 &amp; n &gt; m \\
| 4^n \beta_m - 4^n \alpha_m | = 4^{ n - m } &amp; n \leq m
\end{cases}
\]</span></p>
<p>把<span class="math inline">\(n &lt;
m\)</span>的地方往负了放,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
| f ( \beta_m ) - f ( \alpha_m ) | &amp; = \sum_{ n = 0 }^m ( \frac{ 3
}{ 4 } )^n ( h ( 4^n \beta_m ) - h ( 4^n \alpha_m ) ) \\
&amp; \geq ( \frac{ 3 }{ 4 } )^m - \sum_{ n = 0 }^{ m - 1 } ( \frac{ 3
}{ 4 } )^n 4^{ n - m } \\
&amp; = ( \frac{ 3 }{ 4 } )^m - \frac{ 1 }{ 4^m } \frac{ 3^m - 1 }{ 2 }
\\
&amp; = \frac{ 1 }{ 4^m } \frac{ 3^m + 1 }{ 2 }
\end{aligned}
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
\frac{ | f ( \beta_m ) - f ( \alpha_m ) | }{ \beta_m - \alpha_m } \geq
\frac{ 3^m + 1 }{ 2 }
\]</span></p>
<p>然而如若这点导数存在,那么这里的导数就是<span class="math inline">\(\lim_{ m \to \infty } \frac{ 3^m + 1 }{ 2 } =
\infty\)</span>,这就矛盾了.因此这个函数处处不可导.</p>
<h5><span id="连续曲线充满平面">连续曲线充满平面</span></h5>
<p>存在充满<span class="math inline">\([ 0 , 1 ] \times [ 0 , 1
]\)</span>的连续曲线.连续曲线在这里定义为<span class="math inline">\(( x
( t ) , y ( t ) ) , t \in [ 0 , 1 ]\)</span>满足<span class="math inline">\(x ( t ) , y ( t ) \in C [ 0 , 1
]\)</span>,任意<span class="math inline">\(( a , b ) \in [ 0 , 1 ]
\times [ 0 , 1 ]\)</span>,都存在<span class="math inline">\(t\)</span>使得<span class="math inline">\(a = x (
t ) , b = y ( t )\)</span>.</p>
<p>搞一个连续函数<span class="math inline">\(g ( t )\)</span>满足:</p>
$$ g ( t ) =
<span class="math display">\[\begin{cases}
0 &amp; t \in [ 0 , \frac{ 1 }{ 3 } ] \cup [ \frac{ 5 }{ 3 } , 2 ] \\
3 t - 1 &amp; t \in [ \frac{ 1 }{ 3 } , \frac{ 2 }{ 3 } ] \\
1 &amp; t \in [ \frac{ 2 }{ 3 } , \frac{ 4 }{ 3 } ] \\
3 t + 5 &amp; t \in [ \frac{ 4 }{ 3 } , \frac{ 5 }{ 3 } ] \\

\end{cases}\]</span>
<p>$$</p>
<p>并且满足<span class="math inline">\(g ( t + 2 ) = g ( t
)\)</span>,也就是一个周期梯形函数.</p>
<p>接下来定义:</p>
<p><span class="math display">\[
\begin{aligned}
x ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } g ( 3^{ 2 n - 2
} t ) \\
y ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } g ( 3^{ 2 n - 1
} t )
\end{aligned}
\]</span></p>
<p>容易发现<span class="math inline">\(0 \leq x ( t ) , y ( t ) \leq
\sum_{ n = 1 }^\infty \frac{ 1 }{ 2^n } =
1\)</span>,所以的确绝对一致收敛,继承了连续性而且确实在<span class="math inline">\([ 0 , 1 ] \times [ 0 , 1 ]\)</span>中.</p>
<p>接下来<span class="math inline">\(\forall ( a , b ) \in [ 0 , 1 ]
\times [ 0 , 1 ]\)</span>,我们尝试找到一个<span class="math inline">\(t\)</span>使得<span class="math inline">\(a = x (
t ) , b = y ( t )\)</span>.考虑取二者的二进制表示<span class="math inline">\(a = \sum_{ n = 1 }^\infty \frac{ a_n }{ 2^n } , b
= \sum_{ n = 1 }^\infty \frac{ b_n }{ 2^n }\)</span>,其中<span class="math inline">\(a_n , b_n \in \{ 0 , 1
\}\)</span>.取一个新的数列<span class="math inline">\(c_{ 2 n - 1 } =
a_n , c_{ 2 n } = b_n\)</span>.取<span class="math inline">\(0 \leq c =
2 \sum_{ n = 1 }^\infty \frac{ c_n }{ 3^n } \leq
1\)</span>,下面我们证明<span class="math inline">\(x ( c ) = a , x ( c )
= b\)</span>.</p>
<p>考虑<span class="math inline">\(3^k c = 2 \sum_{ n = 1 }^k \frac{ c_n
}{ 3^{ n - k } } + 2 \sum_{ n = k + 1 }^\infty \frac{ c_n }{ 3^{ n - k }
}\)</span>.其中前半部分是个偶整数,因此在带入函数<span class="math inline">\(g\)</span>后会消失,观察后半部分,容易见到:如果<span class="math inline">\(c_{ k + 1 } = 0\)</span>,则后半部分<span class="math inline">\(\leq \frac{ 1 }{ 3 }\)</span>;如果<span class="math inline">\(c_{ k + 1 } = 1\)</span>,则后半部分<span class="math inline">\(\geq \frac{ 2 }{ 3 }\)</span>,因此<span class="math inline">\(g ( 3^k c ) = c_{ k + 1
}\)</span>.带入原式定义就看到<span class="math inline">\(x ( c ) = a , y
( c ) = b\)</span>.</p>
<p>甚至说,这里的<span class="math inline">\(c\)</span>其实就在康托尔三分集中,所以事实上这个曲线上的零测集就足以覆盖整个平面.</p>
<h4><span id="幂级数">幂级数</span></h4>
<p>我们把形如<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^{
\infty } a_n ( x - x_0
)^n\)</span>的函数项级数称作<strong>幂级数</strong>,由于可以做自变量平移,不妨假设<span class="math inline">\(x_0 = 0\)</span>而<span class="math inline">\(f (
x ) = \sum_{ n = 0 }^{ \infty } a_n x^n\)</span>.</p>
<p>一个最先遇到的问题当然是幂级数的收敛范围,首先<span class="math inline">\(x = 0\)</span>肯定收敛.其次我们可以发现如果<span class="math inline">\(f ( r )\)</span>收敛,那么<span class="math inline">\(\forall x \in \mathbb{ R } , | x | &lt; | r
|\)</span>都有<span class="math inline">\(f ( x
)\)</span>收敛,原因是:</p>
<p><span class="math display">\[
\sum | a_n x^n | = \sum | a_n r^n | \cdot | \frac{ x }{ r } |^n
\]</span></p>
<p>由于<span class="math inline">\(\sum a_n
r^n\)</span>收敛,所以其通项<span class="math inline">\(\lim_{ n \to
\infty } a_n r^n = 0\)</span>,那至少是有界的,而<span class="math inline">\(| \frac{ x }{ r }
|^n\)</span>又是个无穷递降等比数列,那就肯定收敛.既然如此,取<span class="math inline">\(R = \sup \{ | x | , x \in \mathbb{ R } | f ( x )
\text{ is converge } \}\)</span>.由上面的结论我们知道<span class="math inline">\(\forall x \in ( - R , R )\)</span>都有<span class="math inline">\(f ( x )\)</span>收敛,另外<span class="math inline">\(\forall x , | x | &gt; R\)</span>都有<span class="math inline">\(f ( x )\)</span>发散.既然如此,我们将<span class="math inline">\(( - R , R
)\)</span>称作幂级数的<strong>收敛区间</strong>,容易见到收敛域和收敛区间最多只可能差两个点,换言之设收敛域为<span class="math inline">\(E\)</span>,则自然有<span class="math inline">\(( -
R , R ) \subseteq E \subseteq [ - R , R ]\)</span>.</p>
<p>取<span class="math inline">\(\rho = \varlimsup_{ n \to + \infty }
\sqrt[n]{ | a_n | }\)</span>,则<span class="math inline">\(R = \rho^{ -
1 }\)</span>(这里要做一些约定:不妨设<span class="math inline">\(\inf^{ -
1 } = 0\)</span>和<span class="math inline">\(0^{ - 1 } =
\inf\)</span>).原因是<span class="math inline">\(\varlimsup_{ n \to +
\infty } \sqrt[n]{ | a_n x^n | } = | x |
\rho\)</span>,用根值判别法就显然了.</p>
<p>这里还有一个更弱的比值判别法的版本:如若<span class="math inline">\(a_n \ne 0\)</span>,<span class="math inline">\(\rho = \lim_{ n \to \infty } \left | \frac{ a_{ n
+ 1 } }{ a_n } \right |\)</span>存在,则<span class="math inline">\(R =
\rho^{ - 1 }\)</span>.原因是Stolz定理给出:</p>
<p><span class="math display">\[
\varliminf \frac{ | a_{ n + 1 } | }{ | a_n | } \leq \varliminf \sqrt[n]{
| a_n | } \leq \varlimsup \sqrt[n]{ | a_n | } \leq \varlimsup \frac{ |
a_{ n + 1 } | }{ | a_n | }
\]</span></p>
<p>下面我们证明,在收敛区间的内部<span class="math inline">\(( - R , R
)\)</span>内,<span class="math inline">\(\sum a_n
x^n\)</span>是内闭绝对一致收敛的.而如果其在端点处也收敛,例如在<span class="math inline">\(x = R\)</span>时收敛的话,则其在<span class="math inline">\([ 0 , R ]\)</span>上一致收敛.</p>
<p>前者的话,只需用大M判别法即可,任取<span class="math inline">\([ - r ,
r ] \subseteq ( - R , R )\)</span>然后看<span class="math inline">\(|
a_n x^n | \leq | a_n r^n |\)</span>.</p>
<p>而对于后者的话,考虑<span class="math inline">\(\sum a_n x^n = \sum
a_n R^n ( \frac{ x }{ R } )^n\)</span>,而<span class="math inline">\((
\frac{ x }{ R } )^n\)</span>是单调一致有界,而<span class="math inline">\(\sum a_n R^n\)</span>收敛,用DA判法则搞定.</p>
<p>上述结论的一个显然推论是幂级数是收敛域上的连续函数(因为在收敛域上都是一致连续的).</p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(R =
1\)</span>,既然有一致连续性,若<span class="math inline">\(\sum
a_n\)</span>收敛,则极限存在有<span class="math inline">\(\lim_{ x \to 1
- 0 } f ( x ) = f ( 1 ) = \sum
a_n\)</span>.然而这个结论反过来不成立,例如<span class="math inline">\(f
( x ) = \sum ( - x )^n = \frac{ 1 }{ 1 + x
}\)</span>,容易见到极限为<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>可是<span class="math inline">\(f ( 1 )\)</span>并不收敛.</p>
<p>上述结论能不能加点条件使得反之成立呢?我们下面证明若<span class="math inline">\(a_n = o ( \frac{ 1 }{ n } )\)</span>,若<span class="math inline">\(\lim_{ x \to 1 - 0 } f ( x ) =
S\)</span>存在,则<span class="math inline">\(\sum a_n = S\)</span>.</p>
<p>考虑取<span class="math inline">\(\sigma_n = \frac{ 1 }{ n } \sum_{ k
= 0 }^n k | a_k |\)</span>,由Stolz定理知道<span class="math inline">\(\lim \sigma_n = \lim n | a_n | =
0\)</span>.取<span class="math inline">\(S_n = \sum_{ k = 1 }^n
a_k\)</span>,我们要证明的就是当<span class="math inline">\(n \to
\inf\)</span>的时候<span class="math inline">\(| S - S_n
|\)</span>尽可能小.当<span class="math inline">\(x \in ( - 1 , 1
)\)</span>的时候,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
S_n - S &amp; = f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + \sum_{
k = 0 }^n a_k ( 1 - x^k ) \\
&amp; = f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + \sum_{ k = 0
}^n a_k ( 1 - x ) ( 1 + x + \cdots + x^{ k - 1 } ) \\
&amp; \leq f ( x ) - S - \sum_{ k = n + 1 }^\infty a_k x^k + ( 1 - x )
\sum_{ k = 0 }^n ka_k \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math inline">\(\forall \epsilon &gt;
0\)</span>,取足够大的<span class="math inline">\(n\)</span>使得<span class="math inline">\(\sigma_n &lt; \frac{ \epsilon }{ 3
}\)</span>而且使得<span class="math inline">\(| na_n | &lt; \frac{
\epsilon }{ 3 }\)</span>总成立,那么:</p>
<p><span class="math display">\[
| S_n - S | \leq | f ( x ) - S | + ( 1 - x ) n \sigma_n + \frac{
\epsilon }{ 3 n } \frac{ x^{ n + 1 } }{ 1 - x }
\]</span></p>
<p>取<span class="math inline">\(x = 1 - \frac{ 1 }{ n
}\)</span>,即可得证.</p>
<p>如果加点单调性也可以.设<span class="math inline">\(a_n &gt;
0\)</span>,如果<span class="math inline">\(f ( x ) = \sum_n a_n
x^n\)</span>满足<span class="math inline">\(f ( 1 -
)\)</span>存在,则<span class="math inline">\(\sum a_n = f ( 1 -
)\)</span>.</p>
<p>这个结论与之前的一致收敛那里的单调性质完全相似.首先由<span class="math inline">\(\sum_n a_n \leq f ( 1 -
)\)</span>得到这个级数收敛,然后又可以放到<span class="math inline">\(\sum a_n x^n \leq \sum_n
a_n\)</span>,让左边趋近一下得到<span class="math inline">\(f ( 1 - )
\leq \sum_n a_n\)</span>.</p>
<h5><span id="柯西和">柯西和</span></h5>
<p>设<span class="math inline">\(\sum a_n = A , \sum b_n =
B\)</span>,设<span class="math inline">\(c_n = \sum_{ k = 0 }^n a_{ n -
k } b_k\)</span>,我们下面证明若<span class="math inline">\(\sum
c_n\)</span>收敛,则<span class="math inline">\(\sum c_n =
AB\)</span>.</p>
<p>考虑设<span class="math inline">\(f ( x ) = \sum a_n x^n , g ( x ) =
\sum b_n x^n\)</span>,则其收敛半径肯定<span class="math inline">\(\geq
1\)</span>,既然如此在任何内闭区间<span class="math inline">\([ - r , r ]
\subseteq ( - 1 , 1 )\)</span>,<span class="math inline">\(f ,
g\)</span>都在<span class="math inline">\([ - r , r
]\)</span>上绝对一致收敛,既然如此我们就可以把这个乘积随便打乱顺序,得到<span class="math inline">\(f ( x ) g ( x ) = \sum c_n x^n , \forall x \in [ -
r , r ]\)</span>.而我们又有<span class="math inline">\(\sum
c_n\)</span>收敛,既然如此<span class="math inline">\(\sum c_n = h ( 1 )
= \lim_{ x \to 1 - 0 } h ( x ) = ( \lim_{ x \to 1 - 0 } f ( x ) ) (
\lim_{ x \to 1 - 0 } g ( x ) ) = AB\)</span>,则搞定.</p>
<p>其中<span class="math inline">\(\sum
c_n\)</span>收敛这个条件是必须的,如果去掉后结论不成立,有如下反例:</p>
<p>设<span class="math inline">\(a_n = b_n\)</span>考虑对<span class="math inline">\(( 1 + x )^{ - \frac{ 1 }{ 2 }
}\)</span>做泰勒展开,得到<span class="math inline">\(f ( x ) = g ( x ) =
\sum a_n x^n = \frac{ 1 }{ \sqrt{ 1 + x } }\)</span>此时<span class="math inline">\(f ( 1 ) , g ( 1 )\)</span>都收敛,原因是<span class="math inline">\(a_n = ( - 1 )^n \frac{ ( 2 n - 1 ) ! ! }{ 2^n n !
}\)</span>,用DA判法知道其收敛.然而<span class="math inline">\(f ( x ) g
( x ) = \frac{ 1 }{ 1 + x }\)</span>,<span class="math inline">\(c_n = (
- 1 )^n\)</span>,因此<span class="math inline">\(\sum
c_n\)</span>不收敛,这就完蛋了.</p>
<h5><span id="逐项微积分">逐项微积分</span></h5>
<p>既然幂级数在收敛域上一致收敛,那当然可以逐项积分.而且注意到<span class="math inline">\(\varlimsup \sqrt[n + 1]{ \frac{ | a_n | }{ n + 1 }
} = \varlimsup \sqrt[n]{ | a_n | }\)</span>,原因是<span class="math inline">\(\lim \sqrt[n]{ n } =
1\)</span>,因此收敛半径不变,然而积分后,端点处有可能被包含入收敛域,原因是DA判法,原本的<span class="math inline">\(a_n x^n\)</span>之和如果有界,配了一个多的下降<span class="math inline">\(\frac{ 1 }{ n }\)</span>就会收敛,例如<span class="math inline">\(\sum \frac{ x^n }{ n }\)</span>.</p>
<p>同理,对于逐项求导也可以发现收敛半径不变.所以幂级数可以在收敛域上逐项积分任意多次,也可以在收敛区间内逐项求导任意多次.</p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 0 }^\infty \frac{ ( - 1 )^n
}{ 3 n + 1 }\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ 3 n + 1 } x^{
3 n + 1 } \\
&amp; = \sum_{ n = 0 }^\infty \int_0^x ( - 1 )^n t^{ 3 n } \mathrm{ d }
t \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们想让这里的求和和积分交换顺序对吧!那首先得规定<span class="math inline">\(x \in ( - 1 , 1 )\)</span>而取不到<span class="math inline">\(1\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \int_0^x ( - 1 )^n t^{ 3 n }
\mathrm{ d } t \\
&amp; = \int_0^x \sum_{ n = 0 }^\infty ( - t )^{ 3 n } \mathrm{ d } t \\
&amp; = \int_0^x \frac{ \mathrm{ d } t }{ 1 + t^3 }
\end{aligned}
\]</span></p>
<p>后面那个可以积出来,而且<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(( - 1 , 1
)\)</span>上取值就是如此.而发现<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(1\)</span>处收敛,因此拿这个积出来的结果极限逼近一下就行.</p>
<h5><span id="泰勒级数">泰勒级数</span></h5>
<p>对于一个<span class="math inline">\(f \in
C^\infty\)</span>,考虑泰勒展开有:</p>
<p><span class="math display">\[
f ( x ) = \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } ( x - x_0
)^k + r_n ( x )
\]</span></p>
<p>其中依照拉格朗日余项,<span class="math inline">\(r_n ( x ) = \frac{
f^{ ( n + 1 ) } ( \xi ) }{ ( n + 1 ) ! } ( x - x_0 )^{ n + 1
}\)</span>,若存在<span class="math inline">\(\delta &gt;
0\)</span>,当<span class="math inline">\(x \in ( x_0 - \delta , x_0 +
\delta )\)</span>的时候,<span class="math inline">\(\lim_{ n \to \infty
} r_n = 0\)</span>,则称该函数在<span class="math inline">\(x_0\)</span>处解析,也就是可以用泰勒级数逼近它.</p>
<p>我们有一个命题:如果<span class="math inline">\(f ( x
)\)</span>在<span class="math inline">\(x_0\)</span>处解析,则其在<span class="math inline">\(x_0\)</span>附近的一个小邻域上解析(证明可以参考Example15).因此解析的概念以拓宽到区间上,如果其在一个开区间<span class="math inline">\(I\)</span>上解析,则称其<span class="math inline">\(\in C^\omega ( I )\)</span>.</p>
<p>而且我们还可以见到,如果<span class="math inline">\(f^{ ( n ) } ( x
)\)</span>一致有界(或者至少与<span class="math inline">\(n\)</span>无关),则由于<span class="math inline">\(( x - x_0 )^n\)</span>会被<span class="math inline">\(\frac{ 1 }{ ( n + 1 ) !
}\)</span>控制住,所以其在<span class="math inline">\(\mathbb{ R
}\)</span>上都是解析的.所以<span class="math inline">\(\sin x , \cos
x\)</span>都是解析的,另外<span class="math inline">\(e^x , \ln
x\)</span>的导数大小与<span class="math inline">\(n\)</span>无关,所以也解析.</p>
<p>当<span class="math inline">\(f , g\)</span>在<span class="math inline">\(x_0\)</span>处解析的时候,应当有<span class="math inline">\(f \pm g , fg , \frac{ f }{ g
}\)</span>都是解析的.而且如果<span class="math inline">\(f\)</span>在<span class="math inline">\(g ( x_0
)\)</span>处解析,则<span class="math inline">\(f ( g ( x )
)\)</span>也在<span class="math inline">\(x_0\)</span>处解析.这个太难算了,我们承认这个事实好了,反正就是硬算.</p>
<h6><span id="example1广义二项式定理">Example1(广义二项式定理)</span></h6>
<p>求<span class="math inline">\(f ( x ) = ( 1 + x
)^\alpha\)</span>在<span class="math inline">\(0\)</span>处的解析性.</p>
<p>也就是要证明<span class="math inline">\(f ( x ) = ( 1 + x )^\alpha =
\sum_{ n = 0 }^\infty \frac{ \alpha^{ \underline{ n } } }{ n ! }
x^n\)</span>.</p>
<p>用比值法,观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \frac{ \binom{ \alpha }{ n } }{ \binom{ \alpha }{ n + 1 } } | \\
= &amp; | \frac{ n + 1 }{ \alpha - n } | \to 1
\end{aligned}
\]</span></p>
<p>所以右端收敛半径为<span class="math inline">\(1\)</span>.既然如此先搞定右端那个幂级数,设<span class="math inline">\(g ( x ) = \sum_{ n = 0 }^\infty \binom{ \alpha }{
n } x^n , x \in ( - 1 , 1 )\)</span>.观察到:</p>
<p><span class="math display">\[
\begin{aligned}
g &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty n \binom{ \alpha }{ n } x^{
n - 1 } \\
( 1 + x ) g &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty n \binom{ \alpha
}{ n } x^{ n - 1 } + \sum_{ n = 1 }^\infty n \binom{ \alpha }{ n } x^{ n
} \\
&amp; = \alpha + \sum_{ n = 1 }^\infty \left ( n \binom{ \alpha }{ n } +
( n + 1 ) \binom{ \alpha }{ n + 1 } \right ) x^n \\
&amp; = \alpha + \alpha \sum_{ n = 1 }^\infty \binom{ \alpha }{ n } x^n
\\
&amp; = \alpha g
\end{aligned}
\]</span></p>
<p>此时见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \left ( \frac{ g }{ ( 1 + x )^\alpha } \right ) &#39; \\
= &amp; - \alpha ( 1 + x )^{ - \alpha - 1 } g + ( 1 + x )^{ - \alpha } g
&#39; \\
= &amp; ( 1 + x )^{ - \alpha - 1 } ( - \alpha g + ( 1 + x ) g &#39; )
\equiv 0
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\frac{ g }{ ( 1 + x )^\alpha
}\)</span>是一常数,演算<span class="math inline">\(x =
0\)</span>的部分就可以知道当<span class="math inline">\(x \in ( - 1 , 1
)\)</span>的时候它俩相等.</p>
<p>最后再补一下端点,</p>
<p>当<span class="math inline">\(\alpha &gt; 0 , x = \pm
1\)</span>的时候,下面直接证明它绝对收敛,也就是证明<span class="math inline">\(\sum | \binom{ \alpha }{ n } | &lt;
\inf\)</span>.,考虑拉贝判法:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; n \left ( \frac{ | \binom{ \alpha }{ n } | }{ | \binom{ \alpha }{
n + 1 } | } - 1 \right ) \\
= &amp; n ( \frac{ n + 1 }{ n - \alpha } - 1 ) \to 1 + \alpha &gt; 0
\end{aligned}
\]</span></p>
<p>所以此时收敛域是<span class="math inline">\([ - 1 , 1 ]\)</span>.</p>
<p>当<span class="math inline">\(- 1 &lt; \alpha &lt;
0\)</span>的时候,估一下发现:</p>
<p><span class="math display">\[
\begin{aligned}
| \binom{ \alpha }{ n } | &amp; = | ( 1 - \frac{ \alpha + 1 }{ 1 } )
\cdots ( 1 - \frac{ \alpha + 1 }{ n } ) | \\
&amp; = e^{ \sum_k \ln | 1 - \frac{ 1 + \alpha }{ k } | } \\
&amp; \approx e^{ - \sum_k \frac{ 1 + \alpha }{ k } } \\
&amp; \approx \frac{ 1 }{ n^{ 1 + \alpha } }
\end{aligned}
\]</span></p>
<p>而且此时<span class="math inline">\(\binom{ \alpha }{ n
}\)</span>本身是个交错级数,所以在<span class="math inline">\(-
1\)</span>处不收敛而在<span class="math inline">\(1\)</span>处收敛.同理当<span class="math inline">\(\alpha \leq - 1\)</span>的时候,<span class="math inline">\(| \binom{ \alpha }{ n } |\)</span>并不趋向于<span class="math inline">\(0\)</span>所以两端都不收敛.</p>
<h6><span id="example2反三角函数">Example2(反三角函数)</span></h6>
<p>考虑由Example1,当<span class="math inline">\(| x | &lt;
1\)</span>的时候:</p>
<p><span class="math display">\[
( 1 - x^2 )^{ - \frac{ 1 }{ 2 } } = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2
n - 1 ) ! ! }{ ( 2 n ) ! ! } x^{ 2 n }
\]</span></p>
<p>两遍逐项积分,有:</p>
<p><span class="math display">\[
\arcsin x = x + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{ ( 2 n )
! ! } \frac{ x^{ 2 n + 1 } }{ 2 n + 1 }
\]</span></p>
<p>继续用拉贝判别法,注意到:</p>
<p><span class="math display">\[
n \left ( \frac{ a_n }{ a_{ n + 1 } } - 1 \right ) \to \frac{ 3 }{ 2 }
\]</span></p>
<p>所以收敛.而且还可以发现这一下积分使得端点处也搞定了,所以上式对<span class="math inline">\([ - 1 , 1 ]\)</span>都成立.</p>
<h6><span id="example3平方倒数和">Example3(平方倒数和)</span></h6>
<p>还可再整点活,令<span class="math inline">\(x = \sin
t\)</span>带入上式,得到:</p>
$$
<span class="math display">\[\begin{aligned}
t &amp; = \sin t + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{ ( 2 n
) ! ! } \frac{ \sin^{ 2 n + 1 } t }{ 2 n + 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两遍在<span class="math inline">\([ 0 , \frac{ \pi }{ 2 }
]\)</span>上积分,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ \pi^2 }{ 8 } &amp; = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 )
! ! }{ ( 2 n ) ! ! ( 2 n + 1 ) } \frac{ ( 2 n ) ! ! }{ ( 2 n + 1 ) ! ! }
\\
&amp; = 1 + \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n + 1 )^2 } \\
&amp; = \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n - 1 )^2 }
\end{aligned}
\]</span></p>
<p>所以奇数的平方和是<span class="math inline">\(\frac{ \pi^2 }{ 8
}\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } &amp; = \frac{ \pi^2 }{ 8 } +
\frac{ 1 }{ 4 } \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } \\
\sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } &amp; = \frac{ \pi^2 }{ 6 }
\end{aligned}
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>当<span class="math inline">\(c &gt;
0\)</span>的时候,求证存在多项式列<span class="math inline">\(\{ P_n ( x
) \} \rightrightarrows | x | , x \in [ - c , c ]\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
| x | &amp; = ( x^2 )^{ \frac{ 1 }{ 2 } } \\
&amp; = ( c^2 - ( c^2 - x^2 ) )^{ \frac{ 1 }{ 2 } } \\
&amp; = c ( 1 - \left ( 1 - \frac{ x^2 }{ c^2 } \right ) )^{ \frac{ 1 }{
2 } }
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(1 - \frac{ x^2 }{ c^2 } \in [ 0 , 1 ]
, \frac{ 1 }{ 2 } &gt; 0\)</span>,只需要对此用广义二项式定理即可.</p>
<h6><span id="example5">Example5</span></h6>
<p>求<span class="math inline">\(\int_0^\pi \frac{ \ln ( 1 + a \cos x )
}{ \cos x } \mathrm{ d } x\)</span>.</p>
<p>对着上面那个<span class="math inline">\(\ln\)</span>做泰勒级数,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_0^\pi \frac{ \ln ( 1 + a \cos x ) }{ \cos x } \mathrm{ d } x
\\
= &amp; \int_0^\pi a + \sum_{ n = 1 }^\infty ( - 1 )^n \frac{ a^{ n + 1
} \cos^n x }{ n + 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>而回忆到<span class="math inline">\(\int_0^\pi \cos^m x \mathrm{ d }
x\)</span>在<span class="math inline">\(m\)</span>是奇数的时候当然为<span class="math inline">\(0\)</span>,偶数的时候转化为<span class="math inline">\(\sin x\)</span>,答案是<span class="math inline">\(\frac{ ( m - 1 ) ! ! }{ m ! ! } \pi\)</span>.</p>
<p>所以原式变成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^\pi a + \sum_{ n = 1 }^\infty ( - 1 )^n \frac{ a^{ n + 1 }
\cos^n x }{ n + 1 } \\
= &amp; \pi ( a + \sum_{ m = 1 }^\infty \frac{ ( 2 m - 1 ) ! ! }{ ( 2 m
) ! ! } \frac{ a^{ 2 m + 1 } }{ 2 m + 1 } ) \\
= &amp; \pi \arcsin a
\end{aligned}
\]</span></p>
<h6><span id="example6">Example6</span></h6>
<p>求<span class="math inline">\(S = \sum_{ n = 0 }^\infty \frac{ ( - 1
)^n ( n + 1 )^3 }{ n ! }\)</span>.</p>
<p>见到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n ( n + 1 )^3 }{ n ! } e^{ (
n + 1 ) x } \\
= &amp; \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ n ! } ( e^{ ( n + 1 )
x } ) &#39; &#39; &#39; \\

\end{aligned}\]</span>
<p>$$</p>
<p>取<span class="math inline">\(f ( x ) = \sum_{ n = 0 }^\infty \frac{
( - 1 )^n }{ n ! } e^{ ( n + 1 ) x }\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n }{ n ! } e^{ ( n
+ 1 ) x } \\
&amp; = e^x \sum_{ n = 0 }^\infty \frac{ ( - e^x )^n }{ n ! } \\
&amp; = e^{ x - e^x }
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; &amp; = ( 1 - e^x ) f \\
f &#39; &#39; &amp; = ( 1 - 3 e^x + e^{ 2 x } ) f \\
f &#39; &#39; &#39; &amp; = ( - 3 e^x + 2 e^{ 2 x } ) f + ( 1 - e^x ) (
1 - 3 e^x + e^{ 2 x } ) f \\
f &#39; &#39; &#39; ( 0 ) &amp; = - f ( 0 ) = - \frac{ 1 }{ e }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h6><span id="example7">Example7</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ \cos ( nx
) }{ n }\)</span>.</p>
<p>取<span class="math inline">\(t \in ( - 1 , 1 ]\)</span>,设:</p>
$$
<span class="math display">\[\begin{aligned}
f ( t ) &amp; = \sum_{ n = 1 }^\infty \frac{ \cos ( nx ) }{ n } t^n \\
f &#39; &amp; = \sum_{ n = 1 }^\infty \cos ( nx ) t^{ n - 1 } \\
&amp; = \Re \sum_{ n = 1 }^\infty t^{ n - 1 } e^{ inx } \\
&amp; = \Re \frac{ e^{ ix } }{ 1 - te^{ ix } } \\
&amp; = \Re \frac{ \cos x + i \sin x }{ 1 - t \cos x - it \sin x } \\
&amp; = \Re \frac{ ( \cos x + i \sin x ) ( 1 - t \cos x + it \sin x ) }{
( 1 - t \cos x )^2 + t^2 \sin^2 x } \\
&amp; = \frac{ \cos x ( 1 - t \cos x ) - t \sin^2 x }{ ( 1 - t \cos x
)^2 + t^2 \sin^2 x } \\
&amp; = \frac{ \cos x - t }{ 1 - 2 t \cos x + t^2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时应当有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( t ) &amp; = f ( 0 ) + \int_0^t f &#39; ( t ) \mathrm{ d } t \\
&amp; = - \frac{ 1 }{ 2 } \ln ( 1 - 2 t \cos x + t^2 )
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(f ( 1 ) = - \ln 2 - \ln | \sin \frac{ x
}{ 2 } |\)</span>,这就求出了原式.</p>
<h6><span id="example8">Example8</span></h6>
<p>考虑<span class="math inline">\(\zeta ( x ) = \sum_{ n = 1 }^\infty
\frac{ 1 }{ n^x }\)</span>,有定理说:</p>
<p><span class="math display">\[
\zeta ( x ) = \frac{ 1 }{ x - 1 } + \sum_{ n = 0 }^\infty \frac{ ( - 1
)^n \gamma_n }{ n ! } ( x - 1 )^n
\]</span></p>
<p>其中后半部分是整个复平面上的解析函数,并有:</p>
<p><span class="math display">\[
\gamma_n = \lim_{ m \to \infty } \left ( \sum_{ k = 1 }^m \frac{ ( \ln k
)^n }{ k } - \frac{ ( \ln m )^{ n + 1 } }{ n + 1 } \right )
\]</span></p>
<h6><span id="example9">Example9</span></h6>
<p>求<span class="math inline">\(S ( x ) = 1 + \sum_{ n = 1 }^\infty
\frac{ ( 2 n - 1 ) ! ! }{ ( 2 n ) ! ! } x^n\)</span>,其中<span class="math inline">\(| x | &lt; 1\)</span>.</p>
<p>容易见到其收敛半径是<span class="math inline">\(1\)</span>,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
S &#39; ( x ) &amp; = \frac{ 1 }{ 2 } + \sum_{ n = 1 }^\infty \frac{ ( 2
n + 1 ) ! ! }{ ( 2 n + 2 ) ! ! } ( n + 1 ) x^n \\
2 S &#39; ( x ) &amp; = 1 + \sum_{ n = 1 }^\infty \frac{ ( 2 n + 1 ) ! !
}{ ( 2 n ) ! ! } x^{ n } \\
2 xS &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{
( 2 n - 2 ) ! ! } x^n \\
2 xS &#39; ( x ) &amp; = \sum_{ n = 1 }^\infty \frac{ ( 2 n - 1 ) ! ! }{
( 2 n ) ! ! } 2 nx^n \\
2 S &#39; ( x ) - 2 xS &#39; ( x ) &amp; = S ( x ) \\
\frac{ \mathrm{ d } x }{ 2 ( 1 - x ) } &amp; = \frac{ \mathrm{ d } S ( x
) }{ S ( x ) } \\
- \frac{ 1 }{ 2 } \ln ( 1 - x ) &amp; = \ln S ( x ) \\
S ( x ) &amp; = \frac{ 1 }{ \sqrt{ 1 - x } }
\end{aligned}
\]</span></p>
<h6><span id="example10">Example10</span></h6>
<p>当<span class="math inline">\(| x | &lt; 1\)</span>,求<span class="math inline">\(S ( x ) = \sum_{ n = 0 }^\infty \frac{ ( - 1 )^n
x^n }{ 2 n + 1 }\)</span>.</p>
<p>容易见到收敛半径为<span class="math inline">\(1\)</span>,令<span class="math inline">\(x = t^2\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
S ( t^2 ) = \sum_{ n = 0 }^\infty ( - 1 )^n \frac{ 1 }{ t } \int_0^t u^{
2 n } \mathrm{ d } u \\
= \frac{ 1 }{ t } \int_0^t \sum_{ n = 0 }^\infty ( - 1 )^n u^{ 2 n }
\mathrm{ d } u \\
= \frac{ 1 }{ t } \int_0^t \frac{ \mathrm{ d } u }{ 1 + u^2 } \\
= \frac{ \arctan t }{ t } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以<span class="math inline">\(S ( x ) = \frac{ \arctan \sqrt{ x }
}{ \sqrt{ x } }\)</span>.</p>
<h6><span id="example11">Example11</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 2 }^\infty \frac{ ( - 1 )^n
}{ n^2 + n - 2 }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
S ( x ) = \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{ n^2 + n
- 2 } \\
= \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{ 3 } \left (
\frac{ 1 }{ n - 1 } - \frac{ 1 }{ n + 2 } \right ) \\
= \frac{ 1 }{ 3 } \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{ n - 1 } }{
n - 1 } - \frac{ 1 }{ 3 x^3 } \sum_{ n = 2 }^\infty \frac{ ( - 1 )^n x^{
n + 2 } }{ n + 2 } \\
= \frac{ 1 }{ 3 } \ln ( 1 + x ) - \frac{ 1 }{ 3 x^3 } \left ( - \ln ( 1
+ x ) + x - \frac{ x^2 }{ 2 } + \frac{ x^3 }{ 3 } \right )
\end{aligned}
\]</span></p>
<p>而注意到带入<span class="math inline">\(x = 1\)</span>的时候<span class="math inline">\(S ( x )\)</span>收敛,这就搞定了,带入<span class="math inline">\(x = 1\)</span>就行.</p>
<h6><span id="example12">Example12</span></h6>
<p>求<span class="math inline">\(\sum_{ n = 1 }^\infty \frac{ n }{ ( n +
1 ) ! }\)</span>.</p>
<p>设<span class="math inline">\(S ( x ) = \sum_{ n = 0 }^\infty \frac{
( n + 1 ) x^n }{ ( n + 2 ) ! }\)</span>,显然收敛,直接逐项积分.</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^x S ( t ) \mathrm{ d } t &amp; = \sum_{ n = 0 }^\infty \frac{ x^{
n + 1 } }{ ( n + 2 ) ! } \\
&amp; = \sum_{ n = 1 }^\infty \frac{ x^{ n } }{ ( n + 1 ) ! } \\
x ( \int_0^x S ( t ) \mathrm{ d } t + 1 ) &amp; = e^x - 1 \\
S ( x ) &amp; = \left ( \frac{ e^x - 1 }{ x } \right ) &#39; = \frac{
xe^x - e^x + 1 }{ x^2 }
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h6><span id="example13">Example13</span></h6>
<p>求<span class="math inline">\(\int_0^\infty \frac{ x \mathrm{ d } x
}{ e^{ 2 \pi x } - 1 }\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^\infty \frac{ x \mathrm{ d } x }{ e^{ 2 \pi x } - 1 } \\
= \int_0^\infty \frac{ xe^{ - 2 \pi x } \mathrm{ d } x }{ 1 - e^{ - 2
\pi x } } \\
= \int_0^{ \infty } xe^{ - 2 \pi x } \sum_{ n = 0 }^\infty e^{ - 2 \pi n
x } \mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \int_0^{ + \infty } xe^{ - 2 \pi ( n + 1 ) x }
\mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ - 2 \pi ( n + 1 ) } \int_0^{ +
\infty } x \mathrm{ d } e^{ - 2 \pi ( n + 1 ) x } \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ 2 \pi ( n + 1 ) } \int_0^{ + \infty
} e^{ - 2 \pi ( n + 1 ) x } \mathrm{ d } x \\
= \sum_{ n = 0 }^\infty \frac{ 1 }{ 4 \pi^2 ( n + 1 )^2 } \\
= \frac{ 1 }{ 24 }
\end{aligned}
\]</span></p>
<p>其中中间的交换积分号和求和号是源于所有的部分和都可以小于等于<span class="math inline">\(g ( x )\)</span>,并且<span class="math inline">\(\int_0^{ \infty } g\)</span>收敛.</p>
<h6><span id="example14">Example14</span></h6>
<p>求<span class="math inline">\(\int_0^1 \frac{ \ln ( 1 + x ) }{ x }
\mathrm{ d } x\)</span>.</p>
<p>直接展开对吧,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_0^1 \frac{ \ln ( 1 + x ) }{ x } \mathrm{ d } x \\
= &amp; \int_0^1 \sum_{ n = 1 }^\infty \frac{ ( - 1 )^{ n - 1 } x^{ n -
1 } }{ n } \\
= &amp; \sum_{ n = 1 }^\infty \int_0^1 \frac{ ( - 1 )^{ n - 1 } x^{ n -
1 } }{ n } \mathrm{ d } x \\
= &amp; \sum_{ n = 1 }^\infty \frac{ ( - 1 )^{ n - 1 } }{ n^2 } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ ( 2 n - 1 )^2 } - \sum_{ n = 1
}^\infty \frac{ 1 }{ ( 2 n )^2 } \\
= &amp; \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } - 2 \sum_{ n = 1
}^\infty \frac{ 1 }{ ( 2 n )^2 } \\
= &amp; \frac{ 1 }{ 2 } \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } \\
= &amp; \frac{ \pi^2 }{ 12 }
\end{aligned}
\]</span></p>
<h6><span id="example15">Example15</span></h6>
<p>设<span class="math inline">\(I\)</span>是开区间,<span class="math inline">\(f \in C^\infty ( I )\)</span>,求证<span class="math inline">\(f \in C^\omega ( I )\)</span>当且仅当<span class="math inline">\(\forall x_0 \in I , \exists M , B , r &gt;
0\)</span>,使得<span class="math inline">\(\forall | x - x_0 | &lt; r ,
| f^{ ( n ) } ( x ) | \leq MB^n n
!\)</span>.就是说对于区间内任何一个点,在它的小邻域处,任意阶导数都可以被和<span class="math inline">\(n\)</span>有关的一个速率控制住.</p>
<p>充分性比较简单,考虑取<span class="math inline">\(S ( x ) = \sum
\frac{ f^{ ( n ) } ( x_0 ) }{ n ! } ( x - x_0 )^n\)</span>对其取<span class="math inline">\(| \sqrt[n]{ \frac{ f^{ ( n ) } ( x_0 ) }{ n ! } }
| \leq \sqrt[n]{ MB^n } = \sqrt[n]{ M } B &lt; +
\infty\)</span>,所以总之收敛半径不为<span class="math inline">\(0\)</span>.那就总能取一个足够小的<span class="math inline">\(r &lt; \frac{ 1 }{ B
}\)</span>.此时用泰勒展开的拉格朗日余项:</p>
<p><span class="math display">\[
\begin{aligned}
\left | f ( x ) - \sum_{ k = 0 }^n \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } (
x - x_0 )^k \right | &amp; = \left | \frac{ f^{ ( n + 1 ) } ( \xi ) }{ (
n + 1 ) ! } ( x - x_0 )^{ n + 1 } \right | \\
&amp; \leq | B^{ n + 1 } ( x - x_0 )^{ n + 1 } M | \\
&amp; \leq | ( Br )^{ n + 1 } M | \to 0
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>接下来是必要性.考虑<span class="math inline">\(\varlimsup_{ n \to
\infty } \sqrt[n]{ | \frac{ f^{ ( n ) } ( x_0 ) | }{ n ! } } = \frac{ 1
}{ R } &gt; 0\)</span>,那就可以取<span class="math inline">\(0 &lt; r
&lt; M &lt; R\)</span>,存在一个<span class="math inline">\(N\)</span>,使得<span class="math inline">\(\forall
n \geq N\)</span>都有<span class="math inline">\(| f^{ ( n ) } ( x_0 ) |
\leq n ! ( \frac{ 1 }{ M } )^n\)</span>.</p>
<p>接下来想要把这个性质挪到<span class="math inline">\(x_0\)</span>周围小邻域上对吧.于此我们考虑先逼近后逐项求导:</p>
<p><span class="math display">\[
\begin{aligned}
| f^{ ( n ) } ( x ) | &amp; = | \sum_{ k = 0 }^\infty \frac{ f^{ ( n + k
) } ( x_0 ) }{ k ! } ( x - x_0 )^k | \\
&amp; \leq \sum_{ k = 0 }^\infty \frac{ | f^{ ( n + k ) } ( x_0 ) | }{ k
! } | x - x_0 |^k \\
&amp; \leq \sum_{ k = 0 }^\infty \frac{ ( n + k ) ! }{ k ! M^{ n + k } }
r^k \\
&amp; = \frac{ n ! }{ M^n } \sum_{ k = 0 }^\infty \frac{ ( n + k )^{
\underline{ k } } }{ k ! } ( \frac{ r }{ M } )^k \\
&amp; = \frac{ n ! }{ M^n } \sum_{ k = 0 }^\infty \frac{ ( - n - 1 )^{
\underline{ k } } }{ k ! } ( \frac{ - r }{ M } )^k \\
&amp; = \frac{ n ! }{ M^n } ( 1 - \frac{ r }{ M } )^{ - n - 1 } \\
&amp; = Mn ! ( M - r )^{ - ( n + 1 ) }
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h6><span id="example16">Example16</span></h6>
<p>若非常数<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>的每一点都解析,则其零点集在<span class="math inline">\(( a , b )\)</span>内无聚点.</p>
<p>考虑如果一个点<span class="math inline">\(c \in ( a , b
)\)</span>是<span class="math inline">\(f\)</span>的聚点的话,那么<span class="math inline">\(c\)</span>一定是<span class="math inline">\(f\)</span>的任意阶导数的聚点.由于任意阶导数都是连续的,因此<span class="math inline">\(c\)</span>处的任意阶导数都是<span class="math inline">\(0\)</span>.又因为<span class="math inline">\(f\)</span>解析,所以<span class="math inline">\(c\)</span>周围的一个小邻域必然全部为<span class="math inline">\(0\)</span>.既如此取最长的小邻域为<span class="math inline">\(( \alpha , \beta )\)</span>,下面我们证明<span class="math inline">\(( \alpha , \beta ) = ( a , b
)\)</span>,不妨假设<span class="math inline">\(a \ne
\alpha\)</span>,由于连续性得知<span class="math inline">\(f\)</span>在<span class="math inline">\([ \alpha ,
\beta )\)</span>上取值为<span class="math inline">\(0\)</span>,然而这意味着<span class="math inline">\(\alpha\)</span>必然也是零点集的聚点,因此它还可以继续往左延申一个小邻域,这就与<span class="math inline">\(a\)</span>是最靠左的矛盾了.</p>
<p>不过这个做法不能推广到复平面上,原因是平面上的介值定理难搞一点啊.</p>
<p>提供另一种证明方法,考虑<span class="math inline">\(f\)</span>在<span class="math inline">\(( a , b )\)</span>上的零点的聚点<span class="math inline">\(x_0\)</span>,如果<span class="math inline">\(x_0\)</span>的任意阶导数都是<span class="math inline">\(0\)</span>的话,那还是按照上面一样往外面扩就行了对吧.反之,设<span class="math inline">\(f ( x_0 ) = f^{ ( 1 ) } ( x_0 ) = \cdots = f^{ ( N
- 1 ) } ( x_0 ) = 0 , f^{ ( N ) } ( x_0 ) \ne 0\)</span>,此时考虑<span class="math inline">\(f ( x ) = ( x - x_0 )^{ N + 1 } \sum_{ n = 0
}^\infty \frac{ f^{ ( N + n + 1 ) } }{ ( N + n + 1 ) ! } ( x - x_0
)^n\)</span>,不妨设<span class="math inline">\(g ( x ) = \sum_{ n = 0
}^\infty \frac{ f^{ ( N + n + 1 ) } }{ ( N + n + 1 ) ! } ( x - x_0
)^n\)</span>,容易发现<span class="math inline">\(g ( x_0 ) \ne
0\)</span>,既然如此,<span class="math inline">\(g\)</span>肯定在<span class="math inline">\(x_0\)</span>的一个小邻域(要与解析的那个邻域取交)上非<span class="math inline">\(0\)</span>,设为<span class="math inline">\(( x_0 -
\delta , x_0 + \delta )\)</span>上非零,可这样<span class="math inline">\(f ( x )\)</span>在<span class="math inline">\((
x_0 - \delta , x_0 ) \cup ( x_0 , x_0 + \delta
)\)</span>上必然非零,这与<span class="math inline">\(x_0\)</span>是零点聚点矛盾了.</p>
<h5><span id="多项式逼近">多项式逼近</span></h5>
<p>如果对于函数<span class="math inline">\(f ( x ) : [ a , b ] \to
\mathbb{ R }\)</span>,存在一个多项式列可以一致收敛到<span class="math inline">\(f ( x
)\)</span>,则称其可以被多项式<strong>一致逼近</strong>.容易见到一个必要条件是<span class="math inline">\(f ( x ) \in C [ a , b ]\)</span>.</p>
<p>事实上我们有<strong>维尔斯特拉斯定理</strong>:有界闭区间上的连续函数可由多项式一致连续逼近.首先不妨假设<span class="math inline">\([ a , b ] = [ 0 , 1
]\)</span>.下面给出两种证明:</p>
<p>其一是构造性证明,我们有<strong>Bernstein多项式</strong>:</p>
<p><span class="math display">\[
B_n ( f ) = \sum_{ p = 0 }^n \binom{ n }{ p } f ( \frac{ p }{ n } ) x^p
( 1 - x )^{ n - p }
\]</span></p>
<p>这个多项式有很多性质,首先随便放缩一下就知道这个多项式在<span class="math inline">\([ 0 , 1 ]\)</span>上有界,更具体地有<span class="math inline">\(\min f \leq B_n \leq \max f\)</span>,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
B_n ( f ) &amp; \leq \sum_p \binom{ n }{ p } f ( \frac{ p }{ n } ) x^p (
1 - x )^{ n - p } \\
&amp; \leq ( \max f ) \sum_p \binom{ n }{ p } x^p ( 1 - x )^{ n - p } \\
&amp; = \max f
\end{aligned}
\]</span></p>
<p>另一边同理.</p>
<p>其次有<span class="math inline">\(\deg ( B_n ) \leq
n\)</span>.以及这个甚至是<span class="math inline">\(f\)</span>的线性映射,或言<span class="math inline">\(B_n ( \alpha f + \beta g ) = \alpha B_n ( f ) +
\beta B_n ( g )\)</span>.</p>
<p>取<span class="math inline">\(r_p ( x ) = \binom{ n }{ p } x^p ( 1 -
x )^{ n - p }\)</span>,注意到:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_p r_p ( x ) =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p pr_p ( x ) =
nx\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p p ( p - 1 ) r_p ( x ) = n ( n
- 1 ) x^2\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_p p^2 r_p ( x ) = n ( n - 1 )
x^2 + nx\)</span>.</p></li>
<li><p><span class="math inline">\(\sum_{ p = 0 }^n ( p - nx )^2 r_p ( x
) \leq \frac{ n }{ 4 }\)</span>.</p></li>
</ol>
<p>前四条类似,以(3)为例,证明的话考虑对<span class="math inline">\(( x +
y )^n = \sum_p \binom{ n }{ p } x^p y^{ n - p }\)</span>两边对<span class="math inline">\(x\)</span>求两次导数:</p>
<p><span class="math display">\[
n ( n - 1 ) x^2 ( x + y )^{ n - 2 } = \sum_p^n \binom{ n }{ p } p ( p -
1 ) x^p y^{ n - p }
\]</span></p>
<p>带入<span class="math inline">\(y = 1 - x\)</span>即可.</p>
<p>(5)的话也只需要计算,观察到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ p = 0 }^n ( p - nx )^2 r_p ( x ) \\
= &amp; \sum_p p^2 r_p - 2 nx \sum_p pr_p + n^2 x^2 \sum r_p \\
= &amp; n ( n - 1 ) x^2 + nx - 2 n^2 x^2 + n^2 x^2 \\
= &amp; nx ( 1 - x ) \leq \frac{ n }{ 4 }
\end{aligned}
\]</span></p>
<p>我们见到:</p>
$$
<span class="math display">\[\begin{aligned}
| B_n ( f ) - f | &amp; = \left | \sum_{ p = 0 }^n \binom{ n }{ p } f (
\frac{ p }{ n } ) x^p ( 1 - x )^{ n - p } - \sum_{ p = 0 }^n \binom{ n
}{ p } f ( x ) x^p ( 1 - x )^{ n - p } \right | \\
&amp; \leq \sum_{ p = 0 }^n \binom{ n }{ p } | f ( \frac{ p }{ n } ) - f
( x ) | x^p ( 1 - x )^{ n - p } \\

\end{aligned}\]</span>
<p>$$</p>
<p>既然<span class="math inline">\(f ( x
)\)</span>闭区间上连续则有一致连续,<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,取<span class="math inline">\(\delta &gt;
0\)</span>,使得只要<span class="math inline">\(| x - x &#39; | &lt;
\delta , | f ( x ) - f ( x &#39; ) | &lt; \frac{ \epsilon }{ 2
}\)</span>,那有:</p>
<p><span class="math display">\[
\begin{aligned}
| B_n ( f ) - f | &amp; \leq \sum_{ p = 0 }^n \binom{ n }{ p } | f (
\frac{ p }{ n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } \\
&amp; = \sum_{ | \frac{ p }{ n } - x | &lt; \delta }^n \binom{ n }{ p }
| f ( \frac{ p }{ n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } + \sum_{ |
\frac{ p }{ n } - x | \geq \delta }^n \binom{ n }{ p } | f ( \frac{ p }{
n } ) - f ( x ) | x^p ( 1 - x )^{ n - p } \\
&amp; \leq \frac{ \epsilon }{ 2 } + \frac{ 2 \max | f | }{ n^2 \delta^2
} \sum_{ p = 0 }^n ( p - nx )^2 r_p ( x ) \\
&amp; \leq \frac{ \epsilon }{ 2 } + \frac{ \max | f | }{ 2 n \delta^2 }
\end{aligned}
\]</span></p>
<p>倒数第二步是由于当<span class="math inline">\(| \frac{ p }{ n } - x |
\geq \delta\)</span>,所以<span class="math inline">\(\frac{ ( p - nx )^2
}{ n^2 \delta^2 } \geq 1\)</span>.</p>
<p>最后一步是因为当<span class="math inline">\(\epsilon\)</span>确定的时候,<span class="math inline">\(\delta\)</span>就已经确定了,然而<span class="math inline">\(n\)</span>可以足够大,这就控制住了.</p>
<p>再给另一个存在性证明.回忆到<span class="math inline">\([ a , b
]\)</span>上的连续函数组成的集合<span class="math inline">\(C [ a , b
]\)</span>是一个完备线性空间.称<span class="math inline">\(A \subseteq C
[ a , b ]\)</span>是一个<strong>代数</strong>当且仅当<span class="math inline">\(\forall f , g \in A\)</span>,<span class="math inline">\(\forall c \in \mathbb{ R }\)</span>,<span class="math inline">\(f + g , fg , cf \in A\)</span>.容易见到如果<span class="math inline">\(P\)</span>是一个有限项多项式,<span class="math inline">\(f \in A\)</span>,则<span class="math inline">\(P (
f ) \in A\)</span>.</p>
<p>在此基础上定义<span class="math inline">\(\bar{ A }\)</span>为<span class="math inline">\(A\)</span>的<strong>闭包</strong>,定义为:</p>
<p><span class="math display">\[
\bar{ A } = \{ f \in C [ a , b ] | \exists \{ f_n \} \in A , f_n
\rightrightarrows f \}
\]</span></p>
<p>容易见到<span class="math inline">\(A \subseteq \bar{ A
}\)</span>.而且容易见到<span class="math inline">\(\bar{ A
}\)</span>肯定也是一个代数.而见到<span class="math inline">\(\overline{
( \bar{ A } ) } = \bar{ A
}\)</span>,原因是柯西列导出的已经是闭的了,无法再往外拓展.</p>
<p>回忆到绝对值函数可以由多项式函数逼近,所以如果<span class="math inline">\(f \in \bar{ A }\)</span>,则<span class="math inline">\(| f | \in \bar{ A }\)</span>.更进一步,如果<span class="math inline">\(f , g \in \bar{ A }\)</span>,由于<span class="math inline">\(\max ( f , g ) = \frac{ f + g }{ 2 } + \frac{ | f
- g | }{ 2 }\)</span>,所以<span class="math inline">\(\max ( f , g ) \in
\bar{ A }\)</span>,同理<span class="math inline">\(\min ( f , g ) \in
\bar{ A }\)</span>.</p>
<p>我们有一个定理说:设<span class="math inline">\(A \subseteq C [ a , b
]\)</span>是一个代数,并且<span class="math inline">\(f ( x ) = c \in
A\)</span>.并且<span class="math inline">\(\forall x , y \in [ a , b ] ,
x \ne y , \exists f \in A , f ( x ) \ne f ( y )\)</span>则<span class="math inline">\(\bar{ A } = C [ a , b
]\)</span>.容易见到这个定理强于维尔斯特拉斯定理.这个定理叫<strong>Stone-Weierstrass定理</strong>.</p>
<p>下面我们来证明这个结论.</p>
<p>先搞一个引理:<span class="math inline">\(\forall x_1 , x_2 \in [ a ,
b ] , x_1 \ne x_2 , \forall \alpha , \beta \in \mathbb{ R
}\)</span>,则<span class="math inline">\(\exists h \in A , h ( x_1 ) =
\alpha , h ( x_2 ) = \beta\)</span>.</p>
<p>证明的话,考虑由已知<span class="math inline">\(\exists \varphi \in A
, \varphi ( x_1 ) \ne \varphi ( x_2
)\)</span>.此时把这个函数给挪一下,取<span class="math inline">\(h ( x )
= \alpha + ( \beta - \alpha ) \frac{ \varphi ( x ) - \varphi ( x_1 ) }{
\varphi ( x_2 ) - \varphi ( x_1 )
}\)</span>.(其实这个应该是双传递性,但是我目前没看出如何用双传递性来解释证明过程.)</p>
<p>接下来考虑证明原定理,来证明<span class="math inline">\(\forall f \in
C [ a , b ] , \forall n , \exists g_n \in \bar{ A } , | f ( x ) - g_n (
x ) | &lt; \frac{ 1 }{ n }\)</span>,由于我们刚才的引理,<span class="math inline">\(\forall x , y \in [ a , b ] , \exists h_{ x , y }
( z ) \in A , h_{ x , y } ( x ) = f ( x ) , h_{ x , y } ( y ) = f ( y
)\)</span>.这个函数由<span class="math inline">\(x ,
y\)</span>所确定.</p>
<p>固定<span class="math inline">\(x\)</span>不动,对<span class="math inline">\(\forall y \in [ a , b ]\)</span>,<span class="math inline">\(\exists \delta = \delta ( y
)\)</span>,由于一致连续性,当<span class="math inline">\(z \in I_y = ( y
- \delta , y + \delta )\)</span>的时候,<span class="math inline">\(h_{ x
, y } ( z ) &lt; f ( z ) + \frac{ 1 }{ n }\)</span>.而这里的<span class="math inline">\(I_y\)</span>构成了一个开覆盖(边界上可能需要挪一下,但反正能做到),用有限覆盖定理拿到有限个区间<span class="math inline">\(I_{ y_1 , } , \cdots , I_{ y_m
}\)</span>覆盖了<span class="math inline">\([ a , b
]\)</span>.此时取<span class="math inline">\(h_x ( z ) = \min \{ h_{ x ,
y_1 } , \cdots , h_{ x , y_m } \}\)</span>,见到<span class="math inline">\(h_x ( z ) &lt; f ( z ) + \frac{ 1 }{ n } , \forall
z \in [ a , b ]\)</span>.而且<span class="math inline">\(h_x ( x ) = f (
x )\)</span>.</p>
<p>既然<span class="math inline">\(h_x ( x ) = f ( x
)\)</span>,考虑<span class="math inline">\(\exists \delta , I_x = ( x -
\delta , x + \delta )\)</span>使得<span class="math inline">\(h_x ( z )
&gt; f ( z ) - \frac{ 1 }{ n } , \forall z \in
I_x\)</span>.对此再做有限覆盖得到<span class="math inline">\(h_{ x_1 } ,
\cdots , h_{ x_l }\)</span>,取<span class="math inline">\(g_n = \max \{
h_{ x_1 } , \cdots , h_{ x_l } \}\)</span>.显然:</p>
<p><span class="math display">\[
f ( z ) - \frac{ 1 }{ n } &lt; g_n ( z ) &lt; f ( z ) + \frac{ 1 }{ n }
\]</span></p>
<p>搞定了.</p>
<p>那么,这个多项式能不能再来点限制呢?比如说我不许在多项式里出现<span class="math inline">\(x^2\)</span>项可以吗?也可以.考虑<span class="math inline">\(f \in C [ a , b ]\)</span>,则<span class="math inline">\(f ( x^{ \frac{ 1 }{ 3 } } ) \in C [ a^{ \frac{ 1
}{ 3 } } , b^{ \frac{ 1 }{ 3 } } ]\)</span>,所以存在一个多项式<span class="math inline">\(P ( x ) \rightrightarrows f ( x^{ \frac{ 1 }{ 3 }
} )\)</span>,意味着<span class="math inline">\(P ( x^3 )
\rightrightarrows f ( x ) , x \in [ a , b ]\)</span>.而<span class="math inline">\(P ( x^3 )\)</span>当然没有<span class="math inline">\(x^2\)</span>项.</p>
<p>也就是说这些多项式很多都是浪费的.那么有没有一个非常厉害的结论能告诉我什么样的多项式可以呢?考虑在<span class="math inline">\([ 0 , 1 ]\)</span>上,<span class="math inline">\(\mathrm{ Span } \{ 1 , x^{ \lambda_1 } , \cdots
\}\)</span>张成的多项式,其中<span class="math inline">\(0 &lt; \lambda_1
&lt; \lambda_2 &lt; \cdots\)</span>,其中<span class="math inline">\(\lambda_n \to \infty\)</span>.注意这里不要求<span class="math inline">\(\lambda_i\)</span>是整数,如果其闭包能张成<span class="math inline">\(C [ 0 , 1 ]\)</span>,当且仅当<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i } = +
\infty\)</span>.这被称为<strong>Muntz定理</strong>,(其一个更强的推广是去掉<span class="math inline">\(\lambda_n \to
\infty\)</span>的结论,取而代之的是需要满足<span class="math inline">\(\sum \frac{ \lambda_i }{ 1 + \lambda_i^2 } = +
\infty\)</span>)</p>
<p>这个定理的必要性我们目前难以证明,先证明其充分性.</p>
<p>考虑<span class="math inline">\(\forall m \in \mathbb{ N }_+
\setminus \{ \lambda_i \}\)</span>,都可以定义一个函数列,其中<span class="math inline">\(Q_0 ( x ) = x^m , Q_n ( x ) = ( \lambda_n - m )
x^{ \lambda_n } \int_x^1 Q_{ n - 1 } ( t ) t^{ - 1 - \lambda_n }
\mathrm{ d } t\)</span>.我们先证明<span class="math inline">\(Q_n\)</span>一定长成<span class="math inline">\(x^m - \sum_{ i = 1 }^n a_{ n , i } x^{ \lambda_i
}\)</span>的形式.</p>
<p>数学归纳证明此结论,设<span class="math inline">\(Q_n = x^m - \sum_{ i
= 1 }^n a_{ n , i } x^{ \lambda_i }\)</span>,来看<span class="math inline">\(Q_{ n + 1 }\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
Q_{ n + 1 } ( x ) &amp; = ( \lambda_{ n + 1 } - m ) x^{ \lambda_{ n + 1
} } \int_x^1 Q_{ n } ( t ) t^{ - 1 - \lambda_{ n + 1 } } \mathrm{ d } t
\\
&amp; = ( \lambda_{ n + 1 } - m ) x^{ \lambda_{ n + 1 } } \int_x^1 ( t^m
- \sum_{ i = 1 }^n a_{ n , i } t^{ \lambda_i } ) t^{ - 1 - \lambda_{ n +
1 } } \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>后面那部分直接积出来就是了,然后前面有一个<span class="math inline">\(\lambda_{ n + 1 }\)</span>,这样就搞定了.</p>
<p>下面定义一个函数的模长<span class="math inline">\(\Vert Q \Vert =
\max_{ [ 0 , 1 ] } | Q ( x ) |\)</span>,此时:</p>
<p><span class="math display">\[
\begin{aligned}
| Q_n ( x ) | &amp; \leq | \lambda_n - m | x^{ \lambda_n } \Vert Q_{ n -
1 } \Vert \int_x^1 t^{ - 1 - \lambda_n } \mathrm{ d } t \\
&amp; = | \lambda_n - m | x^{ \lambda_n } \cdot \Vert Q_{ n - 1 } \Vert
\frac{ x^{ - \lambda_n } - 1 }{ \lambda_n } \\
&amp; = | 1 - \frac{ m }{ \lambda_n } | \cdot \Vert Q_{ n - 1 } \Vert (
1 - x^{ \lambda_n } ) \\
&amp; \leq | 1 - \frac{ m }{ \lambda_n } | \cdot \Vert Q_{ n - 1 } \Vert
\\
&amp; \leq \prod_{ i = 1 }^n | 1 - \frac{ m }{ \lambda_i } |
\end{aligned}
\]</span></p>
<p>然而回忆到<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i
}\)</span>发散.所以后面那个连乘积必然发散,但是容易见到<span class="math inline">\(m\)</span>取死后,其从<span class="math inline">\(\lambda_i &gt;
m\)</span>的时候就是单调递减的,那又发散必然知道其趋近于<span class="math inline">\(0\)</span>.所以<span class="math inline">\(\lim
\Vert Q_n \Vert = 0\)</span>.那又回忆到<span class="math inline">\(Q_n =
x^m - \sum_{ i = 1 }^n a_{ n , i } x^{ \lambda_i
}\)</span>,这已经说明<span class="math inline">\(x^m\)</span>可以被<span class="math inline">\(\{ x^{ \lambda_i }
\}\)</span>一致逼近,原命题充分性搞定.</p>
<p>现在来看固定在<span class="math inline">\(\lambda_i \in \mathbb{ N
}_+\)</span>的情形,能否给出一个充要条件呢?我们下面证明对于互异的<span class="math inline">\(\{ \lambda_i \} \in \mathbb{ N }_+\)</span>,<span class="math inline">\(C [ a , b ] = \overline{ \mathrm{ span } } \{ x^{
\lambda_i } , 1 \}\)</span>的充要条件是:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(0 \notin ( a , b
)\)</span>,当<span class="math inline">\(\sum \frac{ 1 }{ \lambda_i } =
+ \infty\)</span>.</p></li>
<li><p>如果<span class="math inline">\(a &lt; 0 &lt;
b\)</span>,要求<span class="math inline">\(\sum_{ \lambda_i \in \mathrm{
even } } \frac{ 1 }{ \lambda_i } = + \infty , \sum_{ \lambda_i \in
\mathrm{ odd } } \frac{ 1 }{ \lambda_i } = + \infty\)</span>.</p></li>
</ol>
<p>先证这个命题的充分性,对于<span class="math inline">\(0 \notin ( a , b
)\)</span>,不妨设<span class="math inline">\(0 \leq a &lt; b =
1\)</span>,容易发现此时的确满足<span class="math inline">\(\lim
\lambda_n = + \infty\)</span>而且<span class="math inline">\(\sum_i
\frac{ 1 }{ \lambda_i } = + \infty\)</span>,这就搞定了.</p>
<p>对于<span class="math inline">\(a &lt; 0 &lt;
b\)</span>,我们只要证明在<span class="math inline">\(C [ - 1 , 1
]\)</span>上的函数都可以被一致逼近即可对吧.考虑<span class="math inline">\(g_1 ( x ) = \frac{ f ( x ) + f ( - x ) }{ 2
}\)</span>是其偶函数部分,自然可以被偶次的部分逼近(原因是只需要逼近<span class="math inline">\([ 0 , 1 ]\)</span>上就可以延拓).反之亦然同理,<span class="math inline">\(g_2 ( x ) = \frac{ f ( x ) - f ( - x ) }{ 2
}\)</span>也可以被奇数次的部分逼近并且延拓,这也就搞定.</p>
<p>回忆到如果一个函数如果在一个无穷区间上可以被有限次多项式一致逼近,用柯西准则做那个函数列就可以证明这个函数一定是一个多项式.下面我们来推广这个结论.</p>
<p>设<span class="math inline">\(V\)</span>是一个内积空间,其中<span class="math inline">\(g , f_1 , \cdots , f_n \in V\)</span>是其中的<span class="math inline">\(n\)</span>个向量,设<span class="math inline">\(E =
\mathrm{ Span } \{ f_1 , \cdots , f_n \}\)</span>,回忆到<span class="math inline">\(g\)</span>到<span class="math inline">\(E\)</span>的距离定义为:</p>
<p><span class="math display">\[
d = \min_{ p \in E } \Vert g - p \Vert = \sqrt{ \cfrac{ G ( g , f_1 ,
\cdots , f_n ) }{ G ( f_1 , \cdots , f_n ) } }
\]</span></p>
<p>其中<span class="math inline">\(G ( f_1 , \cdots , f_n ) = \det | (
f_i | f_j ) |\)</span>.</p>
<p>而考虑取两列数列<span class="math inline">\(\{ \alpha_i \} , \{
\beta_j \}\)</span>,回忆到李文威考试题给出过:</p>
<p><span class="math display">\[
\det ( \frac{ 1 }{ \alpha_i + \beta_j } ) = \cfrac{ \prod_{ 1 \leq i
&lt; j \leq n } ( \alpha_j - \alpha_i ) ( \beta_j - \beta_i ) }{ \prod_{
1 \leq i , j \leq n } ( \alpha_i + \beta_j ) }
\]</span></p>
<p>又回忆到<span class="math inline">\(C [ 0 , 1
]\)</span>也是一个内积空间,可以定义<span class="math inline">\(( f | g )
= \int_0^1 fg \mathrm{ d } x\)</span>.容易见到<span class="math inline">\(( x^a | x^b ) = \frac{ 1 }{ a + b + 1
}\)</span>.现在我们就可以用上面的行列式硬算了.考虑取<span class="math inline">\(E = \mathrm{ span } \{ x^{ \lambda_1 } , \cdots ,
x^{ \lambda_n } \}\)</span>,取<span class="math inline">\(d = ( x^{
\lambda } , E )\)</span>,容易见到:</p>
<p><span class="math display">\[
d ( x^\lambda , E ) = \frac{ 1 }{ \sqrt{ 2 \lambda + 1 } } \prod_{ i = 1
}^n \left | \frac{ \lambda - \lambda_i }{ \lambda + \lambda_i + 1 }
\right |
\]</span></p>
<p>下面我们引进一个引理:</p>
<p>对于数列<span class="math inline">\(\{ \lambda_i \} &gt;
0\)</span>且单增,如果<span class="math inline">\(c = \inf_{ i \geq 1 }
\{ \lambda_{ i + 1 } - \lambda_i \} &gt; 0\)</span>,如果<span class="math inline">\(\sum_{ i = 1 }^\infty \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>,则<span class="math inline">\(\lim_{ m \to \infty }
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 , i \ne m }^\infty \ln \left |
\frac{ \lambda_i + \lambda_m }{ \lambda_i - \lambda_m } \right | =
0\)</span>.</p>
<p>这个定理的详细证明较为麻烦,而且与主线无关,将在下述Example3处讲解.</p>
<p>考虑取<span class="math inline">\(P ( x ) \in \mathrm{ Span }_{ i \ne
m } \{ x^{ \lambda_i } \}\)</span>,由于子空间只有有限项非零,所以<span class="math inline">\(\exists n\)</span>使得<span class="math inline">\(P ( x ) \in E = \mathrm{ Span }_{ i \ne m , i \leq
n } \{ x^{ \lambda_i } \}\)</span>,此时观察到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; d ( x^{ \lambda_m } , P ( x ) ) \\
\geq &amp; d ( x^\lambda_m , E ) \\
= &amp; \frac{ 1 }{ \sqrt{ 2 \lambda_m + 1 } } \prod_{ i = 1 , i \ne m
}^n \left | \frac{ \lambda_m - \lambda_i }{ \lambda_m + \lambda_i + 1 }
\right | \\
\geq &amp; \frac{ 1 }{ \sqrt{ 2 \lambda_m + 1 } } \prod_{ i = 1 , i \ne
m }^{ \infty } \left | \frac{ \lambda_m - \lambda_i }{ \lambda_m +
\lambda_i + 1 } \right | \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上述引理,我们知道最后那一项取<span class="math inline">\(\ln\)</span>后是一个<span class="math inline">\(o
( \lambda_m )\)</span>的东西,不妨将后面那一项记作<span class="math inline">\(e^{ - l_m \lambda_m }\)</span>,其中<span class="math inline">\(l_m &gt; 0 , \lim_{ m \to \infty } l_m =
0\)</span>.</p>
<p>为了简化说明引进<span class="math inline">\(\lambda_0 =
0\)</span>,</p>
<p>再来一个引理:对<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,<span class="math inline">\(\exists C_\epsilon &gt;
0\)</span>,满足<span class="math inline">\(\forall P ( x ) \in \mathrm{
Span }_{ i \geq 0 } \{ x^{ \lambda_i } \} , \lambda_0 =
0\)</span>,不妨设<span class="math inline">\(P ( x ) = \sum_{ i = 0 }^n
a_i x^{ \lambda_i }\)</span>,我们有<span class="math inline">\(| a_m |
\leq C_\epsilon ( 1 + \epsilon )^{ \lambda_m } \Vert P
\Vert\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ P ( x ) }{ a_m } &amp; = x^{ \lambda_i } + \sum_{ i \leq n , i
\ne m }^n \frac{ a_i }{ a_m } x^{ \lambda_m } \\
\frac{ \Vert P ( x ) \Vert }{ | a_m | } &amp; \geq d ( x^{ \lambda_m } ,
E ) \geq e^{ - l_m \lambda_m } \\
| a_m | &amp; \leq e^{ l_m \lambda_m } \Vert P ( x ) \Vert
\end{aligned}
\]</span></p>
<p>而当<span class="math inline">\(m\)</span>充分大的时候,当然有<span class="math inline">\(e^{ l_m } \leq 1 +
\epsilon\)</span>,这就证毕了.</p>
<p>万事俱备,下面我们来证明必要性:办法是使用反证法,假设<span class="math inline">\(f \in C [ 0 , 1 ]\)</span>,当<span class="math inline">\(\lambda_0 = 0 , \sum_{ i = 1 }^\infty \frac{ 1 }{
\lambda_i } &lt; \infty\)</span>时,并且<span class="math inline">\(P_n (
x ) = \sum_{ i = 0 }^n a_{ i , n } x^{ \lambda_i } \rightrightarrows f (
x )\)</span>.则当然也有<span class="math inline">\(\Vert P_n \Vert \to
\Vert f \Vert\)</span>,那<span class="math inline">\(\Vert P_n
\Vert\)</span>就有界了,既然如此,<span class="math inline">\(a_{ i , n }
\leq C_\epsilon ( 1 + \epsilon )^{ \lambda_i
}\)</span>,也就是说所有的<span class="math inline">\(a_{ i , n
}\)</span>都是有界的.</p>
<p>我们想要求出一个子列<span class="math inline">\(\{ n_k
\}\)</span>,使得<span class="math inline">\(\forall i , \lim_{ k \to
\infty } a_{ i , n_k }\)</span>收敛于某个数<span class="math inline">\(a_i\)</span>,方法是对角线法则,对于第一行其肯定存在收敛子列,取其第一个数为<span class="math inline">\(n_1\)</span>,对于第二行,在第一行对应下来的元素中肯定也有收敛子列,取其第一个元素作为<span class="math inline">\(n_2\)</span>,依次类推.这样我们就得到了一个新的函数列<span class="math inline">\(P_{ n_k } \to g ( x ) = \sum_{ i = 0 }^\infty a_i
x^{ \lambda_i }\)</span>.此时考虑<span class="math inline">\(\varlimsup
\sqrt[\lambda_i]{ | a_i | } \leq 1 + \epsilon\)</span>,因此<span class="math inline">\(g ( x )\)</span>收敛半径<span class="math inline">\(\geq 1\)</span>.然而,<span class="math inline">\(P_{ n_k } \to f ( x )\)</span>,因此<span class="math inline">\(f ( x ) = g ( x )\)</span>.然而<span class="math inline">\(g ( x )\)</span>的收敛半径<span class="math inline">\(\geq
1\)</span>,因此一般的函数当然不能被一致逼近.</p>
<p>另一个问题是如果<span class="math inline">\(a &lt; 0 &lt;
b\)</span>该怎么办,接下来假设<span class="math inline">\(\sum_{
\lambda_i \in \mathrm{ even } } \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>.放缩一下边界,我们下面来证明此时不能逼近<span class="math inline">\(C [ - 1 , 1 ]\)</span>上的偶函数.</p>
<p>假设<span class="math inline">\(f \in C [ - 1 , 1
]\)</span>并且是偶函数,对于一列函数列,可以拆成偶函数<span class="math inline">\(g_n\)</span>和奇函数<span class="math inline">\(h_n\)</span>部分,前者只包含偶数次后者只包含奇数次.此时有<span class="math inline">\(g_n + h_n \rightrightarrows
f\)</span>,由于是偶函数,换号得到<span class="math inline">\(g_n - h_n
\rightrightarrows f\)</span>,这就必然得到<span class="math inline">\(g_n
\rightrightarrows f\)</span>,但<span class="math inline">\(g_n\)</span>并不能逼近所有的,这就矛盾了.</p>
<h6><span id="example1">Example1</span></h6>
<p>若<span class="math inline">\(f ( x
)\)</span>在无穷区间上可以用多项式一致逼近,求证<span class="math inline">\(f\)</span>为多项式.</p>
<p>考虑多项式列<span class="math inline">\(\{ P_n
\}\)</span>上有柯西准则,所以当<span class="math inline">\(N\)</span>足够大的时候,<span class="math inline">\(\forall n , m \geq N\)</span>,<span class="math inline">\(\sup | P_n - P_m
|\)</span>足够小,然而由于无穷区间,如果<span class="math inline">\(\deg (
P_n - P_m ) &gt;
0\)</span>就完蛋了,所以从某一项开始,这个多项式列的两两之间一定之差一个常数.不妨干脆设<span class="math inline">\(P_n = P + c_n\)</span>的形式,既然<span class="math inline">\(P_n\)</span>收敛,那么<span class="math inline">\(c_n\)</span>肯定收敛,设其收敛于<span class="math inline">\(c\)</span>,则<span class="math inline">\(f ( x ) =
P + c\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>若<span class="math inline">\(f \in C [ a , b ]\)</span>,<span class="math inline">\(\{ p_n \} \rightrightarrows f\)</span>,并且<span class="math inline">\(\{ p_n
\}\)</span>为次数一致有界的多项式列,求证<span class="math inline">\(f\)</span>为多项式.</p>
<p>设次数上界为<span class="math inline">\(n\)</span>,一个想法是说我这些多项式是有限多个的,你直接拿切比雪夫多项式作为基,既然现在都是有限和的情况了,那在线性空间上收敛当然是在每一个基对应的系数都收敛,这就意味着<span class="math inline">\(f\)</span>肯定是多项式.</p>
<h6><span id="example3lemma">Example3(Lemma)</span></h6>
<p>对于数列<span class="math inline">\(\{ \lambda_i \} &gt;
0\)</span>且单增,如果<span class="math inline">\(c = \inf_{ i \geq 1 }
\{ \lambda_{ i + 1 } - \lambda_i \} &gt; 0\)</span>,如果<span class="math inline">\(\sum_{ i = 1 }^\infty \frac{ 1 }{ \lambda_i } &lt;
\infty\)</span>,则<span class="math inline">\(\lim_{ m \to \infty }
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 , i \ne m }^\infty \ln \left |
\frac{ \lambda_i + \lambda_m }{ \lambda_i - \lambda_m } \right | =
0\)</span>.</p>
<p>考虑证明,由于每一项都是正的,因此我们分别证明后面的无穷和部分在<span class="math inline">\([ 1 , m - 1 ]\)</span>和<span class="math inline">\([ m + 1 , + \infty )\)</span>上均为<span class="math inline">\(0\)</span>.</p>
<p>思路呼之欲出,将<span class="math inline">\(\lambda_i\)</span>按照与<span class="math inline">\(\lambda_m\)</span>的比例分为两段:任意取定常数<span class="math inline">\(\epsilon &gt; 0\)</span>,下面开始分析.</p>
<p>设当<span class="math inline">\(i \geq N_1\)</span>的时候有<span class="math inline">\(\lambda_i \geq ( 1 - \epsilon )
\lambda_m\)</span>成立,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N_1 - 1 } \ln ( 1 +
\frac{ 2 \lambda_i }{ \lambda_m - \lambda_i } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 2
\lambda_i }{ \lambda_m - \lambda_i } \\
= &amp; \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 2 \lambda_i }{ ( \lambda_m -
\lambda_i ) \lambda_m } \\
= &amp; 2 \sum_{ i = 1 }^{ N_1 - 1 } ( \frac{ 1 }{ \lambda_m - \lambda_i
} - \frac{ 1 }{ \lambda_m } ) \\
\leq &amp; 2 \sum_{ i = 1 }^{ N_1 - 1 } \frac{ 1 }{ \epsilon \lambda_m }
- \frac{ 1 }{ \lambda_m } \\
= &amp; \frac{ N_1 - 1 }{ \lambda_m } ( \frac{ 2 }{ \epsilon } - 1 ) \\
\leq &amp; \frac{ m }{ \lambda_m } ( \frac{ 2 }{ \epsilon } - 1 )
\end{aligned}
\]</span></p>
<p>然而注意到<span class="math inline">\(\{ \frac{ 1 }{ \lambda_m }
\}\)</span>单调递减,用柯西准则得到:</p>
<p><span class="math display">\[
\sum_{ k = m + 1 }^{ 3 m } \frac{ 1 }{ \lambda_k } \geq \frac{ m }{
\lambda_{ 2 m } }
\]</span></p>
<p>所以得到<span class="math inline">\(\lim_{ m \to + \infty } \frac{ m
}{ \lambda_m } \to 0\)</span>.</p>
<p>然后考虑设<span class="math inline">\(i &gt; N_2\)</span>时有<span class="math inline">\(( 1 + \epsilon ) \lambda_m \leq
\lambda_i\)</span>,设<span class="math inline">\(( 1 + \epsilon ) =
\frac{ 1 }{ 1 - \epsilon_2 }\)</span>,则<span class="math inline">\(\lambda_m \leq ( 1 - \epsilon_2 )
\lambda_i\)</span>留神到:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_2 + 1 }^{ + \infty } \ln ( 1
+ \frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_2 + 1 }^{ + \infty }
\frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } \\
= &amp; \sum_{ i = N_2 + 1 }^{ + \infty } \frac{ 2 }{ \lambda_i -
\lambda_m } \\
\leq &amp; \sum_{ i = N_2 + 1 }^{ + \infty } \frac{ 4 }{ \epsilon_2
\lambda_i } \\
\leq &amp; \sum_{ i = m }^{ + \infty } \frac{ 4 }{ \epsilon_2 \lambda_i
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>由柯西准则就可以知道其趋近于<span class="math inline">\(0\)</span>.</p>
<p>由上面的分析见到如果预先取定<span class="math inline">\(\epsilon\)</span>,再移动<span class="math inline">\(m\)</span>,开头结尾两端都可以尽可能小对吧.最后我们要做的就是中间很靠近<span class="math inline">\(\lambda_m\)</span>的两段了,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln ( \frac{ 2
\lambda_m }{ \lambda_m - \lambda_i } - 1 ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln (
\frac{ 2 \lambda_m }{ c ( m - i ) } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设<span class="math inline">\(M = m - N_1\)</span>,上式变为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = N_1 }^{ m - 1 } \ln ( \frac{ 2
\lambda_m }{ c ( m - i ) } - 1 ) \\
= &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N } \ln ( \frac{ 2
\lambda_m }{ ic } - 1 ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ N } \ln ( \frac{ 2
\lambda_m }{ ic } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln ( 1 +
\frac{ 2 \lambda_m }{ \lambda_i - \lambda_m } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln ( 1 +
\frac{ 2 \lambda_m }{ c ( i - m ) } ) \\
\leq &amp; \frac{ 1 }{ \lambda_m } \sum_{ i = m + 1 }^{ N_2 } \ln (
\frac{ 2 \lambda_m + cm }{ c ( i - m ) } )
\end{aligned}
\]</span></p>
<p>然而<span class="math inline">\(\frac{ m }{ \lambda_m } \to
0\)</span>,于是后面的主要项仍是<span class="math inline">\(\ln ( \frac{
\lambda_m }{ ic } )\)</span>形状,而考虑<span class="math inline">\(\max
( N_2 - m , m - N_1 ) \leq \frac{ \epsilon \lambda_m }{ c
}\)</span>,接下来只要证明:</p>
<p><span class="math display">\[
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( \frac{ \lambda_m }{ ic } ) \to 0
\]</span></p>
<p>就做完了对吧,发现:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( \frac{ \lambda_m }{ ic } ) &amp; = \frac{ 1 }{ \lambda_m }
\sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln ( \lambda_m ) -
\frac{ 1 }{ \lambda_m } \sum_{ i = 1 }^{ \frac{ \epsilon \lambda_m }{ c
} } \ln ( ic ) \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \sum_{ i = 2 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln
( i ) \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \sum_{ i = 2 }^{ \lfloor \frac{ \epsilon \lambda_m }{ c
} \rfloor } \int_{ i - 1 }^{ i } \ln ( i ) \mathrm{ d t } \\
&amp; \leq \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) -
\frac{ 1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } -
1 } \ln t \mathrm{ d t } \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) - \frac{
1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln t
\mathrm{ d t } + \frac{ 1 }{ \lambda_m } \int_{ \frac{ \epsilon
\lambda_m }{ c } - 1 }^{ \frac{ \epsilon \lambda_m }{ c } } \ln t
\mathrm{ d } t \\
&amp; \leq \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) -
\frac{ 1 }{ \lambda_m } \int_{ 1 }^{ \frac{ \epsilon \lambda_m }{ c } }
\ln t \mathrm{ d t } + \frac{ \ln ( \frac{ \epsilon \lambda_m }{ c } )
}{ \lambda_m } \\
&amp; = \frac{ \epsilon }{ c } \ln ( \frac{ \lambda_m }{ c } ) + \frac{
\ln ( \frac{ \epsilon \lambda_m }{ c } ) }{ \lambda_m } - \frac{ 1 }{
\lambda_m } ( \frac{ \epsilon \lambda_m }{ c } \ln ( \frac{ \epsilon
\lambda_m }{ c } ) - 1 ) \\
&amp; = \frac{ \epsilon }{ c } \ln \epsilon + \frac{ 1 + \ln ( \frac{
\epsilon \lambda_m }{ c } ) }{ \lambda_m }
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(\epsilon\)</span>在<span class="math inline">\(m\)</span>之前决定,因此<span class="math inline">\(\lambda_m \to
\infty\)</span>的时候可以让后者趋近于<span class="math inline">\(0\)</span>,此时再让<span class="math inline">\(\epsilon \to 0\)</span>可以让前者为<span class="math inline">\(0\)</span>,这就搞定了.</p>
<h6><span id="example4黎曼引理">Example4(黎曼引理)</span></h6>
<p>求证:<span class="math inline">\(f \in C [ a , b ]\)</span>,<span class="math inline">\(\lim_{ n \to \infty } \int_a^b f ( x ) \sin ( nx )
\mathrm{ d } x = 0\)</span>.</p>
<p>当<span class="math inline">\(f \in C^1 [ a , b
]\)</span>的时候,由于:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b f ( x ) \sin ( nx ) \mathrm{ d } x \\
= &amp; - \frac{ 1 }{ n } \int_a^b f \mathrm{ d } \cos ( nx ) \\
= &amp; - \frac{ 1 }{ n } f \cos ( nx ) |_a^b + \frac{ 1 }{ n } \int_a^b
\cos ( nx ) f &#39; \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>两边取绝对值然后让<span class="math inline">\(n \to
\infty\)</span>就搞定.</p>
<p>既然如此,考虑当<span class="math inline">\(f \in C [ a , b
]\)</span>的时候,用多项式逼近<span class="math inline">\(f\)</span>,有<span class="math inline">\(| f - P |
&lt; \epsilon\)</span>,当然:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \varlimsup_{ n \to \infty } | \int_a^b f \sin ( nx ) \mathrm{ d }
x | \\
\leq &amp; \varlimsup_{ n \to \infty } | \int_a^b | f - P | \sin ( nx )
\mathrm{ d } x | \\
\leq &amp; \epsilon ( b - a )
\end{aligned}
\]</span></p>
<h6><span id="example5">Example5</span></h6>
<p>当<span class="math inline">\(f \in C [ a , b ]\)</span>,如果<span class="math inline">\(\forall n \in \mathbb{ N }\)</span>,<span class="math inline">\(\int_a^b f x^n \mathrm{ d } x =
0\)</span>,求证<span class="math inline">\(f \equiv 0\)</span>.</p>
<p>也就是任意多项式<span class="math inline">\(P\)</span>都有<span class="math inline">\(\int_a^b fP \mathrm{ d } x = 0\)</span>.取<span class="math inline">\(P\)</span>使得<span class="math inline">\(| P - f
| &lt; \epsilon\)</span>,于是:</p>
<p><span class="math display">\[
\begin{aligned}
| \int_a^b f^2 \mathrm{ d } x | &amp; = | \int_a^b fP \mathrm{ d } x +
\int_a^b f ( f - P ) \mathrm{ d } x | \\
&amp; = | \int_a^b f ( f - P ) \mathrm{ d } x | \\
&amp; \leq \epsilon \int_a^b | f | \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(\int_a^b f^2 \mathrm{ d } x =
0\)</span>所以<span class="math inline">\(f \equiv 0\)</span>.</p>
<h4><span id="傅里叶级数">傅里叶级数</span></h4>
<p>定义<strong>三角系</strong>为形如<span class="math inline">\(\{ 1 ,
\cos ( nx ) , \sin ( nx )
\}\)</span>的集合,它们张成的线性空间中,也就是有限的线性组合<span class="math inline">\(\sum_{ k = 0 }^n a_k \cos ( kx ) + b_k \sin ( kx
)\)</span>称为<span class="math inline">\(n\)</span>阶<strong>三角多项式</strong>.当<span class="math inline">\(n \to
\infty\)</span>的时候则称其为<strong>三角级数</strong>.容易见到<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi )\)</span>.</p>
<p>下面我们来证明三角系两两正交,只需检查:</p>
<ol type="1">
<li><p>当<span class="math inline">\(m \ne n\)</span>的时候,<span class="math inline">\(\int_{ - \pi }^{ \pi } \cos ( mx ) \cos ( nx )
\mathrm{ d } x\)</span>.</p></li>
<li><p>当<span class="math inline">\(m \ne n\)</span>的时候,<span class="math inline">\(\int_{ - \pi }^{ \pi } \sin ( mx ) \sin ( nx )
\mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(\forall n , m \in \mathbb{ Z
}\)</span>,<span class="math inline">\(\int_{ - \pi }^{ \pi } \sin ( nx
) \cos ( mx ) \mathrm{ d } x = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ - \pi }^{ \pi } \cos^2 ( nx )
\mathrm{ d x } = \int_{ - \pi }^{ \pi } \sin^2 ( nx ) \mathrm{ d x } =
\pi\)</span>.</p></li>
</ol>
<p>不妨设<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum_{ 1
}^\infty a_k \cos ( kx ) + b_k \sin ( kx ) \rightrightarrows f ( x
)\)</span>,假如<span class="math inline">\(f ( x
)\)</span>的确一致收敛到某个函数,我们实际上可以用<span class="math inline">\(f ( x
)\)</span>去反推系数,两边乘一些东西再积分应该见到:</p>
<ol type="1">
<li><p><span class="math inline">\(a_0 = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(a_k = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \cos ( kx ) \mathrm{ d } x\)</span>.</p></li>
<li><p><span class="math inline">\(b_k = \frac{ 1 }{ \pi } \int_{ - \pi
}^{ \pi } f ( x ) \sin ( kx ) \mathrm{ d } x\)</span>.</p></li>
</ol>
<p>应该是显然见到的.</p>
<p>当<span class="math inline">\(f\)</span>在<span class="math inline">\([ - \pi , \pi ]\)</span>上绝对可积,也就是<span class="math inline">\(\int_{ - \pi }^\pi | f | \mathrm{ d } x &lt;
\infty\)</span>,那我们就可以按照上述方法拿到一个三角级数的系数,这个三角级数被称为<span class="math inline">\(f ( x
)\)</span>的<strong>傅里叶级数</strong>或者<strong>傅里叶展开</strong>.注意我们这里其实还并没有说这个三角级数的确收敛到<span class="math inline">\(f ( x )\)</span>,而只能说我们可以如此由<span class="math inline">\(f ( x
)\)</span>构造出一个傅里叶级数.我们有时也将这样的函数记作<span class="math inline">\(f ( x ) \in F [ - \pi , \pi
]\)</span>,不妨干脆将<span class="math inline">\(f ( x
)\)</span>依照<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>的条件延拓<span class="math inline">\(f ( x
)\)</span>定义(或者干脆要求<span class="math inline">\(f ( x
)\)</span>是以<span class="math inline">\(2
\pi\)</span>为周期的函数),应当见到以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(\lim_{ n \to \infty } a_n = \lim_{ n
\to \infty } b_n = 0\)</span>.</p></li>
<li><p><span class="math inline">\(a_n ( \alpha f + \beta g ) = \alpha
a_n ( f ) + \beta a_n ( g )\)</span>.</p></li>
<li><p><span class="math inline">\(b_n ( \alpha f + \beta g ) = \alpha
b_n ( f ) + \beta b_n ( g )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x )\)</span>是奇函数,则<span class="math inline">\(a_n ( f ) \equiv 0\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x )\)</span>是偶函数,则<span class="math inline">\(b_n ( f ) \equiv 0\)</span>.</p></li>
<li><p>记<span class="math inline">\(f_h ( x ) = f ( x + h
)\)</span>,则<span class="math inline">\(a_n ( f_h ) = a_n ( f ) \cos (
nh ) + b_n ( f ) \sin ( nh )\)</span>.</p></li>
<li><p>记<span class="math inline">\(f_h ( x ) = f ( x + h
)\)</span>,则<span class="math inline">\(b_n ( f_h ) = b_n ( f ) \cos (
nh ) - a_n ( f ) \sin ( nh )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(f ( x ) \equiv f ( x + \pi
)\)</span>,则<span class="math inline">\(a_{ 2 n - 1 } ( f ) = b_{ 2 n -
1 } ( f )\)</span>.</p></li>
<li><p>对<span class="math inline">\(\alpha \in ( 0 , 1
]\)</span>,若<span class="math inline">\(| f ( x ) - f ( y ) | \leq L |
x - y |^\alpha , \forall x , y \in [ - \pi , \pi ]\)</span>,则<span class="math inline">\(a_n = b_n = O ( \frac{ 1 }{ n^\alpha }
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(a_n = b_n = o ( \frac{ 1 }{ n }
)\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(a_n ( f ) = - \frac{ b_n ( f &#39; ) }{ n
}\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可导,<span class="math inline">\(f &#39;\)</span>绝对可积,则<span class="math inline">\(b_n ( f ) = \frac{ a_n ( f &#39; ) }{ n
}\)</span>.</p></li>
<li><p>若<span class="math inline">\(f\)</span>可以导<span class="math inline">\(m\)</span>次,而且<span class="math inline">\(f^{ (
m ) }\)</span>绝对可积,则<span class="math inline">\(a_n = b_n = o (
\frac{ 1 }{ n^m } )\)</span>.</p></li>
<li><p>若<span class="math inline">\(f \in C ( \mathbb{ R } ) , f ( x +
2 \pi ) \equiv f ( x )\)</span>,则<span class="math inline">\(\forall
\epsilon &gt; 0\)</span>,则存在一列三角多项式一致逼近<span class="math inline">\(f\)</span>.</p></li>
<li><p>若<span class="math inline">\(f \in C ( \mathbb{ R } ) , f ( x +
2 \pi ) \equiv f ( x )\)</span>,若<span class="math inline">\(\forall n
\geq 0 , a_n \equiv b_n \equiv 0\)</span>,则<span class="math inline">\(f \equiv 0\)</span>.</p></li>
</ol>
<p>(1)是由于黎曼引理,我们前面已经用若干种方法反复证过了.</p>
<p>(2)(3)是积分线性的显然结果,(4)(5)只需带入定义即可发现.</p>
<p>(6)(7)的话当然是因为和差角公式.(8)的话根据(6)和(7)由于<span class="math inline">\(a_n ( f ) = a_n ( f_\pi ) = a_n ( f ) ( - 1
)^n\)</span>,这就搞定.</p>
<p>(9)的话,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f ( x ) \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi - \frac{ \pi }{ n } }^{ \pi -
\frac{ \pi }{ n } } f ( x + \frac{ \pi }{ n } ) \cos ( nt + \pi )
\mathrm{ d } x \\
&amp; = - \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f ( x + \frac{ \pi }{
n } ) \cos ( nt ) \mathrm{ d } x \\
a_n &amp; = \frac{ 1 }{ 2 \pi } \int_{ - \pi }^{ \pi } ( f ( x ) - f ( x
+ \frac{ \pi }{ n } ) ) \cos ( nx ) \mathrm{ d } x \\
| a_n | &amp; \leq \frac{ 1 }{ 2 \pi } \int_{ - \pi }^{ \pi } L ( \frac{
\pi }{ n } )^\alpha \\
&amp; = O ( 1 ) \frac{ 1 }{ n^\alpha }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>至于(10)的话,<span class="math inline">\(a_n = b_n = O ( \frac{ 1 }{
n } )\)</span>当然只是(9)的推论.那怎么证明是<span class="math inline">\(o ( \frac{ 1 }{ n } )\)</span>的呢?考虑:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^{ \pi } f \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ n \pi } \int_{ - \pi }^{ \pi } f \mathrm{ d } \sin (
nx ) \\
&amp; = - \frac{ 1 }{ n \pi } \int_{ - \pi }^{ \pi } \sin ( nx ) f &#39;
\mathrm{ d } x \\
&amp; = o ( \frac{ 1 }{ n } )
\end{aligned}
\]</span></p>
<p>上述过程也自然拿到了(11)和(12).</p>
<p>(13)的话也只需要由(11)和(12)拿到:</p>
<p><span class="math display">\[
| a_n ( f ) | + | b_n ( f ) | \leq \frac{ | a_n ( f^{ ( m ) } ) | + |
b_n ( f^{ ( m ) } ) | }{ n^m }
\]</span></p>
<p>其实还有一个推论是如果<span class="math inline">\(f\)</span>是<span class="math inline">\(2 \pi\)</span>周期的解析函数,则<span class="math inline">\(| a_n ( f ) | , | b_n ( f ) | \leq Me^{ - nc
}\)</span>.而且甚至说这个条件是充要的,如果趋向于零的速度确实为此,则<span class="math inline">\(f\)</span>也的确是解析函数.可惜的是这个结论需要用到复分析的结果,不得不在此略过.</p>
<p>(14)的话,乍一看像是Stone-Weierstrass定理的另一则应用,直接观察Stone-Weierstrass定理的证明发现的确可以照搬到三角多项式上(因为难点只在<span class="math inline">\(f ( - \pi ) = f ( \pi
)\)</span>,但原证明中分离的性质只用于贴合函数上的两个点),然而如果想要直接封装原定理拿过来的话的确难以处理<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>的性质(其实可以从复平面绕过去).下面提供另一则证明:</p>
<p>先看当<span class="math inline">\(f ( x
)\)</span>是偶函数的时候,观察<span class="math inline">\(x \in [ 0 , \pi
]\)</span>,取<span class="math inline">\(y = \cos x\)</span>,见到<span class="math inline">\(f ( \arccos y ) \in C [ - 1 , 1
]\)</span>.此时存在一个多项式<span class="math inline">\(P ( y ) = P (
\cos x )\)</span>一致逼近<span class="math inline">\(f ( x
)\)</span>,而<span class="math inline">\(P ( \cos x
)\)</span>当然是三角多项式.</p>
<p>考虑取<span class="math inline">\(g ( x ) = f ( x ) + f ( - x
)\)</span>,则如上知道<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,存在三角多项式<span class="math inline">\(T_1 ( x
)\)</span>使得<span class="math inline">\(\forall x \in \mathbb{ R } , |
g ( x ) - T_1 ( x ) | &lt; \frac{ \epsilon }{ 2 }\)</span>.</p>
<p>再取<span class="math inline">\(\varphi ( x ) = ( f ( x ) - f ( - x )
) \sin x\)</span>当然也是偶函数,存在三角多项式<span class="math inline">\(T_2 ( x )\)</span>使得<span class="math inline">\(\forall x \in \mathbb{ R } , | \varphi ( x ) - T_2
( x ) | &lt; \frac{ \epsilon }{ 2 }\)</span>.</p>
<p>既然如此,考虑取<span class="math inline">\(T_3 ( x ) = T_1 \sin^2 x +
T_2 \sin x\)</span>,由上见到<span class="math inline">\(| 2 f ( x )
\sin^2 x - T_3 ( x ) | &lt; \epsilon\)</span>,也就是说对于任何<span class="math inline">\(f ( x )\)</span>都能找到如此一个<span class="math inline">\(T_3 ( x )\)</span>满足条件.</p>
<p>既然如此,考虑对<span class="math inline">\(f ( x - \frac{ \pi }{ 2 }
)\)</span>做上述操作,也就是存在三角多项式<span class="math inline">\(T_4
( x )\)</span>满足:</p>
<p><span class="math display">\[
\begin{aligned}
| 2 f ( x - \frac{ \pi }{ 2 } ) \sin^2 x - T_4 ( x ) | &lt; \epsilon \\
| 2 f ( x ) \cos^2 x - T_4 ( x + \frac{ \pi }{ 2 } ) | &lt; \epsilon
\end{aligned}
\]</span></p>
<p>既然如此,得到:<span class="math inline">\(| 2 f ( x ) - T_3 ( x ) -
T_4 ( x + \frac{ \pi }{ 2 } ) | &lt; 2 \epsilon\)</span>,这就搞定了.</p>
<p>对于(15),考虑找一列三角多项式一致逼近<span class="math inline">\(f (
x )\)</span>,由于<span class="math inline">\(f ( x
)\)</span>的傅里叶级数总是<span class="math inline">\(0\)</span>,所以对于三角多项式<span class="math inline">\(T_n\)</span>来说一定有<span class="math inline">\(\int_{ - \pi }^{ \pi } f ( x ) T_n ( x ) \mathrm{
d } x \equiv 0\)</span>,既然如此考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_{ - \pi }^{ \pi } f^2 \mathrm{ d } x &amp; = \int_{ - \pi }^\pi f (
f - T_n ) \mathrm{ d } x \\
&amp; \leq \int_{ - \pi }^\pi | f | \cdot | f - T_n | \mathrm{ d } x \\
&amp; \leq \epsilon \int_{ - \pi }^\pi | f | \mathrm{ d } x &amp; \to 0
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(f \equiv
0\)</span>.这意味着连续函数的傅里叶展开是唯一的.</p>
<p>(15)的一则类似结果是,你可以从中看出<span class="math inline">\(\{ 1 ,
\sin ( nx ) , \cos ( nx )
\}\)</span>三角系是缺一不可的,而不像多项式那样可以去掉很多.例如如果我们在其中去掉<span class="math inline">\(\sin x\)</span>的话,那么<span class="math inline">\(\sin
x\)</span>本身就无法逼近,原因是反证法,如果能逼近,考虑一列三角多项式<span class="math inline">\(\{ T_n \}\)</span>并且其中不含<span class="math inline">\(\sin
x\)</span>,然而,由于三角系中两两正交,因此<span class="math inline">\(\forall T_n ,\)</span>都有<span class="math inline">\(\int_{ - \pi }^{ \pi } T_n \sin x \mathrm{ d } x
\equiv 0\)</span>,因此从(15)的证明过程就可以见到必然有<span class="math inline">\(\sin x \equiv 0\)</span>,这当然就出事了.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(x \in [ - \pi , \pi
]\)</span>,考虑一列<span class="math inline">\(\{ b_n
\}\)</span>单调下降趋近于<span class="math inline">\(0\)</span>,那么根据DA判法当然有<span class="math inline">\(S ( x ) = \sum_{ n = 1 }^\infty b_n \sin ( nx
)\)</span>是逐点收敛的,假设收敛于<span class="math inline">\(f ( x
)\)</span>.如果<span class="math inline">\(f ( x )\)</span>的确是<span class="math inline">\([ - \pi , \pi
]\)</span>上的绝对可积函数.求证:此时上述<span class="math inline">\(S (
x )\)</span>的确是<span class="math inline">\(f ( x
)\)</span>的傅里叶级数.</p>
<p>容易见到<span class="math inline">\(f ( x
)\)</span>是奇函数,其傅里叶级数中的<span class="math inline">\(a_n
\equiv 0\)</span>.此时不妨只看<span class="math inline">\(x \in [ 0 ,
\pi ]\)</span>上的结果.</p>
<p>难点当然在于<span class="math inline">\(S ( x ) \to
f\)</span>并不一定是一致逼近,但应该观察到的是:</p>
<p><span class="math display">\[
| \sin ( mx ) \sum_{ k = 1 }^n \sin ( kx ) | \leq \left | \frac{ \sin (
mx ) }{ \sin \frac{ x }{ 2 } } \right | \leq \left | \frac{ mx }{ \frac{
x }{ \pi } } \right | = | m \pi |
\]</span></p>
<p>所以这个一致有界,前面的<span class="math inline">\(| b_n
|\)</span>单调趋近于<span class="math inline">\(0\)</span>,DA判法告诉我们<span class="math inline">\(\sin ( mx ) S ( x
)\)</span>一致收敛,那逐项积分就证完了<span class="math inline">\(\int_{
- \pi }^{ \pi } g ( x ) \sin ( mx ) \mathrm{ d } x = \pi
b_m\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(f ( x ) = \frac{ 1 - r^2 }{ 1 - 2 r
\cos x + r^2 } , | r | &lt; 1\)</span>的傅里叶级数.</p>
<p>考虑在复数上做此操作,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ 1 - z } &amp; = \frac{ 1 - \bar{ z } }{ ( 1 - z ) ( 1 -
\bar{ z } ) } \\
&amp; = \frac{ 1 - \bar{ z } }{ 1 - 2 \Re z + | z |^2 } \\
&amp; = \frac{ 1 - r \cos x + ir \sin x }{ 1 - 2 r \cos x + r^2 }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(2 \Re ( \frac{ 1 }{ 1 - z } ) - 1 = f
( x )\)</span>,然而:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ 1 }{ 1 - z } &amp; = \sum_{ n \geq 0 } z^n = \sum_{ n \geq 0 }
r^n e^{ inx } \\
\Re ( \frac{ 1 }{ 1 - z } ) &amp; = 1 + \sum_{ n \geq 1 } r^n \cos ( nx
) \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以<span class="math inline">\(f ( x ) = 1 + \sum_{ n \geq 1 } 2 r^n
\cos ( nx )\)</span>.</p>
<h5><span id="与原函数的收敛关系">与原函数的收敛关系</span></h5>
<p>做完以上操作后,我们来考虑这个傅里叶级数到底是否逼近于<span class="math inline">\(f ( x )\)</span>本身,设<span class="math inline">\(S_n ( x ) = \frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n (
a_k \cos ( kx ) + b_k \sin ( kx ) )\)</span>.此时考虑:</p>
$$
<span class="math display">\[\begin{aligned}
S_n ( x_0 ) &amp; = \frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n \int_{ - \pi
}^\pi f ( x ) ( \cos kx \cdot \cos kx_0 + \sin kx \cdot \sin kx_0 )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ 2 \pi } \int_{ - \pi }^\pi f ( x ) \mathrm{ d } x +
\sum_{ k = 1 }^n \int_{ - \pi }^\pi f ( x ) \cos k ( x - x_0 ) \mathrm{
d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \left ( \frac{ 1 }{
2 } + \sum_{ k = 1 }^n \cos k ( x - x_0 ) \right ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \frac{ \sin ( n +
\frac{ 1 }{ 2 } ) ( x - x_0 ) }{ 2 \sin \frac{ x - x_0 }{ 2 } } \mathrm{
d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨令迪利克雷核<span class="math inline">\(D_n ( x ) = \frac{ \sin (
n + \frac{ 1 }{ 2 } ) x }{ 2 \sin \frac{ x }{ 2 } } , \varphi ( x_0 , x
) = \frac{ f ( x_0 + x ) + f ( x_0 - x ) }{ 2 }\)</span>,应当见到<span class="math inline">\(\frac{ 1 }{ \pi } \int_{ - \pi }^\pi D_n ( x )
\mathrm{ d } x = 1\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
S_n ( x_0 ) &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) D_{ n }
( x - x_0 ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( t + x_0 ) D_{ n } ( t )
\mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } \int_0^\pi ( f ( x_0 + t ) + f ( x_0 - t ) )
D_n ( t ) \mathrm{ d } t \\
&amp; = \frac{ 2 }{ \pi } \int_0^\pi \varphi ( x_0 , t ) D_n ( t )
\mathrm{ d } t
\end{aligned}
\]</span></p>
<p>问题在于最后如何判断这个积分的收敛性,事实上可以找到若干个逼近的充分条件:</p>
<ol type="1">
<li>分段可导时候的情况</li>
</ol>
<p>下面我们来证明:当<span class="math inline">\(f\)</span>是Holder连续的时候,<span class="math inline">\(\lim_{ n \to \infty } S_n ( x ) \to f ( x
)\)</span>.</p>
<p>我们有如下<strong>黎曼局部化引理</strong>:对<span class="math inline">\(\forall 0 &lt; \delta &lt; \pi\)</span>,都有<span class="math inline">\(\lim_{ n \to \infty } \left ( S_n ( x_0 ) - \frac{
2 }{ \pi } \int_0^\delta \varphi ( x_0 , t ) \frac{ \sin ( n + \frac{ 1
}{ 2 } ) t }{ t } \mathrm{ d } t \right ) = 0\)</span>.</p>
<p>如何证明此呢?考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\frac{ \pi }{ 2 } S_n ( x_0 ) &amp; = \int_0^\delta \varphi ( x_0 , t )
D_n ( t ) \mathrm{ d } t + \int_\delta^\pi \varphi ( x_0 , t ) D_n ( t )
\mathrm{ d } t \\
&amp; = \int_0^\delta \varphi ( x_0 , t ) \frac{ \sin ( n + \frac{ 1 }{
2 } ) t }{ t } \mathrm{ d } t + \int_0^\delta \varphi ( x_0 , t ) \frac{
t - 2 \sin \frac{ t }{ 2 } }{ 2 t \sin \frac{ t }{ 2 } } \sin ( n +
\frac{ 1 }{ 2 } ) t \mathrm{ d } t \\
&amp; + \int_\delta^\pi \frac{ \varphi ( x_0 , t ) }{ 2 \sin \frac{ t }{
2 } } \sin ( n + \frac{ 1 }{ 2 } ) t \mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>留神到<span class="math inline">\(\frac{ t - 2 \sin \frac{ t }{ 2 }
}{ 2 t \sin \frac{ t }{ 2 }
}\)</span>极限存在,因此其的确有界,对后面两项用黎曼引理就知道趋近于<span class="math inline">\(0\)</span>.</p>
<p>接下来我们还有一个引理:当<span class="math inline">\(\varphi \in R [
0 , \delta ]\)</span>的时候,如果<span class="math inline">\(\varphi ( 0
+ )\)</span>存在,并且<span class="math inline">\(\int_0^\delta \frac{ |
\varphi ( t ) - \varphi ( 0 + ) | }{ t } &lt; \infty\)</span>,则<span class="math inline">\(\lim_{ \lambda \to \infty } \int_0^\delta \varphi
( t ) \frac{ \sin \lambda t }{ t } \mathrm{ d } t = \frac{ \pi }{ 2 }
\varphi ( 0 + )\)</span>.</p>
<p>于此证明,根据黎曼引理:</p>
<p><span class="math display">\[
\begin{aligned}
\lim_{ \lambda \to \infty } \int_0^\delta \frac{ \varphi ( t ) - \varphi
( 0 + ) }{ t } \sin \lambda t \mathrm{ d } t &amp; = 0 \\
\lim_{ \lambda \to \infty } \int_0^\delta \frac{ \varphi ( t ) }{ t }
\sin \lambda t \mathrm{ d } t &amp; = \lim_{ \lambda \to \infty }
\int_0^\delta \frac{ \varphi ( 0 + ) }{ t } \sin \lambda t \mathrm{ d }
t \\
&amp; = \varphi ( 0 + ) \lim_{ \lambda \to \infty } \int_0^{ \lambda
\delta } \frac{ \sin t }{ t } \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } \varphi ( 0 + )
\end{aligned}
\]</span></p>
<p>既然如此,当<span class="math inline">\(f\)</span>是霍尔德连续,也就是<span class="math inline">\(\exists \alpha \in ( 0 , 1 ] , \exists C &gt;
0\)</span>,使得<span class="math inline">\(| f ( x_0 + t ) - f ( x_0 ) |
\leq C | t |^\alpha\)</span>,此时见到<span class="math inline">\(|
\varphi ( x_0 , t ) - \varphi ( x_0 , 0 + ) | = O ( | t |^\alpha
)\)</span>,用上述引理知道此时<span class="math inline">\(S_n ( x_0 ) \to
f ( x_0 )\)</span>.</p>
<p>上述结论还可以得到一个更神秘的结论,我们上述引理只用到了在<span class="math inline">\(x_0\)</span>附近的结果,那如果<span class="math inline">\(f\)</span>在<span class="math inline">\(x_0\)</span>附近不连续呢?</p>
<p>假设<span class="math inline">\(f ( x_0 \pm 0
)\)</span>均存在,我们可以定义<strong>广义导数</strong>,定义右广义导数为<span class="math inline">\(D_+ f ( x_0 ) = \lim_{ h \to 0 + } \frac{ f ( x_0
+ h ) - f ( x_0 + 0 ) }{ h }\)</span>,同理定义左广义导数.</p>
<p>当<span class="math inline">\(D_\pm f ( x_0
)\)</span>存在的时候,考虑此时<span class="math inline">\(\frac{ |
\varphi ( t ) - \varphi ( 0 + ) | }{ t
}\)</span>没有瑕点,那上述结论当然也就满足.</p>
<p>如果我们定义分段可导为除了若干个断点处的左右广义导数不相同,其余所有点的左右广义导数都存在.那上述结论也就满足.</p>
<ol start="2" type="1">
<li>分段单调时候的情况</li>
</ol>
<p>我们有<strong>Jordan引理</strong>:设<span class="math inline">\(\varphi\)</span>在<span class="math inline">\([ 0
, \delta ]\)</span>上单调,则<span class="math inline">\(\lim_{ \lambda
\to \infty } \int_0^\delta \frac{ \varphi ( x ) }{ x } \sin ( \lambda x
) \mathrm{ d } x = \frac{ \pi }{ 2 } \varphi ( 0 + )\)</span>.</p>
<p>对Jordan引理的证明,不妨设<span class="math inline">\(\varphi\)</span>单调递增,对<span class="math inline">\(\forall \epsilon &gt; 0 , \exists 0 &lt; \delta
&#39; &lt; \delta\)</span>,使得<span class="math inline">\(\forall t \in
( 0 , \delta &#39; ) , 0 \leq \varphi ( t ) - \varphi ( 0 + ) &lt;
\epsilon\)</span>.</p>
<p>不妨设<span class="math inline">\(| \int_0^t \frac{ \sin x }{ x } |
\leq M , \forall t &gt; 0\)</span>,考虑根据积分第二中值定理:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_0^{ \delta &#39; } ( \varphi ( t ) - \varphi ( 0 + ) )
\frac{ \sin ( \lambda t ) }{ t } \mathrm{ d } t | \\
= &amp; | ( \varphi ( \delta &#39; ) - \varphi ( 0 + ) ) \int_\xi^{
\delta &#39; } \frac{ \sin ( \lambda t ) }{ t } \mathrm{ d } t | \\
\leq &amp; 2 M \epsilon
\end{aligned}
\]</span></p>
<p>而在<span class="math inline">\([ \delta &#39; , \delta
]\)</span>上可以直接用黎曼引理这就搞定了.</p>
<p>如果<span class="math inline">\(\varphi\)</span>是有限个单调函数的和,上述结论当然也成立了.所以该结论对有界变差函数是成立的.</p>
<p>因此,当<span class="math inline">\(f \in [ - \pi , \pi
]\)</span>上逐段单调的时候,<span class="math inline">\(\varphi\)</span>逐段是两个单调函数的差,那此时当然也有<span class="math inline">\(\lim_{ n \to \infty } S_n ( x ) = \frac{ f ( x + 0
) + f ( x - 0 ) }{ 2 }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f ( x ) = \begin{cases}- 1 &amp; x \in
( - \pi , 0 ) \\ 0 &amp; x = 0 \lor x = - \pi \lor x = \pi \\ 1 &amp; x
\in ( 0 , \pi )\end{cases}\)</span>.</p>
<p>见到这的确是一个奇函数,直接求它的傅里叶级数,见到是:</p>
<p><span class="math display">\[
\frac{ 4 }{ \pi } \sum_{ n = 0 }^\infty \frac{ \sin ( 2 n + 1 ) x }{ 2 n
+ 1 } = \frac{ f ( x + 0 ) + f ( x - 0 ) }{ 2 } = f ( x )
\]</span></p>
<p>我们竟然得到了一个一个神秘级数,很牛.</p>
<p>而且这个三角级数在<span class="math inline">\(( 0 , \pi
)\)</span>上处处收敛到<span class="math inline">\(1\)</span>,这个性质在幂级数的时候是无法想象的,我们之前证明过了开区间上的非常值幂级数的零点集一定没有聚点.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(f ( x ) = \begin{cases}\pi + x &amp; x
\in [ - \pi , 0 ) \\ \pi - x &amp; x \in [ 0 , \pi
)\end{cases}\)</span>,也就是一个锯齿状的小函数,当然分段单调了.由于是一个偶函数,积分得到<span class="math inline">\(a_n = \frac{ 2 }{ \pi } \int_0^\pi ( \pi - x )
\cos ( nx ) \mathrm{ d } x = \frac{ 2 }{ n^2 \pi } ( 1 - ( - 1 )^n
)\)</span>.</p>
<p>这当然是个连续函数,那此时有:</p>
<p><span class="math display">\[
f ( x ) = \frac{ \pi }{ 2 } + \frac{ 4 }{ \pi } ( \sum_{ k = 0 }^\infty
\frac{ \cos ( 2 k + 1 ) x }{ ( 2 k + 1 )^2 } )
\]</span></p>
<p>两边带入<span class="math inline">\(x = 0\)</span>就知道<span class="math inline">\(\sum_{ k = 0 }^\infty \frac{ 1 }{ ( 2 k + 1 )^2 }
= \frac{ \pi^2 }{ 8 }\)</span>.</p>
<p>还没完,用大M判别法容易检验这个式子两边是绝对一致收敛的,那我们两边逐项积分得到:</p>
$$
<span class="math display">\[\begin{aligned}
\int_0^x f ( t ) \mathrm{ d } t &amp; = \frac{ \pi }{ 2 } x + \frac{ 4
}{ \pi } \sum_{ k = 0 }^\infty \int_0^x \frac{ \cos ( 2 k + 1 ) t }{ ( 2
k + 1 )^2 } \mathrm{ d } t \\
&amp; = \frac{ \pi }{ 2 } x + \frac{ 4 }{ \pi } \sum_{ k = 0 }^\infty
\frac{ \sin ( 2 k + 1 ) t }{ ( 2 k + 1 )^3 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>把左边的<span class="math inline">\(f\)</span>积出来,设其为<span class="math inline">\(g ( x ) = \begin{cases}\pi x + \frac{ x^2 }{ 2 }
&amp; x \in [ - \pi , 0 ) \\ \pi x - \frac{ x^2 }{ 2 } &amp; x \in [ 0 ,
\pi
)\end{cases}\)</span>.那它的傅里叶展开就等于右边的东西(因为一致收敛).带入<span class="math inline">\(x = \frac{ \pi }{ 2 }\)</span>,可以得到<span class="math inline">\(\frac{ \pi^3 }{ 32 } = \sum_{ k = 0 }^\infty
\frac{ ( - 1 )^k }{ ( 2 k + 1 )^3 }\)</span>.</p>
<p>那接下来还可以两边再积分对吧!过程我也懒得写了,总之能推出<span class="math inline">\(\sum_{ k = 0 }^\infty \frac{ 1 }{ ( 2 k + 1 )^4 }
= \frac{ \pi^4 }{ 96 }\)</span>,可以得到<span class="math inline">\(\sum_{ k = 1 }^\infty \frac{ 1 }{ k^4 } = \frac{
\pi^4 }{ 90 }\)</span>.</p>
<p>所以总之,我们可以用上面的策略得到所有的<span class="math inline">\(\zeta ( 2 n )\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑对<span class="math inline">\(\cos ( ax )\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>截取出来并延拓,然后对其作傅里叶展开,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\cos ( ax ) &amp; = \frac{ \sin ( a \pi ) }{ a \pi } + \sum_{ n = 1
}^\infty \frac{ ( - 1 )^n 2 a }{ a^2 - n^2 } \frac{ \sin ( a \pi ) }{
\pi } \cos ( nx ) \\
\frac{ 1 }{ \sin ( a \pi ) } &amp; = \frac{ 1 }{ a \pi } + \sum_{ n = 1
}^\infty \frac{ ( - 1 )^n 2 a \pi }{ ( a \pi )^2 - ( n \pi )^2 }
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(z = a \pi\)</span>,得到:</p>
<p><span class="math display">\[
\frac{ 1 }{ \sin z } = \frac{ 1 }{ z } + \sum_{ n = 1 }^\infty ( - 1 )^n
( \frac{ 1 }{ z - n \pi } + \frac{ 1 }{ z + n \pi } )
\]</span></p>
<h6><span id="example4">Example4</span></h6>
<p>假设<span class="math inline">\(\int_{ - \infty }^{ + \infty } | f |
\mathrm{ d } x &lt; \infty\)</span>,且存在<span class="math inline">\(x_0 , \delta\)</span>,<span class="math inline">\(f ( x_0 \pm 0
)\)</span>存在,使得以下二者其一成立:</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span>在<span class="math inline">\(( x_0 - \delta , x_0 + \delta
)\)</span>上是有界变差的.</p></li>
<li><p>积分<span class="math inline">\(\int_0^\delta \frac{ | f ( x_0
\pm t ) - f ( x_0 \pm 0 ) | }{ t } &lt; \infty\)</span>.</p></li>
</ol>
<p>则:</p>
<p><span class="math display">\[
\lim_{ \alpha \to \infty } \frac{ 1 }{ \pi } \int_{ - \infty }^{ +
\infty } f ( x_0 + t ) \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d } t =
\frac{ 1 }{ 2 } ( f ( x_0 + 0 ) + f ( x_0 - 0 ) )
\]</span></p>
<p>只需要证明:</p>
<p><span class="math display">\[
\lim_{ \alpha \to \infty } \int_{ 0 }^\infty ( f ( x_0 + t ) - f ( x_0 +
0 ) ) \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d } t = 0
\]</span></p>
<p>首先<span class="math inline">\([ 0 , + \infty )\)</span>上,对于<span class="math inline">\([ 0 , \delta
]\)</span>只需要正常做就行了.可是<span class="math inline">\(\frac{ f (
x_0 + t ) - f ( x_0 + 0 ) }{ t }\)</span>在<span class="math inline">\((
\delta , + \infty
)\)</span>上未必可积,这就有点难绷.开动脑筋,想起来既然这里有一个<span class="math inline">\(\mathbb{ R
}\)</span>上的绝对可积,那当然得用一用我们的柯西准则,考虑将后面拆成<span class="math inline">\(( \delta , M )\)</span>和<span class="math inline">\([ M , + \infty )\)</span>.如果我们能把后面的<span class="math inline">\([ M , + \infty
)\)</span>搞定,那中间那一段用黎曼引理就搞定了.</p>
<p>后面怎么做呢,简单放缩:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ M }^\infty ( f ( x_0 + t ) - f ( x_0 + 0 ) ) \frac{ \sin
( \alpha t ) }{ t } \mathrm{ d } t | \\
\leq &amp; | \int_{ M }^\infty f ( x_0 + t ) \frac{ \sin ( \alpha t ) }{
t } \mathrm{ d } t | + | \int_{ M }^\infty f ( x_0 + 0 ) \frac{ \sin (
\alpha t ) }{ t } \mathrm{ d } t | \\
\leq &amp; \int_{ M }^\infty | f ( x_0 + t ) | \mathrm{ d } t + | f (
x_0 + 0 ) \int_{ M }^\infty \frac{ \sin ( \alpha t ) }{ t } \mathrm{ d }
t | \\
\to &amp; 0
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h5><span id="一致收敛到原函数的情形">一致收敛到原函数的情形</span></h5>
<p>那此时该函数肯定连续,然而连续函数未必总能一致逼近,Example1给出了一个反例.</p>
<p>那么应该加如何条件呢?先证明一个加强版的黎曼引理:</p>
<p>设<span class="math inline">\(g ( x )\)</span>是<span class="math inline">\([ A , B ]\)</span>上的绝对可积函数,取<span class="math inline">\(S_p = \sup_{ a , b \in [ A , B ] } | \int_a^b g (
t ) \sin pt \mathrm{ d } t | + \sup_{ a , b \in [ A , B ] } | \int_a^b g
( t ) \cos pt \mathrm{ d } t |\)</span>,我们要证明<span class="math inline">\(\lim_{ p \to \infty } S_p =
0\)</span>.这个还并不显然,因为<span class="math inline">\(a ,
b\)</span>是可以在<span class="math inline">\(p\)</span>之后决定的.实际上这里就是为了拿到一个一致控制性,我们想让我们的黎曼引理是能一致控制住整个区间的,这样我们才能得到一致收敛的条件.</p>
<p>首先考虑<span class="math inline">\(\forall \epsilon &gt;
0\)</span>,当<span class="math inline">\(g ( x ) \in R [ a , b
]\)</span>的时候,可以先用连续函数逼近,再将连续函数变为多项式逼近.而当<span class="math inline">\(g ( x
)\)</span>有瑕点的时候,可以将瑕点逼掉.所以总能找到一个多项式<span class="math inline">\(f ( x )\)</span>满足<span class="math inline">\(\int_A^B | g ( x ) - f ( x ) | \mathrm{ d } x &lt;
\frac{ \epsilon }{ 2 }\)</span>.然后考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\int_a^b f \sin ( pt ) \mathrm{ d } t &amp; = \frac{ 1 }{ p } f \cos (
pt ) |_a^b + \frac{ 1 }{ p } \int_a^b \cos ( pt ) f &#39; \mathrm{ d } t
\\
&amp; \to 0
\end{aligned}
\]</span></p>
<p>由此还可以再推出一个引理,<span class="math inline">\(\lim_{ p \to
\infty } \sup_{ A \leq x_0 \pm a , x_0 \pm b \leq B } | \int_a^b g ( x_0
\pm t ) \cos ( pt ) \mathrm{ d } t | =
0\)</span>.原因是换元后用和差角公式拆开就行.</p>
<p>进一步推广,考虑<span class="math inline">\(\gamma ( t
)\)</span>是<span class="math inline">\([ a , b
]\)</span>上的有界变差函数,我们证明:<span class="math inline">\(\lim_{ p
\to \infty } \sup_{ A \leq x_0 \pm a , x_0 \pm b \leq B } | \int_a^b g (
x_0 \pm t ) \gamma ( t ) \cos ( pt ) \mathrm{ d } t | = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(\gamma ( t
)\)</span>单调递增,然后用积分第二中值定理就可以发现:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \int_a^b g ( x_0 \pm t ) \gamma ( t ) \sin ( pt ) \mathrm{ d } t
\\
= &amp; \gamma ( a ) \int_a^\xi g ( x_0 \pm t ) \sin ( pt ) \mathrm{ d }
t + \gamma ( b ) \int_\xi^b g ( x_0 \pm t ) \sin ( pt ) \mathrm{ d } t
\\
\to &amp; 0
\end{aligned}
\]</span></p>
<p>接下来设<span class="math inline">\(\varphi ( t ) = f ( x + t ) + f (
x - t ) - 2 f ( x )\)</span>,假设<span class="math inline">\(f\)</span>是<span class="math inline">\([ - \pi ,
\pi ]\)</span>上的绝对可积函数,而且<span class="math inline">\(f\)</span>限制在子区间<span class="math inline">\([ a , b
]\)</span>上是连续的.我们有<strong>迪尼定理</strong>:若<span class="math inline">\(\forall \epsilon &gt; 0 , \exists \delta &gt; 0 ,
\sup_{ x \in [ a , b ] } \int_0^\delta \frac{ | \varphi ( t ) | }{ t }
\mathrm{ d } t &lt; \epsilon\)</span>,则其傅里叶级数<span class="math inline">\(S_n ( x )\)</span>在区间<span class="math inline">\([ a , b ]\)</span>上一致逼近<span class="math inline">\(f\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
S_n ( x ) - f ( x ) &amp; = \frac{ 1 }{ \pi } \int_0^\pi \varphi ( t )
\frac{ \sin ( n + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } ( \int_0^\delta + \int_\delta^\pi ) \varphi (
t ) \frac{ \sin ( n + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑前者:</p>
<p><span class="math display">\[
\begin{aligned}
\int_0^\delta &amp; \leq \frac{ 1 }{ \pi } \int_0^\delta \frac{ |
\varphi ( t ) | }{ t } \frac{ \frac{ t }{ 2 } }{ \sin \frac{ t }{ 2 } }
\mathrm{ d } t \\
&amp; \leq \frac{ 1 }{ 2 } \int_0^\delta \frac{ | \varphi ( t ) | }{ t }
\mathrm{ d } t \\
&amp; &lt; \frac{ \epsilon }{ 2 }
\end{aligned}
\]</span></p>
<p>至于后者,只需上述引理就搞定.</p>
<p>于是最后我们可以得到,如果<span class="math inline">\(f\)</span>是Holder连续的时候,那对于任意的<span class="math inline">\([ a , b ]\)</span>,都一定有<span class="math inline">\(S_n \rightrightarrows f ( x )\)</span>.</p>
<p>而如果当<span class="math inline">\(f\)</span>是有界变差的时候,此时考虑<span class="math inline">\(f\)</span>几乎处处可导,而在其可导的地方当然由上面的结果就一致收敛了,所以可以知道这个函数列几乎处处一致收敛到<span class="math inline">\(f\)</span>.</p>
<p>然而容易检验如果一个连续函数列几乎处处一致收敛到一个连续函数,那当然它们就是一致收敛的关系.考虑反证,<span class="math inline">\(\forall \epsilon &gt; 0\)</span>,设可导点集为<span class="math inline">\(A\)</span>,则<span class="math inline">\(\exists n
, \sup_{ x \in A } ( f ( x ) - f_n ( x ) ) &lt; \epsilon\)</span>.</p>
<p>假设不一致收敛,此时<span class="math inline">\(\exists
x_0\)</span>使得<span class="math inline">\(f ( x_0 ) - f_n ( x_0 ) &gt;
4 \epsilon\)</span>.然而由于<span class="math inline">\(n\)</span>已经定死,所以现在<span class="math inline">\(f\)</span>和<span class="math inline">\(f_n\)</span>都是一致连续的,往旁边区间绕一下就行了.不管这个区间多小,由于<span class="math inline">\([ - \pi , \pi ] \setminus
A\)</span>是零测的,所以总有与<span class="math inline">\(A\)</span>的交.</p>
<p>从上面也可以看到,只要一个连续函数几乎处处可导,那它的傅里叶级数就可以一致逼近它.</p>
<h6><span id="example1">Example1</span></h6>
<p>设:</p>
<p><span class="math display">\[
\begin{aligned}
Q_{ m , n } &amp; &amp; = \sum_{ k = 1 }^n \frac{ \sin ( m + n - k ) x
}{ k } - \sum_{ k = 1 }^n \frac{ \sin ( m + n + k ) x }{ k } \\
&amp; &amp; = - 2 \cos ( m + n ) x \sum_{ v = 1 } \frac{ \sin ( vx ) }{
v }
\end{aligned}
\]</span></p>
<p>容易检查这个函数是有界的,只需:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ v = 1 }^n \frac{ \sin vx }{ v } &amp; &amp; = \int_0^x \sum_{ v =
1 }^n \cos vt \mathrm{ d } t \\
&amp; &amp; = \int_0^x ( - \frac{ 1 }{ 2 } + \frac{ \sin ( n + \frac{ 1
}{ 2 } ) t }{ 2 \sin \frac{ t }{ 2 } } ) \\
&amp; &amp; = - \frac{ x }{ 2 } + \int_0^x ( \frac{ 1 }{ 2 \sin \frac{ t
}{ 2 } } - \frac{ 1 }{ t } ) + \int_0^{ ( n + \frac{ 1 }{ 2 } ) x }
\frac{ \sin t }{ t } \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>这样用黎曼引理立刻见到其有界,存在常数<span class="math inline">\(C\)</span>使得<span class="math inline">\(| \sum_{
v = 1 }^n \frac{ \sin vx }{ v } | \leq C\)</span>,那<span class="math inline">\(| Q_{ n , m } | \leq 2 C\)</span>也有界.</p>
<p>定义<span class="math inline">\(m_k = n_k = 2^{ k^3
}\)</span>,取函数<span class="math inline">\(\varphi ( x ) = \sum_{ k =
1 }^\infty \frac{ 1 }{ k^2 } Q_{ m_k , n_k } ( x )\)</span>,既然<span class="math inline">\(Q_{ m_k , n_k
}\)</span>有界,根据大M判别法,这个东西当然一致收敛而且<span class="math inline">\(2 \pi\)</span>周期连续.</p>
<p>既然如此,考察<span class="math inline">\(\varphi ( x
)\)</span>是奇函数,它的傅里叶展开的确就是上述形式(原因是连续函数有唯一傅里叶展开).</p>
<p>接下来考虑其波动考虑由于我们的<span class="math inline">\(m_k = n_k =
2^{ k^3 }\)</span>,所以其实这里很稀疏的,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ 2 n_k - 1 } ( x ) - S_{ n_k - 1 } ( x ) &amp; = \frac{ 1 }{ k^2 }
\left ( \sum_{ l = 1 }^{ n_k } \frac{ \sin ( 2 n_k - l ) x }{ l } \right
)
\end{aligned}
\]</span></p>
<p>接下来带入<span class="math inline">\(x = \frac{ \pi }{ 4 n_k
}\)</span>,见到:</p>
<p><span class="math display">\[
\begin{aligned}
( S_{ 2 n_k - 1 } - S_{ n_k - 1 } ) ( \frac{ \pi }{ 4 n_k } ) &amp; &gt;
\frac{ \sqrt{ 2 } }{ 2 } \frac{ 1 }{ k^2 } ( \sum_{ l = 1 }^{ n_k }
\frac{ 1 }{ l } ) \\
&amp; &gt; \frac{ \sqrt{ 2 } }{ 2 } \frac{ 1 }{ k^2 } \ln n_k \\
&amp; &gt; \frac{ \sqrt{ 2 } \ln 2 }{ 2 } k \\
&amp; \to \infty
\end{aligned}
\]</span></p>
<p>因此见到不一致收敛,很厉害!</p>
<h5><span id="cesaro收敛">Cesaro收敛</span></h5>
<p>接下来我们引入<strong>Cesaro收敛</strong>的概念,回忆到Stolz定理给出若取定<span class="math inline">\(\sigma_n = \frac{ a_1 + \cdots + a_n }{ n
}\)</span>,回忆到如果<span class="math inline">\(a_n \to
a\)</span>,则<span class="math inline">\(\sigma_n \to
a\)</span>,然而反之未必成立.因此,<span class="math inline">\(\sigma_n\)</span>如果收敛的话,这是一个比<span class="math inline">\(a_n\)</span>收敛弱的条件.</p>
<p>在傅里叶级数这里也引入这个概念,我们不再研究<span class="math inline">\(S_n ( x )\)</span>的收敛性,而考虑<span class="math inline">\(\sigma_n ( x ) = \frac{ S_0 ( x ) + \cdots + S_n (
x ) }{ n + 1 }\)</span>的收敛性.考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\sigma_n ( x ) &amp; = \frac{ S_0 ( x ) + \cdots + S_n ( x ) }{ n + 1 }
\\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ \sum_{ k = 0 }^n \sin ( k + \frac{ 1 }{ 2 } ) t }{ 2 \sin \frac{
t }{ 2 } } \mathrm{ d } t \\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ 1 - \cos ( n + 1 ) t }{ 2 \sin^2 \frac{ t }{ 2 } } \mathrm{ d } t
\\
&amp; = \frac{ 1 }{ ( n + 1 ) \pi } \int_{ - \pi }^\pi f ( x + t )
\frac{ \sin^2 ( \frac{ n + 1 }{ 2 } t ) }{ 2 \sin^2 \frac{ t }{ 2 } }
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>设费叶核<span class="math inline">\(\phi_n ( t ) = \frac{ \sin^2
\frac{ n + 1 }{ 2 } t }{ 2 ( n + 1 ) \sin^2 \frac{ t }{ 2 }
}\)</span>.容易见到<span class="math inline">\(\phi_n ( t ) = \phi_n ( -
t )\)</span>,<span class="math inline">\(\phi ( 0 ) = \frac{ n + 1 }{ 2
}\)</span>,而且<span class="math inline">\(\frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \phi_n ( t ) \mathrm{ d } t = 1\)</span>,原因是<span class="math inline">\(\phi_n ( t
)\)</span>原本是个三角多项式,因此这里的积分只和其常数项有关,而常数项为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>现在我们说,当<span class="math inline">\(f ( x ) \equiv f ( x + 2 \pi
)\)</span>,<span class="math inline">\(f\)</span>在<span class="math inline">\([ - \pi , \pi ]\)</span>上绝对可积,并且<span class="math inline">\(f ( x_0 \pm 0 )\)</span>极限存在,则<span class="math inline">\(\lim_{ n \to \infty } \sigma_n ( x_n ) = \frac{ f
( x_0 + 0 ) + f ( x_0 - 0 ) }{ 2 }\)</span>.进一步,如果<span class="math inline">\(f \in C ( \mathbb{ R } )\)</span>,则<span class="math inline">\(\sigma_n ( x ) \rightrightarrows f ( x
)\)</span>.</p>
<p>考虑设<span class="math inline">\(I_n = \sigma_n ( x ) - \frac{ f ( x
+ 0 ) + f ( x - 0 ) }{ 2 }\)</span>,有:</p>
<p><span class="math display">\[
I_n = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \phi_n ( t ) ( f ( x + t ) +
f ( x - t ) - f ( x + 0 ) - f ( x - 0 ) ) \mathrm{ d } t
\]</span></p>
<p>此时考虑<span class="math inline">\(f ( x \pm 0
)\)</span>存在意味着<span class="math inline">\(\forall \epsilon &gt; 0
, \exists \delta &gt; 0\)</span>,使得当<span class="math inline">\(0
&lt; t \leq \delta\)</span>的时候,总有<span class="math inline">\(| f (
x \pm t ) - f ( x \pm 0 ) | &lt; \frac{ \epsilon }{ 2 \pi
}\)</span>,于是我们上面的<span class="math inline">\(I_n\)</span>就可以拆成<span class="math inline">\(\int_0^\delta +
\int_\delta^\pi\)</span>两部分.</p>
<p>对于前者:</p>
<p><span class="math display">\[
\frac{ 1 }{ \pi } | \int_0^\delta | \leq \frac{ \epsilon }{ 2 \pi }
\int_0^\pi \phi_n ( t ) \mathrm{ d } t &lt; \frac{ \epsilon }{ 2 }
\]</span></p>
<p>对于后者只要能控制<span class="math inline">\(\max_{ [ \delta , \pi ]
} \phi_n ( t )\)</span>就行,而这是显然的,因为当<span class="math inline">\(t \geq
\delta\)</span>的时候,分母就有下界了,让<span class="math inline">\(n \to
\infty\)</span>的时候当然趋近于<span class="math inline">\(0\)</span>.所以<span class="math inline">\(\lim_{
n \to \infty } I_n = 0\)</span>.</p>
<p>接下来的疑问是当<span class="math inline">\(f\)</span>连续时为何一致收敛,这当然是因为<span class="math inline">\(f\)</span>是一致连续的,那我上述唯一涉及<span class="math inline">\(x\)</span>的地方,也就是当<span class="math inline">\(f ( x \pm t ) \to f ( x
)\)</span>的部分就可以被控制住,这就搞定了.</p>
<p>Cesaro收敛的另一个好处在于,当<span class="math inline">\(f ( x + 0
)\)</span>和<span class="math inline">\(f ( x - 0
)\)</span>存在的时候,由于如果逐点收敛一定就能导出Cesaro收敛,因此,如果傅里叶级数在某一点处收敛,则它必然也在这一点处Cesaro收敛且收敛于同一个<span class="math inline">\(\frac{ f ( x + 0 ) + f ( x - 0 ) }{ 2
}\)</span>,换言之如果收敛则一定收敛于此.</p>
<h5><span id="平均收敛">平均收敛</span></h5>
<p>考虑如果一列函数<span class="math inline">\(f_n\)</span>,如果<span class="math inline">\(\int | f_n - f | \to
0\)</span>则我们称这列函数<strong>平均收敛</strong>到<span class="math inline">\(f\)</span>.一个平均收敛的函数列可以处处点不收敛,一个逐点收敛的函数也可能并不平均收敛(因为积分不一定收敛).</p>
<p>考虑定义<strong>平方可积函数</strong><span class="math inline">\(f\)</span>为几乎处处连续而且只有有限个瑕点的<span class="math inline">\(f\)</span>并且满足<span class="math inline">\(\int_{ - \pi }^\pi f^2 \mathrm{ d } x &lt;
\infty\)</span>.容易见到闭区间上的平方可积要强于绝对可积,原因正是柯西不等式:</p>
<p><span class="math display">\[
\int_{ - \pi }^\pi | f | \mathrm{ d } x \leq \sqrt{ ( \int_{ - \pi }^\pi
f^2 \mathrm{ d } x ) ( \int_{ - \pi }^\pi 1 \mathrm{ d } x ) }
\]</span></p>
<p>从而看到如果<span class="math inline">\(\int ( f_n - f )^2 \mathrm{ d
} x \to 0\)</span>则当然有<span class="math inline">\(\int | f_n - f |
\mathrm{ d } x \to 0\)</span>,因此我们往往计算前者.</p>
<p>假设<span class="math inline">\(f\)</span>是平方绝对可积的,考虑定义<span class="math inline">\(\mathcal{ F }_n\)</span>为<span class="math inline">\(n\)</span>阶三角多项式组成的集合,设<span class="math inline">\(S_n\)</span>是<span class="math inline">\(f\)</span>的傅里叶展开的前<span class="math inline">\(n\)</span>项,我们有:</p>
<ol type="1">
<li><p><span class="math inline">\(\int_{ - \pi }^\pi ( f - S_n )^2
\mathrm{ d } x = \min_{ T_n \in \mathcal{ F }_n } \int_{ - \pi }^\pi ( f
- T_n )^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>Bessel不等式</strong>:<span class="math inline">\(\frac{
a_0^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n^2 + b_n^2 ) \leq \frac{ 1 }{
\pi } \int_{ - \pi }^\pi f^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>Parseval等式</strong>:<span class="math inline">\(\frac{
a_0^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n^2 + b_n^2 ) = \frac{ 1 }{ \pi
} \int_{ - \pi }^\pi f^2 \mathrm{ d } x\)</span>.</p></li>
<li><p><strong>广义Parseval等式</strong>:设<span class="math inline">\(f
, g\)</span>都平方可积,则<span class="math inline">\(\frac{ 1 }{ \pi }
\int_{ - \pi }^\pi fg \mathrm{ d } x = \frac{ a_0 ( f ) a_0 ( g ) }{ 2 }
+ \sum_{ n = 1 }^\infty ( a_n ( f ) a_n ( g ) + b_n ( f ) b_n ( g )
)\)</span>.</p></li>
</ol>
<p>先看(1)和(2),假设<span class="math inline">\(T_n = \frac{ A_0 }{ 2 }
+ \sum_{ k = 1 }^n A_k \cos ( kx ) + B_k \sin ( kx )\)</span>,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \int_{ - \pi }^\pi ( f - T_n )^2 \mathrm{ d } x \\
= &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x + \pi \left ( \frac{ A_0^2
}{ 2 } + \sum_{ k = 1 }^n ( A_k^2 + B_k^2 ) \right ) - 2 \pi ( A_0
\frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n a_k A_k + b_k B_k ) \\
= &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x + \pi \left ( \frac{ ( A_0
- a_0 )^2 }{ 2 } + \sum_{ k = 1 }^n ( a_k - A_k )^2 + ( b_k - B_k )^2
\right ) - \pi \left ( \frac{ a_0^2 }{ 2 } + \sum_{ k = 1 }^n a_k^2 +
b_k^2 \right ) \\
\geq &amp; \int_{ - \pi }^\pi f^2 \mathrm{ d } x - \pi \left ( \frac{
a_0^2 }{ 2 } + \sum_{ k = 1 }^n a_k^2 + b_k^2 \right ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>等号成立当且仅当<span class="math inline">\(A_k = a_k , B_k =
b_k\)</span>,这样上述两者就都证毕.</p>
<p>再看(3),由(1)和(2),只需要证明对于平方可积函数总存在一列三角多项式<span class="math inline">\(T_n\)</span>使得<span class="math inline">\(\lim_{
n \to \infty } \int_{ - \pi }^\pi ( f - T_n )^2 \mathrm{ d } x =
0\)</span>即可.</p>
<p>当<span class="math inline">\(f\)</span>是黎曼可积的时候这里较为平凡,只需要先用连续函数<span class="math inline">\(g\)</span>逼近<span class="math inline">\(f\)</span>,再用三角多项式逼近<span class="math inline">\(g\)</span>即可.最终因为有<span class="math inline">\(( T - f )^2 \leq 2 ( T - g )^2 + 2 ( f - g
)^2\)</span>就行.顺便一提这个不等式还可以证明平方可积的函数的和差也一定是平方可积.</p>
<p>接下来要把瑕点给处理掉,由于平方可积,所以瑕点那里的积分会足够小,直接把那一段抹平成<span class="math inline">\(0\)</span>就行.抹平了后的函数可以被逼近,而抹平带来的影响又很小,这就搞定了.</p>
<p>再看(4),对<span class="math inline">\(( f + g )\)</span>和<span class="math inline">\(( f - g
)\)</span>分别做Parseval等式,然后用它们一作差就能证明此结论.</p>
<p>关于Bessel不等式和Parseval等式,一个更好的理解是它体现了正交基上的操作,Bessel不等式说对于一组正交基我们总有<span class="math inline">\(\Vert u \Vert^2 \leq \sum_k ( u | e_k
)^2\)</span>成立.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:函数<span class="math inline">\(f , g\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>上黎曼可积,则它们的傅里叶级数相同的充分必要条件是<span class="math inline">\(\int_{ - \pi }^\pi | f - g | \mathrm{ d } x =
0\)</span>.</p>
<p>先证明充分性,比较显然:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \int_{ - \pi }^\pi ( f - g ) \sin ( nx ) \mathrm{ d } x | \\
\leq &amp; \int_{ - \pi }^\pi | f - g | \mathrm{ d } x
\end{aligned}
\]</span></p>
<p>再证必要性,也很显然,考虑如果傅里叶级数相同,则Parseval等式必有<span class="math inline">\(\int f^2 \mathrm{ d } x = \int g^2 \mathrm{ d } x
= \int fg \mathrm{ d } x\)</span>,这说明<span class="math inline">\(\int
( f - g )^2 \mathrm{ d } x = 0\)</span>,立刻推出<span class="math inline">\(\int | f - g | \mathrm{ d } x = 0\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:当<span class="math inline">\(b_n\)</span>单调递减趋近于<span class="math inline">\(0\)</span>的时候,如果<span class="math inline">\(\sum \frac{ b_n }{ n } &lt;
\infty\)</span>,则<span class="math inline">\(f ( x ) = \sum b_n \sin (
nx )\)</span>在<span class="math inline">\([ - \pi , \pi
]\)</span>上绝对可积.</p>
<p>不妨设<span class="math inline">\(x \in [ - \pi , \pi
]\)</span>,首先考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + m } \sin ( kx ) | \\
= &amp; | \frac{ \cos ( n + m + \frac{ 1 }{ 2 } ) - \cos ( n + \frac{ 1
}{ 2 } ) }{ 2 \sin \frac{ x }{ 2 } } | \\
\leq &amp; \frac{ 1 }{ | \sin \frac{ x }{ 2 } | }
\end{aligned}
\]</span></p>
<p>此时考虑设<span class="math inline">\(S_m = \sum_{ k = n + 1 }^{ m }
\sin ( kx )\)</span>,取<span class="math inline">\(x \in [ \frac{ \pi }{
n + 1 } , \frac{ \pi }{ n } ]\)</span>,用Abel变换立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ k = n + 1 }^{ n + m } b_k \sin ( kx ) | \\
= &amp; | \sum_{ k = n + 1 }^{ n + m } b_k ( S_{ k } - S_{ k - 1 } ) |
\\
= &amp; | \sum_{ k = n + 1 }^{ n + m - 1 } ( b_{ k } - b_{ k + 1 } ) S_{
k } - b_{ n + 1 } S_{ n } + b_{ n + m } S_{ n + m } | \\
= &amp; | \sum_{ k = n + 1 }^{ n + m - 1 } ( b_{ k } - b_{ k + 1 } ) S_{
k } + b_{ n + m } S_{ n + m } | \\
\leq &amp; \frac{ b_n }{ | \sin \frac{ x }{ 2 } | } \\
\leq &amp; \frac{ \pi }{ x } b_{ n + 1 } \\
\leq &amp; ( n + 1 ) b_n
\end{aligned}
\]</span></p>
<p>这里已经和<span class="math inline">\(m\)</span>没有关系了,既然如此考虑取<span class="math inline">\(B_n = \sum_{ k = 1 }^n b_k\)</span>,自然有:</p>
$$
<span class="math display">\[\begin{aligned}
\int_0^\pi | f | \mathrm{ d x } &amp; = \sum_{ n = 1 }^\infty \int_{
\frac{ \pi }{ n + 1 } }^{ \frac{ \pi }{ n } } | f | \mathrm{ d } x \\
&amp; \leq \sum_{ n = 1 }^\infty \int_{ \frac{ \pi }{ n + 1 } }^{ \frac{
\pi }{ n } } ( B_n + ( n + 1 ) b_n ) \mathrm{ d } x \\
&amp; = \sum_{ n = 1 }^\infty \frac{ \pi }{ n ( n + 1 ) } ( B_n + ( n +
1 ) b_n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时只需检验<span class="math inline">\(\sum \frac{ B_n }{ n ( n + 1
) }\)</span>收敛就行了对吧.这个比较平凡:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 1 }^\infty \frac{ B_n }{ n ( n + 1 ) } &amp; = \sum_{ n = 1
}^\infty \frac{ 1 }{ n ( n + 1 ) } \sum_{ k = 1 } b_k \\
&amp; = \sum_{ k = 1 }^\infty b_k \sum_{ n = k }^\infty \frac{ 1 }{ n (
n + 1 ) } \\
&amp; = \sum_{ k = 1 }^\infty \frac{ b_k }{ k } \\
&amp; &lt; \infty
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<h5><span id="逐项积分">逐项积分</span></h5>
<p>设<span class="math inline">\(f\)</span>绝对可积,其傅里叶级数为<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n
\sin ( nx )\)</span>,考虑取<span class="math inline">\(F ( x ) =
\int_0^x ( f ( t ) - \frac{ a_0 }{ 2 } ) \mathrm{ d }
t\)</span>,容易检查<span class="math inline">\(F ( x
)\)</span>是有界变差的,原因是<span class="math inline">\(\sum | F ( x_i
) - F ( x_{ i - 1 } ) | = \sum | \int_{ x_{ i - 1 } }^{ x_i } f ( t )
\mathrm{ d } t | \leq \int | f |\)</span>.</p>
<p>既然如此,它就会被它的傅里叶级数一致逼近,不妨记作<span class="math inline">\(F ( x ) = \frac{ A_0 }{ 2 } + \sum_{ n = 1
}^\infty A_n \cos ( nx ) + B_n \sin ( nx )\)</span>.</p>
<p>接下来考虑把这些系数都求出来,先令<span class="math inline">\(x =
0\)</span>求出<span class="math inline">\(\frac{ A_0 }{ 2 } + \sum_{ n =
1 }^\infty A_n = 0\)</span>,当<span class="math inline">\(n \geq
1\)</span>的时候,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
A_n &amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi F ( x ) \cos ( nx )
\mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } F ( x ) \frac{ \sin ( nx ) }{ n } |_{ - \pi
}^\pi - \frac{ 1 }{ n \pi } \int_{ - \pi }^\pi f ( x ) \sin ( nx )
\mathrm{ d } x \\
&amp; = - \frac{ b_n }{ n }
\end{aligned}
\]</span></p>
<p>注意这里用的分部积分是广义分部积分,我们曾经搞过.</p>
<p>同理<span class="math inline">\(B_n = \frac{ a_n }{ n
}\)</span>,补一个<span class="math inline">\(x\)</span>的傅里叶级数进去,于是我们见到:</p>
<p><span class="math display">\[
\int_0^x f ( t ) \mathrm{ d } t = \frac{ a_0 }{ 2 } x + \sum_{ n = 1
}^\infty a_n \int_0^x \cos ( nt ) \mathrm{ d } t + b_n \int_0^x \sin (
nt ) \mathrm{ d } t
\]</span></p>
<p>也就是一个函数和傅里叶级数逐项积分后总相等.</p>
<h5><span id="逐项微分">逐项微分</span></h5>
<p>设<span class="math inline">\(f\)</span>可导而且是<span class="math inline">\(2 \pi\)</span>周期的,并且<span class="math inline">\(\int_{ - \pi }^\pi | f &#39; | \mathrm{ d } x &lt;
\infty\)</span>,那由逐项积分那里的结论,自然有<span class="math inline">\(a_0 ( f &#39; ) = 0 , a_n ( f &#39; ) = nb_n ( f )
, b_n ( f &#39; ) = - na_n ( f )\)</span>,也就是当:<span class="math inline">\(f = \frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n
\sin ( nx )\)</span>,则<span class="math inline">\(f &#39; \sim \sum -
na_n \sin ( nx ) + nb_n \cos ( nx )\)</span>.</p>
<h5><span id="收敛速度的估计">收敛速度的估计</span></h5>
<p>最后来分析一下它的收敛能力,不妨假设<span class="math inline">\(f\)</span>是<span class="math inline">\(2
\pi\)</span>周期逐段可导函数,并且<span class="math inline">\(\int_{ -
\pi }^{ \pi } ( f &#39; )^2 \mathrm{ d } x &lt; \infty\)</span>,则<span class="math inline">\(\max | f ( x ) - S_n ( x ) | = o ( \frac{ 1 }{
\sqrt{ n } } )\)</span>,原因是由Parseval等式,有:</p>
<p><span class="math display">\[
\frac{ 1 }{ \pi } \int_{ - \pi }^\pi ( f &#39; )^2 \mathrm{ d } x =
\frac{ a_0 ( f &#39; )^2 }{ 2 } + \sum_{ n = 1 }^\infty ( a_n ( f &#39;
)^2 + b_n ( f &#39; )^2 )
\]</span></p>
<p>也就是后面这个级数收敛对吧,那柯西准则给出:</p>
<p><span class="math display">\[
\sum_{ k = n + 1 }^\infty ( a_k ( f &#39; )^2 + b_k ( f &#39; )^2 ) = o
( 1 )
\]</span></p>
<p>现在来看误差项:</p>
<p><span class="math display">\[
\begin{aligned}
| f ( x ) - S_n ( x ) | &amp; \leq | \sum_{ k = n + 1 }^\infty a_k ( f )
\cos ( kx ) + b_k ( f ) \sin ( kx ) | \\
&amp; \leq \sum_{ k = n + 1 }^\infty | a_k ( f ) | + | b_k ( f ) | \\
&amp; = \sum_{ k = n + 1 }^\infty \frac{ | a_k ( f &#39; ) | + | b_k ( f
&#39; ) | }{ k } \\
&amp; \leq \sqrt{ \sum_{ k = n + 1 }^\infty | a_k ( f &#39; )^2 | + |
b_k ( f &#39; )^2 | } \sqrt{ \sum_{ k = n + 1 }^\infty \frac{ 1 }{ k^2 }
} \\
&amp; = o ( 1 ) \frac{ 1 }{ \sqrt{ n } }
\end{aligned}
\]</span></p>
<h5><span id="复数形式">复数形式</span></h5>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \sim \frac{ a_0 }{ 2 } + \sum a_n \cos ( nx ) + b_n \sin (
nx ) \\
&amp; = \frac{ a_0 }{ 2 } + \sum a_n \frac{ e^{ inx } + e^{ - inx } }{ 2
} + \sum b_n \frac{ e^{ inx } - e^{ - inx } }{ 2 i } \\
&amp; = \sum_{ n = - \infty }^\infty c_n e^{ inx }
\end{aligned}
\]</span></p>
<p>此时有<span class="math inline">\(c_n = \frac{ 1 }{ 2 \pi } \int_{ -
\pi }^\pi f ( x ) e^{ - inx } \mathrm{ d } x\)</span>.</p>
<h5><span id="三角级数的唯一性问题">三角级数的唯一性问题</span></h5>
<p>接下来来解决点看上去很平凡的问题,如果:</p>
<p><span class="math display">\[
\frac{ a_0 }{ 2 } + \sum_{ n = 1 }^\infty a_n \cos ( nx ) + b_n \sin (
nx ) = \frac{ \tilde{ a_0 } }{ 2 } + \sum_{ n = 1 }^\infty \tilde{ a_n }
\cos ( nx ) + \tilde{ b_n } \sin ( nx )
\]</span></p>
<p>而且左右两端都收敛到某个函数.能否导出<span class="math inline">\(a_n
= \tilde{ a_n } , b_n = \tilde{ b_n
}\)</span>.注意这里并不能两遍乘个<span class="math inline">\(\cos ( nx
)\)</span>然后积分,因为未必可积.</p>
<p>我们下面可以证明,如果上面这种相等除了至多可数个点以外都成立,那就是同一个三角级数.当然只需要证明当:</p>
<p><span class="math display">\[
\frac{ a_0 }{ 2 } + \sum_{ n = 1 }^\infty a_n \cos ( nx ) + b_n \sin (
nx ) = 0
\]</span></p>
<p>至多除了一个可数集合<span class="math inline">\(E = \{ x_1 , x_2 ,
\cdots \}\)</span>以外成立的时候有<span class="math inline">\(a_n = b_n
= 0\)</span>即可.</p>
<p>先来证明一个引理:此时<span class="math inline">\(\lim_{ n \to \infty
} a_n = \lim_{ n \to \infty } b_n =
0\)</span>.这还并不显然,因为这个三角级数并不一定是傅里叶级数.</p>
<p>首先级数收敛,通项趋近于<span class="math inline">\(0\)</span>,首先设<span class="math inline">\(\rho_n = \sqrt{ a_n^2 + b_n^2 }\)</span>,则<span class="math inline">\(a_n \cos ( nx ) + b_n \sin ( nx ) = \rho_n \sin (
nx + \varphi_n )\)</span>.现在只需要证明<span class="math inline">\(\lim_{ n \to \infty } \rho_n = 0\)</span>.</p>
<p>反证,如果没有上述结论,则总存在一个无穷子列<span class="math inline">\(\{ \rho_{ n_k } \}_k\)</span>大于某一个正常数<span class="math inline">\(c\)</span>,设其指标集合为<span class="math inline">\(F = \{ n_1 &lt; n_2 &lt; \cdots \}\)</span>.</p>
<p>现在考虑<span class="math inline">\([ 0 , 2 \pi
]\)</span>上,找一个区间<span class="math inline">\(I_1 = [ l_1 , r_1
]\)</span>使得其不含有<span class="math inline">\(x_1\)</span>,由于<span class="math inline">\(F\)</span>通项肯定趋近无穷大,总能找到一个<span class="math inline">\(m_1 \in F\)</span>,使得<span class="math inline">\(| [ m_1 l_1 , m_1 r_1 ] | = m_1 | I_1 | &gt; 2
\pi\)</span>.既然它的区间长度足够大,那其中总有一个子区间<span class="math inline">\(J_1 \subseteq I_1\)</span>,使得<span class="math inline">\(\sin ( m_1 x + \varphi_{ m_1 } ) &gt; \frac{ 1 }{
2 }\)</span>在<span class="math inline">\(J_1\)</span>上成立.那我当然可以再找一个子区间<span class="math inline">\(I_2 \subseteq J_1\)</span>使得<span class="math inline">\(I_2\)</span>中不含有<span class="math inline">\(x_2\)</span>,重复以上操作,这就是一个闭区间套.最后套出来了一个点<span class="math inline">\(w \notin E\)</span>,此时<span class="math inline">\(\sin ( m_k w + \varphi_{ m_k } ) &gt; \frac{ 1 }{
2 }\)</span>,自然有<span class="math inline">\(\varphi_{ m_k } \sin (
m_k w + \varphi_{ m_k } ) &gt; \frac{ c }{ 2
}\)</span>,这立刻导出矛盾.</p>
<p>再来一个引理:假设<span class="math inline">\(F ( x ) \in C ( a , b
)\)</span>,可数集合<span class="math inline">\(E \subseteq ( a , b
)\)</span>.定义其<strong>二阶差分</strong>为<span class="math inline">\(\Delta_h^2 F ( x ) = F ( x + 2 h ) + F ( x - 2 h )
- 2 F ( x )\)</span>.已知其<strong>广义二阶导数</strong><span class="math inline">\(\delta^2 F = \varlimsup_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \geq 0 , \forall x \notin
E\)</span>,而<span class="math inline">\(\varlimsup_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ h } \geq 0 , \forall x \in
E\)</span>.则结论是<span class="math inline">\(F ( x
)\)</span>是一个下凸函数.</p>
<p>这个结论的自然之处在于如果<span class="math inline">\(F &#39; &#39; (
x )\)</span>存在,那<span class="math inline">\(F ( x + 2 h ) = F ( x ) +
F &#39; ( x ) 2 h + \frac{ F &#39; &#39; ( x ) }{ 2 } ( 2 h )^2 + o (
h^2 )\)</span>并且<span class="math inline">\(F ( x - 2 h ) = F ( x ) -
F &#39; ( x ) 2 h + \frac{ F &#39; &#39; ( x ) }{ 2 } ( 2 h )^2 + o (
h^2 )\)</span>,所以上面那个<span class="math inline">\(\delta^2 F = F
&#39; &#39; ( x )\)</span>,那如果它非负当然是下凸函数.</p>
<p>那如果<span class="math inline">\(F &#39; &#39; ( x
)\)</span>不存在呢?反证,假设<span class="math inline">\(F\)</span>不凸,则一定存在一个子区间<span class="math inline">\(( \alpha , \beta ) \subseteq ( a , b
)\)</span>,使得在这个区间上,<span class="math inline">\(F ( x
)\)</span>函数在<span class="math inline">\(( \alpha , \beta
)\)</span>这条弦之上(因为连续性,至少有三个点是违背三弦定理的,作一条弦后,函数有一些部分在上面有一些部分在下面,取某个恒在上面的子区间即可).</p>
<p>总之,我们找到了一个子区间<span class="math inline">\(( \alpha , \beta
)\)</span>使得:</p>
<p><span class="math display">\[
F ( x ) - \left ( \frac{ F ( \beta ) - F ( \alpha ) }{ \beta - \alpha }
( x - \alpha ) + F ( \alpha ) \right ) &gt; 0
\]</span></p>
<p>接下来要推矛盾,分成两种情况:</p>
<p>第一种情况是<span class="math inline">\(\delta^2 F &gt;
0\)</span>的情形,考虑辅助函数<span class="math inline">\(G_\mu ( x ) = F
( x ) - ( \mu ( x - a ) + F ( \alpha ) )\)</span>,其中<span class="math inline">\(\mu = \frac{ F ( \beta ) - F ( \alpha ) }{ \beta -
\alpha } +
\epsilon\)</span>,也就是比原本那条弦的斜率稍微大了一点点,那只要<span class="math inline">\(\epsilon\)</span>落在某个足够小的区间内,<span class="math inline">\(G_\mu ( x )\)</span>仍然有大于零的部分.直接取<span class="math inline">\(G_\mu ( x_0 ( \mu ) ) = \max_{ [ \alpha , \beta ]
} G_\mu\)</span>,此时观察到<span class="math inline">\(G_\mu\)</span>和<span class="math inline">\(F\)</span>只差一个一次函数,它们作二阶差分后就相等了,然而,由于<span class="math inline">\(G_\mu ( x_0 ( \mu ) )\)</span>取的是最大值,当<span class="math inline">\(h\)</span>取足够小的时候,它的二阶差分一定小于等于<span class="math inline">\(0\)</span>,因此能导出<span class="math inline">\(x_0 ( \mu ) \in E\)</span>,并且同理能导出<span class="math inline">\(\varlimsup_{ h \to + 0 } \frac{ \Delta_h^2 F ( x_0
( \mu ) ) }{ h } = 0\)</span>.从而导出:</p>
<p><span class="math display">\[
\varlimsup_{ h \to + 0 } \frac{ G_\mu ( x_0 ( \mu ) - 2 h ) - G_\mu (
x_0 ( \mu ) ) }{ h } = \varlimsup_{ h \to + 0 } \frac{ G_\mu ( x_0 ( \mu
) + 2 h ) - G_\mu ( x_0 ( \mu ) ) }{ h } = 0
\]</span></p>
<p>欸,你怎么变一阶差分了,那我的一次函数不就有用了么,必定有:</p>
<p><span class="math display">\[
\varlimsup_{ h \to + 0 } \frac{ F ( x_0 ( \mu ) - 2 h ) - F ( x_0 ( \mu
) ) }{ h } = 2 \mu
\]</span></p>
<p>所以<span class="math inline">\(\mu \to x_0 ( \mu
)\)</span>为单射,这与<span class="math inline">\(x_0 ( \mu ) \in
E\)</span>矛盾.</p>
<p>那么等于<span class="math inline">\(0\)</span>的情况呼之欲出了对吧,此时任意的<span class="math inline">\(n\)</span>都可以做到<span class="math inline">\(F
( x ) + \frac{ x^2 }{ n }\)</span>是凸的,随便搞个反证法就可以知道<span class="math inline">\(F ( x )\)</span>必定是凸的.</p>
<p>最后来设<span class="math inline">\(F ( x ) = \frac{ a_0 }{ 4 } x^2 -
\sum_{ n = 1 }^\infty \frac{ a_n \cos ( nx ) + b_n \sin ( nx ) }{ n^2
}\)</span>,由于<span class="math inline">\(a_n \to 0 , b_n \to
0\)</span>,所以这玩意用大M判别法知道绝对一致收敛,那就是一个连续函数.</p>
<p>此时计算:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta_h^2 F ( x ) &amp; = \frac{ a_0 }{ 4 } ( ( x + 2 h )^2 + ( x - 2 h
)^2 - 2 x^2 ) \\
&amp; - \sum_{ n = 1 }^\infty \frac{ 1 }{ n^2 } ( a_n ( \cos ( n ( x + 2
h ) ) + \cos ( n ( x - 2 h ) ) - 2 \cos ( nx ) ) \\
&amp; + b_n ( \sin ( n ( x + 2 h ) ) + \sin ( n ( x - 2 h ) ) - 2 \sin (
nx ) ) ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>而此时对后面的部分用和差化积,留神到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \cos ( n ( x + 2 h ) ) + \cos ( n ( x - 2 h ) ) - 2 \cos ( nx ) \\
= &amp; 2 \cos ( nx ) \cos ( 2 nh ) - 2 \cos ( nx ) \\
= &amp; 2 \cos ( nx ) ( \cos ( 2 nh ) - 1 ) \\
= &amp; - 4 \cos ( nx ) \sin^2 ( nh )
\end{aligned}
\]</span></p>
<p>于是:</p>
<p><span class="math display">\[
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } = \frac{ a_0 }{ 2 } + \sum_{ n = 1
}^\infty ( a_n \cos ( nx ) + b_n \sin ( nx ) ) ( \frac{ \sin ( nh ) }{
nh } )^2
\]</span></p>
<p>乍一看已经要完事了对吧!很可惜并没有,因为这个<span class="math inline">\(n \to
\infty\)</span>了,我们还需要证明下面这个引理:当<span class="math inline">\(\sum_{ n = 1 }^\infty a_n =
s\)</span>收敛的时候,那么<span class="math inline">\(\lim_{ h \to 0 + }
\sum_{ n = 1 }^\infty a_n ( \frac{ \sin ( nh ) }{ nh } )^2 =
s\)</span>.</p>
<p>最难过的是这里的<span class="math inline">\(a_n\)</span>不定号,我们可能第一反应是前部分可以让<span class="math inline">\(n \to
\infty\)</span>而后半部分可以直接抛掉,可在不定号的时候这一切都难以实现了.对于不定号项的求和,我们也许唯一的武器只有Abel变换.设<span class="math inline">\(a_0 = 0 , b_n ( h ) = ( \frac{ \sin ( nh ) }{ nh }
)^2 , b_0 ( h ) = 1 , S_n = \sum_{ k = 1 }^n a_k\)</span>.立刻得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ n = 0 }^\infty a_n b_n ( h ) &amp; = \sum_{ n = 1 }^\infty ( S_n
- S_{ n - 1 } ) b_n ( h ) \\
&amp; = \sum_{ n = 0 }^\infty S_n ( b_n ( h ) - b_{ n + 1 } ( h ) )
\end{aligned}
\]</span></p>
<p>既然<span class="math inline">\(S_n\)</span>收敛,不妨设<span class="math inline">\(| S_n | &lt; M\)</span>,下面来估计:</p>
$$
<span class="math display">\[\begin{aligned}
| b_{ n + 1 } ( h ) - b_{ n } ( h ) | &amp; = | \int_{ nh }^{ ( n + 1 )
h } ( \frac{ \sin^2 t }{ t^2 } ) &#39; \mathrm{ d } t | \\
&amp; \leq \int_{ nh }^{ ( n + 1 ) h } | \frac{ 2 \sin t ( \cos t -
\frac{ \sin t }{ t } ) }{ t^2 } | \mathrm{ d } t \\
\sum | b_{ n + 1 } ( h ) - b_{ n } ( h ) | &amp; \leq \int_{ 0 }^{ +
\infty } | \frac{ 2 \sin t ( \cos t - \frac{ \sin t }{ t } ) }{ t^2 } |
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>盯着这个积分,发现其在<span class="math inline">\(0\)</span>附近极限存在(泰勒展开就能看到),而在无穷处其实就是<span class="math inline">\(O ( \frac{ 1 }{ t^2 }
)\)</span>,所以这个积分存在,当然有<span class="math inline">\(\sum | b_{
n + 1 } ( h ) - b_{ n } ( h ) | \leq +
\infty\)</span>,其实上面的过程就是在证明这个函数是有界变差的对吧!准备工作业已就绪,不妨设<span class="math inline">\(\varphi_n = b_n ( h ) - b_{ n + 1 } ( h
)\)</span>,请看:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | \sum_{ n = 0 }^\infty a_n b_n ( h ) - s | \\
= &amp; | \sum_{ n = 0 }^\infty ( s_n \varphi_n ( h ) - s \varphi_n ( h
) ) | \\
\leq &amp; \sum_{ n = 0 }^N | S_n - s | \cdot | \varphi_n ( h ) | +
\sum_{ n = N + 1 }^\infty | S_n - s | \cdot | \varphi_n ( h ) |
\end{aligned}
\]</span></p>
<p>只要取定足够大的<span class="math inline">\(N\)</span>就可以使得<span class="math inline">\(| S_n - s | \to 0\)</span>,而在此时只要让<span class="math inline">\(h \to 0\)</span>就可以让前半部分定死的<span class="math inline">\(\varphi_n ( h ) \to 0\)</span>,于是就搞定了.</p>
<p>从而我们可以看到上述引理的确成立了,进一步地两个上极限都等于<span class="math inline">\(0\)</span>,所以<span class="math inline">\(F ( x
)\)</span>的确是下凸函数,然而正是因为等于<span class="math inline">\(0\)</span>,所以<span class="math inline">\(- F ( x
)\)</span>也是下凸函数,所以<span class="math inline">\(F ( x
)\)</span>既是上凸,又是下凸,那它必然是一个一次函数.那<span class="math inline">\(a_0 = 0\)</span>就是必然的了.既然<span class="math inline">\(a_0 = 0\)</span>,<span class="math inline">\(F ( x
)\)</span>就是一个<span class="math inline">\(2
\pi\)</span>周期函数,所以它必然是常值函数.然而一个三角级数一致收敛到一个常值函数,这个三角级数本身必然是常值函数,所以<span class="math inline">\(a_n = b_n = 0\)</span>,这就搞定了.</p>
<h5><span id="傅里叶级数的最佳逼近性">傅里叶级数的最佳逼近性</span></h5>
<p>下面我们想证明:傅里叶级数是最佳逼近,如果一个三角级数处处收敛到了一个黎曼可积函数,则这个三角级数就是这个函数的傅里叶级数.(事实上这个结论在绝对可积时也是对的,甚至可以有有限个点不收敛到它)</p>
<p>不妨设<span class="math inline">\(f \in R [ - \pi , \pi
]\)</span>,有界<span class="math inline">\(m \leq f \leq
M\)</span>.三角级数<span class="math inline">\(\frac{ a_0 }{ 2 } + \sum
a_n \cos ( nx ) + b_n \sin ( nx
)\)</span>逐点逼近于它本身.我们上面引入的也就是<span class="math inline">\(\delta^2 F ( x_0 ) = f ( x_0 )\)</span>.</p>
<p>来引入一个引理:如果<span class="math inline">\(\forall x_0 \in ( a ,
b ) , \delta^2 F = \lim_{ h \to + 0 } \frac{ \Delta_h^2 F }{ 4 h^2 } \in
[ m , M ]\)</span>,则不加极限的情况,<span class="math inline">\(\forall
x_0 \in ( a + h , b - h ) , h &gt; 0 , \frac{ \Delta_h^2 F }{ 4 h^2 }
\in [ m , M ]\)</span>.</p>
<p>我想这应该是平凡的,方向呼之欲出:使用介值定理.不过这里是二次函数,那我们就取定<span class="math inline">\(F ( x_0 ) , F ( x_0 \pm 2 h
)\)</span>三个点,过这三个点做一个二次函数.事实上这个二次函数就是<span class="math inline">\(\varphi ( x ) = F ( x_0 ) + ( x - x_0 ) \frac{ F (
x_0 + 2 h ) - F ( x_0 - 2 h ) }{ 4 h } + \frac{ ( x - x_0 )^2 }{ 2 }
\frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 }\)</span>.取<span class="math inline">\(g ( x ) = F ( x ) - \varphi ( x )\)</span>,则<span class="math inline">\(g ( x )\)</span>会在<span class="math inline">\(x_0 , x_0 \pm 2 h\)</span>取值为<span class="math inline">\(0\)</span>,并且其在<span class="math inline">\((
x_0 - 2 h , x_0 + 2 h )\)</span>上肯定有一个最大值<span class="math inline">\(x_1\)</span>和一个最小值<span class="math inline">\(x_2\)</span>,在前者的广义二阶导数<span class="math inline">\(\leq 0\)</span>而后者<span class="math inline">\(\geq 0\)</span>,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\delta^2 F ( x_1 ) - \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } &amp; \leq 0
\leq \delta^2 F ( x_2 ) - \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } \\
m &amp; \leq \frac{ \Delta_h^2 F ( x_0 ) }{ 4 h^2 } \leq M
\end{aligned}
\]</span></p>
<p>现在我们就知道如何做了,回忆到:</p>
<p><span class="math display">\[
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } = \frac{ a_0 }{ 2 } + \sum_{ n = 1
}^\infty ( a_n \cos ( nx ) + b_n \sin ( nx ) ) ( \frac{ \sin ( nh ) }{
nh } )^2
\]</span></p>
<p>当我不取<span class="math inline">\(h \to
0\)</span>的时候这个两边可是一致收敛的.那右边肯定是前边的傅里叶级数,立刻有:</p>
$$
<span class="math display">\[\begin{aligned}
a_n ( \frac{ \sin ( nh ) }{ nh } )^2 &amp; = \frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d }
x \\
b_n ( \frac{ \sin ( nh ) }{ nh } )^2 &amp; = \frac{ 1 }{ \pi } \int_{ -
\pi }^\pi \frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \sin ( nx ) \mathrm{ d }
x \\

\end{aligned}\]</span>
<p>$$</p>
<p>那我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
a_n &amp; = \lim_{ h \to + 0 } a_n ( \frac{ \sin ( nh ) }{ nh } )^2 \\
&amp; = \lim_{ h \to + 0 } \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>然而此时<span class="math inline">\(\frac{ \Delta_h^2 F ( x ) }{ 4
h^2 } \in [ m , M ]\)</span>,后面积分那个东西有界.欸,取<span class="math inline">\(h = \frac{ 1 }{ n } \to
0\)</span>可以拿到一个一致有界的函数列,这不是我们控制收敛定理么,交换顺序!</p>
$$
<span class="math display">\[\begin{aligned}
a_n &amp; = \lim_{ h \to + 0 } \frac{ 1 }{ \pi } \int_{ - \pi }^\pi
\frac{ \Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi \lim_{ h \to + 0 } \frac{
\Delta_h^2 F ( x ) }{ 4 h^2 } \cos ( nx ) \mathrm{ d } x \\
&amp; = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( x ) \cos ( nx )
\mathrm{ d } x \\

\end{aligned}\]</span>
<p>$$</p>
<p>这就证毕了.</p>
<h5><span id="傅里叶级数不逐点收敛到自身的连续周期函数">傅里叶级数不逐点收敛到自身的连续周期函数</span></h5>
<p>定义<span class="math inline">\(C ( T )\)</span>为<span class="math inline">\(2
\pi\)</span>周期连续函数组成的线性空间.此时定义<span class="math inline">\(\Vert f - g \Vert = \sup | f - g
|\)</span>,其实也就是Banach空间对吧.有了范数定义距离,有了距离就可以有开闭集的概念.Baire纲定理告诉我们此时可数个开稠集的交集仍然是稠密集(不过未必是开集).</p>
<p>现在考虑<span class="math inline">\(f ( x
)\)</span>的傅里叶级数,取<span class="math inline">\(S_n ( f , x ) =
\frac{ a_0 }{ 2 } + \sum_{ k = 1 }^n a_k \cos ( kx ) + b_k \sin ( kx
)\)</span>,迪利克雷核的结论告诉我们<span class="math inline">\(S_n ( f ,
x ) = \frac{ 1 }{ \pi } \int_{ - \pi }^\pi f ( t ) D_n ( x - t )
\mathrm{ d } t\)</span>,其中<span class="math inline">\(D_n ( w ) =
\frac{ \sin ( n + \frac{ 1 }{ 2 } ) w }{ 2 \sin \frac{ w }{ 2 }
}\)</span>.</p>
<p>接下来定义<span class="math inline">\(\varphi_f ( x ) = \sup_{ n \geq
1 } | S_n ( f , x ) |\)</span>,取<span class="math inline">\(E_m ( x ) =
\{ f \in C ( T ) | \varphi_f ( x ) &gt; m
\}\)</span>.下面我们来证明:<span class="math inline">\(E_m ( x
)\)</span>是<span class="math inline">\(C ( T )\)</span>的开稠子集.</p>
<p>是开集应该是自然的结论,因为当<span class="math inline">\(n ,
x\)</span>定死的时候,<span class="math inline">\(S_n ( f , x
)\)</span>从定义看是连续地依赖于<span class="math inline">\(f\)</span>.如果<span class="math inline">\(f \in
E_m ( x )\)</span>,则<span class="math inline">\(\exists n , | S_n ( f ,
x ) | &gt; m\)</span>,那它周围当然有一个小邻域,使得其中的<span class="math inline">\(g\)</span>都满足<span class="math inline">\(| S_n
( g , x ) | &gt; m\)</span>了,所以这肯定是开集.</p>
<p>接下来得证明它是稠集,定义<span class="math inline">\(g_n ( t ) =
\begin{cases}1 &amp; D_n ( t ) \geq 1 \\ - 1 &amp; D_n ( t ) \leq - 1 \\
D_n ( t ) &amp; \text{ otherwise }\end{cases}\)</span>.此时发现:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \frac{ 1 }{ \pi } \int_{ - \pi }^\pi g_n ( t ) D_n ( t ) \mathrm{
d } t \\
= &amp; O ( 1 ) + \frac{ 1 }{ \pi } \int_{ - \pi }^\pi | D_n ( t ) |
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>原因是<span class="math inline">\(| D_n ( t ) | \geq
1\)</span>的部分二者相等,而不同的部分在有限区间上积分不会太大.</p>
<p>然而:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \frac{ 1 }{ \pi } \int_{ - \pi }^\pi | D_n ( t ) | \mathrm{ d } t
\\
= &amp; \frac{ 2 }{ \pi } \int_0^\pi | D_n ( t ) | \mathrm{ d } t \\
= &amp; \frac{ 1 }{ \pi } \int_0^\pi | \frac{ \sin ( n + \frac{ 1 }{ 2 }
) t }{ 2 \sin \frac{ t }{ 2 } } | \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \int_0^\pi | \frac{ \sin ( n + \frac{ 1 }{
2 } ) t }{ t } | \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \int_0^{ ( n + \frac{ 1 }{ 2 } ) \pi }
\frac{ | \sin t | }{ t } \mathrm{ d } t \\
&gt; &amp; \frac{ 1 }{ \pi } \sum_{ k = 2 }^n \int_{ ( k - 1 ) \pi }^{ k
\pi } \frac{ | \sin t | }{ t } \mathrm{ d } t \\
= &amp; \sum_{ k = 2 }^n O ( 1 ) \frac{ 1 }{ k } \\
= &amp; O ( \ln n )
\end{aligned}
\]</span></p>
<p>接下来考虑取<span class="math inline">\(h_n = \frac{ g_n }{ \sqrt{ ln
n } } \to 0\)</span>,则<span class="math inline">\(S_n ( h_n , x ) = O (
\sqrt{ \ln n } )\)</span>.此时设<span class="math inline">\(U_{ \epsilon
} ( f ) = \{ g \in C ( T ) | \Vert f - g \Vert &lt; \epsilon
\}\)</span>,回忆到三角多项式可以一致逼近任何连续周期函数,所以存在三角多项式(有限项)<span class="math inline">\(T \in U_{ \frac{ \epsilon }{ 2 } } ( f
)\)</span>.</p>
<p>取<span class="math inline">\(r_n ( x ) = T + h_n\)</span>,由于<span class="math inline">\(h_n \to 0\)</span>,所以当<span class="math inline">\(n\)</span>足够大的时候<span class="math inline">\(r_n ( x ) = g + h_n \in U_\epsilon ( f
)\)</span>.此时<span class="math inline">\(S_n ( r_n , x ) = S_n ( T , x
) + S_n ( h_n , x )\)</span>,但是<span class="math inline">\(T\)</span>是有限项三角多项式,所以<span class="math inline">\(S_n ( r_n , x ) = O ( 1 ) + O ( \sqrt{ \ln n } )
\to \infty\)</span>.这就搞定了,那此时<span class="math inline">\(r_n \in
E_m ( x )\)</span>而且在<span class="math inline">\(f\)</span>的邻域里.所以这个集合是稠密的.</p>
<p>接下来取<span class="math inline">\(E_x = \bigcap_{ m = 1 }^\infty
E_m ( x )\)</span>,容易发现<span class="math inline">\(E_x\)</span>中的所有函数在<span class="math inline">\(x\)</span>这一点的傅里叶级数竟然都无界,我可以干脆取<span class="math inline">\(E = \bigcap_{ x \in \mathbb{ Q } }
E_x\)</span>,则这里面存在一个函数,这个函数的傅里叶级数在任意有理点处发散.</p>
<p>其实还可以更牛,取<span class="math inline">\(F_m ( f ) = \{ x \in
\mathbb{ R } | \varphi_f ( x ) &gt; m \}\)</span>,这显然是个开集.取<span class="math inline">\(F_f = \bigcap_{ n = 1 }^\infty
F_n\)</span>,这就是可数个开集的交.而且从上面的论证可以发现<span class="math inline">\(\mathbb{ Q } \subseteq
F_f\)</span>,可是这里的<span class="math inline">\(\mathbb{ Q
}\)</span>是稠密的,所以<span class="math inline">\(F_f\)</span>必然也是稠密的,那它就是可数个开稠集的交,有结论说可数个开稠集的交一定是不可数集合.</p>
<p>然而,还有结论说一个周期连续函数的傅里叶级数其实几乎处处收敛于本身.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(f ( x )\)</span>是<span class="math inline">\(2 \pi\)</span>周期连续函数,设<span class="math inline">\(M_n = \max_{ x \in [ - \pi , \pi ] } | S_n ( x )
|\)</span>,求证:<span class="math inline">\(\lim_{ n \to \infty } \frac{
M_n }{ \ln n } = 0\)</span>.</p>
<p>不妨设<span class="math inline">\(M_f = \max f\)</span>,考虑<span class="math inline">\(| S_n ( x ) | \leq | S_n ( x ) - f | +
M_f\)</span>,而后者是个死数,除以<span class="math inline">\(\ln
n\)</span>后当然趋近于<span class="math inline">\(0\)</span>.</p>
<p>现在只需要看前者,然而:</p>
<p><span class="math display">\[
\begin{aligned}
S_n ( x ) - f &amp; = \frac{ 1 }{ \pi } \int_{ 0 }^\pi ( f ( x + t ) + f
( x - t ) - 2 f ( x ) ) D_n ( t ) \mathrm{ d } t \\
&amp; = \frac{ 1 }{ \pi } \int_{ 0 }^\delta ( f ( x + t ) + f ( x - t )
- 2 f ( x ) ) D_n ( t ) \mathrm{ d } t
\end{aligned}
\]</span></p>
<p>而回忆到<span class="math inline">\(\int_0^\pi | D_n ( t ) | = O (
\ln n )\)</span>,由一致连续性前半部分显然可以决定一个<span class="math inline">\(\delta\)</span>是前者<span class="math inline">\(&lt; \epsilon\)</span>,这就搞定了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">平邑一中集训作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%B9%B3%E9%82%91%E4%B8%80%E4%B8%AD%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="反悔贪心">反悔贪心</span></h3>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6940</p>
<p>首先发现,从上往下扫行,然后对于每个右下角匹配一个列最近的左上角是最优秀的.所以拿set维护上述过程.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3268</p>
<p>这题比较厉害,直接扫,然后维护每个圆当前与这条线的两个交点,注意到这些交点的顺序是固定的,于是可以拿set维护.</p>
<h3><span id="二分图hall定理">二分图HALL定理</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc076_d</p>
<p>根据Hall定理,我们只要找到一个子集的人,使得人数与它们的区间的并所包含的椅子数量之差最大,这个最大值就是答案.而它们区间的并显然是同样类型的区间,也就是中间扣去一段.考虑枚举中间扣去的那一段是啥,就可以快速算答案.这玩意可以扫描线维护.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF981F</p>
<p>一眼丁真,鉴定为二分+Hall定理.</p>
<p>这题真正的难点在于如何check.考虑我们现在有了若干个区间<span class="math inline">\([ l , r
]\)</span>,每个整数点上都有一个人.然后要check.那就必须满足<span class="math inline">\(r_j - l_i \geq j - i\)</span>,这意味着<span class="math inline">\(r_j - j \geq l_i - i\)</span>,然后就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3488</p>
<p>比较简单,考虑如果最后找的若干个区间是分开的,那它们必然其中有一个区间自己就不合法.因此找到这个区间就行,然后每个位置减去<span class="math inline">\(k\)</span>,用线段树维护区间小子段和判断加上<span class="math inline">\(k \times d\)</span>是否小于<span class="math inline">\(0\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>这题比较厉害啊.首先猜到要用网络流.</p>
<p>然后注意到选的集合<span class="math inline">\(=\)</span>选的数字等价于不选的集合<span class="math inline">\(+\)</span>选的数字<span class="math inline">\(=
n\)</span>.考虑最小割.先将边权全部取反,这样变成求最大权值,</p>
<p>然后集合连权值加上一个极大值<span class="math inline">\(M\)</span>,单点连极大值<span class="math inline">\(M\)</span>.这样割掉一个单点意味着选这个单点,割掉一个集合意味着不选这个集合.由于存在完美匹配,因此一定会跑出答案.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc106_e</p>
<p>首先答案显然不会超过<span class="math inline">\(2
nk\)</span>,考虑二分,这样每一天会有哪些人来就知道了.然后对着上面的信息做高维前缀和就可以知道对于一个人的集合,它会来哪些天.这样就可以check.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc037_d</p>
<p>考虑最后<span class="math inline">\(C \rightarrow
D\)</span>显然需要把该放的位置归位,这样我们的<span class="math inline">\(a\)</span>里面存的完全可以是它应该在第几行这个信息.</p>
<p>再考虑<span class="math inline">\(B \rightarrow
C\)</span>,显然只需要保证每列的<span class="math inline">\(a\)</span>互不相同,这一步就可以满足上面的要求.</p>
<p>于是,<span class="math inline">\(A \rightarrow
B\)</span>只需要保证每列的<span class="math inline">\(a\)</span>互不相同.这个可以使用网络流实现.</p>
<p>那么,如何证明一定有解呢?这是一张正则二分图,根据Hall定理推论,一定存在完美匹配.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc029_f</p>
<p>这题好牛啊.发现如果几个集合的并的点数过少,那么一定无解.因为怎么连都会连出环来.这直接将整个题的思路引向Hall定理.</p>
<p>考虑直接做二分图匹配.左边是点右边是集合,然后连边.</p>
<p>那么根据Hall定理一定存在<span class="math inline">\(n -
1\)</span>的匹配,并且恰好有一个点没被匹配到.我们干脆删掉这个点,最后再加回来.事实上理论上来说我删掉哪个点都应该存在完美匹配,我们先只删一个.然后从<span class="math inline">\(r\)</span>开始不断dfs找到一条遍历所有边的交错树,对着交错树构造就行.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1519F</p>
<p>首先注意到,只要任意一个宝箱集合需要的钥匙集合的权值大于等于自己,那Bob就输了.这类似Hall定理.我们把钥匙和宝箱都拆点,然后判断拆点后的图是否存在完美匹配.求完美匹配可以使用状压.</p>
<h3><span id="轮廓线dp">轮廓线dp</span></h3>
<p>这个板块好像没啥说的,因为思维难度远低于代码难度.而且思路都比较直接.</p>
<p>放一下我做的题.</p>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5056</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2289</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3886</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P1933</p>
<h3><span id="广义串并联图">广义串并联图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6790</p>
<p>比较简单,首先这个图这么简单,那它大概率是个广义串并联图.感性理解一下,<span class="math inline">\(n \geq
4\)</span>的时候肯定是存在度数较小的边的,并且你在合并的过程中它也一直是仙人掌+至多一条边的形状.</p>
<p>然后简单做做.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P8426</p>
<p>ps:本题选入笔记:图论-广义串并联图/三度化-Example2.</p>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>在一个点双中,我们找到两个点<span class="math inline">\(u , v\)</span>,使得<span class="math inline">\(u
\rightarrow v\)</span>,并且<span class="math inline">\(u\)</span>的出度至少是<span class="math inline">\(2\)</span>,<span class="math inline">\(v\)</span>的入度至少是<span class="math inline">\(2\)</span>,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为<span class="math inline">\(2\)</span>的点<span class="math inline">\(v\)</span>,找到它的入点<span class="math inline">\(u\)</span>,如果<span class="math inline">\(u\)</span>的出度不是<span class="math inline">\(2\)</span>,那么<span class="math inline">\(u\)</span>也是一个入度至少为<span class="math inline">\(2\)</span>的点.这样往前推一定至少能推到一个点(因为不可能<span class="math inline">\(S\)</span>贡献了俩入度).</p>
<p>如何保证<span class="math inline">\(S ,
T\)</span>在一个点双中呢?其实只需要添加一条边<span class="math inline">\(( S , T , dis_{ S \rightarrow T }
)\)</span>就行了.显然加了后不会对答案产生影响.然后不在<span class="math inline">\(S , T\)</span>这个边双内的点也没有用了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://loj.ac/p/3076</p>
<p>这题没啥好说的,小E的集训队论文讲的很清楚.简单来说就是用三度化求出一棵决策树,然后做动态dp.</p>
<h3><span id="动态规划第一期">动态规划第一期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1810G</p>
<p>ps:本题选入笔记:动态规划-动态规划的优化-反向操作-Example1.</p>
<p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个<span class="math inline">\(k\)</span>暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取<span class="math inline">\(\max\)</span>操作很艰难.但如果!我把这个dp反过来,我设<span class="math inline">\(f_{ i , j
}\)</span>表示<strong>从后往前</strong>dp到<span class="math inline">\(i\)</span>,当前的最大前缀和是多少,这个dp的转移极其简单:</p>
<p><span class="math display">\[
P \times f_{ i , j } \rightarrow f_{ i - 1 , \max \{ 0 , j + a_{ i - 1 }
\} }
\]</span></p>
<p>最后在<span class="math inline">\(f_{ 1 , j }\)</span>处乘上<span class="math inline">\(h_j\)</span>.</p>
<p>但是这样是<span class="math inline">\(O ( n^3
)\)</span>的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设<span class="math inline">\(g_{ i , j
}\)</span>表示如果初始只有<span class="math inline">\(f_{ i , j } =
1\)</span>,dp到最后的答案是多少.于是只需要:</p>
$$
<span class="math display">\[\begin{aligned}
P \times g_{ i - 1 , \max \{ 0 , j + a_{ i - 1 } \} } &amp; \rightarrow
g_{ i , j } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我认真考虑过这个<span class="math inline">\(P\)</span>应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些<span class="math inline">\(P\)</span>变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<p>回来简单提下容斥做法,其实是有一个自然的想法是只要这个序列中出现过前缀和为<span class="math inline">\(x\)</span>的位置,我们就加上一个<span class="math inline">\(h_x - h_{ x - 1
}\)</span>.然后我们要统计的是出现过的,因此用容斥把这个条件删了就行.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc061_c</p>
<p>这题纯容斥,首先考虑找到一种统计答案序列而非操作序列的方式:一般而言会选择建立某种双射.考虑一个答案序列可以怎么被操作到:或者说,对于一个答案序列,判断它能否操作到.</p>
<p>注意到序列中第一个元素,肯定是选择左端点比较合理.因为这样它对后面的限制要少一些.那么其实双射方式就呼之欲出了:就是从左往右扫,能取左端点就取左端点.我们就可以对这个操作序列进行计数.</p>
<p>这个操作序列怎么计数呢?考虑这个序列满足啥条件:其实就是能选左边的就不会选右边的,那也就是不可能出现一个空的区间,这个区间没有任何数字.对着这个条件容斥即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc134_e</p>
<p>这题见过两次了.大概是按部就班一点一点去找条件.</p>
<p>至于考试怎么办,考试打表啊!</p>
<p>下面抄一下演算纸上的结论,注意这些判定条件的优先级从前往后:</p>
<ol type="1">
<li><p>如果序列全<span class="math inline">\(1\)</span>,显然后手获胜.</p></li>
<li><p>如果序列不是全<span class="math inline">\(1\)</span>并且存在奇数,选择<span class="math inline">\(m = 2\)</span>,先手获胜.</p></li>
<li><p>如果序列全<span class="math inline">\(2\)</span>,显然后手获胜.</p></li>
<li><p>如果序列全是偶数并且不全是<span class="math inline">\(4\)</span>的倍数,取<span class="math inline">\(m =
4\)</span>转化为(3),先手获胜.</p></li>
<li><p>如果序列全是<span class="math inline">\(4\)</span>的倍数,考虑取<span class="math inline">\(m = 3\)</span>,如果序列中只有<span class="math inline">\(\bmod 3 = 1\)</span>或者只有<span class="math inline">\(\bmod 3 =
2\)</span>的数字,显然先手获胜.不然,如果同时存在,考虑先手取<span class="math inline">\(m = 12\)</span>,序列中就会只剩下<span class="math inline">\(\{ 4 , 8
\}\)</span>.此时如果后手取一个奇数,显然会剩下奇数,根据(2)先手获胜;如果后手取一个偶数,讨论一下全部的偶数,都是先手获胜.</p></li>
</ol>
<p>综上,除非所有的数字都是<span class="math inline">\(12\)</span>的倍数,不然后手获胜当且仅当序列是<span class="math inline">\(\{ 1 \} , \{ 2 \} , \{ 4 , 8 \}\)</span>.</p>
<p>如果所有的数字都是<span class="math inline">\(12\)</span>的倍数,最多只有<span class="math inline">\(16\)</span>个,状压即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_abc290_h</p>
<p>显然对于猫来说,它的<span class="math inline">\(d\)</span>(定义为左右狗的数量之差,对于狗同理)是一个从左到右先减少再增加的东西.因此一个<span class="math inline">\(O ( n^4 )\)</span>的dp是简单设计的,也就是<span class="math inline">\(f_{ i , j , k , l }\)</span>表示目前用了<span class="math inline">\(i\)</span>只猫,有<span class="math inline">\(j\)</span>只放在前面,<span class="math inline">\(i
- j\)</span>只放在后面,狗同理.</p>
<p>这个怎么优化呢?我们仔细思考,如果要放,是不是最好放的平均一点.因此引出一个结论:那就是一定存在一个分界点,使得左右猫的数量相同,狗的数量也相同.你可能会好奇<span class="math inline">\(n ,
m\)</span>都是奇数怎么办,这种情况下会把中间的两个点当作分界点.如果<span class="math inline">\(n +
m\)</span>是奇数就找中间的那个点,不然就找中间的那个空格.</p>
<p>这个是怎么证明的呢?我们考虑对于猫来说,先找到能平分猫的分界点.然后考虑这个点左右两侧的狗的数量是否相同(这里先假设狗的数量是偶数,奇数是同理的,只是要多说几步).我们选择狗多的那一边,把这边最靠近分界线的那只狗恰好移过分界线.注意到这样一定更优秀.</p>
<p>那么上面的结论证明了啥呢?证明了整个序列一定可以分成两部分(左右两部分).这有什么用?这去掉了前两维.具体来讲,对于一部分,如果可以填某只猫或某只狗二者之一,一定选择权值较小的先填,这样的话这一对的贡献就会少一些.其实就是把权值转化为每个序列中每一对的贡献.于是这个结论就是对的,我们可以把猫狗放在一起排序来处理第一维.复杂度<span class="math inline">\(O ( n^3 )\)</span>.</p>
<p>测完样例发现一个问题啊,上面那个结论还真不能简单地拓展到奇数.因为会出现权值相等的情况.对于偶数来讲,权值相等是无所谓的.但是奇数不行.因此我们选择如果<span class="math inline">\(n\)</span>是奇数,就挑出最大的那只强行放在中间,<span class="math inline">\(m\)</span>同理.</p>
<p>但是,这题被爆标了.存在<span class="math inline">\(O ( n \log n
)\)</span>的做法:</p>
<p>注意到,<span class="math inline">\(\sum
d\)</span>总是一样的.因为这个猫前面的狗会因为它而贡献<span class="math inline">\(1\)</span>,然后这个猫和后面的狗也会贡献<span class="math inline">\(1\)</span>.于是考虑从大到小开始放,优先放中间.然后先把狗堆一边,猫堆另一边,堆不动了再放对边,这样就是满足让<span class="math inline">\(a\)</span>较大的<span class="math inline">\(d\)</span>较小.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9338</p>
<p>首先能划分就一定需要是一个合法括号序列.同时这意味着一定可以划分出<span class="math inline">\(N\)</span>个合法的序列.</p>
<p>也就是说,我们其实只在乎这个序列最少能划分出多少,并且判断这个数字是否小于等于<span class="math inline">\(K\)</span>.那么如何求这个数字呢?</p>
<p>考虑第一个<span class="math inline">\(B\)</span>,它一定会和它左边的某个<span class="math inline">\(A\)</span>配对,不妨设它左边有<span class="math inline">\(i\)</span>个<span class="math inline">\(A\)</span>,那么最好的办法显然是这<span class="math inline">\(i\)</span>个<span class="math inline">\(A\)</span>和后面紧接着的<span class="math inline">\(i\)</span>个<span class="math inline">\(B\)</span>合并成一个序列.这是为什么呢?因为第一个<span class="math inline">\(B\)</span>需要配对,因此它需要在一个序列中,把它删掉后后面的一个<span class="math inline">\(B\)</span>也需要配对,而此时它前面的<span class="math inline">\(A\)</span>其实都是等价的,于是选择最早的那个,以此类推.</p>
<p>然后题解开始变魔术了.设<span class="math inline">\(f [ x
]\)</span>表示第<span class="math inline">\(x\)</span>个<span class="math inline">\(B\)</span>前有多少个<span class="math inline">\(A\)</span>,那我们做的实际上就是<span class="math inline">\(x = 1\)</span>,然后不断做<span class="math inline">\(x : = f [ x ] + 1\)</span>直到<span class="math inline">\(x &gt;
n\)</span>.发现这样其实顺便把合法括号序列那个条件一起满足了,因为如果不合法一定会跳跳跳跳跳然后死循环.</p>
<p>那么我们的交换操作实际上是啥呢?首先不可能交换两个相同的,那实际上就是给一个<span class="math inline">\(f \pm 1\)</span>,实际上显然不可能给一个<span class="math inline">\(f\)</span>减一.</p>
<p>但是这样会出现一个问题是,我们其实并不能选择任意一个<span class="math inline">\(f\)</span>进行更改.那怎么办呢?事实上,只要过程中满足<span class="math inline">\(\forall 1 &lt; i \leq n , f_i \geq f_{ i - 1
}\)</span>,那我们的修改就一定可以实现.因为这等价于把后面的一个<span class="math inline">\(A\)</span>挪前面去了.这样我们一开始进行操作使得整个序列满足<span class="math inline">\(f_i \geq i\)</span>.</p>
<p>于是就有了一个<span class="math inline">\(O ( n^3
)\)</span>的dp,即设<span class="math inline">\(dp_{ i , k
}\)</span>表示跳到<span class="math inline">\(i\)</span>跳了<span class="math inline">\(k\)</span>步的最小花费,每次跳到<span class="math inline">\(j\)</span>的话要求把<span class="math inline">\([
i , n ]\)</span>上的所有<span class="math inline">\(f\)</span>对<span class="math inline">\(j - 1\)</span>取<span class="math inline">\(\max\)</span>.</p>
<p>仔细观察上面的过程,不难发现答案关于<span class="math inline">\(k\)</span>是凸的,用wqs二分去掉第二维,于是现在就有了一个<span class="math inline">\(O ( n^2 \log n )\)</span>的一维dp.</p>
<p>不妨设<span class="math inline">\(sum_x\)</span>表示<span class="math inline">\(f_i \leq x\)</span>的<span class="math inline">\(f_i\)</span>之和,<span class="math inline">\(cnt_x\)</span>表示这样的<span class="math inline">\(f_i\)</span>的个数,再设<span class="math inline">\(pre_i\)</span>为<span class="math inline">\(f\)</span>的前缀和.由于<span class="math inline">\(f_i \geq i\)</span>,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
dp_i &amp; = dp_j + \\
( i - 1 ) ( cnt_{ i - 1 } - j + 1 ) - sum_{ i - 1 } + pre_{ j - 1 } -
val
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(val\)</span>是wqs二分出来的惩罚量.然后如果能选前面的<span class="math inline">\(i\)</span>尽量选靠前的.再就是dp过程中需要记录跳了几步,但是不作为dp的维度而是内容.</p>
<p>显然可以斜率优化,于是复杂度<span class="math inline">\(O ( n \log n
)\)</span>.</p>
<h4><span id="第六题">第六题</span></h4>
<p>考虑Hall定理,设最后的盒子是<span class="math inline">\(x_1 , x_2 ,
\cdots ,
x_k\)</span>,将它们<strong>从大到小</strong>排序,那么合法当且仅当:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum x = \sum a\)</span>.</p></li>
<li><p><span class="math inline">\(\forall k , \sum_{ i = 1 }^k x_i \leq
\sum_{ i = 1 }^n \min \{ k , a_i \}\)</span>.</p></li>
</ol>
<p>为啥是这个方向的Hall定理呢?因为我们肯定要对<span class="math inline">\(x\)</span>做一个背包的问题,这个时候肯定是对后面那一个已知的操作会比较好.</p>
<p>然后就直接dp.把<span class="math inline">\(b\)</span>从大到小排序,<span class="math inline">\(f_{ i , j , k }\)</span>表示当前考虑前<span class="math inline">\(i\)</span>个<span class="math inline">\(b\)</span>,选了<span class="math inline">\(j\)</span>个,和为<span class="math inline">\(k\)</span>是否可行,用bitset优化一下得到<span class="math inline">\(O ( \frac{ mS^2 }{ w } )\)</span>的算法.</p>
<p>但是实际上,考虑到<span class="math inline">\(m\)</span>其实是<span class="math inline">\(\sqrt{ S }\)</span>级别的,再注意到dp的过程中,<span class="math inline">\(j \leq \frac{ S }{ b_i }\)</span>,因此<span class="math inline">\(\sum max_j = O ( S \log S
)\)</span>,所以这个算法是<span class="math inline">\(O ( \frac{ S^2 \log
S }{ w } )\)</span>的.</p>
<p>实现可以使用滚动数组.然后压位的话要压掉最后一维.</p>
<p>dp的话是下面这样的:</p>
<p><span class="math display">\[
\begin{aligned}
dp_{ i , j , k } &amp; \rightarrow dp_{ i + 1 , j , k } \\
dp_{ i , j , k } &amp; \rightarrow dp_{ i , j + 1 , k + b_i }
\end{aligned}
\]</span></p>
<p>算的时候记得删掉过大的<span class="math inline">\(k\)</span>.</p>
<p>看到这种dp可能第一反应是考虑能不能交换dp状态和dp值,但是这个哪一维状态也不是和状态是单调的.</p>
<p>至于构造方案,暴力用堆一个一个做.</p>
<h3><span id="组合数学">组合数学</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_jsc2019_qual_f</p>
<p>比较牛.首先千万要看清楚不是每个点的值在<span class="math inline">\([
L , R ]\)</span>之间而是和在<span class="math inline">\([ L , R
]\)</span>之间!</p>
<p>然后考虑后者怎么做.注意到如果是第<span class="math inline">\(M\)</span>大等于第<span class="math inline">\(M +
1\)</span>大的话,中间那一段会是一段连续的,这个特别难搞.所以我们考虑求第<span class="math inline">\(M\)</span>大不等于第<span class="math inline">\(M
+ 1\)</span>大,这样前<span class="math inline">\(M\)</span>个和后<span class="math inline">\(N -
M\)</span>个数字其实就分开了.而且因为前后没有相等的数字,我们很容易把它们乱序合并起来.</p>
<p>因此接下来的关键在于把前后分开,假设<span class="math inline">\(a_M =
x\)</span>,那么前<span class="math inline">\(M\)</span>个数字大于等于<span class="math inline">\(x\)</span>,后<span class="math inline">\(M\)</span>个数字小于<span class="math inline">\(x\)</span>.不妨假设此时全局和为<span class="math inline">\(s\)</span>,那我们如何解决这个问题呢?</p>
<p>首先较大的那几个可以隔板法做,较小的那几个是个经典容斥:枚举有几个大于等于<span class="math inline">\(x\)</span>的,这个数量不会超过<span class="math inline">\(\frac{ R }{ x }\)</span>,然后剩下的暴力隔板.</p>
<p>写式子之前考虑上面那个<span class="math inline">\(s\)</span>怎么办,总不能暴力枚举,其实写出来也可以用二项式技巧去掉,但是更重要的是,为啥你不转化成和在<span class="math inline">\([ 0 , R ]\)</span>的答案减去和在<span class="math inline">\([ 0 , L - 1 ]\)</span>的答案呢?这下做完了.</p>
<p>于是我们只考虑限制是<span class="math inline">\([ 0 , R
]\)</span>.</p>
<p>这个时候我还在想要把左右两边分开求答案然后卷起来,但是这样还是避免不了枚举一边的和.事实上,我们可以把二者放在一起做容斥.下面式子会给出一个显式的表达.另外就是,有一个很大的问题在于我们如何钦定<span class="math inline">\(a_M =
x\)</span>,这一点其实是难以做到的.但我们可以钦定<span class="math inline">\(a_M \geq x , a_{ M + 1 } &lt;
x\)</span>,然后再减去<span class="math inline">\(a_M \geq x + 1 , a_{ M
+ 1 } &lt; x\)</span>.为了方便,我们不妨设<span class="math inline">\(a_M
\geq x , a_{ M + 1 } \leq y\)</span>的答案是<span class="math inline">\(f ( x , y )\)</span>,然后我们要求的就是<span class="math inline">\(\sum_{ x } f ( x , x - 1 ) - f ( x + 1 , x - 1
)\)</span>.</p>
<p>接下来写一下<span class="math inline">\(f ( x , y
)\)</span>的式子:</p>
<p><span class="math display">\[
f ( x , y ) = \sum_{ i = 0 } \binom{ N - M }{ i } ( - 1 )^i \binom{ R -
Mx - i ( y + 1 ) + N }{ N }
\]</span></p>
<p>乍一看不太能算,实际上注意到<span class="math inline">\(R - Mx - i ( y
+ 1 ) \geq 0\)</span>,由于<span class="math inline">\(x ,
y\)</span>同级别,这意味着<span class="math inline">\(i\)</span>大致是<span class="math inline">\(\frac{
R }{ x }\)</span>级别的.于是就是一个调和级数复杂度.</p>
<h4><span id="第二题第三题">第二题/第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1264D2</p>
<p>直接做的hard version.</p>
<p>首先我们发现,不妨我们最后取出来的串一定是个<span class="math inline">\(( ( ( \cdots ) )
)\)</span>这样的结构.再进一步,我们找到这个结构在原串上的分界点,设其左侧有<span class="math inline">\(s_l\)</span>个<span class="math inline">\((\)</span>,右侧有<span class="math inline">\(s_r\)</span>个<span class="math inline">\()\)</span>,那么这个串的长度一定形如<span class="math inline">\(\min \{ s_l , s_r
\}\)</span>,由于随着分界点的右移,<span class="math inline">\(s_l\)</span>增大,<span class="math inline">\(s_r\)</span>减小,因此一定是它俩相等的时候最优秀.</p>
<p>于是我们考虑枚举分界点,对于每个分界点枚举答案.不妨设左侧有<span class="math inline">\(a_l\)</span>个问号,总共有<span class="math inline">\(a\)</span>个问问号,答案显然是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ k } k \binom{ a_l }{ k - s_l } \binom{ a - a_l }{ k - s_r }
\\
= &amp; \sum_{ k } ( k - s_l ) \binom{ a_l }{ k - s_l } \binom{ a - a_l
}{ k - s_r } + \sum_{ k } s_l \binom{ a_l }{ k - s_l } \binom{ a - a_l
}{ k - s_r } \\
= &amp; a_l \sum_{ k } \binom{ a_l - 1 }{ k - s_l - 1 } \binom{ a - a_l
}{ k - s_r } + s_l \sum_{ k } \binom{ a_l }{ k - s_l } \binom{ a - a_l
}{ k - s_r } \\
= &amp; a_l \sum_{ k } \binom{ a_l - 1 }{ a_l - k + s_l } \binom{ a -
a_l }{ k - s_r } + s_l \sum_{ k } \binom{ a_l }{ a_l - k + s_l } \binom{
a - a_l }{ k - s_r } \\
= &amp; a_l \binom{ a - 1 }{ a_l + s_l - s_r } + s_l \binom{ a }{ a_l +
s_l - s_r }
\end{aligned}
\]</span></p>
<p>不过这里有个问题啊,那就是<span class="math inline">\(a =
0\)</span>怎么办,扩域的二项式我其实是不太会算的.于是我特判了<span class="math inline">\(a = 0\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc146_e</p>
<p>由于相同值域相互间有限制,不妨考虑值域那一维扫一下.</p>
<p>进一步地,我们考虑维护若干个上升的直线,然后每次可以选择把两条直线并起来成为一个峰,或者凭空分裂出两条直线作为一个谷.维护直线数量并且从下往上扫就可以了.</p>
<p>但是你注意一个问题,我们是不能先分裂出两条直线,再把它俩合并起来的.考虑能不能设计一点自适应的东西.当前的直线数量一定是偶数,然后我们每隔一个判断是否要合并,或者直接在一半的空位置上判断是否要分裂就行.更具体地,我们设<span class="math inline">\(f_{ i , j }\)</span>表示当前有<span class="math inline">\(j\)</span>个位置能放<span class="math inline">\(i\)</span>的答案.显然<span class="math inline">\(j
= b_i\)</span>,所以这一维看上去是没用的.</p>
<p>但是我们仔细想一想,我们要维护若干条折线.这些折线是有左右端点的,我们需要做的就是要么加入一条折线,要么合并两条折线,这两个操作都会带来一个空位置.而一条不操作的折线会带来两个空位置.其实相当于每个操作减少了一个空位置.不过有一个问题啊,我们只能通过<span class="math inline">\(b_i\)</span>得知有多少个空位置,却不知道有多少条折线.事实上空位置数量=折线端点数量+操作次数.也就是说,和dp关系比较大的是折线数量,但我们只能推测出空位置数量.这下这下了.</p>
<p>但是但是但是,我们写一个<span class="math inline">\(O ( n^2
)\)</span>的dp,<span class="math inline">\(f_{ i , j , 0 / 1 , 0 / 1
}\)</span>表示当前做到<span class="math inline">\(i\)</span>,有<span class="math inline">\(j\)</span>条折线,左端点是否已经选定,右端点是否已经选定.为啥要记录后两维呢?因为这不是环,这是一个排列,最左侧端点和最右侧端点是有可能直接停步的.因此我们还得讨论这个.说实话有点麻烦,所以我们先忽略左右端点,假设它们一直延伸.不妨设<span class="math inline">\(k = cnt_{ merge } - cnt_{ split
}\)</span>,自然有<span class="math inline">\(k = 2 j -
b_i\)</span>.不放在设<span class="math inline">\(w = cnt_{ split } ,
cnt_{ merge } = k + w\)</span>,再设<span class="math inline">\(F ( n , m
)\)</span>为将<span class="math inline">\(n\)</span>个无编号球放到<span class="math inline">\(m\)</span>个有编号盒子(盒子可空)的方案数,不难发现<span class="math inline">\(F ( n , m ) = \binom{ n + m - 1 }{ m - 1
}\)</span>.那我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i - 1 , j } \sum_{ w \geq 0 } \binom{ j - 1 }{ k + w } F ( w , j - w
- k + 1 ) &amp; \rightarrow f_{ i , j - k } \\
f_{ i - 1 , j } \sum_{ w } \binom{ j - 1 }{ k + w } \binom{ j - k }{ j -
w - k } &amp; \rightarrow f_{ i , j - k } \\
f_{ i - 1 , j } \binom{ 2 j - k - 1 }{ j } &amp; \rightarrow f_{ i , j -
k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>用范德蒙德卷积的时候一定要注意,这个东西是扩域后的二项式,因此一定要在意一下枚举量是否取遍整数,这里是发现如果<span class="math inline">\(w &lt; 0\)</span>,那么后面那个组合数一定是<span class="math inline">\(0\)</span>.</p>
<p>原本其实很怕这个转移,因为觉得很麻烦,但其实写出来就不麻烦了.甚至加两维也是好做的,我们不妨设后两维的和为<span class="math inline">\(t\)</span>,就是几个端点是挂的,我们仍然有:</p>
<p><span class="math display">\[
\begin{aligned}
b_i &amp; = 2 ( j - k ) + cnt_{ merge } - cnt_{ split } - t + \Delta t
\\
k &amp; = 2 j - t + \Delta t - b_i
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\Delta
t\)</span>是决定在这里停步的端点数量,<span class="math inline">\(t\)</span>是停步后的端点数量,<span class="math inline">\(j - k\)</span>是做完选择后,在<span class="math inline">\(i\)</span>处的折线数量,两个<span class="math inline">\(cnt\)</span>都是在做选择的<strong>过程中</strong>所做的merge和split的抉择数量.这样我们就完成了转移.</p>
<p>没完没完,差点就寄了.如果左右端点没有确认,那么我们是可以在左边或者右边split的.令<span class="math inline">\(t &#39; = t - \Delta
t\)</span>,于是重推一下式子:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i - 1 , j } \sum_{ w \geq 0 } \binom{ j - 1 }{ k + w } F ( w , j - w
- k + 1 - t &#39; ) &amp; \rightarrow f_{ i , j - k } \\
f_{ i - 1 , j } \sum_{ w } \binom{ j - 1 }{ k + w } \binom{ j - k - t
&#39; }{ j - w - k - t &#39; } &amp; \rightarrow f_{ i , j - k } \\
f_{ i - 1 , j } \binom{ 2 j - k - 1 - t &#39; }{ j - t &#39; } &amp;
\rightarrow f_{ i , j - k } \\
f_{ i - 1 , j } \binom{ b_i - 1 }{ j - t &#39; } &amp; \rightarrow f_{ i
, j - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这一步步是怎么加上去的呢?实际上是按照先merge,再slipt,再stop来做的.因为split一定要放在最后,防止split了一个stop的点或者split在了一个merge好了的区间中.</p>
<p>但是这个转移是<span class="math inline">\(O ( n \sum b
)\)</span>的,咋办呢?我们本着先冷静再冷静始终冷静的想法,去考虑一下<span class="math inline">\(j\)</span>的取值:不难发现在上面的操作过程中,基本都是一个<span class="math inline">\(j\)</span>对应一个<span class="math inline">\(j -
k\)</span>,只有在<span class="math inline">\(t\)</span>变化的时候才会增加一个状态,这意味着<span class="math inline">\(O ( \sum cnt_t ) = O ( \sum cnt_j
)\)</span>,因此总空间是<span class="math inline">\(O ( n
)\)</span>的,于是时间也是<span class="math inline">\(O ( n
)\)</span>的,拿map维护一下这个dp就行,时间退化至<span class="math inline">\(O ( n \log n )\)</span>.</p>
<p>再有一个细节就是组合数怎么办,哦,<span class="math inline">\(b\)</span>这么小,那没事了.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P6276</p>
<p>首先显然不会破坏环的形态.也就是说,你把所有置换环的长度求出来然后求lcm就是一个排列的阶.这直接启发我们对于每个质数分开求贡献.</p>
<p>更进一步地,我们发现只要排列中有<span class="math inline">\(p^k\)</span>的倍数,我们就直接贡献一个<span class="math inline">\(p\)</span>作为答案.因此我们枚举<span class="math inline">\(q =
p^k\)</span>并统计有多少个排列至少有长度为<span class="math inline">\(q\)</span>的倍数的环.这都至少了,直接容斥就行,我们设当前有<span class="math inline">\(i\)</span>个点,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ i } &amp; = \sum_{ q | k } - f_{ i - k , j - 1 } \binom{ i - 1 }{ k
- 1 } ( k - 1 ) ! \\
&amp; = \sum_{ q | k } -{ ( i - 1 ) }^{ \underline{ k - 1 } } f_{ i - k
, j - 1 }
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\sum_{ q | i } - f_i \times ( n - i ) !
\times \binom{ n }{ i }\)</span>就是答案.这样复杂度是<span class="math inline">\(O ( \sum ( \frac{ n }{ q } )^2 ) = O ( n^2
)\)</span>,事实上要更少,因为你发现我们只会对某个<span class="math inline">\(q = p^k\)</span>做这个东西.</p>
<p>另外由于模数不确定,我们还要对着每个<span class="math inline">\(i\)</span>预处理下降幂,有点难蚌的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_agc060_d</p>
<p>ps:本题选入笔记:常见套路-组合意义-Example3.</p>
<p>这题听了三遍,直接抄笔记.</p>
<p>不妨设<span class="math inline">\(C_p = \{ i | p_i &gt; p_{ i + 1 } ,
1 \leq i &lt; n \}\)</span>.</p>
<p>用一下组合意义,注意到答案等于:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ p } [ S = C_p ] )^2
\]</span></p>
<p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ p } [ S = C_p ] )^2 = \sum_{ S } ( \sum_{ S
\subseteq T } \sum_{ p } ( - 1 )^{ | T | - | S | } [ T \subseteq C_p ]
)^2
\]</span></p>
<p>这个咋做呢?我们考虑用组合意义展开:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } ( \sum_{ S \subseteq T } \sum_{ p } ( - 1 )^{ | T | - |
S | } [ T \subseteq C_p ] )^2 \\
= &amp; \sum_{ S } \sum_{ S \subseteq T_1 , T_2 } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] )
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(S\)</span>屁用没有,直接交换枚举顺序.</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } \sum_{ S \subseteq T_1 , T_2 } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] ) \\
= &amp; \sum_{ T_1 , T_2 } 2^{ | T_1 \cap T_2 | } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] )
\end{aligned}
\]</span></p>
<p>考虑<span class="math inline">\(( \sum_{ p } [ T_1 \subseteq C_p ]
)\)</span>怎么求,注意到这等价于所有<span class="math inline">\(T_1\)</span>中的位置全都被钦定为<span class="math inline">\(&gt;\)</span>,而其他位置任意,如果我们设所有以大于号连接的部分的长度为<span class="math inline">\(l_1 , l_2 , . . . ,
l_k\)</span>,那么这里的答案就是<span class="math inline">\(n ! \prod_{ i
= 1 }^k \frac{ 1 }{ l_i ! }\)</span>.</p>
<p>但我们很快发现了难点:<span class="math inline">\(2^{ | T_1 \cap T_2 |
}\)</span>这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中都是<span class="math inline">\(&gt;\)</span>的位置,这个好像不太好求,因为<span class="math inline">\(&gt;\)</span>是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ T_1 , T_2 } 2^{ | T_1 \cap T_2 | } ( - 1 )^{ | T_1 | + |
T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] ) ( \sum_p [ T_2 \subseteq
C_p ] ) \\
= &amp; \sum_{ T_1 , T_2 } 2^{ ( ( n - 1 ) - | T_1 \cup T_2 | ) - ( n -
1 ) } ( - 2 )^{ | T_1 | + | T_2 | } ( \sum_{ p } [ T_1 \subseteq C_p ] )
( \sum_p [ T_2 \subseteq C_p ] ) \\
= &amp; 2^{ 1 - n } ( n ! )^2 \sum_{ T_1 } ( ( - 2 )^{ | T_1 | } \frac{
1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( ( - 2 )^{ | T_2 | } \frac{ 1
}{ \prod l_{ 2 , i } ! } ) 2^{ n - 1 - | T_1 \cup T_2 | }
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(n - 1 - | T_1 \cup T_2
|\)</span>意味着均不在<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>中的位置的数量.为了给每一段连续的<span class="math inline">\(&gt;\)</span>都分配权值,我们进行一个细小的修改:</p>
<p><span class="math display">\[
2^{ - 1 - n } ( n ! )^2 \sum_{ T_1 } ( ( - 2 )^{ | T_1 | + 1 } \frac{ 1
}{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( ( - 2 )^{ | T_2 | + 1 } \frac{
1 }{ \prod l_{ 2 , i } ! } ) 2^{ n - 1 - | T_1 \cup T_2 | }
\]</span></p>
<p>写到这里应该就能发现,接下来必然要对<span class="math inline">\(n - 1
- | T_1 \cup T_2
|\)</span>做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_2\)</span>求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了<span class="math inline">\(&gt;\)</span>,我们自然有:</p>
$$
<span class="math display">\[\begin{gathered}
2^{ 1 + n } ( n ! )^2 \sum_{ T_1 } ( \frac{ 1 }{ ( - 2 )^{ | T_1 | + 1 }
} \frac{ 1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( \frac{ 1 }{ ( - 2
)^{ | T_2 | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } ) 2^{ | T_1 \cap
T_2 | } \\

\end{gathered}\]</span>
<p>$$</p>
<p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时<span class="math inline">\(| T_1 \cap T_2
|\)</span>这个限制就显得尤其强,如果只是<span class="math inline">\(S
\subseteq T_1 , T_2\)</span>就会好做很多:我们可以钦定<span class="math inline">\(S\)</span>作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; 2^{ 1 + n } ( n ! )^2 \sum_{ T_1 } ( \frac{ 1 }{ ( - 2 )^{ | T_1 |
+ 1 } } \frac{ 1 }{ \prod l_{ 1 , i } ! } ) \sum_{ T_2 } ( \frac{ 1 }{ (
- 2 )^{ | T_2 | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } ) 2^{ | T_1
\cap T_2 | } \\
= &amp; 2^{ 1 + n } ( n ! )^2 \sum_{ S } \sum_{ S \subseteq T_1 } (
\frac{ 1 }{ ( - 2 )^{ | T_1 | + 1 } } \frac{ 1 }{ \prod l_{ 1 , i } ! }
) \sum_{ S \subseteq T_2 } ( \frac{ 1 }{ ( - 2 )^{ | T_2 | + 1 } }
\frac{ 1 }{ \prod l_{ 2 , i } ! } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(f ( T ) = \sum_{ S \subseteq T } (
\frac{ 1 }{ ( - 2 )^{ | T | + 1 } } \frac{ 1 }{ \prod l_{ 2 , i } ! } )
\\\)</span>,则原式即:</p>
<p><span class="math display">\[
2^{ 1 + n } ( n ! )^2 \sum_{ S } ( \sum_{ S \subseteq T } f ( T ) )^2
\]</span></p>
<p>考虑下面这个东西怎么求:</p>
<p><span class="math display">\[
\sum_{ S } ( \sum_{ S \subseteq T } f ( T ) )^2
\]</span></p>
<p>注意到,如果我们把每一段(<span class="math inline">\([ T_i , T_{ i + 1
} )\)</span>)的贡献求和,那么<span class="math inline">\(f ( T
)\)</span>相当于这些和乘起来,那么<span class="math inline">\(( \sum_{ S
\subseteq T } f ( T )
)^2\)</span>就是这些和的平方乘起来.换句话说,我们自然有<span class="math inline">\(ans_n = \sum_{ m } ans_{ n - m } g^2_{ m
}\)</span>,其中<span class="math inline">\(g_m\)</span>表示长度为<span class="math inline">\(m\)</span>的一段的贡献之和.而<span class="math inline">\(g_{ n } = \sum_m g_{ n - m } \frac{ 1 }{ - 2 m !
}\)</span>.二者都可以使用分治FFT或多项式求逆解决.更进一步地,<span class="math inline">\(h_i = \frac{ 1 }{ - 2 i ! } , G = \frac{ 1 }{ 1 -
H } , F = \frac{ 1 }{ 1 - G }\)</span>.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将<span class="math inline">\(( &gt; , &gt;
)\)</span>容斥掉,这样我们有若干种对:<span class="math inline">\(2 ( &lt;
, &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e
)\)</span>,然后我们发现两个序列联系得太紧了,我们考虑分配系数:<span class="math inline">\(&lt; \rightarrow \sqrt{ 2 }\)</span>,<span class="math inline">\(e \rightarrow - \frac{ 1 }{ \sqrt{ 2 }
}\)</span>,但是这样发现<span class="math inline">\(( e , e
)\)</span>算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1188E</p>
<p>首先发现肯定不可能所有颜色都点过,那么至少有一个颜色没点过.</p>
<p>然后呢?考虑操作序列和答案序列是否一一对应,事实上确实是这样,因为至少有一个颜色没点过,因此可以找到下降最多的那个颜色,这样就知道了总共操作过程.然后由每个颜色减少的次数,就可以知道每种颜色操作的次数.接下来就只需要对于每种操作次数判断是否能在全程非负的前提下做完.</p>
<p>一个显然的必要条件是,不妨设<span class="math inline">\(l_i\)</span>为第<span class="math inline">\(i\)</span>种颜色操作次数,<span class="math inline">\(a_i + l_i k \geq \sum
l\)</span>.但是操作过程中有可能有负数,这个怎么办呢?注意到为了让<span class="math inline">\(a\)</span>不变负数,我们必须要让它在<span class="math inline">\(a_i + 1\)</span>时刻前完成至少一次操作,在<span class="math inline">\(a_i + k + 1\)</span>时刻前完成至少两次操作……</p>
<p>注意到只需要满足第一个条件就行,因为后面的条件只需要把当前所有需要做的人排个序,挨个做.显然就一定会满足条件.根据Hall定理,从前往后判断每一时刻是不是能填满前面的每个人,并将它和<span class="math inline">\(\max a\)</span>取<span class="math inline">\(\min\)</span>得到<span class="math inline">\(maxt\)</span>,这就是<span class="math inline">\(\sum l\)</span>的最大值.不难发现只要<span class="math inline">\(\sum l \leq maxt\)</span>就一定有解.枚举<span class="math inline">\(t\)</span>计算每个<span class="math inline">\(a\)</span>需要的次数,剩下的次数随意分配,注意要保证<span class="math inline">\(\min l = 0\)</span>,要减去<span class="math inline">\(\min l \geq 1\)</span>的情况.</p>
<p>事实上啊,只要我们得知了前一个要求条件然后枚举<span class="math inline">\(t\)</span>就行,时刻维护着复杂度就对,根本不用管后面的东西.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1595</p>
<p>弱智题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://darkbzoj.cc/problem/4665</p>
<p>直接容斥,用dp出前<span class="math inline">\(i\)</span>个人,钦定<span class="math inline">\(j\)</span>个人拿到了自己的糖果的方案数.然后容斥起来就行.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4859</p>
<p>ps:本题选入笔记:容斥与反演-容斥-Example3.</p>
<p>首先可以用dp+双指针得到<span class="math inline">\(f_i\)</span>表示勒令<span class="math inline">\(i\)</span>对满足条件的方案数.把<span class="math inline">\(k\)</span>的定义改为恰好<span class="math inline">\(k\)</span>对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好<span class="math inline">\(a\)</span>对的方案会被恰好<span class="math inline">\(b\)</span>对的方案计算<span class="math inline">\(\binom{ b }{ a
}\)</span>次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为<span class="math inline">\(k\)</span>的方案贡献为<span class="math inline">\(1\)</span>,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为<span class="math inline">\(k + 1\)</span>的方案贡献为<span class="math inline">\(0\)</span>,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令<span class="math inline">\(ans = f_k\)</span>,第二步除去其中被多算的<span class="math inline">\(k + 1\)</span>,这一步令<span class="math inline">\(ans - = \binom{ k + 1 }{ k } f_{ k + 1
}\)</span>.这个时候,我们再考虑<span class="math inline">\(k +
2\)</span>的贡献:它将在<span class="math inline">\(f_k\)</span>时贡献<span class="math inline">\(\binom{ k + 2 }{ k }\)</span>次,在<span class="math inline">\(f_{ k + 1 }\)</span>时贡献<span class="math inline">\(- \binom{ k + 2 }{ k + 1 } \binom{ k + 1 }{ k } =
- \binom{ k + 2 }{ k } \binom{ 2 }{ 1
}\)</span>次,那它现在的贡献还有:<span class="math inline">\(- \binom{ k
+ 2 }{ k }\)</span>次.以此类推,可以得到<span class="math inline">\(ans =
\sum_{ i = k }^n f_i ( - 1 )^{ i - k } \binom{ i }{ k }\)</span>.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个<span class="math inline">\(P_i\)</span>.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画<span class="math inline">\(P_i\)</span>,因为只有这个时候,我们才能通过分析满不满足<span class="math inline">\(P_i\)</span>的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成<span class="math inline">\(1 / 0\)</span>就行.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://darkbzoj.cc/problem/2839</p>
<p>简单二项式反演.(埋下伏笔)</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://codeforces.com/gym/101933/problem/K</p>
<p>考虑如果用小于等于<span class="math inline">\(k\)</span>种是好计算的(设为<span class="math inline">\(f_k\)</span>),显然<span class="math inline">\(f_k
= k ( k - 1 )^{ n - 1 }\)</span>,对着做二项式反演.</p>
<p>一开始想直接拿<span class="math inline">\(f_k - f_{ k - 1
}\)</span>,实际上不行,因为颜色之间是有区别的.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6478</p>
<p>这个题面真你妈逆天.</p>
<p>发现我们要求恰好<span class="math inline">\(k\)</span>个,自然的想法是想到钦定<span class="math inline">\(k\)</span>个,不妨假设钦定<span class="math inline">\(k\)</span>个的答案是<span class="math inline">\(f_k\)</span>,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } ans_i \\
ans_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } ( - 1 )^{ i - k } f_i
\end{aligned}
\]</span></p>
<p>至于<span class="math inline">\(f\)</span>怎么求,你直接dp,设<span class="math inline">\(dp_{ i , j }\)</span>表示当前在<span class="math inline">\(i\)</span>,子树内部选了<span class="math inline">\(j\)</span>对祖先后代,那我们就知道目前子树内还有多少可以和<span class="math inline">\(i\)</span>配对.合并是个树形背包.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1228E</p>
<p>ps:本题选入笔记:容斥与反演-反演-二项式反演-Example3.</p>
<p>不妨设至多有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(f_{
i , j }\)</span>,恰好有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(g_{
i , j }\)</span>,注意到:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>令<span class="math inline">\(h_{ n , m } = \sum_{ j = 0 }^m \binom{
m }{ j } g_{ n , j } \\\)</span>,则<span class="math inline">\(f_{ n , m
} = \sum_{ i = 0 }^n \binom{ n }{ i } h_{ i , m } \\\)</span>,而<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>.做两次二项式反演得到<span class="math inline">\(g\)</span>.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥<span class="math inline">\(f_{ n , m } \ne \binom{ N }{ n } \binom{ M }{ m }
k^{ nm } ( k - 1 )^{ NM - nm }\)</span>呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ S , T } &amp; = \sum_{ s \subseteq S } \sum_{ t \subseteq T } g_{ s
, t } \\
f_{ S , T } &amp; = \sum_{ s \subseteq S } h_{ s , T } \\
h_{ S , T } &amp; = \sum_{ t \subseteq T } g_{ S , t } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ S , T } &amp; = k^{ | S | \times | T | } ( k - 1 )^{ NM - | S | | T
| } \\
h_{ S , T } &amp; = \sum_{ s \subseteq S } ( - 1 )^{ | s | - | S | } f_{
s , T } \\
g_{ S , T } &amp; = \sum_{ t \subseteq T } ( - 1 )^{ | t | - | T | } h_{
S , t }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,<span class="math inline">\(g_{ n , m
}\)</span>本身就包含了所有<span class="math inline">\(| S | = n , | T |
= m\)</span>的情况的和,并且在组合数<span class="math inline">\(\binom{ m
}{ j }\)</span>那里就找到了唯一确定的<span class="math inline">\(f_{ s ,
t }\)</span>,因此<span class="math inline">\(f_{ n , m
}\)</span>是唯一确定的.这意味着这里<span class="math inline">\(f\)</span>的<span class="math inline">\(n ,
m\)</span>并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = 2^{ 2^{ n - i } } \binom{ n }{ i } \\
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\
g_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k } f_i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个问题其实非常显然,我们的<span class="math inline">\(g_{ i , j
}\)</span>定义为所有<span class="math inline">\(| S | = i , | T | =
j\)</span>的答案之和.<span class="math inline">\(f\)</span>也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ N - i }{ n - i } \sum_{ j = 0 }^m
\binom{ M - j }{ m - j } g_{ i , j }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求<span class="math inline">\(g_{ N , M }\)</span>,那此时<span class="math inline">\(g\)</span>怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,<span class="math inline">\(g\)</span>是已知的集合,<span class="math inline">\(f\)</span>是未知的集合.我们乘上组合数就可以得到对于<span class="math inline">\(f\)</span>来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把<span class="math inline">\(f\)</span>的定义改成<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的集合的前提下,从中选出<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列并求<span class="math inline">\(g\)</span>.那么你从哪知道的<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列呢?你得组合数啊!</p>
<p>所以,实际上的<span class="math inline">\(f\)</span>是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } \sum_{ i = 0 }^n
\binom{ n }{ i } \sum_{ j = 0 }^m \binom{ m }{ j } g_{ i , j } \\
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } k^{ nm } ( k - 1
)^{ NM - nm }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = n }^N C_n^k g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = n }^N ( - 1 )^{ k - n } C_n^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设<span class="math inline">\(f &#39;_{ i , j }\)</span>为至少有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列不满足条件的方案数,自然有<span class="math inline">\(f &#39;_{ i , j } = f_{ N - i , M - j
}\)</span>.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39;_{ n , m } = \sum_{ i = n }^N \binom{ i }{ n } \sum_{ j = m }^M
\binom{ j }{ m } g &#39;_{ i , j }
\]</span></p>
<p>最后答案就是<span class="math inline">\(g &#39;_{ 0 , 0
}\)</span>.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF997C</p>
<p>和上一题差不多,不妨设<span class="math inline">\(g_{ n , m
}\)</span>表示恰好有<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列同色的答案,<span class="math inline">\(f_{ i , j }\)</span>为钦定<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列同色的答案,自然有:</p>
<p><span class="math display">\[
g_{ n , m } = \sum_{ i = n }^N ( - 1 )^{ i - n } \binom{ N }{ i }
\binom{ i }{ n } \sum_{ j = m }^N ( - 1 )^{ j - m } \binom{ N }{ j }
\binom{ j }{ m } f_{ i , j }
\]</span></p>
<p>可以求出<span class="math inline">\(g_{ 0 , 0
}\)</span>然后再拿全集减一下.</p>
<p>我们求一下<span class="math inline">\(g_{ 0 , 0 }\)</span>:</p>
<p><span class="math display">\[
g_{ 0 , 0 } = \sum_{ i = 0 }^N ( - 1 )^{ i } \binom{ N }{ i } \sum_{ j =
0 }^N ( - 1 )^{ j } \binom{ N }{ j } f_{ i , j }
\]</span></p>
<p>注意到<span class="math inline">\([ i = 0 \lor j = 0
]\)</span>的时候算的挺特殊的,因此先把那些算掉,我们就只需要算下面这个东西:</p>
<p><span class="math display">\[
3 \sum_{ i = 1 }^N ( - 1 )^{ i } \binom{ N }{ i } \sum_{ j = 1 }^N ( - 1
)^{ j } \binom{ N }{ j } 3^{ ( N - i ) ( N - j ) }
\]</span></p>
<p>看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ j = 1 }^N ( - 1 )^{ j } \binom{ N }{ j }{ ( 3^{ ( N - i ) }
) }^{ ( N - j ) } \\
= &amp; ( - 1 )^{ [ N \ne 0 \pmod{ 2 } ] } \sum_{ j = 1 }^N ( - 1 )^{ N
- j } \binom{ N }{ N - j }{ ( 3^{ ( N - i ) } ) }^{ ( N - j ) }
\end{aligned}
\]</span></p>
<p>再看后面那一块:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ j = 1 }^N ( - 1 )^{ N - j } \binom{ N }{ N - j }{ ( 3^{ ( N
- i ) } ) }^{ ( N - j ) } \\
= &amp; \sum_{ j = 0 }^{ N - 1 } ( - 1 )^j \binom{ N }{ j }{ ( 3^{ N - i
} ) }^{ j } \\
= &amp; \sum_{ j = 0 }^{ N } ( - 1 )^j \binom{ N }{ j }{ ( 3^{ N - i } )
}^{ j } - ( - 1 )^N{ ( 3^{ N - i } ) }^N \\
= &amp; ( 1 - 3^{ N - i } )^N - ( - 1 )^N{ ( 3^{ N - i } ) }^N
\end{aligned}
\]</span></p>
<p>这样就做完了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4491</p>
<p>直接二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
f_k &amp; = \sum_{ i = k }^{ m } ( - 1 )^{ i - k } \binom{ m }{ i }
\binom{ i }{ k } \binom{ n }{ iS } \frac{ ( iS ) ! }{ ( S ! )^i } ( m -
i )^{ n - iS } \\
&amp; = \sum_{ i = k }^{ m } ( - 1 )^{ i - k } \frac{ m ! }{ ( m - i ) !
} \frac{ 1 }{ k ! ( i - k ) ! } \frac{ n ! }{ ( n - iS ) ! } \frac{ 1 }{
( S ! )^i } ( m - i )^{ n - iS }
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\(tag = m ! n !\)</span>,自然有:</p>
<p><span class="math display">\[
\frac{ k ! f_k }{ tag } = \sum_{ i = k }^m \frac{ ( - 1 )^{ i - k } }{ (
i - k ) ! } \frac{ ( m - i )^{ n - iS } }{ ( m - i ) ! ( n - iS ) ! ( S
! )^i }
\]</span></p>
<p>注意到枚举量即<span class="math inline">\(i , k , i -
k\)</span>,是一个卷积的形式,更进一步地,我们设<span class="math inline">\(F_k = \frac{ k ! f_k }{ tag } , g_{ i } = \frac{ (
- 1 )^i }{ i ! } , h_i = \frac{ ( m - i )^{ n - iS } }{ ( m - i ) ! ( n
- iS ) ! ( S ! )^i } \\\)</span>.自然有:</p>
<p><span class="math display">\[
F_k = g_{ i - k } h_i
\]</span></p>
<p>再设<span class="math inline">\(g_k = G_{ m - k } , G_k = g_{ m - k
}\)</span>,自然有:</p>
<p><span class="math display">\[
F_k = G_{ m - i + k } h_i
\]</span></p>
<p>ntt即可.</p>
<h4><span id="第十题第十一题">第十题/第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4931</p>
<p>ps:本题选入笔记:多项式与生成函数-生成函数-求微分方程</p>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k }
\binom{ n }{ i } \binom{ n }{ i } i ! ( 2 n - 2 i ) ! 2^i \\
&amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \frac{ 1 }{ k ! ( i - k ) ! }
\frac{ n ! }{ ( n - i ) ! } \frac{ n ! }{ ( n - i ) ! } ( 2 n - 2 i ) !
2^i \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = k }^n ( - 1 )^{ i - k }
\frac{ 1 }{ ( i - k ) ! } \binom{ 2 n - 2 i }{ n - i } 2^{ i - k } \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = 0 }^{ n } \frac{ ( - 2
)^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到后者只与<span class="math inline">\(n -
k\)</span>有关,不妨设其为<span class="math inline">\(f_{ n } = \sum_{ i
= 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i
}\)</span>,预处理一下就可以做到<span class="math inline">\(O ( n^2 + nT
)\)</span>.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! )^2 \frac{ 2^k }{ k ! } f_{ n - k } \\
f_{ n } &amp; = \sum_{ i = 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! }
\binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(f\)</span>是一个卷积的形式,设其生成函数为<span class="math inline">\(F_n\)</span>,<span class="math inline">\(g_n =
\frac{ ( - 2 )^n }{ n ! } , h_n = \binom{ 2 n }{ n
}\)</span>,我们自然有<span class="math inline">\(F = GH\)</span>.</p>
<p>考虑<span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>的生成函数形式,先看<span class="math inline">\(G\)</span>,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum_{ n \geq 0 } \frac{ ( - 2 x )^n }{ n ! } = e^{ - 2 x }
\]</span></p>
<p>再看<span class="math inline">\(H\)</span>,是一个类似卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac{ 1 }{ \sqrt{ 1 - 4 x } }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! )^2 \frac{ 2^k }{ k ! } [ x^{ n - k } ] \frac{ e^{ - 2 x } }{
\sqrt{ 1 - 4 x } }
\]</span></p>
<p>现在看<span class="math inline">\(F\)</span>,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F^2 = e^{ - 4 x }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e^{ - 4 x } \\
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F^2 \\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f_{ i + 1 } - 8 if_i &amp; = 16 f_{ i - 1 } \\
if_i &amp; = 4 ( i - 1 ) f_{ i - 1 } + 8 f_{ i - 2 }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P5339</p>
<p>简单题,不妨设当前这个序列中不同颜色的分别有<span class="math inline">\(a , b , c , d\)</span>个(区别于题面中的<span class="math inline">\(A , B , C , D\)</span>),自然有:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ k = 0 }^n ( - 1 )^k \binom{ k }{ 0 } \binom{ n - 3 k
}{ k } \frac{ ( n - 4 k ) ! }{ ( a - k ) ! ( b - k ) ! ( c - k ) ! ( d -
k ) ! } \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^k \binom{ n - 3 k }{ k } \frac{ ( n - 4
k ) ! }{ ( a - k ) ! ( b - k ) ! ( c - k ) ! ( d - k ) ! }
\end{aligned}
\]</span></p>
<p>然后对最后那个东西做背包就行.</p>
<h4><span id="第十三题">第十三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5400</p>
<h3><span id="字符串算法">字符串算法</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P7114</p>
<p>调和级数加哈希,简单题,场切了.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3526</p>
<p>注意到一个事实:如果这个字符串存在长度为<span class="math inline">\(k\)</span>的周期,等价于存在长度为<span class="math inline">\(len - k\)</span>的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设<span class="math inline">\(q\)</span>为最小周期,如果<span class="math inline">\(2 q \leq n\)</span>,也就是原串能写成<span class="math inline">\(tt \cdots t &#39;\)</span>的形式.我们不妨先求<span class="math inline">\(tt &#39;\)</span>对应的答案,然后在前面拼<span class="math inline">\(t\)</span>.根据<span class="math inline">\(\leq
\frac{ n }{ 2 }\)</span>的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果<span class="math inline">\(2 q &gt; n\)</span>,此时必定有<span class="math inline">\(s = tat\)</span>,其中<span class="math inline">\(t\)</span>是border.考虑递归求解<span class="math inline">\(t\)</span>,然后就只需要找到一个<span class="math inline">\(a\)</span>满足条件,最小的<span class="math inline">\(a\)</span>是全<span class="math inline">\(0\)</span>,能放的话肯定放,不然我们就放一个<span class="math inline">\(0 \cdots 01\)</span>.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全<span class="math inline">\(0\)</span>不合法:</p>
<ol type="1">
<li><p>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l \leq | t | + | a |\)</span>:考虑<span class="math inline">\(l\)</span>的最后一段是一段全<span class="math inline">\(0\)</span>,也就必然意味着<span class="math inline">\(t\)</span>的最后一段是全<span class="math inline">\(0\)</span>,这么不断推下去就可以说明整个序列都是全<span class="math inline">\(0\)</span>,此时放上<span class="math inline">\(0
\cdots 01\)</span>必定合法.</p></li>
<li><p>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l &gt; | t | + | a |\)</span>:不妨设当前的<span class="math inline">\(l\)</span>是最大的那个(最小的无意义,因为需要保证<span class="math inline">\(| l | &gt; | t |\)</span>),此时最短周期必然是<span class="math inline">\(d = 2 | t | + | a | - l\)</span>.由于<span class="math inline">\(| t | + | a |\)</span>也是周期并且二者之和<span class="math inline">\(\leq n\)</span>,因此必然有<span class="math inline">\(d | ( | t | + | a | )\)</span>.把<span class="math inline">\(ta\)</span>按照<span class="math inline">\(d\)</span>长度划分.如果<span class="math inline">\(d \geq | a |\)</span>必有该串是全<span class="math inline">\(0\)</span>串,不然考虑此时<span class="math inline">\(d = | b | + | a |\)</span>,<span class="math inline">\(b\)</span>是<span class="math inline">\(t\)</span>的一段后缀.考虑此时的周期必然<span class="math inline">\(&lt; | b | + | a
|\)</span>,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比<span class="math inline">\(| b | - | a |\)</span>少了<span class="math inline">\(w\)</span>,那么此时必定有<span class="math inline">\(b\)</span>的前<span class="math inline">\(w\)</span>个字符是<span class="math inline">\(0\)</span>,但是由于<span class="math inline">\(0
\cdots 01\)</span>后面第一个<span class="math inline">\(b\)</span>也往前平移了<span class="math inline">\(w\)</span>格,因此它的第<span class="math inline">\(w\)</span>个字符必定是<span class="math inline">\(1\)</span>,这就保证了<span class="math inline">\(0
\cdots 0 1\)</span>必定合法.</p></li>
</ol>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6623</p>
<p>考虑怎么维护所有点权值<span class="math inline">\(+
1\)</span>后的结果.一个自然的想法是,如果前<span class="math inline">\([
0 , k - 1 ]\)</span>位都是<span class="math inline">\(1\)</span>,或者说<span class="math inline">\(v
\equiv - 1 \pmod{ 2^k }\)</span>,那加一后会让第<span class="math inline">\(k\)</span>位取反.所以我们设<span class="math inline">\(t_{ i , j , k }\)</span>表示<span class="math inline">\(i\)</span>的子树内,<span class="math inline">\(\bmod 2^k\)</span>的结果为<span class="math inline">\(j\)</span>的权值的数量.发现这个非常容易维护,用启发式合并可以做到<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<p>考虑这个权值的变化其实比较有规律,因为是树上的距离的差.我们考虑把距离这个东西做树上差分,设<span class="math inline">\(v_i = c_i + dis ( i , 1
)\)</span>,我们要找到子树内部满足条件的其实就是在找满足:</p>
<p><span class="math display">\[
\begin{aligned}
v_i - dis ( x , 1 ) - 1 &amp; \equiv - 1 \pmod{ 2^k } \\
v_i &amp; \equiv dis ( x , 1 ) \pmod{ 2^k }
\end{aligned}
\]</span></p>
<p>也就是说我们每次对这个桶中要找的元素很固定,用一下colorful
tree的trick可以做到<span class="math inline">\(O ( n \log n
)\)</span>.</p>
<p>然后然后,这题还有一个无脑做法是,我们倒着建01trie,这样<span class="math inline">\(+ 1\)</span>后可以快速更新.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1535F</p>
<p>我一开始第一反应是对<span class="math inline">\(n \times len \leq 2
\times 10^5\)</span>这玩意根号分治,但是麻烦得很.</p>
<p>我们来看我当时想的根号分治部分:首先枚举两个字符串然后判断是好做的.我们来看<span class="math inline">\(n\)</span>很大,<span class="math inline">\(len\)</span>较小的时候:此时枚举某个串的后缀,并同时枚举其前缀,然后前缀相同的若干个字符是一个trie上的子树,dfn是一个区间,后缀同理,这样就是一个二维数点问题.</p>
<p>冷静看一下上面的过程,你需要判断中间那一段<span class="math inline">\([ l + 1 , r - 1
]\)</span>是否是单调不降的序列.那如果我们枚举<span class="math inline">\(r\)</span>,然后直接看满足单调不降的序列最靠左的<span class="math inline">\(l\)</span>是谁,再看<span class="math inline">\([ 1
, l ] \cup [ r , n
]\)</span>相同,这样不就直接做完了嘛?总之,先按照字符不同分类,再按照字典序排序,然后枚举<span class="math inline">\(r\)</span>,二分找LCP满足条件的区间,和trie上dfn区间构成一个二维数点,总复杂度<span class="math inline">\(O ( n \times len \log len )\)</span>.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3311</p>
<p>简单题,ACAM上做数位dp.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1437G</p>
<p>首先肯定可以fail树上树剖,这个做法一眼秒.</p>
<p>然后我看题解发现这个题也可以colorful
tree.大概就是你先离线,然后维护时间维的答案,那么所有的修改操作就可以改成将时间在<span class="math inline">\([ l , r ]\)</span>这段的字数答案取<span class="math inline">\(\max\)</span>.这个是一个二维的问题.</p>
<p>但是,我们按照colorful
tree的思路去搞,每次dfs到一个点的时候,把答案加入线段树,在返回的时候撤销.注意colorful
tree其实不用撤销,因为它的信息满足可减性,这题不行.然后就实现了单<span class="math inline">\(\log\)</span>做法.可以使用吉司机,但是没必要,因为查询是单点查询,在每个节点上标记永久化然后一路取<span class="math inline">\(\min\)</span>就行.</p>
<p>总结一下上面的这个东西是啥啊,就是说,你发现我们查询的内容是到根的一条链的最大值,这个还挺难做的,因为这条链不满足什么区间的性质,但是子树满足,因此想到了我们可以把操作改成对子树取<span class="math inline">\(\min\)</span>.但是这个操作不满足可减性,难以消去.</p>
<p>如果不满足可删除性,我们一般要想想它是不是满足可撤销性,显然是满足的.因此自然想到了colorful
tree.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1483F</p>
<p>这题可能比较像lxl当时讲的那个支配对问题.我们考虑合法的<span class="math inline">\(( i , j
)\)</span>的数量的一个上界.一个自然的发现是,考虑先把所有的串按照长度排个序,然后对于较长的串,去找较小的串是否和它满足条件,一个自然的观察是,对于这个较长的串的每个位置<span class="math inline">\(i\)</span>,最多只有一个串是满足条件的<span class="math inline">\([ 1 , i
]\)</span>的后缀.因为如果有多个后缀可以选取最长的那个(注意当<span class="math inline">\(i =
len\)</span>的时候要选次长的那个,最长的是这个串本身),于是合法的<span class="math inline">\(( i , j )\)</span>数量只有<span class="math inline">\(\sum len\)</span>个.首先这些<span class="math inline">\(( i , j
)\)</span>是有重复的,不过去重很简单.我们现在需要判定是否统计上了<span class="math inline">\(( i , j )\)</span>和<span class="math inline">\((
k , j )\)</span>使得<span class="math inline">\(i\)</span>是<span class="math inline">\(k\)</span>的子串,<span class="math inline">\(k\)</span>是<span class="math inline">\(j\)</span>的子串.不难发现如果有这种情况出现,必然是因为<span class="math inline">\(k\)</span>在<span class="math inline">\(j\)</span>中的出现位置在某一个<span class="math inline">\(i\)</span>之后,但是<span class="math inline">\(k\)</span>中又出现了<span class="math inline">\(i\)</span>,因此它的左端点必然在<span class="math inline">\(i\)</span>之前.我们维护一个单调栈,每次弹出左端点比当前左端点靠右的那些点,这些一定不会贡献答案.</p>
<p>我本来以为这样就做完了,实际上没有,上面的过程出了什么问题呢?我们确实能删掉所有的<span class="math inline">\(( i , j )\)</span>使得存在<span class="math inline">\(( k , j )\)</span>满足<span class="math inline">\(i\)</span>是<span class="math inline">\(k\)</span>的子串,并且<span class="math inline">\(i\)</span>不是<span class="math inline">\(k\)</span>的后缀.但是如果是后缀的话我们是有可能删不掉的.</p>
<p>这个问题怎么解决呢?考虑这种事情会发生当且仅当<span class="math inline">\(i\)</span>所代表的ACAM的节点是<span class="math inline">\(k\)</span>的父亲.于是我们用树状数组维护这个东西,具体来说,从大到小判断<span class="math inline">\(i\)</span>是否合法,并且在这个点上<span class="math inline">\(+
1\)</span>,用树状数组统计子树内部是否有点就行.注意即使被弹出栈的那些字符串,也需要在这个过程中删去它所有的后缀.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1110H</p>
<p>考虑一个暴力的想法是,这个<span class="math inline">\([ l , r
]\)</span>的限制条件其实等价于要求<span class="math inline">\([ l , r
]\)</span>内的所有数字作为子串出现的次数加起来.把所有的这些字符串全部扔进ACAM,然后对着它dp.不妨设<span class="math inline">\(dp_{ i , j }\)</span>表示当前走到<span class="math inline">\(i\)</span>节点,然后后面还可以填<span class="math inline">\(j\)</span>个位置的答案,自然有:</p>
<p><span class="math display">\[
dp_{ i , j } = \max \{ dp_{ son , j - 1 } \} + cnt_i
\]</span></p>
<p>其中<span class="math inline">\(cnt_i\)</span>表示<span class="math inline">\(i\)</span>节点是多少子串的endn,构造方案是简单的.</p>
<p>考虑如何优化,注意到dp部分看上去挺优秀的,难搞的是ACAM的建树.我们不能把所有数字全扔进去.这种区间信息看上去就是如果走到当前,后面全填<span class="math inline">\(0\)</span>或者后面全填<span class="math inline">\(9\)</span>都能满足条件,那我们就开摆.更具体地来说,我们发现当前的最靠前的那一位没有用了:以它为开头的一定可以找到一个答案(其实因为填的数位).所以我们直接跳fail把那一位跳掉.</p>
<p>如果说的再形象一点的话就是,我们插入的过程其实很废,对于一些特定的前缀<span class="math inline">\(x\)</span>,它的子树内部会形成一个满十叉树.这个是我们无法接受的.来考虑这个东西怎么办,我们一路dfs到叶子后肯定要跳fail,根据ACAM的建树过程,这等价于跳到<span class="math inline">\(x\)</span>的fail,因此其实就等价于把<span class="math inline">\(x\)</span>这一位(或者后面的几位)跳掉.</p>
<p>但是,如果你顺着这个思路想,你开始逐渐剥掉满十叉树,然后一点一点搞,你会做的巨他妈复杂.</p>
<p>我们完全没有必要只在满十叉树的时候才跳跃.换句话说,如果后面填<span class="math inline">\(len \in [ l , r
]\)</span>长度的字符串全部合法,我们就在这里统计答案,然后继续跳son而不是fail.</p>
<p>我们考虑既然这里填<span class="math inline">\(len \in [ l , r
]\)</span>都可以,那填<span class="math inline">\(l -
1\)</span>的长度或者填<span class="math inline">\(r +
1\)</span>的长度就不一定能全部合法了.只有后面几位填的满足某种条件才能合法.但是你注意啊,我们并不在左端点统计答案,而是在这个串填到某一位(可能是最后一位),然后后面都可以随便填的时候,才统计这里的答案,不一定跳fail.而我们跳fail的时候,会删去若干个前缀字符,这些答案会随着fail链一路传过来.还有一个问题是,如果我们跳fail跳到了被删去的虚拟节点怎么办?这种情况压根不会有贡献:这个被删去的虚拟节点的贡献会被传到它的某个祖先上,然后早早地贡献掉.我们跳到的fail应该是第一个不是虚拟节点的位置.因此这里也不会被更新答案.</p>
<p>这样整个题就是简单的了.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4218</p>
<p>首先有一个<span class="math inline">\(O ( n^2
)\)</span>的暴力是,我们暴力在<span class="math inline">\(SAM\)</span>上跑一遍所有的串.我们考虑怎么优化这个东西.</p>
<p>树上路径,想到点分治,我们考虑对于一个分治中心<span class="math inline">\(x\)</span>,求出所有经过它的路径.这个怎么求呢?我们考虑先求出所有<span class="math inline">\(u \rightarrow x\)</span>的路径,以及所有<span class="math inline">\(x \rightarrow
v\)</span>的路径,假设前者的终点为<span class="math inline">\(p\)</span>,后者的起点为<span class="math inline">\(p\)</span>,那我们可以在<span class="math inline">\(p\)</span>节点统计答案.但是发现<span class="math inline">\(u \rightarrow
x\)</span>这个东西需要往前加字符,不过这个好做,首先往前加字符等价于在parent
tree上跳儿子,而所有的儿子前面的第一个字符肯定是不同的,我们处理出<span class="math inline">\(son_{ x , c }\)</span>表示在<span class="math inline">\(x\)</span>这个节点,往前加一个字符<span class="math inline">\(c\)</span>会到哪个节点.当然这个你实在不行把串反过来也行.</p>
<p>以及为了不让<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>在同一棵子树内,我们需要对其做容斥.不难发现每次操作和每次容斥的复杂度都是<span class="math inline">\(O ( m + size )\)</span>的.总复杂度<span class="math inline">\(O ( n \log n + nm )\)</span>,好像不太行.</p>
<p>冷静一下,我们把<span class="math inline">\(siz\)</span>较小的那些拿上面的暴力处理掉,这样就只有<span class="math inline">\(siz\)</span>较大的那些会有用了.这个复杂度怎么证明呢?我们考虑点分树.不妨假设它是一棵二叉树(其它的情况是类似的).</p>
<p>考虑将它的第<span class="math inline">\(B\)</span>层以下的树全部暴力,这里一共有<span class="math inline">\(2^{ B }\)</span>棵树,每棵复杂度是<span class="math inline">\(O ( 2^{ 2 ( \log n - B ) } )\)</span>的.</p>
<p>它的第<span class="math inline">\(B\)</span>层以上的跑上面的点分树,这里一共有<span class="math inline">\(2^B\)</span>个节点,每个节点要跑一次<span class="math inline">\(O ( n + m )\)</span>的做法.</p>
<p>平衡一下复杂度,设<span class="math inline">\(B = \frac{ \log n }{ 2
}\)</span>,此时复杂度<span class="math inline">\(O ( ( n + m ) \sqrt{ n
} )\)</span>.</p>
<h3><span id="动态规划第二期">动态规划第二期</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P9318</p>
<p>不合法的情况如此方便,因为两边直接独立了,因此直接考虑二项式反演,设<span class="math inline">\(f_k\)</span>表示恰好有<span class="math inline">\(k\)</span>个裂缝,<span class="math inline">\(g_k\)</span>表示钦定有<span class="math inline">\(k\)</span>个裂缝,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g_k &amp; = \sum_{ i = k }^w \binom{ i }{ k } f_i \\
f_k &amp; = \sum_{ i = k }^w \binom{ i }{ k } ( - 1 )^{ i - k } g_i \\
ans &amp; = f_0 = \sum_{ i = 0 }^w ( - 1 )^{ i } g_i
\end{aligned}
\]</span></p>
<p>考虑设一个高为<span class="math inline">\(h\)</span>,长为<span class="math inline">\(k\)</span>的段随便填的方案数,显然就是每一层都随便填的方案数,也就是<span class="math inline">\(w_k = ( F_k )^h ( w_0 = 0 )\)</span>,其中<span class="math inline">\(F_k\)</span>是斐波那契数列的第<span class="math inline">\(k\)</span>项,那么<span class="math inline">\(g_i\)</span>就是这玩意做卷积.更具体地,我们设<span class="math inline">\(g_{ i , j }\)</span>表示目前长度为<span class="math inline">\(j\)</span>,分成了<span class="math inline">\(i\)</span>段的答案,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g_{ i , j } &amp; = \sum_{ k &lt; j } g_{ i - 1 , k } w_{ j - k } \\
G_i &amp; = W^i
\end{aligned}
\]</span></p>
<p>这个生成函数形式其实没啥用,因为模数是<span class="math inline">\(10^9
+ 7\)</span>.上述dp的复杂度是<span class="math inline">\(O ( n^3
)\)</span>的.</p>
<p>冷静一下不要魔怔,我们考虑别二项式反演,直接补集转化,这样就只需要知道最靠前的裂缝.换句话说,我们设<span class="math inline">\(f_i\)</span>表示当前考虑到前<span class="math inline">\(i\)</span>列,然后没有裂缝的方案数,不难发现<span class="math inline">\(f_n = w_n - \sum_{ k = 1 }^{ n - 1 } f_k w_{ n - k
}\)</span>.这样就是<span class="math inline">\(O ( w^2 )\)</span>的.</p>
<p>冷静一下,注意到<span class="math inline">\(wh\)</span>有限制,因此复杂度应该要和<span class="math inline">\(wh\)</span>有关,考虑对于一个联通的块的答案,你的最右侧一定不是平的,应该是有凹凸的.我们设<span class="math inline">\(f_{ i , j }\)</span>表示当前dp完了前<span class="math inline">\(i\)</span>列,在第<span class="math inline">\(i +
1\)</span>列凸出来了<span class="math inline">\(j\)</span>个位置.转移的话考虑凹的位置填什么,如果填<span class="math inline">\(2\)</span>就往后再凸一格,如果填<span class="math inline">\(1\)</span>就没啥事.具体地:</p>
<p><span class="math display">\[
f_{ n , m } \binom{ h - m }{ k } \rightarrow f_{ n + 1 , k } , k \in [ 0
, h - m ]
\]</span></p>
<p>这个dp的复杂度为<span class="math inline">\(O ( wh^2
)\)</span>.注意到这两个dp的复杂度不同,于是分治,不妨设<span class="math inline">\(N = wh\)</span>,</p>
<p>第一个dp的复杂度是<span class="math inline">\(O ( \frac{ N^2 }{ h^2 }
)\)</span>,第二个dp的复杂度是<span class="math inline">\(O ( Nh
)\)</span>,当<span class="math inline">\(h \leq N^{ \frac{ 1 }{ 3 }
}\)</span>的时候使用第二个dp,不然使用第一个,复杂度<span class="math inline">\(O ( N^{ \frac{ 4 }{ 3 } } )\)</span>.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1250D</p>
<p>最重要的观察在于,这题等价于保留最多的区间,使得若其中某两个区间有交,那么它们必定颜色相同,但是同时需要满足一些形如某个区间只能染某种颜色的限制条件.原因很简单,首先原题的意思自然是找到染色方式,使得满足与其有交的区间颜色必定和它相同.那么对于一个满足条件的区间,如果与它有交的区间不满足条件,我们把那个区间删了这个区间也不会不满足条件.于是合法的不会变成不合法,接下来需要说明不合法的不会变成合法.首先是原本已经确定了颜色的区间,这个限制好做.然后是如果一个区间没有确定颜色,那它不能被包括在多个确定了的区间.这等价于,我们对于与右端点相交的所有无色区间全部作为新的右端点来更新.这样后面选的时候就不会错误更新右端点了.</p>
<p>或者我们换一个更清晰的描述,我们现在想要得到一些极长的段,使得这些段两两不交,并且与这些段相交的区间都是一个颜色.那么被完全包含在这个段内的区间显然就是答案,我们要最大化这个.</p>
<p>然后上面形成若干限制条件,但是这个在下面的dp中是好处理的.不过有个细节是,如果有两个相邻的连续段(不一定紧邻)的颜色相同,那么我们上一个区间的后面拖着的无色区间是不必对此产生影响的.这怎么办呢?特判一下同色.</p>
<p>这样的dp就很好设计了,更具体地,设<span class="math inline">\(f_{ r , k
}\)</span>表示目前<span class="math inline">\([ 1 , r
]\)</span>,包含<span class="math inline">\(r\)</span>的那个区间颜色是<span class="math inline">\(k\)</span>,最多能保留多少个区间.自然有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f_{ r , k } \leftarrow cnt_{ l , r , k } +
\max_{ i = 0 }^{ l - 1 } f_{ i , k &#39; }
\]</span></p>
<p>设<span class="math inline">\(g_{ i } = \max_{ k } f_{ i , k
}\)</span>,我们有:</p>
<p><span class="math display">\[
[ l , r ] = k \Rightarrow f_{ r , k } \leftarrow cnt_{ l , r , k } +
\max_{ i = 0 }^{ l - 1 } g_{ i }
\]</span></p>
<p>对于<span class="math inline">\(g_i\)</span>做前缀<span class="math inline">\(\max\)</span>,这样就只需要枚举<span class="math inline">\(r , k\)</span>.复杂度<span class="math inline">\(O
( n^2 c )\)</span>.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1158F</p>
<p>考虑如何判断一个串的密度,不妨设它密度为<span class="math inline">\(P\)</span>,我们从左往右找到第一个位置,使得前缀的密度为<span class="math inline">\(1\)</span>,那么显然这个位置的后缀的密度是<span class="math inline">\(P -
1\)</span>,如果小了,那么这个第一个位置所代表的那个数字开头的子序列就不全.如果多了,那显然可以构造出密度至少为<span class="math inline">\(P +
1\)</span>的子序列.由上面这个描述,我们发现一个密度为<span class="math inline">\(P\)</span>的序列一定可以分成<span class="math inline">\(P\)</span>个子段,使得每个子段都出现了<span class="math inline">\([ 1 , c
]\)</span>中所有的数字.更进一步地,我们如果不是划分,那么<span class="math inline">\(P\)</span>中一定存在<span class="math inline">\(P\)</span>个互不相交的子段,使得每个子段都出现了<span class="math inline">\([ 1 , c
]\)</span>中所有的数字并且每个子段最后的那个元素只出现了一次.顺便我们还可以发现<span class="math inline">\(p \leq \frac{ n }{ c }\)</span>.</p>
<p>由上面,我们可以发现一个状压dp,也就是设<span class="math inline">\(dp_{ i , j , S }\)</span>表示当前走到<span class="math inline">\(i\)</span>,前面的密度为<span class="math inline">\(j\)</span>,然后如果在后面全出现了<span class="math inline">\(S\)</span>中的数字,那么密度会变大<span class="math inline">\(1\)</span>.这样给出了一个<span class="math inline">\(\frac{ n^2 }{ c } 2^c\)</span>的做法.</p>
<p>质数感觉不太行啊,考虑考虑dp,上面的形式看上去就很好dp,设<span class="math inline">\(dp_{ i , j }\)</span>表示当前在<span class="math inline">\(i\)</span>然后密度是<span class="math inline">\(j\)</span>的方案数,再设<span class="math inline">\(f_{ l , r }\)</span>表示在<span class="math inline">\([ l , r ]\)</span>中选出一个子序列,<span class="math inline">\(r\)</span>必选且<span class="math inline">\(a_r\)</span>只出现了一次的方案数.不妨设<span class="math inline">\(T_i\)</span>表示<span class="math inline">\(i\)</span>在这个区间出现的次数,不难发现<span class="math inline">\(f_{ l , r } = \prod_{ i \ne a_r } ( 2^{ T_i } - 1
)\)</span>.这个只需要枚举<span class="math inline">\(l\)</span>扫<span class="math inline">\(r\)</span>就可以<span class="math inline">\(O (
n^2 )\)</span>算.自然有转移:</p>
<p><span class="math display">\[
dp_{ i , j } = \sum_{ k &lt; i } dp_{ k , j - 1 } f_{ k + 1 , i }
\]</span></p>
<p>不过吧这么转移有一个小问题,那就是我们的<span class="math inline">\(dp_{ i , j }\)</span>必须是最后一段以<span class="math inline">\(i\)</span>结尾.那么我们最后统计答案还要算上最后的那一段没有选出<span class="math inline">\([ 1 , c ]\)</span>的答案.不过这个也好算.</p>
<p>但是还有一个方式,那就是从后往前dp,然后每次放这么一段,对dp取一个后缀和来转移.</p>
<p>总之,这个dp的复杂度是<span class="math inline">\(O ( \frac{ n^3 }{ c
} )\)</span>的.取<span class="math inline">\(c = \log
n\)</span>为两个复杂度的边界,这样总复杂度是<span class="math inline">\(O
( n^2 \log n )\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1175G</p>
<p>显然设<span class="math inline">\(f_{ i , j }\)</span>为前<span class="math inline">\(j\)</span>个划分了<span class="math inline">\(i\)</span>段,自然有:</p>
<p><span class="math display">\[
f_{ i , j } = \min_{ k &lt; j } \{ f_{ i - 1 , k } + ( j - k ) \max_{ l
= k + 1 }^j a_l \}
\]</span></p>
<p>第一反应是决策单调性,可惜没有.</p>
<p>不过后面那个形式很简单,我们暴力一点维护这个东西.用单调栈维护出当前哪些后缀的最大值相等,不妨记这个最大值为<span class="math inline">\(m\)</span>.我们改成刷表更新:</p>
<p><span class="math display">\[
f_{ i - 1 , k } + ( j - k ) \max_{ l = k + 1 }^j a_l \rightarrow f_{ i ,
j }
\]</span></p>
<p>对于每层<span class="math inline">\(i\)</span>从左往右扫<span class="math inline">\(k\)</span>,然后维护单调栈,然后对于每个点,它对右边的贡献在<span class="math inline">\(\max_{ l = k + 1 }^j
a_l\)</span>不变的情况下,就是一条稳定的一次函数.但是这样还有一个问题,就是我们如何快速求出一个区间的所有的直线.这个的话,我们考虑对于不同的<span class="math inline">\(\max_{ l = k + 1 }^j a_l\)</span>,求出最小的<span class="math inline">\(f_{ i - 1 , k } - k \max_{ l = k + 1 }^j
a_l\)</span>,这相当于一个凸包,然后用斜率为<span class="math inline">\(m\)</span>的直线来切点.然后合并两个凸包可以启发式合并,用链表维护队列.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P9312</p>
<p>首先观察到我们可以限制手上的灯笼能照亮的海拔是一段区间,因为我们可以先选择不断扩张,而不是提前买,等到了需要用的时候再买就行.</p>
<p>一个自然的想法是<span class="math inline">\(f_{ s , l , r
}\)</span>表示以<span class="math inline">\(s\)</span>为起点,当前能走到的海拔高度是<span class="math inline">\([ l , r ]\)</span>.为什么需要记录<span class="math inline">\(s\)</span>呢?因为可能有不同的区间走出来的海拔高度都是<span class="math inline">\([ l , r ]\)</span>.那我们设<span class="math inline">\(f_{ l , r
}\)</span>为当前海拔最低的那个灯编号是<span class="math inline">\(l\)</span>,最高的那个编号是<span class="math inline">\(r\)</span>.然后我们要知道的就是<span class="math inline">\(f_{ s , s
}\)</span>.然后按照区间从大到小dp.这样有一个<span class="math inline">\(O ( k^3 )\)</span>的做法.</p>
<p>考虑如何优化,不妨假设当前新买的灯笼是第<span class="math inline">\(u\)</span>个,那么我们分情况讨论一下:</p>
<ol type="1">
<li><p><span class="math inline">\(f_{ i , u } + c_u \rightarrow f_{ i ,
j }\)</span>.这种情况需要保证<span class="math inline">\(u\)</span>能买的地方在<span class="math inline">\(i , j\)</span>的控制区域里,并且需要满足<span class="math inline">\(u\)</span>的区间和<span class="math inline">\(i ,
j\)</span>的区间是相交的.这种情况上也就是需要<span class="math inline">\(u\)</span>的下界小于等于<span class="math inline">\(j\)</span>的上界.这个比较好处理,我们从大到小枚举<span class="math inline">\(j\)</span>,等<span class="math inline">\(f_{ i , u
}\)</span>不合法的时候把它删了就是了.</p></li>
<li><p><span class="math inline">\(f_{ u , u } + c_u \rightarrow f_{ i ,
j }\)</span>.和上面是类似的.</p></li>
</ol>
<p>也就是说,我们现在唯一最需要搞定的就是怎么让<span class="math inline">\(u\)</span>能买的地方在<span class="math inline">\(i ,
j\)</span>的控制区域里,不难发现这是一个看上去比较典的线段树维护dp.</p>
<p>事实上有一种更简单的写法,不妨设<span class="math inline">\(L ,
R\)</span>为实际控制的海拔范围,<span class="math inline">\(S ,
T\)</span>为实际控制的山峰范围,我们先把转移仔细写一下:</p>
<ol type="1">
<li><p><span class="math inline">\(f_{ l , u } + c_u \rightarrow f_{ l ,
r } ( R_u &gt; R_r \geq L_u \land u \in [ S_l , T_r ]
)\)</span>.</p></li>
<li><p><span class="math inline">\(f_{ u , r } + c_u \rightarrow f_{ l ,
r } ( L_u &lt; L_l \leq R_u \land u \in [ S_l , T_r ]
)\)</span>.</p></li>
<li><p><span class="math inline">\(f_{ u , u } + c_u \rightarrow f_{ l ,
r } ( L_u &lt; L_l \leq R_u \land R_u &gt; R_r \geq L_u \land u \in [
S_l , T_r ] )\)</span>.</p></li>
</ol>
<p>按照<span class="math inline">\(L\)</span>从小到大枚举,按照<span class="math inline">\(R\)</span>从大到小枚举,那上面的所有转移都是无后效性的.</p>
<p>注意到第三种转移没有意义,我们可以直接改写成:</p>
<ol type="1">
<li><p><span class="math inline">\(\min \{ f_{ l , u } , f_{ u , u } \}
+ c_u \rightarrow f_{ l , r } ( R_u &gt; R_r \geq L_u \land u \in [ S_l
, T_r ] )\)</span>.</p></li>
<li><p><span class="math inline">\(\min \{ f_{ u , r } , f_{ u , u } \}
+ c_u \rightarrow f_{ l , r } ( L_u &lt; L_l \leq R_u \land u \in [ S_l
, T_r ] )\)</span>.</p></li>
</ol>
<p>原因在于,我们其实只想要让<span class="math inline">\(u\)</span>与<span class="math inline">\(l ,
r\)</span>所代表的区间相交,这个比较重要,其它的都不重要.就算转移是错误的,那样转移一定不优秀.</p>
<p>此刻对于(1)我们想知道的就是固定<span class="math inline">\(l\)</span>的情况下,按照<span class="math inline">\(R\)</span>从大到小枚举的贡献,以及对称情况,不难发现这个用堆也是能做的.也就是在<span class="math inline">\(l\)</span>相同的前提下,如果<span class="math inline">\(R_i &lt; R_j &lt; R_k\)</span>,如果<span class="math inline">\(k\)</span>不能贡献到<span class="math inline">\(j\)</span>,那么<span class="math inline">\(k\)</span>必然不能贡献到<span class="math inline">\(i\)</span>,这就保证了堆的正确性.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P8294</p>
<p>毛估估的话就是设<span class="math inline">\(f_{ x , s , t
}\)</span>表示在断开<span class="math inline">\(x\)</span>到父亲这条边时,<span class="math inline">\(x\)</span>的值来自子树内的点<span class="math inline">\(s\)</span>,然后从父亲换下来的值将要去子树内的<span class="math inline">\(t\)</span>.不难发现<span class="math inline">\(( x
, s , t )\)</span>合法当且仅当<span class="math inline">\(x = lca ( s ,
t )\)</span>,这样状态数就是<span class="math inline">\(O ( n^2
)\)</span>的.</p>
<p>来细细写一写转移:</p>
<p>首先,如果<span class="math inline">\(cnt_{ son } =
0\)</span>,显然<span class="math inline">\(f_{ x , x , x } =
d_x\)</span>.</p>
<p>如果<span class="math inline">\(cnt_{ son } =
1\)</span>,不妨设其儿子是<span class="math inline">\(u\)</span>,不难发现此时必有<span class="math inline">\(s_x = x \lor t_x = x\)</span>,讨论一下:</p>
<p>若<span class="math inline">\(s_x =
x\)</span>,那么之间换出去就行,然后因为要一路换下去:</p>
<p><span class="math display">\[
f_{ x , x , t_x } \leftarrow f_{ u , s_u , t_x } + d_x
\]</span></p>
<p>反之,那么要先把<span class="math inline">\(s_x\)</span>换到<span class="math inline">\(x\)</span>这里,然后再换出去,此时有:</p>
<p><span class="math display">\[
f_{ x , s_x , x } \leftarrow f_{ u , s_x , t_u } + d_x + d_{ s_x } (
dep_{ s_x } - dep_{ x } )
\]</span></p>
<p>注意到上述复杂度均为<span class="math inline">\(O ( n^2
)\)</span>.因为枚举一下<span class="math inline">\(( s_u , t_x
)\)</span>或<span class="math inline">\(( s_x , t_u
)\)</span>就可以确定<span class="math inline">\(u\)</span>,而<span class="math inline">\(x\)</span>是<span class="math inline">\(u\)</span>的父亲,自然也可以确定.</p>
<p>这个式子已经给了我们启发了,剩下的类似.有时间再补这个题吧,太精神污染了.</p>
<h3><span id="数据结构">数据结构</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1648D</p>
<p>不妨设<span class="math inline">\(f_i\)</span>表示从<span class="math inline">\(( 1 , 1 )\)</span>走到<span class="math inline">\(( 2 , i
)\)</span>的最大收益,显然求出这个后再拼一下第三行的后缀和就是答案.我们枚举覆盖<span class="math inline">\(( 2 , i )\)</span>的区间是<span class="math inline">\(k\)</span>,此时必然需要满足<span class="math inline">\(l_k \leq i \leq r_k\)</span>.</p>
<p>不妨设<span class="math inline">\(sum\)</span>表示每一行的前缀和,<span class="math inline">\(sufsum\)</span>表示第三行的后缀和,注意到转移:</p>
<p><span class="math display">\[
\begin{aligned}
- c_k + \max_{ l_k - 1 \leq j &lt; i \leq r_k } \{ f_j \} &amp;
\rightarrow f_i \\
- c_k + \max_{ l_k \leq j \leq i \leq r_k } \{ sum_{ 1 , j } - sum_{ 2 ,
j - 1 } \} &amp; \rightarrow f_i
\end{aligned}
\]</span></p>
<p>这个东西即使我们枚举<span class="math inline">\(k ,
i\)</span>,然后数据结构优化<span class="math inline">\(j\)</span>来转移它也是艰难的.那咋办呢?我们考虑我们枚举<span class="math inline">\(k\)</span>的原因是,我们需要保证<span class="math inline">\(i \leq r_k\)</span>.如果我们钦点<span class="math inline">\(i =
r_k\)</span>,那我们上面的枚举就只有一维了.也就是需要保证<span class="math inline">\(i\)</span>右边的点一定走不到,这样我们上面的转移仍然是正确的.至于计算答案,一个反应是把这个<span class="math inline">\(f\)</span>做一下后缀<span class="math inline">\(\max\)</span>.但其实不对!因为你往后多走点可能多吃到了一点<span class="math inline">\(a\)</span>.</p>
<p>那么怎么处理这个东西呢?考虑如果当前选的这个区间不是最后一个区间,那我从后面的<span class="math inline">\(r\)</span>走到前面的一个<span class="math inline">\(i\)</span>再拐到第三行去,显然只会有第二行的一段和的差别,我们把这个差别统计进去就行.但是如果只开了一个区间,也就是从第一行拐下来没到结尾直接拐下第三行了,那么第一行的贡献也要减去.我们可以把<span class="math inline">\(f_{ i }\)</span>改成<span class="math inline">\(f_{ i , 0 / 1 }\)</span>来解决这种问题.</p>
<p>于是吧,我们就有了下面这个转移:</p>
<p><span class="math display">\[
\begin{aligned}
- c_k + \max_{ l_k - 1 \leq j &lt; r_k } \{ f_{ j , 0 } , f_{ j , 1 } \}
&amp; \rightarrow f_{ r_k , 1 } \\
- c_k + \max_{ l_k \leq j \leq r_k } \{ sum_{ 1 , j } - sum_{ 2 , j - 1
} \} &amp; \rightarrow f_{ r_k , 0 }
\end{aligned}
\]</span></p>
<p>然后怎么贡献答案呢?首先你不能往左走太多,至少不能超过最后选的那个区间.事实上我们发现最后一定只有一个区间的右端点超过了拐点.因为选择的所有区间一定没有包含关系,而右端点可以对拐点取<span class="math inline">\(\min\)</span>.因此我们枚举当前最靠右的那个区间<span class="math inline">\(k\)</span>,以及最后拐到第三行的点<span class="math inline">\(i\)</span>,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
- c_k + \max_{ l_k - 1 \leq j &lt; r_k } \{ f_{ j , 0 } , f_{ j , 1 } \}
+ \max_{ j &lt; i \leq r_k } \{ sum_{ 2 , i } + sufsum_{ i } \} &amp;
\rightarrow ans \\
- c_k + \max_{ l_k \leq j \leq i \leq r_k } \{ sum_{ 1 , j } - sum_{ 2 ,
j - 1 } + sum_{ 2 , i } + sufsum_i \} &amp; \rightarrow ans
\end{aligned}
\]</span></p>
<p>要统计所有<span class="math inline">\(j &lt; i\)</span>或者<span class="math inline">\(j \leq
i\)</span>的点对的答案在线段树上都是好做的.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P9371</p>
<p>考虑如何判断<span class="math inline">\(x\)</span>是否是这个区间的中位数:我们把大于<span class="math inline">\(x\)</span>的记作<span class="math inline">\(1\)</span>,小于<span class="math inline">\(x\)</span>的记作<span class="math inline">\(-
1\)</span>,<span class="math inline">\(x\)</span>记作<span class="math inline">\(0\)</span>,如果区间和的绝对值小于等于<span class="math inline">\(x\)</span>的出现次数,那么<span class="math inline">\(x\)</span>满足条件.</p>
<p>我们先扫值域,这样修改每个点的取值的总复杂度均摊.对于每一个权值<span class="math inline">\(v\)</span>,枚举权值是<span class="math inline">\(v\)</span>的一个点作为这个区间中最靠左的<span class="math inline">\(v\)</span>,然后考虑找到最大的右端点使得合法,而由于确定了最靠左的<span class="math inline">\(v\)</span>,我们其实是不在乎这个区间左端点是啥的,只要包含这个点就行,不妨设这个点为<span class="math inline">\(l\)</span>.</p>
<p>接下来在每个点记录以这个点的为结尾的所有后缀和(要求左端点小于等于<span class="math inline">\(l\)</span>)的集合.不难发现,这个集合一定是一段区间,因为每个值只有可能是<span class="math inline">\(\pm 1\)</span>或<span class="math inline">\(0\)</span>.于是我们要维护的就是这些点的最大后缀和以及最小后缀和,然后判断这个值与<span class="math inline">\(x\)</span>的大小关系.用线段树维护这两个东西的<span class="math inline">\(\max\)</span>和<span class="math inline">\(\min\)</span>,能往右跳就往右跳.</p>
<p>有个细节是我们需要保证这些后缀和的左端点小于等于<span class="math inline">\(l\)</span>,这其实等价于直接求<span class="math inline">\(l\)</span>这里的最小后缀和以及最大后缀和,然后在每个点上只需要存这个点与<span class="math inline">\(l\)</span>这段区间和即可,这个在<span class="math inline">\(l\)</span>的移动过程中是好维护的.</p>
<p>至于最大后缀和的合并是简单的.</p>
<p>写起来发现上面那个东西其实不太好搞啊,我们考虑改改描述,上面等价于将每个区间改成最小后缀和<span class="math inline">\(- x\)</span>出现次数,以及最大后缀和<span class="math inline">\(+
x\)</span>出现次数,然后只需要判断这个区间是否包含<span class="math inline">\(0\)</span>.好像还是不太好做???</p>
<p>冷静一下,注意到相邻两个位置的最大后缀和相差不超过<span class="math inline">\(1\)</span>,这意味着我们可以维护一段区间的所有区间的并,这必定还是一个区间.然后判断这个并是否包含<span class="math inline">\(0\)</span>,这个就方便线段树上二分了.至于我们的修改操作,无非是以下几种操作:</p>
<ol type="1">
<li><p>对于每个<span class="math inline">\(l\)</span>以及它的一对后缀和,在线段树上找到最靠右的一个叶子使得这个区间在加上这对后缀和更改后包含<span class="math inline">\(0\)</span>.</p></li>
<li><p>在更改当前处理的值<span class="math inline">\(v\)</span>的时候,将所有点的值恢复为前缀和.</p></li>
<li><p>在更改当前处理的值<span class="math inline">\(v\)</span>的时候,将某些点的值置为<span class="math inline">\(- 1\)</span>,将某些点的值置为<span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>显然都好做.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P7220</p>
<p>ps:本题选入笔记:常见套路-二进制分组-Example1</p>
<p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点<span class="math inline">\(( x , y )\)</span>,随着<span class="math inline">\(x\)</span>的增大<span class="math inline">\(y\)</span>不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.考虑求出所有能影响到一个询问的区间,把它们扔到线段树上,然后就可以用线段树分治维护这个东西.具体来说,我们在线段树上dfs,每次遇到一个区间,把该搞得全部搞完,然后这个点的位置就留在这里了,在后面dfs到其它的区间后再改.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9168</p>
<p>场上写了<span class="math inline">\(48
pts\)</span>,简单来说就是对于每个<span class="math inline">\(m\)</span>,从下往上合并,然后当某一个时刻某棵子树内人数大于子树大小,就把最菜的那几个给删了.根据Hall定理,这样做显然是正确的.</p>
<p>接下来看怎么优化,首先第一反应肯定是线段树分治,这样我们只需要做加入和撤销,就不需要做删除了.撤销总是好做的.</p>
<p>那么只有加入怎么做呢?这个点能造成的影响无非是以下几种:</p>
<ol type="1">
<li><p>它被加入,没有别的点被删除.</p></li>
<li><p>它被加入,另一个点被删除.</p></li>
<li><p>它没有被加入.</p></li>
</ol>
<p>注意到(1)发生当且仅当这个点到根的路径上没有节点是满节点,这个判一下就行.</p>
<p>然后考虑(2),(3),淘汰必然会发生,并且必定是在离插入点最近的那个满的祖先.</p>
<p>这样的话我们需要实现的就是两件事:</p>
<ol type="1">
<li><p>对于一个点,找到离他最近的满的祖先.</p></li>
<li><p>查询子树内部点的最小值.</p></li>
<li><p>支持在点上插入和删除.</p></li>
</ol>
<p>这三个操作显然都可以用树剖维护.算上线段树分治,这样就是<span class="math inline">\(O ( n \log^3 n )\)</span>.</p>
<p>不过吧,我们需要说明一件事情:那就是为啥选择子树内最小的那个点一定是优秀的.我们可以简单举个例子来反对这个直觉:如果有两个点权值相同,一个点是另一个点的祖先,那显然选择祖先会优秀一点,因为这个祖先对下面子树的限制要小一些.</p>
<p>我们可以这么干:我们在一开始那个暴力中这么规定:每次满员了之后,删掉权值最小的,权值相同的则按照编号删.对于一个子树<span class="math inline">\(x\)</span>,假设它所有儿子的子树都合法了,并且它需要删,此时:</p>
<ol type="1">
<li><p>如果我们之前想删的那个点已经死了,那就完事了.</p></li>
<li><p>如果我们之前想删的那个点没死,注意到我们接下来插入的点一定排序比当时想删它的时候只大不小,那此时必然还要删掉它.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF464E</p>
<p>之前做过,就是最短路.但是我们要实现高精度加法和高精度比较大小,注意到加上一个<span class="math inline">\(2^x\)</span>在二进制上的体现是某段<span class="math inline">\(1\)</span>变成<span class="math inline">\(0\)</span>,某一个<span class="math inline">\(0\)</span>变成<span class="math inline">\(1\)</span>,这个可以用主席树实现.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1801E</p>
<p>简单题,考虑暴力显然是直接大力并查集,而并查集的操作其实是不多的:一次有用的并查集操作必定是会让连通块个数减少<span class="math inline">\(1\)</span>,因此操作均摊.于是考虑二分+哈希找到第一个有用的并查集操作.这就必然要求我们快速求出一条路径的哈希值.考虑哈希是可以差分的,因此处理每个点到根的哈希值(注意要维护两个方向)即可.每改变一个点就把子树内全部更改一下,这样就做完了.使用启发式合并可以做到<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<p>不过发现这个过程只有区间加法和单点查询,可以使用树状数组.</p>
<p>然后就卡了一晚上常数.事实上这题存在二进制分组做法:我们发现我们要做的无非是将两段直上直下的序列,然后定义它们对应数字相等.我们可以将一个点到它的<span class="math inline">\(2^k\)</span>级祖先所形成的这么一段拆成一段,这样就可以直接倍增然后处理.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF702F</p>
<p>典典典.考虑维护人的平衡树,然后每次check一个衬衫.注意到它会把大于等于它的人给减去这个值.我们考虑将这个splay分裂开来,然后对大于等于它的那些点打个减法tag,再与小于它的那个分裂出去的树合并起来.但是splay无法支持快速合并两棵无大小关系的树(ye不能启发式合并,因为以后还要裂开),我们考虑当前衬衫的价格是<span class="math inline">\(v\)</span>,将所有人分成<span class="math inline">\([ 0 , v ) , [ v , 2 v ) , [ 2 v , + \infty
)\)</span>,三个部分,第一个部分不用管,第二个部分减去<span class="math inline">\(v\)</span>后变成第一个部分,我们把它们暴力插入第一个部分.第三个部分直接打tag并合并,由于第二个部分的暴力插入会使得权值减半,因此总复杂度<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P6072</p>
<p>考虑对于每一条边,求出以这条边为界限,两边的最大值然后加起来,显然就是答案.</p>
<p>还有一点是,一条路径<span class="math inline">\(x -
y\)</span>的权值可以表示为<span class="math inline">\(dep_x \oplus
dep_y\)</span>,这就启发我们用01trie维护最大异或值.</p>
<p>现在相当于求出<span class="math inline">\(f_x\)</span>表示<span class="math inline">\(x\)</span>的子树内的答案,再求出<span class="math inline">\(g_x\)</span>表示<span class="math inline">\(x\)</span>的子树外的答案.这个怎么求呢?首先<span class="math inline">\(f_x\)</span>可以启发式合并01trie.</p>
<p>对于<span class="math inline">\(g_x\)</span>,也很好做.你考虑求出全局最大的那条路径,显然只要分割点不在这条路径上,就会选取它.反之的话,就是两条路径往下dfs,这个直接暴力做01trie就是<span class="math inline">\(O ( n \log w )\)</span>.</p>
<p>做到这里我们冷静一下看看<span class="math inline">\(f\)</span>,注意到只有临近上面我们说的那条链的<span class="math inline">\(f\)</span>,或者是就在这条链上的<span class="math inline">\(f\)</span>.我们只需要求出这些<span class="math inline">\(f\)</span>,因为再往下也没啥用,这样就能让总复杂度变成<span class="math inline">\(O ( n \log w )\)</span>.</p>
<h3><span id="图论">图论</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P4768</p>
<p>典中典,求kruskal重构树,以及<span class="math inline">\(1\)</span>到所有点的最短路即可.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1408G</p>
<p>首先你需要发现,一个点集内部的边全部小于它与外界相连的边,那么如果我们从小到大加边,那么必然有一个时刻是这个点集成为了一个和外界分离的团.因此,考虑从小到大加边,并考虑kruskal重构树的结构,我们就可以将这个过程展现在树上.并且这个过程等价于区间合并.因此我们的问题转化为了有若干区间,选取若干不交的区间覆盖全集的方案数,简单的.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P9167</p>
<p>我们设题面中的<span class="math inline">\(t\)</span>座城市是关键城市,根据题面,断掉这<span class="math inline">\(t\)</span>座城市之间的边,会使得图分裂成若干个大小相差至多为<span class="math inline">\(k\)</span>的连通块.我们不妨认为在一个连通块中,关键城市控制着里面的所有点,那么被不同城市控制的点一定没有边相连.如果此时图是树的话我们已经做完了,无非是要在树上划分点集.反之,我们考虑dfs树,维护出点双意义下的<span class="math inline">\(dfn ,
low\)</span>.注意到一个连通块必定在dfs树上也是连通块.</p>
<p>那么一个点能作为关键点,当且仅当它在dfs树上的某些子树所组成的城市都被控制,这个可以通过<span class="math inline">\(low\)</span>来判断.枚举连通块大小,并设<span class="math inline">\(dp_{ i , j }\)</span>表示<span class="math inline">\(i\)</span>子树上部还有<span class="math inline">\(j\)</span>个城市没决定被控制,这样就可以dp.注意到第二维有用的信息不多,这样就可以优化到<span class="math inline">\(O ( n \sqrt{ n } )\)</span>.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P9170</p>
<p>先看Bob,先把<span class="math inline">\(| T | =
1\)</span>的选了,然后删掉.不断做这个过程直到所有的<span class="math inline">\(| T | =
2\)</span>,此时将这两个点之间连一条边,那就会形成一张图.对于每个连通块,若<span class="math inline">\(| E | &gt; | V
|\)</span>,则必然无解.其它的情况必然有解,这就解决了第一个问题.</p>
<p>不过其实没必要删<span class="math inline">\(| T | =
1\)</span>,直接连自环就行.</p>
<p>对于Alice,考虑以下几种情况:</p>
<ol type="1">
<li><p><span class="math inline">\(| S \land T | =
0\)</span>,显然Alice选啥都没用.</p></li>
<li><p><span class="math inline">\(| S \land T | =
1\)</span>,此时Alice必然选那个和Bob有交的.</p></li>
<li><p><span class="math inline">\(| S \land T | =
2\)</span>,此时Alice可以选择其中一个.</p></li>
</ol>
<p>这样的话,Alice就已经确定了一些东西,而不确定另一些东西.Alice必然是要让Bob能选的最小情况最大,我们考虑再讨论一下:</p>
<ol type="1">
<li><p><span class="math inline">\(| E | = | V
|\)</span>,此时连通块是一个基环树.那么除了环以外的点一定都选好了.如果是自环那么怎么选都行.反之,环上有两种选择方式(就是一个点会在哪条边上被选).考虑对于两种方式,Alice已经确定必选的数量分别是<span class="math inline">\(c_1 ,
c_2\)</span>,而Alice现在还可以选的个数是<span class="math inline">\(c\)</span>,我们也就是要选取<span class="math inline">\(i\)</span>,最大化<span class="math inline">\(\min
\{ c_1 + i , c_2 + c - i \}\)</span>,显然取<span class="math inline">\(c_1 + i = c_2 + c - i , i = \lfloor \frac{ c_2 + c
- c_1 }{ 2 } \rfloor\)</span>,注意如果<span class="math inline">\(i\)</span>要对<span class="math inline">\(0\)</span>取<span class="math inline">\(\max\)</span>,对<span class="math inline">\(c\)</span>取<span class="math inline">\(\min\)</span>.</p></li>
<li><p><span class="math inline">\(| E | = | V | -
1\)</span>,此时连通块是一棵树,并且有一个点不会被选择.不妨设<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>这个点不会被选的方案数,那Alice对于一条边的定向,会让这条边其中一侧的子树的<span class="math inline">\(f\)</span>整体<span class="math inline">\(+
1\)</span>.这个看上去极其熟悉.典中典套路是,考虑两条边选择使得<span class="math inline">\(V_1 , V_2\)</span>分别加了<span class="math inline">\(1\)</span>,如果<span class="math inline">\(V_1
\cap V_2 =
\emptyset\)</span>,同时取反这两条边的选择,一定不劣.于是选择的边会让加<span class="math inline">\(1\)</span>的点集两两有交.枚举交集中的一个点<span class="math inline">\(x\)</span>,则所有边的选择全部确定:每条边都选择深度较低的那个点.仔细考虑此时,Bob的最优选择是啥.如果Bob选择了一个点<span class="math inline">\(y\)</span>,那么<span class="math inline">\(f_y\)</span>显然是<span class="math inline">\(f_x\)</span>减去<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>的路径上Alice能选的数量加上Alice只有一种选择,并且在这里为反向选择的数量.我们要最大化这个东西,也就是最小化<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>的路径上Alice能选的数量,其实也就是最小化一棵树的深度,这个是方便dp的.</p></li>
</ol>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF235D</p>
<p>这个形式看上去极其复杂,考虑简单化一下:我们考虑对当前图选一个分治中心,对答案的贡献是<span class="math inline">\(| G
|\)</span>,不难发现,这相当于每个点贡献了一次.进一步地,这等价于对于每个点,判断它会在多少个点作为分治重心的时候,仍然在那个点所在的连通块中.</p>
<p>如果原图是树,这等价于对于<span class="math inline">\(u ,
v\)</span>,<span class="math inline">\(u\)</span>是<span class="math inline">\(( u , v
)\)</span>路径上第一个被删除的点的概率,这等价于<span class="math inline">\(\frac{ 1 }{ len
}\)</span>.这样树的情况就做完了.</p>
<p>考虑基环树怎么做:如果两个点<span class="math inline">\(( u , v
)\)</span>之间路径唯一,那上面做的显然还是对的.反之,我们有公式<span class="math inline">\(P ( A \lor B ) = P ( A ) + P ( B ) - P ( A \land B
)\)</span>,因此你把这两条路径求出来,加起来,减去它们同时发生的概率即可.注意同时发生的概率不是<span class="math inline">\(P ( A ) P ( B
)\)</span>,因为这两件事不独立,事实上应该是这两条路径的点集并的大小分之一.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4429</p>
<p>如果图不连通可以对于每个块分开考虑,下面只考虑图连通的情况:</p>
<p>显然,如果图不是二分图一定无解.</p>
<p>其次,我们注意到孤立点和一度点一定都可以删去,前者显然,后者是因为与它相邻的那个点的颜色如果确定,那它一定有一种和它选不一样的方法.这样当前所有点的度数<span class="math inline">\(\geq 2\)</span>.</p>
<p>接下来,青鱼说得好,我们把很多比较能看出来有解的情况判掉,剩下的就是无解.</p>
<ol type="1">
<li>偶环一定有解.</li>
</ol>
<p>如果偶环上的颜色全都一样,那直接二分图染色.不然,一定存在相邻的两个点<span class="math inline">\(x , y\)</span>使得<span class="math inline">\(x\)</span>有一种颜色,<span class="math inline">\(y\)</span>没有,直接让<span class="math inline">\(x\)</span>染这种颜色,<span class="math inline">\(x
- y\)</span>这条边就没用了,断掉,然后顺着<span class="math inline">\(x\)</span>平推过去,一定有解.</p>
<p>妈的,剩下的不会了,先咕着.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1672G</p>
<p>发现个事情:如果当前所有行和所有列的异或值都是<span class="math inline">\(0\)</span>,那么我们可以每次选取四个点然后点击,这样这四个点会改变,而其它点都不改变,从左上开始一直点相邻的四个点,这样最后左上角的<span class="math inline">\(( n - 1 ) ( m - 1
)\)</span>的矩阵就全空,而由于每行每列<span class="math inline">\(1\)</span>的个数都是偶数,这个过程不改变这个性质,因此最后一定全图是空的.</p>
<p>而由于最后的状态是全空,因此在变化过程中总有一个时刻使得每行每列异或值为<span class="math inline">\(0\)</span>.</p>
<p>考虑异或的过程,如果<span class="math inline">\(n\)</span>是偶数,那么这么一次异或会使得除了一列以外的所有列都异或上<span class="math inline">\(1\)</span>.如果<span class="math inline">\(n\)</span>是奇数,则会使得全局异或上<span class="math inline">\(1\)</span>.</p>
<p>现在我们来讨论一下<span class="math inline">\(n ,
m\)</span>的奇偶性(对称情况可以反转,不讨论):</p>
<ol type="1">
<li><p><span class="math inline">\(n ,
m\)</span>均为偶数.只考虑第一行,从第二列开始,如果当前这一列和第一列不一样就把它操作掉.这样最后所有列的异或值都相同.如果最后是全<span class="math inline">\(1\)</span>,我们把第一行轮着点一遍,这样每一列都被点了<span class="math inline">\(m -
1\)</span>次,而行的奇偶性不变.也就是说,此时无论怎么填都是有解的.行再一样做</p></li>
<li><p><span class="math inline">\(n\)</span>是奇数,<span class="math inline">\(m\)</span>是偶数.此时必须要求所有列的异或值相同.每一行如何做可以(1)一样使得每一行异或值都是<span class="math inline">\(0\)</span>.枚举所有列是<span class="math inline">\(0\)</span>还是是<span class="math inline">\(1\)</span>,留一个?来调整,剩下的?随便选.</p></li>
<li><p>都是奇数,此时要求所有行和所有列的奇偶性分别相同.枚举这四种奇偶性情况,然后将<span class="math inline">\(?\)</span>看成连在横坐标和纵坐标之间的边.那也就相当于确定了每个点的度数,然后问有多少种选边方式.典中典.对于每个连通块,求出一棵生成树,然后剩下的边随便选,用生成树一路调整上去.注意这要求所有点的度数之和是偶数,也就是至少得是一张合法的图.</p></li>
</ol>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/AT_arc117_f</p>
<p>考虑求出前缀和,此时要满足条件,不妨设全局和为<span class="math inline">\(x\)</span>,此时必然有:</p>
<p><span class="math display">\[
\begin{aligned}
\forall 0 &amp; \leq i &lt; n , s_{ i + n } - s_i \geq a_i \\
\forall n &amp; \leq i &lt; 2 n , x - ( s_{ i } - s_{ i - n } ) \geq a_i
, s_i - s_{ i - n } \leq x - a_i \\
\forall 0 &amp; \leq i &lt; 2 n , s_i \leq s_{ i + 1 }
\end{aligned}
\]</span></p>
<p>注意上面的限制条件限制住了<span class="math inline">\(s_{ i + n } -
s_{ i }\)</span>的上下界,我们不妨设它的上下界分别为<span class="math inline">\(l\)</span>和<span class="math inline">\(r\)</span>.但是这俩需要知道<span class="math inline">\(x\)</span>才能求出来,于是不妨二分<span class="math inline">\(x\)</span>.</p>
<p>贪心地构造,考虑每次要求<span class="math inline">\(s_{ i + n
}\)</span>尽可能地小,于是如果<span class="math inline">\(l_i \leq s_{ i
- 1 + n } - s_{ i - 1 } \leq
r_i\)</span>,我们就继承前面的答案.反之,如果<span class="math inline">\(l_i &gt; s_{ i - 1 + n } - s_{ i - 1
}\)</span>,我们就提升<span class="math inline">\(s_{ i + n } = s_{ i - 1
} + l_i\)</span>,<span class="math inline">\(r\)</span>同理.这样走到最后一定是最小的,只需要满足<span class="math inline">\(s_{ n - 1 } \leq s_n \land s_{ 2 n - 1 } \leq
x\)</span>即可.</p>
<p>但是你发现个事情,我们前面一直在保证<span class="math inline">\(s\)</span>尽可能小,却没有保证<span class="math inline">\(s_{ n - 1 } \leq
s_n\)</span>.我们怎么处理这里的<span class="math inline">\(s_n\)</span>呢?考虑再次二分,每次找到最小的<span class="math inline">\(s_n\)</span>满足前一个条件.那我们就需要说明两件事情:</p>
<ol type="1">
<li><p>满足前一个条件的<span class="math inline">\(s_n\)</span>满足单调性.</p></li>
<li><p><span class="math inline">\(s_n\)</span>越小,越有可能满足第二个条件.</p></li>
</ol>
<p>先来说(2),这个比较显然.因为如果<span class="math inline">\(s_n\)</span>在前面较小不满足的话,我们可以在后面某个地方给提升得大一点,显然由于<span class="math inline">\(s_n\)</span>的提升比较自由,这个是可以做到的.</p>
<p>再来看(1),如果一个<span class="math inline">\(s_n\)</span>满足条件,我们把这个<span class="math inline">\(s_n\)</span>增大<span class="math inline">\(1\)</span>.考虑将前面的所有<span class="math inline">\(s_{ 0 \cdots n - 1 }\)</span>全部提升<span class="math inline">\(1\)</span>,这样所有的差都不变,因此仍然满足条件.</p>
<p>冷静总结一下这个题,其实就是我们首先要发现很多可二分的性质:</p>
<ol type="1">
<li><span class="math inline">\(s_{ 2 n }\)</span>可二分.</li>
</ol>
<p>这个是显然的,放更多显然不会更劣.但是我们要在这个基础上找到一种方法,使得如果当前二分的值合法,一定能构造出一组答案.我们发现如果没有<span class="math inline">\(s_{ n } \geq s_{ n - 1
}\)</span>这个限制,一切都是好做的:因为我们可以贪心地使得当前的<span class="math inline">\(s\)</span>最小.</p>
<ol start="2" type="1">
<li><span class="math inline">\(s_n\)</span>可二分.</li>
</ol>
<p>这个是怎么发现的呢?因为我们发现我们勒令<span class="math inline">\(s_n\)</span>是啥,似乎对这个贪心过程没有啥影响.如果<span class="math inline">\(s_n\)</span>过小,上面的贪心过程就会在<span class="math inline">\(s_n \geq s_{ n - 1 }\)</span>这里判出错.如果<span class="math inline">\(s_n\)</span>过大,则会在<span class="math inline">\(s_{ 2 n - 1 } \leq s_{ 2 n
}\)</span>上判错.这意味着<span class="math inline">\(s_n\)</span>可能需要是一个区间才合法.接下来就是去证明它确实是一个区间是合法的,并且证明我们的贪心过程能在这个贪心过程中正确地check.</p>
<h3><span id="线性代数">线性代数</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P1224</p>
<p>首先显然的一点是,我们把它搞成一个矩阵<span class="math inline">\(A\)</span>,然后拿<span class="math inline">\(A
\times A^T\)</span>.注意到如果最后的答案矩阵存在<span class="math inline">\(0\)</span>就有解,这个解就是<span class="math inline">\(B_{ i , j } = 0\)</span>的那对<span class="math inline">\(( i , j
)\)</span>.到这里已经可以猜到,这题不是什么正经题,应该要搞一些随机化东西.</p>
<p>想起来之前那个经典判断<span class="math inline">\(A \times B =
C\)</span>的题,就是随机几个向量然后乘起来.这个我们想想能不能类似做.</p>
<p>先考虑<span class="math inline">\(k = 2\)</span>,如果<span class="math inline">\(A \times A^T\)</span>是全<span class="math inline">\(1\)</span>矩阵,那么我们随机一个向量去乘它,得到的向量每一位必然都是这个向量所有数字之和.不难发现如果这个向量每一位差别足够大就可以check,这就提供了一个<span class="math inline">\(O ( nd
)\)</span>的做法,不过我们实现肯定造不出差别足够大的向量,因此可以多check几次.然后如果第<span class="math inline">\(i\)</span>行不满足条件,一定存在一组<span class="math inline">\(( i , j )\)</span>作为答案,枚举<span class="math inline">\(j\)</span>即可.</p>
<p>再考虑<span class="math inline">\(k =
3\)</span>,这个有点难搞.实际上是一个牛逼发现:<span class="math inline">\(1^2 \equiv 2^2 \equiv 1 \pmod{ 3
}\)</span>.因此我们考虑将<span class="math inline">\(B\)</span>矩阵的每一位平方后与一个向量相乘.考虑<span class="math inline">\(\sum_{ j } B_{ i , j }^2 r_j = \sum_{ j } B_{ i ,
j } r_j B^T_{ j , i }\)</span>,考虑构造矩阵<span class="math inline">\(R\)</span>,使得<span class="math inline">\(R_{ i ,
i } = r_i , R_{ i , j } = 0 , i \ne j\)</span>,不难发现<span class="math inline">\(( BR )_{ i , j } = B_{ i , j } R_{ j , j
}\)</span>,于是<span class="math inline">\(( BRB^T )_{ i , i } = \sum_{
j } B_{ i , j } R_{ j , j } B^T_{ j , i }\)</span>.接下来我们只要check
<span class="math inline">\(BRB^T\)</span>的对角线即可.然后<span class="math inline">\(B^T = ( AA^T )^T ={ A^T }^T A^T =
AA^T\)</span>.于是有:</p>
<p><span class="math display">\[
BRB^T = AA^T RAA^T
\]</span></p>
<p>考虑<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n \times d\)</span>的矩阵,<span class="math inline">\(A^T\)</span>是一个<span class="math inline">\(d
\times n\)</span>的矩阵.不妨假设我们已经算出了<span class="math inline">\(A^T RA\)</span>,那这里是好算的,因为<span class="math inline">\(( ABC )_{ i , i } = \sum_{ j , k } A_{ i , k } B_{
k , j } C_{ j , i }\)</span>,这里可以<span class="math inline">\(O (
nd^2 )\)</span>地check每一个位置.</p>
<p>那我们现在面临的问题就是如何去求出来<span class="math inline">\(A^T
RA\)</span>.注意到<span class="math inline">\(RA\)</span>是一个<span class="math inline">\(n \times d\)</span>的矩阵,因此如果知道<span class="math inline">\(RA\)</span>,<span class="math inline">\(A^T ( RA
)\)</span>是好求的.我们现在需要求出<span class="math inline">\(RA\)</span>.由于<span class="math inline">\(R\)</span>是对角线矩阵,<span class="math inline">\(( RA )_{ i , j } = R_{ i , i } A_{ i , j
}\)</span>,这样就可以<span class="math inline">\(O ( nd
)\)</span>求.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P6772</p>
<p>典中典,首先如果是边权的话有个经典dp:设<span class="math inline">\(dp_{ i , x }\)</span>表示当前经过了<span class="math inline">\(i\)</span>条边,目前在<span class="math inline">\(x\)</span>点的最优答案,自然有转移:</p>
<p><span class="math display">\[
dp_{ i , x } = \max \{ dp_{ i - 1 , y } + val_{ y \rightarrow x } \}
\]</span></p>
<p>这是一个经典的<span class="math inline">\(\{ \max , +
\}\)</span>矩阵,可以矩阵加速.</p>
<p>这个题不是边权,但是点权可以改成入边的边权,只不过起点需要特判.</p>
<p>还有一个问题是边权不是<span class="math inline">\(1\)</span>,拆边的话复杂度太高,考虑拆点,每个点拆成五个,然后只有最后一个点才会连出边,剩下的按照距离出边的距离连到前面的点.</p>
<p>至于美食节,一个想法是直接矩阵加速到那一天,然后把对应的点加上美食节的权值,继续做完每个美食节即可.但这样复杂度是<span class="math inline">\(O ( kN^3 \log T )\)</span>的.</p>
<p>冷静一下,预处理出矩阵的二的次幂,这样就是<span class="math inline">\(O
( kN^2 \log T + N^3 \log T )\)</span>.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P6125</p>
<p>简单题,建ACAM,然后对于每个人求答案.枚举每个人,对于每个点,设<span class="math inline">\(p_i\)</span>为以它为起点,最后这个人胜利的概率,做高斯消元即可.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3706</p>
<p>ps:本题选入笔记:概率与期望-概率生成函数-Example3.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{ k , i }\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F , G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(1 + xG ( x ) = \sum_k F_k ( x ) + G (
x )\)</span>.</p></li>
<li><p><span class="math inline">\(( \frac{ 1 }{ 2 } x )^L G ( x ) =
\sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 } ( \frac{ 1 }{ 2 } x
)^i [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i ) } ]\)</span>.</p></li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x =
1\)</span>,发现<span class="math inline">\(\sum_{ k } F_k ( 1 ) =
1\)</span>.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 }
( \frac{ 1 }{ 2 } x )^{ i - L } [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i )
} ] \\
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 1 }^{ L } (
\frac{ 1 }{ 2 } x )^{ - i } [ A_k^{ ( i ) } ={ A_j }_{ ( i ) } ]
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(x = 1\)</span>,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum_{ j = 1 }^n F_j ( 1 ) \sum_{ i = 1 }^{ L } 2^i [ A_k^{ (
i ) } ={ A_j }_{ ( i ) } ]
\]</span></p>
<p>不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n + 1\)</span>个等式,可以算出<span class="math inline">\(G ( 1 ) , F_{ 1 \cdots n } ( 1 )\)</span>这<span class="math inline">\(n + 1\)</span>个未知数.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P3292</p>
<p>首先第一反应是树剖+线段树上合并线性基,轻松做到<span class="math inline">\(O ( q \log^2 n \log^2 v )\)</span>.</p>
<p>但是过不太去!注意到<span class="math inline">\(n\)</span>要小一点,考虑离线点分治.记录下从分治中心到每个点的线性基,这样只需要做<span class="math inline">\(q\)</span>次线性基合并,复杂度是<span class="math inline">\(O ( q \log^2 v + n \log n \log v )\)</span>.</p>
<p>不过如果你做过CF1100F,那这题就是上个树.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P4151</p>
<p>典中典,注意到一个值异或两遍就会没掉.我们考虑随便求一条<span class="math inline">\(S \rightarrow
T\)</span>的路径,然后再求出来所有的环上的异或值.我们发现我们可以走到一个简单环上,走一圈再原路返回,这样答案只会异或上简单环的异或值.对这个东西用线性基就行.</p>
<p>至于这个东西的正确性,首先考虑<span class="math inline">\(S
\rightarrow
T\)</span>唯一的情况,这样的话你如果要扩展就必须走环.不然,则<span class="math inline">\(S \rightarrow
T\)</span>有边在环上,只要溜达一圈就行.</p>
<p>接下来的问题在于找简单环.我们直接dfs,就可以找到一部分环.但是其实是没有找到全部的环的.但是没关系,在dfs的过程中,dfs树不可能有横插边,也就是所有找到的的环不在树上的边一定是反走边.而没有找到的环可能是若干个反走边拼起来的.这必然意味着它可以由那些反走边所代表的环拼起来:原因比较简单,考虑从上往下遍历这个没找到的环,那么每条边一定被经过了两次:下去一次,上来一次.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P6178</p>
<p>板子题</p>
<h4><span id="第八题">第八题</span></h4>
<p>https://www.luogu.com.cn/problem/P4455</p>
<p>板子题</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P4336</p>
<p>简单题,无脑矩阵树定理+容斥.复杂度<span class="math inline">\(O ( 2^n
n^3 )\)</span>.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P5807</p>
<p>板子题</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF917D</p>
<p>一眼二项式反演.不妨设<span class="math inline">\(f_i\)</span>表示钦定<span class="math inline">\(i\)</span>条边已经选上了的答案.显然:</p>
<p><span class="math display">\[
ans_k = \sum_{ i \geq k } ( - 1 )^{ i - k } \binom{ i }{ k } f_i
\]</span></p>
<p>对于<span class="math inline">\(f_i\)</span>,考虑Prufer序列的推论:<span class="math inline">\(k\)</span>个大小分别为<span class="math inline">\(s_1 , s_2 , \cdots ,
s_k\)</span>的连通块,任意加边使得连通块成树的方案数是<span class="math inline">\(n^{ k - 2 } \prod
s\)</span>.于是考虑dp,不妨设<span class="math inline">\(dp_{ x , i , j
}\)</span>表示当前<span class="math inline">\(x\)</span>为根的子树内部,当前<span class="math inline">\(x\)</span>所在连通块的大小是<span class="math inline">\(i\)</span>的方案数,这样可以做到<span class="math inline">\(O ( n^3 )\)</span>.</p>
<p>看了看题解发现可以做到<span class="math inline">\(O ( n^2
)\)</span>.简单来说就是考虑<span class="math inline">\(\prod
s\)</span>的组合意义,是在每个连通块内选一个点的方案数.那我们可以用<span class="math inline">\(f_{ i , j , 0 / 1 }\)</span>表示当前<span class="math inline">\(i\)</span>子树内选了<span class="math inline">\(j\)</span>个点,然后<span class="math inline">\(i\)</span>所在连通块内是否选点了的方案数.</p>
<h3><span id="计算几何">计算几何</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2742</p>
<p>板子题.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3829</p>
<p>简单题,注意到圆弧之和一定是一个圆,因此把角上的四个点拿出来做凸包即可.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P4196</p>
<p>板子题.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P3256</p>
<p>板子题.甚至</p>
<h4><span id="第五题第六题第七题">第五题/第六题/第七题</span></h4>
<p>https://www.luogu.com.cn/problem/P1742</p>
<p>https://www.luogu.com.cn/problem/P2533</p>
<p>https://www.luogu.com.cn/problem/P4288</p>
<p>三个题全是一样的.</p>
<p>大概是这么做的啊,就是说我们增量构造,每次对于前<span class="math inline">\(i\)</span>个点的最小覆盖圆,考虑<span class="math inline">\(i +
1\)</span>个点在不在圆上.如果在就忽略,不在的话,那它必然是新圆的一个卡着边的点.考虑再找到另两个卡着边的点,我们暴力枚举这两个点.并且计算出所有的圆,挑选面积最大的那个.事实上,可以直接每次更新圆,直到这个圆包含了前<span class="math inline">\(i +
1\)</span>个点,显然总会遇到,然后之后就不会更新这个圆了.</p>
<p>这个写法导致了复杂度正确.具体来说,考虑一个点成为卡着圆边界的点的概率是<span class="math inline">\(\frac{ 3 }{ n
}\)</span>,这三层循环的调用次数分别是:</p>
<p><span class="math display">\[
\begin{aligned}
T_3 ( n ) &amp; = O ( n ) \\
T_2 ( n ) &amp; = O ( n ) + \sum_{ i = 1 }^n \frac{ 3 }{ i } T_3 ( i )
\\
T_1 ( n ) &amp; = O ( n ) + \sum_{ i = 1 }^n \frac{ 3 }{ i } T_2 ( n )
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(T_1 ( n ) = O ( n )\)</span>.</p>
<h4><span id="第九题">第九题</span></h4>
<p>https://www.luogu.com.cn/problem/P2287</p>
<p>枚举三个点,然后判断这三个点所在平面是否是三维凸包的一个面.注意四点共面就完蛋了,因此每个点加上一个随机扰动量.这个量首先得在eps范围内显著体现出来,其次还不能对答案影响太大.这个题是直接给了一个小于<span class="math inline">\(10^{ - 10
}\)</span>的扰动量,然后因为没有判相等操作,直接用了c++的浮点数比较.</p>
<h4><span id="第十题">第十题</span></h4>
<p>https://www.luogu.com.cn/problem/P1452</p>
<p>板子题.</p>
<h4><span id="第十一题">第十一题</span></h4>
<p>https://www.luogu.com.cn/problem/P6247</p>
<p>板子题.</p>
<h4><span id="第十二题">第十二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3187</p>
<p>旋转卡壳的时候维护三个边界就行.</p>
<h3><span id="网络流建图">网络流建图</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/CF103E</p>
<p>Hall引理的时候做过.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/CF311E</p>
<p>发现变<span class="math inline">\(0\)</span>变<span class="math inline">\(1\)</span>这个操作可逆,不妨先把所有位置都变成<span class="math inline">\(1\)</span>.</p>
<p>接下来考虑把若干个<span class="math inline">\(1\)</span>变成<span class="math inline">\(0\)</span>.不难发现:一个全<span class="math inline">\(0\)</span>的要求合法<span class="math inline">\(\Rightarrow\)</span>所有包含位置都是<span class="math inline">\(0\)</span>$所 有 包 含 位 置 都 不 是<span class="math inline">\(1\)</span>$包含这些的全<span class="math inline">\(1\)</span>要求不合法.这是一个最大权闭合子图问题.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/CF884F</p>
<p>直接费用流,考虑左边每个点是字母,然后连到右边的点上,拆一下点保证对应的位置不会有相同字母.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/CF802C</p>
<p>牛逼题,考虑我们不好搞这个丢弃的东西,因为你也不知道你留下来的是谁.因此我们考虑如果一本书不在当天丢弃,那就一定会对下本书产生贡献,我们把它当成将书卖出.</p>
<p>也就是说,考虑将每一天建点,上面这个过程保证了我们每一天的书都会买,这就保证了最大流量.</p>
<p>将每一天建点并以流量为<span class="math inline">\(k -
1\)</span>的边相连(因为下一天必须买书),然后如果这本书要留着,就在前一天卖掉.</p>
<p>但是这样需要保证,我们卖书的时候必定在前面没有丢弃这本书,拆点维护,用一个点同时维护当天丢弃和卖书两种操作即可.</p>
<p>点数是<span class="math inline">\(2 n\)</span>的,边数有拆点的<span class="math inline">\(n\)</span>条,连接相邻两天的<span class="math inline">\(n\)</span>条,卖出的和丢弃的共<span class="math inline">\(2 n\)</span>条,这样总共是<span class="math inline">\(4 n\)</span>条边.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/CF786E</p>
<p>一眼最小割,然后线段树+树剖优化建图.注意这样是<span class="math inline">\(O ( n \log^2 n
)\)</span>的建图,我们把树剖跳topn的过程建一个点,这样就是<span class="math inline">\(O ( n \log n )\)</span>的建图.</p>
<p>考虑点数,原图有<span class="math inline">\(n\)</span>个点,线段树是<span class="math inline">\(2 n\)</span>个点,树剖只会贡献<span class="math inline">\(n\)</span>个点,点数是<span class="math inline">\(4
n\)</span>的.</p>
<p>考虑边数,注意到一个点会连<span class="math inline">\(2 \log
n\)</span>条边到树剖上,在最后一下会连<span class="math inline">\(\log
n\)</span>个点到线段树上,因此总边数是<span class="math inline">\(2 n + 3
m \log n \leq 10^6\)</span>,但是显然远远跑不满.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1139E</p>
<p>第一反应是二分答案,然后拿网络流二分图匹配check,这样复杂度是<span class="math inline">\(O ( n^2 \sqrt{ n } \log n )\)</span>的.</p>
<p>事实上注意删人后答案只减不增,因此复杂度<span class="math inline">\(O
( n^2 \sqrt{ n } )\)</span>.</p>
<p>但是这样过不去,考虑把删除改成增加,这样就可以在残留网络上跑,然后就能过了.</p>
<h4><span id="第七题">第七题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1061E</p>
<p>考虑每个问题,其实是形如要保证子树内有一定数量的点不能选.也就是这个限制要和修建港口抢城市.</p>
<p>但是不同的限制可能限制了同一城市,我们发现深度更浅的那个限制数量可以减去深度较深的限制数量,毕竟较深的满足较浅的也就满足了.</p>
<p>但是这个思路建图好像有点不太对.因为两个树的港口是通用的,那考虑让一个限制是入,另一个限制是出.换句话说,让一个限制被源点流,另一个限制流向汇点,中间是树节点,源点连出去的边有一个权值,跑费用流.</p>
<p>注意到每个点只会被连一次,因此边数大概是<span class="math inline">\(2
n\)</span>级别,点数是<span class="math inline">\(3 n\)</span>级别.</p>
<p>总之这种网络流题,主要还是要考虑谁连着源点,谁连着汇点.这个题我一开始以为是限制连源点,然后城市连汇点,发现做不了,那就两种限制分别连源点和汇点.</p>
<h3><span id="交互题练习">交互题练习</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P5875</p>
<p>这是广义串并联图嘛?好像显然不是.</p>
<p>但是仍然有性质,如果没有点权的话,注意到(1)一定会选新加入的点,(3)也一定会选新加入的点,(2)则一定要么两者都选要么都不选.</p>
<p>现在有点权,考虑把新加入的点删了,不妨设新加入的点为<span class="math inline">\(i\)</span>,主持人为<span class="math inline">\(x\)</span>,自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(a_i \rightarrow ans , a_x : = \max \{
0 , a_x - a_i \}\)</span>.</p></li>
<li><p><span class="math inline">\(a_x : = a_x + a_i\)</span>.</p></li>
<li><p><span class="math inline">\(a_x : = \max \{ a_x , a_i
\}\)</span>.</p></li>
</ol>
<p>不难发现每一步操作做完后,答案都不会改变.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P3641</p>
<p>牛逼题.</p>
<p>考虑答案最小是什么,根据鸽笼原理,显然是<span class="math inline">\(B =
\lceil \frac{ a_n - a_1 }{ n - 1 } \rceil\)</span>.</p>
<p>所以我们按照值域每<span class="math inline">\(B\)</span>长度分块,然后考虑答案不可能出现在块内,也就是块内的点对不可能贡献答案,答案只有可能由上一个数字(也就是上一个查询到的<span class="math inline">\(mx\)</span>)和当前块的<span class="math inline">\(mn\)</span>贡献.这样一开始的贡献是<span class="math inline">\(n + 1\)</span>,中间问了<span class="math inline">\(n - 1\)</span>次,总共涉及到了<span class="math inline">\(n - 2\)</span>个数字,这样就做完了.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P3777</p>
<h5><span id="sub1">Sub1</span></h5>
<p>minValue是好求的,我们考虑选取<span class="math inline">\(\{ 1 , 0 ,
\cdots , 0
\}\)</span>,这样的话对手必然放弃一个,被放弃的那个就是最小的.</p>
<h5><span id="sub2">Sub2</span></h5>
<p>一个显然的想法是,如果我们一开始全选<span class="math inline">\(1\)</span>,那么对手一定会选取<span class="math inline">\([ 51 , 100 ]\)</span>中的所有数字.</p>
<p>然后呢?我们接下来考虑继续在<span class="math inline">\([ 51 , 100
]\)</span>这些数字中找到最大的.我们肯定要让它们全选<span class="math inline">\(2\)</span>,这样对方可能会放弃一些这个区间中较小的数字,然后去选取<span class="math inline">\([ 1 , 50
]\)</span>中较大的一些.持续这个过程,发现正好需要四次操作.</p>
<h5><span id="sub3">Sub3</span></h5>
<p>考虑结合sub1和sub2,我们不妨询问<span class="math inline">\(\{ x , x ,
0 , 0 , \cdots \}\)</span>,这样直觉上总是存在一个<span class="math inline">\(x\)</span>使得前两个数字有一个被放弃.</p>
<p>事实上也确实.考虑前两个数字中较小的那一个,设为<span class="math inline">\(v\)</span>,当<span class="math inline">\(\sum_{ i
= x }^{ 2 x } i = \frac{ 3 x ( x + 1 ) }{ 2 } \geq
v\)</span>的时候,显然它就会被放弃,对于这个最小的<span class="math inline">\(x\)</span>,会发现两个数字中较大的那个(设为<span class="math inline">\(w
)\)</span>一定不会被放弃,因为如果它被放弃了,一定是因为<span class="math inline">\(w \leq x - 1\)</span>,而我们知道<span class="math inline">\(\frac{ ( 3 x - 3 ) x }{ 2 } &lt; v &lt; w \leq x -
1\)</span>,又因为<span class="math inline">\(x \geq
1\)</span>,因此显然不成立.</p>
<p>二分这个<span class="math inline">\(x\)</span>,由于<span class="math inline">\(v_{ \max } = 99\)</span>,发现<span class="math inline">\(x \in [ 1 , 8 ]\)</span>,直接二分需要四次.</p>
<p>然后有个牛逼做法是,考虑每个<span class="math inline">\(x\)</span>能控制一个区间的<span class="math inline">\(v\)</span>,发现<span class="math inline">\(x =
7\)</span>的那个区间全部被覆盖了两次,因此不用选取<span class="math inline">\(x = 7\)</span>.</p>
<h5><span id="sub4">Sub4</span></h5>
<p>这个简单,不难发现只需要在<span class="math inline">\(B_i = B_j =
100\)</span>,那么对手就必然需要在这两者中选一个留下来,这样我们就可以比较任意两个位置的大小,使用stable_sort即可.</p>
<h5><span id="sub5">Sub5</span></h5>
<p>一种想法是sub4+sub3,但过不去.</p>
<p>冷静思考,注意到sub2,我们其实是知道了某些位置在哪个权值区间的.对着这个分治下去,这样实现了划分区间的功能,按理说应该是会有<span class="math inline">\(2 n - 1\)</span>个节点.</p>
<p>冷静一下,<span class="math inline">\(l =
r\)</span>的叶子节点是不用计算的,因此刚好玩了<span class="math inline">\(n - 1\)</span>次.</p>
<p>现在唯一的问题是,我们怎么找到一个<span class="math inline">\(w\)</span>,使得这个区间内我都选<span class="math inline">\(w\)</span>后,然后这个区间一定会被划分呢?考虑<span class="math inline">\(sub 3\)</span>告诉我们如果<span class="math inline">\(r - l + 1 \leq 12\)</span>一定有解,考虑<span class="math inline">\(( r , 100
]\)</span>的数字肯定要被选,那对方只剩下<span class="math inline">\(r\)</span>个石子,不妨直接令<span class="math inline">\(w = \lfloor \frac{ r }{ r - l + 1 } \rfloor +
1\)</span>,注意到这个区间一定选不满.并且由于<span class="math inline">\(r - l + 1 &gt;
12\)</span>,因此你会发现前面即使全选了也有剩余.</p>
<p>实际的写法选择了直接枚举<span class="math inline">\(w\)</span>,然后判断是否合法.</p>
<h4><span id="第四题">第四题</span></h4>
<p>https://www.luogu.com.cn/problem/P4373</p>
<p>这怎么做!考虑分块.(这谁想得到啊)</p>
<p>不妨设<span class="math inline">\(f_i\)</span>表示<span class="math inline">\([ i , i + k - 1
]\)</span>的最小值,我们先求出来<span class="math inline">\(f_{ 0 } , f_{
B } , f_{ 2 B } ,
\cdots\)</span>的值.这个怎么求呢?考虑一个值什么时候有用:如果它比队列末尾优秀肯定有用,不然只有它是<span class="math inline">\(B\)</span>的倍数,它才有可能有用.我们只去维护这两种情况,就可以做到<span class="math inline">\(O ( \sqrt{ n } )\)</span>的空间.</p>
<p>然后考虑剩下的<span class="math inline">\(( iB , ( i + 1 ) B
)\)</span>这些答案怎么求.不难发现这些的<span class="math inline">\(f\)</span>一定大于等于<span class="math inline">\(f_{ iB }\)</span>并且小于等于<span class="math inline">\(f_{ ( i + 1 ) B
}\)</span>.如果直接对这个做单调队列空间还是不足,但我们发现做单调队列的时候,会被弹出的只有<span class="math inline">\([ f_{ iB } , ( i + 1 ) B
)\)</span>这些数字,剩下的只要右端点卡到它,就一定不会被弹出.因此只需要对前面这个东西做单调队列,直到做到<span class="math inline">\(f_{ ( i + 1 ) B
}\)</span>出现,那我们就停下来,把前面该输出的答案全部输出.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P5473</p>
<p>考虑异或能实现的是判断奇偶性,具体来说,我们很容易判断一个点到一个集合内部点的奇偶性.考虑这样其实已经能<span class="math inline">\(O ( n
)\)</span>找到一个点了:我们每修改一个前缀,然后check所有不在这个前缀内的点,这样就可以知道它俩是有边的.</p>
<p>这个过程能不能二分呢?好像不能,那我们随机化.</p>
<p>换句话说,我们random_shuffle一下序列,然后分治,每次把左侧的点全部点亮,然后看右侧的点有没有发生变化.如果发生了,则说明左侧的点到右侧的点的边的数量是奇数,递归下去处理,就可以至少连一条边,把这条边删了继续做.</p>
<p>然后发现这么写有个<span class="math inline">\(L_c = 0\)</span>的<span class="math inline">\(B\)</span>包过不去啊,那个包可以考虑我们对于一个点<span class="math inline">\(x\)</span>,二分<span class="math inline">\([ 0 , x
- 1 ]\)</span>中谁是它的父亲.不难发现如果把<span class="math inline">\([
0 , k
]\)</span>这个前缀全部modify掉,并且它父亲在里面,那它当前状态一定是<span class="math inline">\(1\)</span>.用整体二分解决这个问题.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/P6541</p>
<p>考虑动态点分树.每次找到一对点<span class="math inline">\(x ,
y\)</span>,<span class="math inline">\(x\)</span>已知,<span class="math inline">\(y\)</span>未知,然后explore(x,y).如果得到的是未知的点,那就不断操作直到得到<span class="math inline">\(y\)</span>.</p>
<p>反之,考虑得到了<span class="math inline">\(z\)</span>,由于<span class="math inline">\(z\)</span>已知,因此<span class="math inline">\(z\)</span>在我们的点分树上.不妨从<span class="math inline">\(z\)</span>暴力向上跳到<span class="math inline">\(x\)</span>,这样就可以知道<span class="math inline">\(y\)</span>在<span class="math inline">\(x\)</span>的哪个方向,往那个方向的点分树儿子走一步即可.</p>
<p>至于动态点分树怎么做,替罪羊重构即可.</p>
<p>至于链,我们每次随机一个没有搞定的点,走过去即可.期望的错误次数是<span class="math inline">\(O ( \log n )\)</span>的.</p>
<h3><span id="模拟退火">模拟退火</span></h3>
<h4><span id="第一题">第一题</span></h4>
<p>https://www.luogu.com.cn/problem/P2503</p>
<p>考虑如果要求有序划分,可以直接写一个dp.</p>
<p>因此我们考虑每次交换几个位置,然后当成有序的跑dp,用这个来模拟退火.</p>
<h4><span id="第二题">第二题</span></h4>
<p>https://www.luogu.com.cn/problem/P2538</p>
<p>随机交换两个城市的状态即可.如果为了复杂度更好一点可以要求交换的城市状态必然不同.</p>
<h4><span id="第三题">第三题</span></h4>
<p>https://www.luogu.com.cn/problem/P5544</p>
<p>这题退火退半天退不出来,但是爬山直接过了.</p>
<p>这是为啥呢?原因在于,这题我们既然要对坐标进行跳跃,很有可能大部分坐标的答案都是<span class="math inline">\(0\)</span>.这就必然导致了我们一开始可能跳到了很远的地方,但是由于一直是<span class="math inline">\(0\)</span>,因此不断地跳过去.很难蚌.</p>
<p>而爬山不会有这种问题.</p>
<p>有没有什么改良的方式?一种是改变估价函数,通过精细实现估价函数导致其估价为连续实数函数,这样退火的效果就会好很多.</p>
<p>总的来说,退火失败的地方在于它一开始跳跃得太远了.而由于前几次操作我们跳出去的概率很大,因此极难得到答案.对于这种跳跃性不确定的题,反而你发现爬山不会拘束于局部最优解,而是会跳出去的.这也就是爬山在这题表现极其良好的原因.</p>
<p>有没有什么更优秀的方式呢?我们考虑先爬几次山,爬到一个好地方,然后以这个位置开始退火往旁边跳.</p>
<h4><span id="第五题">第五题</span></h4>
<p>https://www.luogu.com.cn/problem/P7218</p>
<p>考虑一个显然的贪心是,直接枚举每个<span class="math inline">\(W\)</span>,能放就放.</p>
<p>考虑把一开始所有能放的<span class="math inline">\(W\)</span>全拿出来作为一个操作序列,然后用模拟退火打乱.</p>
<h4><span id="第六题">第六题</span></h4>
<p>https://www.luogu.com.cn/problem/CF1105E</p>
<p>不妨考虑满足某个人要求,就一定要在一段时间内全是它的id.也就是说如果两个人都抢了一段时间,那这两个人不能同时选择.</p>
<p>这也就是一个最大团问题,模拟退火解决一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="kmp">KMP</span></h3>
<h5><span id="example1zr23省选第一轮集训day5b">Example1(zr23省选第一轮集训day5b)</span></h5>
<p>必须提一下的是,能用KMP的前提是可以比较两个字符串是否相等,不一定是比较两个字母相等.只要能比较两个字符串是否相等,并且已知<span class="math inline">\(A = B\)</span>能快速判断是否有<span class="math inline">\(A + a = B +
b\)</span>,那么就可以使用KMP.并不要求<span class="math inline">\(A =
B\)</span>并且<span class="math inline">\(a = b\)</span>才有<span class="math inline">\(A + a = B + b\)</span>.</p>
<p>因此,我们取<span class="math inline">\(p\)</span>的置换<span class="math inline">\(q\)</span>,然后找到所有和<span class="math inline">\(q\)</span>的大小关系一样的区间即可,要证明这是个等价关系,然后就可以上KMP了.</p>
<h5><span id="example2noi2014-动物园">Example2(NOI2014 动物园)</span></h5>
<p>自然的想法是先求border数组,然后每次暴力跳border直到当前前后缀不重叠.根据border的定义显然是对的.但这样复杂度不对.</p>
<p>另一个想法是我们能不能在做KMP的时候,直接判掉当前长度是否超过,如果超过就放弃呢?也不对,因为这样往前跳也会用到这个border数组,但往前跳有可能跳的很少.</p>
<p>因此我们先求border,再第二遍做KMP,用另一个数组,但是往前跳的时候用border跳,其他情况正常做就行.</p>
<h3><span id="border理论">border理论</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="定理1">定理1</span></h5>
<p><span class="math inline">\(s\)</span>的某个border长度为<span class="math inline">\(k\)</span>等价于<span class="math inline">\(| s |
- k\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>证明显然.</p>
<h5><span id="定理2周期引理">定理2(周期引理)</span></h5>
<p>弱周期引理:如果<span class="math inline">\(p , q\)</span>是<span class="math inline">\(s\)</span>的周期且<span class="math inline">\(p +
q \leq | s |\)</span>,那么<span class="math inline">\(\gcd ( p , q
)\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>考虑分开两面证明,不妨设<span class="math inline">\(p &gt; q , r = p -
q\)</span>,先证明<span class="math inline">\(\forall i &gt; q , s_i =
s_{ i + r }\)</span>,事实上<span class="math inline">\(s_i = s_{ i - q }
= s_{ i - q + p } = s_{ i + r }\)</span>.再考虑证明<span class="math inline">\(i \leq | s | - p , s_i = s_{ i + r
}\)</span>,事实上<span class="math inline">\(s_i = s_{ i + p } = s_{ i +
p - q } = s_{ i + r }\)</span>.</p>
<p>由于<span class="math inline">\(p + q \leq | s
|\)</span>,因此上面那个证明对所有<span class="math inline">\(i\)</span>成立,由此得证.</p>
<p>强周期引理:如果<span class="math inline">\(p , q\)</span>是<span class="math inline">\(s\)</span>的周期且<span class="math inline">\(p +
q - \gcd ( p , q ) \leq | s |\)</span>,那么<span class="math inline">\(\gcd ( p , q )\)</span>是<span class="math inline">\(s\)</span>的周期.</p>
<p>这个有一个生成函数证明.简单来说我们不妨设长度为<span class="math inline">\(p\)</span>的那个周期的生成函数为<span class="math inline">\(P ( z )\)</span>,它是一个<span class="math inline">\(p - 1\)</span>次的生成函数.同理定义<span class="math inline">\(Q ( z )\)</span>.不妨设<span class="math inline">\(S_p ( z ) = \frac{ P ( z ) }{ 1 - z^p
}\)</span>,同理定义<span class="math inline">\(S_q ( z )\)</span>.</p>
<p>如果我们能说明<span class="math inline">\(S_p ( z ) = S_q ( z
)\)</span>,由于这两个都是无穷项,由欧几里得算法立刻得到<span class="math inline">\(\gcd ( p , q )\)</span>是其周期.考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; S_p ( z ) - S_q ( z ) \\
= &amp; \frac{ P ( z ) }{ 1 - z^p } - \frac{ Q ( z ) }{ 1 - z^q } \\
= &amp; \frac{ 1 - z^g }{ ( 1 - z^p ) ( 1 - z^q ) } ( \frac{ 1 - z^q }{
1 - z^g } P ( z ) - \frac{ 1 - z^p }{ 1 - z^g } Q ( z ) )
\end{aligned}
\]</span></p>
<p>此时注意到括号里面的那个东西的次数有限,设其为<span class="math inline">\(H ( z )\)</span>,不难发现<span class="math inline">\(H ( z )\)</span>的次数是<span class="math inline">\(p + q - g - 1\)</span>.若<span class="math inline">\(H ( z ) \ne 0\)</span>,又因为<span class="math inline">\(\frac{ 1 - z^g }{ ( 1 - z^p ) ( 1 - z^q )
}\)</span>的常数项不为<span class="math inline">\(0\)</span>,因此<span class="math inline">\(\exists 0 \leq k \leq p + q - g - 1 , [ z^k ] (
S_p ( z ) - S_q ( z ) ) \ne 0\)</span>,但根据假设,<span class="math inline">\(\forall 0 \leq k \leq n - 1 \leq p + q - g -
1\)</span>,应该有<span class="math inline">\([ z^k ] ( S_p ( z ) - S_q (
z ) ) = 0\)</span>,因此<span class="math inline">\(H ( z ) =
0\)</span>,因此<span class="math inline">\(S_p ( z ) = S_q ( z
)\)</span>.</p>
<h5><span id="定理3">定理3</span></h5>
<p>若<span class="math inline">\(S\)</span>是<span class="math inline">\(T\)</span>的前缀,且<span class="math inline">\(T\)</span>有周期<span class="math inline">\(a\)</span>,<span class="math inline">\(S\)</span>有整周期<span class="math inline">\(b\)</span>,<span class="math inline">\(b | a , | S
| \geq a\)</span>,则<span class="math inline">\(T\)</span>有周期<span class="math inline">\(b\)</span>.证明显然.</p>
<h5><span id="定理4">定理4</span></h5>
<p>若<span class="math inline">\(2 | S | \geq | T |\)</span>,则<span class="math inline">\(S\)</span>在<span class="math inline">\(T\)</span>中的匹配位置必为等差序列.</p>
<p>证明考虑WPL就行.</p>
<h5><span id="定理5">定理5</span></h5>
<p><span class="math inline">\(S\)</span>的长度大于等于<span class="math inline">\(\frac{ n }{ 2
}\)</span>的border长度构成一个等差序列.</p>
<p>不妨设最长的border长度为<span class="math inline">\(n -
p\)</span>,还有一个border长度是<span class="math inline">\(n -
q\)</span>,<span class="math inline">\(q &gt;
p\)</span>,那么必有长度为<span class="math inline">\(n - \gcd ( p , q
)\)</span>的border.注意到<span class="math inline">\(n -
p\)</span>是最长的border,则<span class="math inline">\(\gcd ( p , q )
\geq p\)</span>,<span class="math inline">\(p | q\)</span>.</p>
<h5><span id="定理6">定理6</span></h5>
<p>一个串的所有border按照长度排序后,可以被划分成<span class="math inline">\(O ( \log n )\)</span>个等差序列.</p>
<p>首先,将该串的长度<span class="math inline">\(\geq \frac{ n }{ 2
}\)</span>的border拿出作为一个等差序列.考虑这些中长度最小的<span class="math inline">\(T\)</span>.</p>
<p>再考虑最小循环节<span class="math inline">\(d\)</span>,如果<span class="math inline">\(d \leq \frac{ n }{ 4
}\)</span>,那么不断减小一定有<span class="math inline">\(| T | \leq
\frac{ 3 }{ 4 } n\)</span>.反之则最长border本身就<span class="math inline">\(\leq \frac{ 3 }{ 4 }
n\)</span>,于是剩下的border都是<span class="math inline">\(T\)</span>的border.这样就证明了<span class="math inline">\(O ( \log n )\)</span>,事实上更紧凑的界是<span class="math inline">\(\lceil \log_2 | S | \rceil\)</span>,不会证.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poi2011okr-periodicity">Example1([POI2011]OKR-Periodicity)</span></h5>
<p>注意到一个事实:如果这个字符串存在长度为<span class="math inline">\(k\)</span>的周期,等价于存在长度为<span class="math inline">\(len - k\)</span>的border,证明是显然的.</p>
<p>考虑从小周期开始向大周期确定,首先可以用KMP求出所有前缀的最大border,然后就可以得到整个字符串的所有border.换句话说,我们实际上是在一步一步确定整个字符串的若干前缀的最大border.</p>
<p>考虑border理论,设<span class="math inline">\(q\)</span>为最小周期,如果<span class="math inline">\(2 q &lt; n\)</span>,也就是原串能写成<span class="math inline">\(tt \cdots t &#39;\)</span>的形式.我们不妨先求<span class="math inline">\(tt &#39;\)</span>对应的答案,然后在前面拼<span class="math inline">\(t\)</span>.根据<span class="math inline">\(\leq
\frac{ n }{ 2 }\)</span>的border构成等差序列的结论,这样显然是正确的.</p>
<p>如果<span class="math inline">\(2 q \geq n\)</span>,此时必定有<span class="math inline">\(s = tat\)</span>,其中<span class="math inline">\(t\)</span>是border.考虑递归求解<span class="math inline">\(t\)</span>,然后就只需要找到一个<span class="math inline">\(a\)</span>满足条件,最小的<span class="math inline">\(a\)</span>是全<span class="math inline">\(0\)</span>,能放的话肯定放,不然我们就放一个<span class="math inline">\(0 \cdots 01\)</span>.</p>
<p>为什么这样一定是对的呢?我们考虑什么时候全<span class="math inline">\(0\)</span>不合法:</p>
<ol type="1">
<li><p>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l \leq | t | + | a |\)</span>:考虑<span class="math inline">\(l\)</span>的最后一段是一段全<span class="math inline">\(0\)</span>,也就必然意味着<span class="math inline">\(t\)</span>的最后一段是全<span class="math inline">\(0\)</span>,这么不断推下去就可以说明整个序列都是全<span class="math inline">\(0\)</span>,此时放上<span class="math inline">\(0
\cdots 01\)</span>必定合法.</p></li>
<li><p>新增一个长度<span class="math inline">\(l\)</span>的border,<span class="math inline">\(l &gt; | t | + | a |\)</span>:不妨设当前的<span class="math inline">\(l\)</span>是最大的那个(最小的无意义,因为需要保证<span class="math inline">\(| l | &gt; | t |\)</span>),此时最短周期必然是<span class="math inline">\(d = 2 | t | + | a | - l\)</span>.由于<span class="math inline">\(| t | + | a |\)</span>也是周期并且二者之和<span class="math inline">\(\leq n\)</span>,因此必然有<span class="math inline">\(d | ( | t | + | a | )\)</span>.把<span class="math inline">\(ta\)</span>按照<span class="math inline">\(d\)</span>长度划分.如果<span class="math inline">\(d \geq | a |\)</span>必有该串是全<span class="math inline">\(0\)</span>串,不然考虑此时<span class="math inline">\(d = | b | + | a |\)</span>,<span class="math inline">\(b\)</span>是<span class="math inline">\(t\)</span>的一段后缀.考虑此时的周期必然<span class="math inline">\(&lt; | b | + | a
|\)</span>,首先不可能等于,如果大于的话可以平移一格.不妨假设周期比<span class="math inline">\(| b | - | a |\)</span>少了<span class="math inline">\(w\)</span>,那么此时必定有<span class="math inline">\(b\)</span>的前<span class="math inline">\(w\)</span>个字符是<span class="math inline">\(0\)</span>,但是由于<span class="math inline">\(0
\cdots 01\)</span>后面第一个<span class="math inline">\(b\)</span>也往前平移了<span class="math inline">\(w\)</span>格,因此它的第<span class="math inline">\(w\)</span>个字符必定是<span class="math inline">\(1\)</span>,这就保证了<span class="math inline">\(0
\cdots 0 1\)</span>必定合法.</p></li>
</ol>
<h3><span id="sa">SA</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个长度为<span class="math inline">\(n\)</span>的字符串,要从中从左往右选出若干段不相交的子串,使得选出的这些串中,每个串都是上一个串的严格子串.求最多能选出多少段.<span class="math inline">\(n \leq 5 \times 10^5\)</span>.</p>
<p>不难发现一定有一组答案每段的长度是<span class="math inline">\(k , k -
1 , \cdots , 2 , 1\)</span>,我们不妨把串反过来,这样就是<span class="math inline">\(1 , 2 , \cdots , k - 1 ,
k\)</span>.这样就可以设计一个简单的dp是<span class="math inline">\(f_{ i
, j }\)</span>表示以<span class="math inline">\(i\)</span>结尾,<span class="math inline">\(i\)</span>这段长度为<span class="math inline">\(j\)</span>是否可行,发现单调性后把dp状态扔进值里,<span class="math inline">\(f_i\)</span>表示以<span class="math inline">\(i\)</span>结尾的最大长度是多少,这样用SA做lcp就可以实现<span class="math inline">\(O ( n^2
)\)</span>.仔细观察转移过程,我们可以二分答案,然后用主席树+SA判断答案是否可行.复杂度<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<p>那么怎么优化呢?我们考虑类似height的证明:<span class="math inline">\(f_i \leq f_{ i - 1 } +
1\)</span>,原因很简单,如果<span class="math inline">\(f_i &gt; f_{ i - 1
} + 1\)</span>,那么我们把<span class="math inline">\(f_i\)</span>那个序列的末尾字符全部删掉,自然得到了一个以<span class="math inline">\(i - 1\)</span>结尾,长度为<span class="math inline">\(f_i - 1 &gt; f_{ i - 1
}\)</span>的串,于是就可以类似height那样去掉二分,很厉害.</p>
<h3><span id="acam">ACAM</span></h3>
<p>用于对于每个文本串的前缀,求出它以哪些模式串为后缀.</p>
<h5><span id="example1uoj772企鹅游戏">Example1(uoj772企鹅游戏)</span></h5>
<p>考虑一个暴力:建出<span class="math inline">\(s\)</span>的AC自动机,然后我们记录fail树结构,然后把<span class="math inline">\(t\)</span>放上去跑,每次暴力向上跳fail树上的匹配节点,这样的复杂度就是<span class="math inline">\(O ( \sum 匹 配 节 点 个 数 )\)</span>.</p>
<p>但是这个复杂度是正确的.</p>
<p>为啥呢?首先对于任意节点,它在fail树上的祖先中匹配节点个数不可能超过<span class="math inline">\(O ( \sqrt{ L }
)\)</span>个,这是个自然根号,因此复杂度至少是<span class="math inline">\(O ( L \sqrt{ L } )\)</span>.</p>
<p>但还没完,考虑所有长度小于等于<span class="math inline">\(B\)</span>的模式串,他们会被匹配<span class="math inline">\(O ( B | t | )\)</span>次.对于所有长度大于<span class="math inline">\(B\)</span>的模式串,考虑只有长度大于<span class="math inline">\(B\)</span>的文本串会匹配到他们,于是复杂度<span class="math inline">\(O ( \frac{ L^2 }{ B^2 } )\)</span>,<span class="math inline">\(B = L^{ \frac{ 1 }{ 3 } }\)</span>得到<span class="math inline">\(O ( L^{ \frac{ 4 }{ 3 } } )\)</span>.</p>
<h5><span id="example2loj3396-novel">Example2(loj3396 novel)</span></h5>
<p>offline.</p>
<h3><span id="pam">PAM</span></h3>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li>本质不同回文串最多只有<span class="math inline">\(n\)</span>个.</li>
</ol>
<p>证明:考虑类似manacher,每次将<span class="math inline">\(S \rightarrow
S + c\)</span>,新产生的回文串一定是<span class="math inline">\(S +
c\)</span>的最长回文后缀.</p>
<h4><span id="算法">算法</span></h4>
<p>回文自动机由转移边和fail树构成,经过一条转移边的影响是在前后均添加一个该字符,一个状态在fail树上指向它的最长回文border.</p>
<p>我们记录两个根:长度为<span class="math inline">\(-
1\)</span>的奇根和长度为<span class="math inline">\(0\)</span>的偶根,偶根的失配指针指向奇根.</p>
<p>增量构造,每次加入个新字符,然后在fail树上跳祖先直到<span class="math inline">\(s_i = s_{ i - len - 1 }\)</span>.</p>
<p>继续跳这个节点,直到又遇到一个位置,那这个位置就是当前节点的fail指针所指向的点.这个操作是<span class="math inline">\(O ( n
)\)</span>的,因为这个fail指针只有一个永远不会访问,另外的都会访问至少一次,在访问的时候就会均摊掉求的时候往上跳的复杂度,因为深度直接减去这玩意了.</p>
<h3><span id="sam">SAM</span></h3>
<ol type="1">
<li><p><span class="math inline">\(endpos ( T )\)</span>表示子串<span class="math inline">\(T\)</span>在<span class="math inline">\(S\)</span>中出现位置的末尾集合,特别地,我们设<span class="math inline">\(endpos ( \emptyset ) = \{ 1 , \cdots , | S | - 1 ,
| S | \}\)</span>.</p></li>
<li><p>若两个不同的子串的<span class="math inline">\(endpos\)</span>相等,则称它们为一个<span class="math inline">\(endpos\)</span>等价类.</p></li>
</ol>
<p>下面开始证明引理:</p>
<h4><span id="引理">引理</span></h4>
<ol type="1">
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>相同(假设<span class="math inline">\(| u | \leq | w |\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>在<span class="math inline">\(s\)</span>中的每次出现,都是以<span class="math inline">\(w\)</span>后缀的形式存在.</p></li>
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>集合的交为空(假设<span class="math inline">\(| u | \leq | w |\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>不是<span class="math inline">\(w\)</span>的后缀.</p></li>
<li><p>字符串<span class="math inline">\(s\)</span>的两个非空子串<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>的<span class="math inline">\(endpos\)</span>集合的交为<span class="math inline">\(endpos ( w )\)</span>(假设<span class="math inline">\(| u | \leq | w |\)</span>),当且仅当字符串<span class="math inline">\(u\)</span>是<span class="math inline">\(w\)</span>的后缀.</p></li>
</ol>
<p>证明都是显然的.</p>
<ol start="4" type="1">
<li>对于一个<span class="math inline">\(endpos\)</span>等价类中的子串<span class="math inline">\(u\)</span>,要么<span class="math inline">\(u\)</span>是这个等价类中最短的子串,要么存在一个子串<span class="math inline">\(w\)</span>且<span class="math inline">\(| w | + 1
= | u |\)</span>,<span class="math inline">\(w\)</span>是<span class="math inline">\(u\)</span>的后缀</li>
</ol>
<p>由前面的引理,容易证明.</p>
<ol start="5" type="1">
<li>对于一个<span class="math inline">\(endpos\)</span>等价类中最短的子串<span class="math inline">\(w\)</span>,不妨设<span class="math inline">\(v\)</span>是<span class="math inline">\(w\)</span>去掉最前面的元素后得到的子串,那么<span class="math inline">\(v\)</span>在另一个<span class="math inline">\(endpos\)</span>等价类中,我们将<span class="math inline">\(endpos ( w ) \rightarrow endpos ( v
)\)</span>,记<span class="math inline">\(link ( w ) = v\)</span>或<span class="math inline">\(fa ( w ) =
v\)</span>,这就是后缀链接link,这些关系构成树.</li>
</ol>
<p>首先除了<span class="math inline">\(\emptyset\)</span>,每个<span class="math inline">\(w\)</span>的出度都是<span class="math inline">\(1\)</span>,而我们发现所有的子串都会以<span class="math inline">\(\emptyset\)</span>作为祖先,这就证明了连通性.</p>
<ol start="6" type="1">
<li><span class="math inline">\(endpos\)</span>等价类的数量有<span class="math inline">\(O ( n )\)</span>个.</li>
</ol>
<p>考虑后缀链接树,显然一个点的<span class="math inline">\(endpos\)</span>集合包含它的所有儿子的<span class="math inline">\(endpos\)</span>集合的并,并且它所有儿子的<span class="math inline">\(endpos\)</span>集合两两无交,这等价于一个合并的过程.</p>
<h4><span id="约定">约定</span></h4>
<ol type="1">
<li><p>记<span class="math inline">\(longest ( v )\)</span>为<span class="math inline">\(v\)</span>这个<span class="math inline">\(endpos\)</span>等价类中最长的一个字符串,记<span class="math inline">\(len ( v )\)</span>为它的长度.类似地定义<span class="math inline">\(shortest ( v )\)</span>和<span class="math inline">\(minlen ( v )\)</span>,不难发现<span class="math inline">\(minlen ( v ) = len ( fa ( v ) ) +
1\)</span>.每个节点的子串数量也就是<span class="math inline">\(len ( v )
- len ( fa ( v ) )\)</span>.</p></li>
<li><p>记<span class="math inline">\(siz ( v )\)</span>为<span class="math inline">\(v\)</span>这个<span class="math inline">\(endpos\)</span>等价类的<span class="math inline">\(endpos\)</span>集合的大小.</p></li>
</ol>
<h4><span id="算法">算法</span></h4>
<p>先来捋一下整个过程:整个SAM分为两部分:</p>
<p>第一部分:后缀链接树(parent tree).</p>
<p>它的信息由下文中的fa记录.对于每一个节点:它对应一个endpos等价类,因此它拥有一个父亲节点,也就是后缀链接link指向的节点.同时它拥有一个len,表示这个endpos等价类中最长的子串的长度.</p>
<p>第二部分:trie图.</p>
<p>它的信息由下文中的son记录,表示一个endpos(设为x)通过一条trie边走到另一个endpos(设为y),不难发现x中的所有endpos+1所形成的集合包含y.我们注意这一点后,会发现只要从<span class="math inline">\(\emptyset\)</span>所代表的节点不断地走trie边,最后走到的节点的对应长度的子串就是我们想要的子串.这也意味着我们要保证对应长度的子串一定在走到节点的子串集合中.另外有个结论是trie图的边数是<span class="math inline">\(O ( n
)\)</span>的.这必然要求走trie走到的那个节点的<span class="math inline">\(len\)</span>的长度的区间包含了这个节点的<span class="math inline">\(len\)</span>的长度的区间<span class="math inline">\(+ 1\)</span>.</p>
<p>也就是说,走trie边的过程是不断在字符串后面添加字符的过程,而走link的过程是不断在字符串前面删去字符串的过程(当然,反向link自然是不断在字符串前面加上另一个字符串集合的过程).</p>
<p>下面给出构造代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SAM</span>&#123;</span><br><span class="line"><span class="type">int</span> fa;</span><br><span class="line"><span class="type">int</span> son[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> len,siz;</span><br><span class="line">&#125;tr[MAXN&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cntp=<span class="number">1</span>,las=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> End[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_c</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=++cntp;</span><br><span class="line">End[i]=x;tr[x].siz=<span class="number">1</span>;<span class="comment">//新建一个endpos=&#123;i&#125;</span></span><br><span class="line"><span class="comment">//End[i]存的是前缀[1,i]的结束位置,由于我们当前正在插入i,自然是x.</span></span><br><span class="line"><span class="type">int</span> prex=las;</span><br><span class="line">las=cntp;</span><br><span class="line"><span class="comment">//las存储的是当前的终止节点,其实也就是End[i],我们每次要找到上一次的终止节点,根据它来操作.</span></span><br><span class="line">tr[x].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==<span class="number">0</span>;prex=tr[prex].fa)tr[prex].son[c]=x;</span><br><span class="line"><span class="comment">//考虑当前的串:[1,i-1]+&#x27;c&#x27;,如果前面存在一个endpos集合包含[j,i-1](这个集合可能是空子串所在的集合)并且它存在一条&#x27;c&#x27;边,那么就存在这么一个子串[j,i-1]+&#x27;c&#x27;,它的endpos应该是&#123;i&#125;这个集合的祖先.</span></span><br><span class="line"><span class="comment">//如果在判断[j,i-1]的时候,发现[j,i-1]+&#x27;c&#x27;在原串中不存在,那么我们就直接连过来.可以发现在这个跳跃的过程中就是不断探索当前x的shortest的过程.</span></span><br><span class="line"><span class="keyword">if</span>(!prex)&#123;</span><br><span class="line"><span class="comment">//说明一直到最后都没有找到字母c,这也意味着c在前面根本没出现过,于是endpos=&#123;i&#125;的等价类是[1,i],[2,i],...,[i,i],所以父亲设为1.</span></span><br><span class="line">tr[x].fa=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y=tr[prex].son[c];</span><br><span class="line"><span class="comment">//考虑这里的prex到底是什么意义,它意味着我们找到了一个最长的[j,i-1]的子串所在的endpos集合,并且[j,i-1]+&#x27;c&#x27;这个子串在原串存在,这也意味着[j,i-1]+&#x27;c&#x27;这个子串所在的endpos集合必然真包含&#123;i&#125;,而这个子串的长度是tr[prex].len+1.</span></span><br><span class="line"><span class="keyword">if</span>(tr[y].len==tr[prex].len+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果y这个节点的长度恰好也是tr[prex].len+1,那么必然意味着[j,i]这个子串完全就在y这里,而[j-1,i]这些子串不在y这里,但被y表示的endpos集合包含.</span></span><br><span class="line">tr[x].fa=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//反之,这里y这个节点的endpos集合就可以分成两部分了:第一部分的endpos集合在加入[j,i]这个子串后不变:因为它们的长度都大于tr[prex].len+1,它们必然不可能存在一个endpos是i.而第二部分,其实也只包含一个子串:就是长度等于tr[prex].len+1的子串,它的endpos集合必然是第一部分的endpos集合并上&#123;i&#125;,根据我们上面所发现的parent tree的本质是合并endpos集合的性质,它应该是第一部分以及&#123;i&#125;的父亲(也就是这两部分合并的结果),我们把第二部分拿出来单独建点.</span></span><br><span class="line"><span class="type">int</span> fay=++cntp;</span><br><span class="line">tr[fay]=tr[y];</span><br><span class="line">tr[fay].len=tr[prex].len+<span class="number">1</span>;</span><br><span class="line">tr[y].fa=tr[x].fa=fay;</span><br><span class="line"><span class="keyword">for</span>(;prex&amp;&amp;tr[prex].son[c]==y;prex=tr[prex].fa)tr[prex].son[c]=fay;</span><br><span class="line"><span class="comment">//注意单独建点后,原本指向y的trie边要改向.这是为什么呢?考虑当前这条边是什么意义:它必然指向一个endpos集合要包含&#123;i&#125;的点,因为这样才能保证trie图的性质.此时指向y的点就不能是包含&#123;i-1&#125;的点了.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> que[MAXN&lt;&lt;<span class="number">1</span>],l,r;</span><br><span class="line"><span class="type">int</span> ind[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work_siz</span><span class="params">()</span></span>&#123;<span class="comment">//通过一次拓扑排序处理出siz</span></span><br><span class="line">l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">++ind[tr[i].fa];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ind[i]==<span class="number">0</span>)que[++r]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> x=que[l];++l;</span><br><span class="line">tr[tr[x].fa].siz+=tr[x].siz;</span><br><span class="line">--ind[tr[x].fa];</span><br><span class="line"><span class="keyword">if</span>(ind[tr[x].fa]==<span class="number">0</span>)que[++r]=tr[x].fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是省掉了很多说明:比如这里的复杂度证明以及边数证明,但是我们咕了吧.</p>
<h4><span id="应用">应用</span></h4>
<h5><span id="检查字符串是否出现">检查字符串是否出现</span></h5>
<p>从根开始跳trie边就行.</p>
<h5><span id="不同子串个数">不同子串个数</span></h5>
<p>显然是<span class="math inline">\(\sum len_i - len_{ fa_i
}\)</span>.</p>
<h4><span id="例题">例题</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给出一个长度为<span class="math inline">\(n\)</span>的小写字母串,你需要计算有多少对非空字符串<span class="math inline">\(( A , B )\)</span>满足:</p>
<ol type="1">
<li><p><span class="math inline">\(AB\)</span>是原串的子串.</p></li>
<li><p>每次<span class="math inline">\(A\)</span>在原串中作为子串出现后,要么紧跟着出现一个子串<span class="math inline">\(B\)</span>,要么<span class="math inline">\(A\)</span>后面放不下一个子串<span class="math inline">\(B\)</span>.</p></li>
</ol>
<p>两个字符串被认为是不同的当且仅当他们在某个位置上字母不同,<span class="math inline">\(| S | \leq 2 \times 10^5\)</span>.</p>
<p>首先,我们考虑确定<span class="math inline">\(( AB , A
)\)</span>这个二元组,对反串建立SAM,我们自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(AB\)</span>的endpos集合是<span class="math inline">\(A\)</span>的endpos集合的后缀.</p></li>
<li><p><span class="math inline">\(A\)</span>的endpos集合中存在的最大的不存在于<span class="math inline">\(AB\)</span>的endpos集合的endpos的大小小于<span class="math inline">\(| AB |\)</span>.</p></li>
</ol>
<p>看到这里你可能有疑问:为啥要建立反串.因为不建立反串的话<span class="math inline">\(( AB , B
)\)</span>的endpos可能根本没啥区别,这个很难处理<span class="math inline">\(A\)</span>.SAM最强大的武器还是在于它能快速处理endpos.</p>
<p>那么接下来我们要在SAM上判断这两件事,我们需要一些更方便判断的条件.首先一个自然的发现是,<span class="math inline">\(A\)</span>的最大的endpos必然也是<span class="math inline">\(AB\)</span>的最大的endpos,我们进行一个类似重链剖分的操作:将每个点的重儿子设为它所有儿子中最大的endpos最大的那个.不难发现此时的<span class="math inline">\(A\)</span>与<span class="math inline">\(AB\)</span>必然在同一条重链上,且<span class="math inline">\(A\)</span>是<span class="math inline">\(AB\)</span>的祖先.不过显然这并不能保证一定是后缀,我们开始补条件,直到补到它充要:另一个显然的条件是,设<span class="math inline">\(mx_v\)</span>表示节点<span class="math inline">\(v\)</span>的轻儿子中最大的endpos最大是多少,那么<span class="math inline">\(A\)</span>与<span class="math inline">\(AB\)</span>间的所有<span class="math inline">\(mx\)</span>的最大值就是<span class="math inline">\(A\)</span>的endpos集合中存在的最大的不存在于<span class="math inline">\(AB\)</span>的endpos集合的endpos的大小,它需要小于<span class="math inline">\(| AB
|\)</span>.进一步发现这个数字必然需要小于<span class="math inline">\(AB\)</span>的endpos的集合中最小的那个(不然就不是后缀),这被包含于小于<span class="math inline">\(| AB |\)</span>这个条件.</p>
<p>接下来就拆重链,写单调栈就行.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">多项式与生成函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2>
<h3><span id="复数相关">复数相关</span></h3>
<p>棣莫弗定理:<span class="math inline">\(( cos \theta + i \sin \theta
)^n = \cos ( n \theta ) + i \sin ( n \theta )\)</span>.</p>
<p>欧拉公式:<span class="math inline">\(e^{ i \pi } = - 1\)</span>.</p>
<p>也就是<span class="math inline">\(e^{ 2 i \pi } =
1\)</span>,同时又有<span class="math inline">\(e^{ i \theta } = cos
\theta + i · sin \theta\)</span>,证明直接使用泰勒展开.</p>
<p>单位根:对于<span class="math inline">\(x^n = 1\)</span>,我们会有<span class="math inline">\(n\)</span>个根,设第<span class="math inline">\(k\)</span>个根为<span class="math inline">\(\omega_n^k\)</span>.那么我们有:<span class="math inline">\(\omega_n^k = e^{ 2 \pi \frac{ k }{ n } i } = cos (
2 \pi \frac{ k }{ n } ) + i · sin ( 2 \pi \frac{ k }{ n }
)\)</span>.</p>
<p>单位根有以下性质:</p>
<ol type="1">
<li><p>折半引理:<span class="math inline">\(\omega_{ 2 n }^{ 2 k } =
\omega_n^k \\\)</span>,由我们上面推导的通项公式即可证明.</p></li>
<li><p>消去引理:<span class="math inline">\(\omega_n^{ k + \frac{ n }{ 2
} } = - \omega_n^k
\\\)</span>,同样使用通项，运用三角恒等变换可证明.</p></li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4>
<p>上复平面,设<span class="math inline">\(S_k = ( \cos \frac{ 2 k \pi }{
n } , \sin \frac{ 2 k \pi }{ n } )\)</span>,也就是<span class="math inline">\(z_k = \cos \frac{ 2 k \pi }{ n } + i \sin \frac{ 2
k \pi }{ n }\)</span>是方程<span class="math inline">\(z^n - 1 =
0\)</span>的复根.我们把这个方程写开:</p>
<p><span class="math display">\[
z^n - 1 = ( z - 1 ) ( z^{ n - 1 } + z^{ n - 2 } + \cdots + 1 ) = 0
\]</span></p>
<p>不难发现<span class="math inline">\(z = 1\)</span>是平凡解.</p>
<p>我们不妨定义<span class="math inline">\(f ( x ) = \prod_{ k = 1 }^n (
1 + X^k ) = \sum_{ k \geq 0 } a_k X^k\)</span>,事实上我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 1 }{ n } \sum_{ j = 1 }^n f ( \omega_n^j ) &amp; = \frac{ 1 }{ n
} \sum_{ j = 1 }^n \sum_{ k \geq 0 } a_k \omega^{ kj }_n \\
&amp; = \frac{ 1 }{ n } \sum_{ k \geq 0 } a_k \sum_{ j = 1 }^n \omega_{
n }^{ kj } \\
&amp; = \sum_{ j \geq 0 } a_{ jn } + \frac{ 1 }{ n } \sum_{ k \geq 0 , n
\nmid k } a_k \frac{ 1 - \omega^{ nj }_n }{ 1 - \omega^{ k }_n }
\omega_{ n }^j \\
&amp; = \sum_{ j \geq 0 } a_{ jn }
\end{aligned}
\]</span></p>
<p>事实上,我们令<span class="math inline">\(d = \frac{ n }{ \gcd ( j , n
) }\)</span>,容易发现<span class="math inline">\(f ( \omega_n^j ) = (
\prod_{ k = 1 }^d ( 1 + \omega_n^{ kj } ) )^{ \frac{ n }{ d }
}\)</span>,又容易发现<span class="math inline">\(n | jd\)</span>.</p>
<p>接下来观察<span class="math inline">\(X^d - 1 = \prod_{ k = 1 }^d ( X
- \omega_{ n }^{ kj } )\)</span>,带入<span class="math inline">\(X = -
1\)</span>得到<span class="math inline">\(f ( \omega_n^j ) =
\begin{cases}2^{ \frac{ n }{ d } } &amp; d \in \text{ odd } \\ 0 &amp; d
\in \text{ even }\end{cases}\)</span>.</p>
<p>接下来考虑拿到<span class="math inline">\(\sum_{ j } a_{ jn
}\)</span>,只需求<span class="math inline">\(\frac{ 1 }{ n } \sum_{ j =
1 }^n f ( \omega_n^j ) = \frac{ 1 }{ n } \sum_{ d \in \text{ odd } ,
\gcd ( j , n ) = \frac{ n }{ d } } 2^{ \frac{ n }{ d } } = \frac{ 1 }{ n
} \sum_{ d \in \text{ odd } } \varphi ( d ) 2^{ \frac{ n }{ d }
}\)</span>.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5>
<p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现<span class="math inline">\(+ , - , \times , \div ,
\sqrt[2]{  }\)</span>五种操作.而对于正<span class="math inline">\(n\)</span>边形,显然只要我们能将<span class="math inline">\(\cos \frac{ 2 \pi }{ n
}\)</span>用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6>
<p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 &amp; = z_1 + z_4 \\
\sigma_2 &amp; = z_2 + z_3
\end{aligned}
\]</span></p>
<p>不难验证:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 + \sigma_2 &amp; = - 1 \\
\sigma_1 \sigma_2 &amp; = - 1
\end{aligned}
\]</span></p>
<p>可以求出复合条件的解,将<span class="math inline">\(z\)</span>带入又有:</p>
<p><span class="math display">\[
\begin{aligned}
\sigma_1 &amp; = 2 \cos \frac{ 2 \pi }{ 5 } \\
\sigma_2 &amp; = 2 \cos \frac{ 4 \pi }{ 5 }
\end{aligned}
\]</span></p>
<p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6>
<p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6>
<p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设<span class="math inline">\(n \in \mathrm{ prime
}\)</span>,我们用<span class="math inline">\(p\)</span>代替<span class="math inline">\(n\)</span>.</p>
<p>我们有<span class="math inline">\(z_1 = \cos \frac{ 2 \pi }{ p } + i
\sin \frac{ 2 \pi }{ p }\)</span>,由于其它的<span class="math inline">\(z\)</span>都可以表示成它的幂,因此我们记<span class="math inline">\(\varepsilon = z_1\)</span>.</p>
<p>我们现在想要这么分组:</p>
<p><span class="math display">\[
\sigma_{ k + 1 } = \sum_{ 1 \leq l \leq p - 1 , f ( l , k ) = 1 }
\varepsilon^l
\]</span></p>
<h3><span id="泰勒展开">泰勒展开</span></h3>
<p>即<span class="math inline">\(f ( x ) = g ( x ) = f ( x_0 ) + \sum_{
k \geq 1 } \frac{ f^{ ( k ) } ( x_0 ) }{ k ! } ( x - x_0 )^k
\\\)</span>.<span class="math inline">\(x_0 =
0\)</span>的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2>
<h3><span id="多项式基础">多项式基础</span></h3>
<h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4>
<p>代数基本定理:一个<span class="math inline">\(n -
1\)</span>次方程在复数域上有且只有<span class="math inline">\(n -
1\)</span>个根.</p>
<p>定理:一个<span class="math inline">\(n - 1\)</span>次多项式在<span class="math inline">\(n\)</span>个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个<span class="math inline">\(n - 1\)</span>次多项式<span class="math inline">\(A ( x )\)</span>和<span class="math inline">\(B (
x )\)</span>且有<span class="math inline">\(\forall i \in [ 0 , n - 1 ]
, A ( x_i ) = B ( x_i ) \\\)</span>.</p>
<p>令<span class="math inline">\(C ( x ) = A ( x ) - B ( x
)\)</span>,那么<span class="math inline">\(C ( x
)\)</span>至多是一个<span class="math inline">\(n -
1\)</span>次多项式且<span class="math inline">\(\forall i \in [ 0 , n -
1 ] , C ( x_i ) = 0 \\\)</span>,也就是<span class="math inline">\(C ( x
)\)</span>有<span class="math inline">\(n\)</span>个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:<span class="math inline">\(A ( x ) = \sum_{ i = 0 }^{ n -
1 } a_i x^i \\\)</span>.</p>
<p>点值表示法:<span class="math inline">\(y_i = \sum_{ j = 0 }^{ n - 1 }
a_j x_i^j \\\)</span>.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4>
<p>构造多项式<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } y_i (
\prod_{ j = 0 \land j \ne i }^{ n - 1 } \frac{ x - x_j }{ x_i - x_j } )
\\\)</span>.显然当<span class="math inline">\(x =
x_i\)</span>时,该多项式的答案为<span class="math inline">\(y_i\)</span>.</p>
<p>另外,如果<span class="math inline">\(x_i =
i\)</span>,不难发现这个式子可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ i = 1 }^{ n } y_i ( \prod_{ j = 1 \land j \ne i }^{ n }
\frac{ x - x_j }{ x_i - x_j } ) \\
\\
= &amp; \sum_{ i = 1 }^n y_i ( \prod_{ j = 1 \land j \ne i }^n \cfrac{ x
- j }{ i - j } ) \\
= &amp; \sum_{ i = 1 }^n y_i ( - 1 )^{ n - i } ( \cfrac{ 1 }{ ( i - 1 )
! ( n - i ) ! } \prod_{ j = 1 , j \ne i }^{ n } ( x - j ) )
\end{aligned}
\]</span></p>
<h3><span id="多项式运算">多项式运算</span></h3>
<p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4>
<h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5>
<h6><span id="dft">DFT</span></h6>
<p>将<span class="math inline">\(n\)</span>次单位根(默认<span class="math inline">\(n\)</span>是二的整次幂,如果少了的话补零,设<span class="math inline">\(n = 2^w\)</span>)分别带入<span class="math inline">\(A ( x )\)</span>得到点值向量<span class="math inline">\(A ( \omega_n^k ) \\\)</span>.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
A ( x ) &amp; = \sum_{ i = 0 }^{ n - 1 } a_i x^i \\
&amp; = \sum_{ i = 2 k , k \in \mathbb{ N } }^{ n - 2 } a_i x^i + \sum_{
i = 2 k + 1 , k \in \mathbb{ N } }^{ n - 1 } a_i x^i \\
&amp; = \sum_{ i = 2 k , k \in \mathbb{ N } }^{ n - 2 } a_i x^{ 2 k } +
x \sum_{ i = 2 k + 1 , k \in \mathbb{ N } }^{ n - 1 } a_i x^{ 2 k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>令</p>
<p>A_2(x)=_{i=2k+1,k}<sup>{n-1}a_ix</sup>{k}\<span class="math inline">\(, 那
么\)</span>A(x)=A_1(x<sup>2)+xA_2(x</sup>2)\</p>
<p>接下来分类讨论:</p>
<p><span class="math inline">\(\forall 0 \leq k \leq \frac{ n }{ 2 } - 1
, k \in \mathbb{ N } \\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^k ) &amp; = A_1 ( \omega_n^{ 2 k } ) + \omega_n^k A_2 (
\omega_n^{ 2 k } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据折半引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^k ) &amp; = A_1 ( \omega_{ \frac{ n }{ 2 } }^k ) +
\omega_n^k A_2 ( \omega^k_{ \frac{ n }{ 2 } } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们处理完了前半部分.</p>
<p><span class="math inline">\(\forall \frac{ n }{ 2 } \leq k + \frac{ n
}{ 2 } \leq n - 1 , k \in \mathbb{ N } \\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^{ k + \frac{ n }{ 2 } } ) &amp; = A_1 ( \omega_n^{ 2 k + n
} ) + \omega_n^{ k + \frac{ n }{ 2 } } A_2 ( \omega_n^{ 2 k + n } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据消去引理:</p>
$$
<span class="math display">\[\begin{aligned}
A ( \omega_n^{ k + \frac{ n }{ 2 } } ) &amp; = A_1 ( \omega_{ \frac{ n
}{ 2 } }^k ) - \omega_n^k A_2 ( \omega_{ \frac{ n }{ 2 } }^k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>综上,我们可以递归处理<span class="math inline">\(A_1\)</span>和<span class="math inline">\(A_2\)</span>,然后合并得到<span class="math inline">\(A\)</span>的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6>
<p>设<span class="math inline">\(A ( \omega_n^k ) = d_k
\\\)</span>,构造多项式<span class="math inline">\(F ( x ) = \sum_{ i = 0
}^{ n - 1 } d_i x^i \\\)</span>.</p>
<p>我们求出<span class="math inline">\(F ( x
)\)</span>的点值表示,设<span class="math inline">\(c_k = F ( \omega_n^{
- k } ) \\\)</span>,也即:</p>
$$
<span class="math display">\[\begin{aligned}
c_k &amp; = \sum_{ i = 0 }^{ n - 1 } d_i ( \omega_n^{ - k } )^i \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( \sum_{ j = 0 }^{ n - 1 } a_j (
\omega_n^i )^j ) ( \omega_n^{ - k } )^i \\
&amp; = \sum_{ j = 0 }^{ n - 1 } a_j \sum_{ i = 0 }^{ n - 1 } (
\omega_n^i )^{ j - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(j = k\)</span>时,显然<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } ( \omega_n^i )^{ j - k }
= n \\\)</span>.</p>
<p>否则根据等比数列求和公式,<span class="math inline">\(\sum_{ i = 0 }^{
n - 1 } ( \omega_n^i )^{ j - k } = \frac{ \omega^0_n [ ( \omega_n^{ j -
k } )^n - 1 ] }{ \omega_n^{ j - k } - 1 } = 0 \\\)</span>.</p>
<p>所以<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } ( \omega_n^i
)^{ j - k } = n [ j = k ] \\\)</span>.</p>
<p>那么我们有</p>
<p>a_k=\</p>
<h6><span id="写法">写法</span></h6>
<p>递归写法显然.</p>
<p>递归过程中,第<span class="math inline">\(k\)</span>层相当于在根据数在第<span class="math inline">\(k\)</span>位的二进制数是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">ll ak=a[i+k];</span><br><span class="line">a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5>
<p>由于FFT中的单位根会产生精度误差,因此在膜<span class="math inline">\(998244353\)</span>意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为<span class="math inline">\(g\)</span>,<span class="math inline">\(g_n = g^{
\frac{ p - 1 }{ n } }
\\\)</span>,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol type="1">
<li><p><span class="math inline">\(g_n^n = g_n^0 = 1\)</span>且<span class="math inline">\(\forall 0 \leq i &lt; j &lt; n , g_n^i \ne
g_n^j\)</span>,证明由原根的性质.</p></li>
<li><p>折半引理:<span class="math inline">\(g_{ 2 n }^{ 2 k } = g_{ n
}^k\)</span>,证明显然.</p></li>
<li><p>消去引理:<span class="math inline">\(g_{ n }^{ k + \frac{ n }{ 2
} } = - g^k_n \\\)</span>.由于<span class="math inline">\(g^{ \frac{ p -
1 }{ 2 } } = - 1\)</span>,该结论显然成立.</p></li>
</ol>
<p>由上我们证明了,我们完全可以使用<span class="math inline">\(g_n\)</span>代替<span class="math inline">\(\omega_n\)</span>进行变换.</p>
<p>另外,注意到<span class="math inline">\(998244352 = 2^{ 23 } \times 7
\times 17 \\\)</span>,而<span class="math inline">\(2^{ 23 } \approx 8
\times 10^6 \\\)</span>.因而,当<span class="math inline">\(n \leq 8
\times 10^6\)</span>的时候,<span class="math inline">\(g_n\)</span>可以直接求出.这也是为什么大部分NTT题目都使用<span class="math inline">\(998244353\)</span>作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5>
<p>范德蒙德矩阵形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; \alpha_1 &amp; \cdots &amp; \alpha_1^{ n - 1 } \\
1 &amp; \alpha_2 &amp; \cdots &amp; \alpha_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \alpha_m &amp; \cdots &amp; \alpha_m^{ n - 1 }
\end{bmatrix} \in \mathbb{ R }^{ m \times n }
\]</span></p>
<p>如果取单位根,我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \cdots &amp; \omega_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ n - 1 } &amp; \cdots &amp; \omega_n^{ ( n - 1 )^2 }
\end{bmatrix} \in \mathbb{ R }^{ n \times n }
\]</span></p>
<p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \cdots &amp; \omega_2^{ n - 1 } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ n - 1 } &amp; \cdots &amp; \omega_n^{ ( n - 1 )^2 }
\end{bmatrix}^{ - 1 } = \frac{ 1 }{ n } \begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^{ - 1 } &amp; \cdots &amp; \omega_2^{ - ( n - 1 ) } \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{ - ( n - 1 ) } &amp; \cdots &amp; \omega_n^{ - ( n - 1
)^2 }
\end{bmatrix}
\]</span></p>
<h4><span id="分治fft">分治FFT</span></h4>
<p>给定<span class="math inline">\(g ( x )\)</span>和<span class="math inline">\(f ( 0 )\)</span>,求<span class="math inline">\(f (
x ) = \sum_{ y = 1 }^x f ( x - y ) g ( y )\)</span>,答案对<span class="math inline">\(998244353\)</span>取膜.</p>
<p>考虑分治,假如我们已经知道了<span class="math inline">\(f ( x ) , x
\in [ 1 , \frac{ n }{ 2 } ]\)</span>.那我们可以计算出这段部分对<span class="math inline">\(f ( y ) ， y \in [ \frac{ n }{ 2 } + 1 , n
]\)</span>的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4>
<p>对于多项式<span class="math inline">\(P ( x )\)</span>,找到<span class="math inline">\(Q ( x )\)</span>使得<span class="math inline">\(Q
( x ) P ( x ) \equiv 1 \pmod{ x^{ n } } \\\)</span>.显然<span class="math inline">\(Q ( x )\)</span>是唯一的.</p>
<p>首先不妨设<span class="math inline">\(n = 2^k \\\)</span>.</p>
<p>如果我们已知<span class="math inline">\(P ( x ) Q_{ k - 1 } ( x )
\equiv 1 \pmod{ x^{ 2^{ k - 1 } } } \\\)</span>,同时肯定有<span class="math inline">\(P ( x ) Q_{ k } ( x ) \equiv 1 \pmod{ x^{ 2^{ k -
1 } } } \\\)</span>,相减得到<span class="math inline">\(Q_k ( x ) - Q_{
k - 1 } ( x ) \equiv 0 \pmod{ x^{ 2^{ k - 1 } } } \\\)</span>.</p>
<p>两边平方:</p>
$$
<span class="math display">\[\begin{aligned}
Q_k^2 ( x ) + Q^2_{ k - 1 } ( x ) - 2 Q_k ( x ) Q_{ k - 1 } ( x ) &amp;
\equiv 0 \pmod{ x^{ 2^k } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边乘一下<span class="math inline">\(P ( x )\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
Q_k ( x ) - 2 Q_{ k - 1 } ( x ) + P ( x ) Q_{ k - 1 }^2 ( x ) &amp;
\equiv 0 \pmod{ x^n } \\
Q_k ( x ) &amp; \equiv 2 Q_{ k - 1 } ( x ) - P ( x ) Q_{ k - 1 }^2 ( x )
\pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据主定理，这么做复杂度是<span class="math inline">\(O ( n \log_2 n
)\)</span>的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; \equiv F ( x ) G ( x ) + f_0 \pmod{ x^{ n + 1 } } \\
F ( x ) &amp; = \frac{ f ( 0 ) }{ 1 - G ( x ) } \pmod{ x^{ n + 1 } }
\end{aligned}
\]</span></p>
<p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4>
<p>对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F ( x )\)</span>和<span class="math inline">\(m\)</span>次多项式<span class="math inline">\(G (
x )\)</span>,找到<span class="math inline">\(Q ( x ) , R ( x
)\)</span>使得<span class="math inline">\(F ( x ) = G ( x ) Q ( x ) + R
( x ) \\\)</span>.</p>
<p>考虑对于<span class="math inline">\(n\)</span>次多项式<span class="math inline">\(F ( x )\)</span>,令<span class="math inline">\(F_R
( x ) = x^n F ( \cfrac{ 1 }{ x } )\)</span>,如果设<span class="math inline">\(f_i\)</span>为其<span class="math inline">\(x^i\)</span>项前的系数,不难发现<span class="math inline">\(f_R ( i ) = f ( n - i )\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
F ( x ) &amp; = G ( x ) Q ( x ) + R ( x ) \\
F ( \cfrac{ 1 }{ x } ) &amp; = G ( \cfrac{ 1 }{ x } ) Q ( \cfrac{ 1 }{ x
} ) + R ( \cfrac{ 1 }{ x } ) \\
x^n F ( \cfrac{ 1 }{ x } ) &amp; = x^m G ( \cfrac{ 1 }{ x } ) x^{ n - m
} Q ( \cfrac{ 1 }{ x } ) + x^{ n - m + 1 } x^{ m - 1 } R ( \cfrac{ 1 }{
x } ) \\
F_R ( x ) &amp; = G_R ( x ) Q_R ( x ) + x^{ n - m + 1 } R_R ( x ) \\
F_R ( x ) &amp; \equiv G_R ( x ) Q_R ( x ) \pmod{ x^{ n - m + 1 } } \\
Q_R ( x ) &amp; \equiv F_R ( x ) G_R^{ - 1 } ( x ) \pmod{ x^{ n - m + 1
} }
\end{aligned}
\]</span></p>
<p>于是只要做一遍多项式求逆即可求得<span class="math inline">\(Q ( x
)\)</span>,再做一遍相减既可以得到<span class="math inline">\(R ( x
)\)</span>.</p>
<h4><span id="多项式ln">多项式ln</span></h4>
<p>给出<span class="math inline">\(n - 1\)</span>次多项式<span class="math inline">\(A ( x )\)</span>,求一个多项式<span class="math inline">\(B ( x )\)</span>,满足<span class="math inline">\(B
( x ) \equiv \ln A ( x )\)</span>.</p>
<p>我们有:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \ln A ( x ) \pmod{ x^n } \\
B &#39; ( x ) &amp; \equiv \cfrac{ A &#39; ( x ) }{ A ( x ) } \pmod{
nx^{ n - 1 } } \\
B ( x ) &amp; \equiv \int \cfrac{ A &#39; ( x ) }{ A ( x ) } dx \pmod{
x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当<span class="math inline">\([ x^0 ] f ( x ) =
1\)</span>的时候,<span class="math inline">\(f ( x
)\)</span>有对数多项式.</p>
<p>我们对最后再做一步:</p>
$$
<span class="math display">\[\begin{aligned}
B ( x ) &amp; \equiv \int_0^x \cfrac{ A &#39; ( t ) }{ A ( t ) } dt + B
( 0 ) \pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>首先<span class="math inline">\(B ( 0 ) = \ln A ( 0 ) = \ln
a_0\)</span>,如果<span class="math inline">\(a_0 \in \mathbb{ Q } \land
a_0 \ne 1\)</span>,则<span class="math inline">\(B ( 0 ) \notin \mathbb{
Q }\)</span>,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若<span class="math inline">\([ x^0 ] f ( x ) =
1\)</span>的时候,<span class="math inline">\(B ( 0 ) =
0\)</span>,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4>
<p>给定多项式<span class="math inline">\(G ( x
)\)</span>,求一个多项式<span class="math inline">\(F ( x
)\)</span>满足<span class="math inline">\(G ( F ( x ) ) \equiv 0 \pmod{
x^n }\)</span>.</p>
<p>首先<span class="math inline">\(n = 1\)</span>的时候,也就是求<span class="math inline">\(G ( F ( x ) ) \equiv 0 \pmod{ x
}\)</span>.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在<span class="math inline">\(\bmod x^{ \lceil
\frac{ n }{ 2 } \rceil }\)</span>意义下的答案<span class="math inline">\(F_0 ( x )\)</span>,我们考虑在<span class="math inline">\(F_0 ( x )\)</span>处做泰勒展开:</p>
$$
<span class="math display">\[\begin{aligned}
G ( F ( x ) ) &amp; = \sum_{ k = 0 }^{ + \infty } \frac{ G^{ ( k ) } (
F_0 ( x ) ) }{ k ! } ( F ( x ) - F_0 ( x ) )^k \equiv 0 \pmod{ x^n } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(F ( x ) - F_0 ( x
)\)</span>,由于<span class="math inline">\(F_0 ( x ) \equiv F ( x )
\pmod{ x^{ \lceil \frac{ n }{ 2 } \rceil } }\)</span>,因此,因此<span class="math inline">\(( F ( x ) - F_0 ( x ) )^2 \equiv 0 \pmod{ x^n
}\)</span>.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^{ + \infty } \frac{ G^{ ( k ) } ( F_0 ( x ) ) }{ k ! } (
F ( x ) - F_0 ( x ) )^k &amp; \equiv 0 \pmod{ x^n } \\
G ( F_0 ( x ) ) + G &#39; ( F_0 ( x ) ) ( F ( x ) - F_0 ( x ) ) &amp;
\equiv 0 \pmod{ x^n } \\
F ( x ) &amp; \equiv F_0 ( x ) - \frac{ G ( F_0 ( x ) ) }{ G &#39; ( F_0
( x ) ) } \pmod{ x^n }
\end{aligned}
\]</span></p>
<p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4>
<p>给定<span class="math inline">\(h ( x )\)</span>,设<span class="math inline">\(g ( f ( x ) ) = f^2 ( x ) - h ( x
)\)</span>,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
f ( x ) \equiv f_0 ( x ) - \frac{ f^2 ( x ) - h ( x ) }{ 2 f_0 ( x ) }
\equiv \frac{ f^2 ( x ) + h ( x ) }{ 2 f_0 ( x ) } \pmod{ x^n }
\]</span></p>
<p>还没完,用牛顿迭代前一定要求<span class="math inline">\(g ( a ) \equiv
0 \pmod{ x^n }\)</span>的解,也就是<span class="math inline">\([ x^0 ] h
( x )\)</span>的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4>
<p>给定<span class="math inline">\(h ( x )\)</span>,设<span class="math inline">\(g ( f ( x ) ) = \ln f ( x ) - h ( x
)\)</span>,求零点.</p>
<p>根据牛顿迭代,有:</p>
<p><span class="math display">\[
\begin{aligned}
f ( x ) &amp; \equiv f_0 ( x ) - \frac{ \ln f_0 ( x ) - h ( x ) }{
\frac{ 1 }{ f_0 ( x ) } } \pmod{ x^n } \\
&amp; \equiv f_0 ( x ) ( 1 - \ln f_0 ( x ) + h ( x ) ) \pmod{ x^n }
\end{aligned}
\]</span></p>
<p>还没完,还需要求<span class="math inline">\(g ( a ) \equiv 0 \pmod{
x^n }\)</span>的解,注意到存在<span class="math inline">\(\exp\)</span>当且仅当<span class="math inline">\([
x^0 ] g ( x ) \equiv 0\)</span>,此时<span class="math inline">\(f ( x )
\equiv 1 \pmod{ x }\)</span>.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4>
<p>求<span class="math inline">\(\ln\)</span>后求<span class="math inline">\(\exp\)</span>即可,唯一的问题是为什么指数可以对<span class="math inline">\(p\)</span>取膜.</p>
<p>我们有一个结论:</p>
<p><span class="math display">\[
f ( x^p ) \equiv f ( x )^p \pmod{ p }
\]</span></p>
<p>这个结论很简单,注意到<span class="math inline">\(( a + b )^p \equiv
a^p + b^p \pmod{ p }\)</span>即可.</p>
<p>而又由于<span class="math inline">\(n &lt; p\)</span>,因此<span class="math inline">\(f ( x )^p \equiv f ( 0 ) \pmod{ p
}\)</span>,通常取<span class="math inline">\(f ( 0 ) =
1\)</span>,于是就可以直接对<span class="math inline">\(p\)</span>取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4>
<p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做<span class="math inline">\(\exp\)</span>的时候的直接数组传参,会导致<span class="math inline">\(\exp\)</span>的复杂度退化到<span class="math inline">\(O ( n \log^2 n )\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">ll x[qwq];</span><br><span class="line"><span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">ll ak=(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">x.k=k;</span><br><span class="line">x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">y.x[i]=x*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">y.limit=x.limit;y.k=x.k;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">tmp_inv.x[i]=x.x[i];</span><br><span class="line">&#125;</span><br><span class="line">tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">tmp_inv.k=q_inv.k=k;</span><br><span class="line">q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">&#125;</span><br><span class="line">q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line"><span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line"><span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">x.limit=lim,x.k=k;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">x.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">tmp_exp.k=q_exp.k=k;</span><br><span class="line">q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_exp;</span><br><span class="line">&#125;</span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3>
<p>集合幂级数形如<span class="math inline">\(\sum_{ i = 0 }^{ 2^n - 1 }
a_i x^i\)</span>,其中二进制数<span class="math inline">\(i\)</span>表示<span class="math inline">\(\{ 1 , 2
, . . . , n \}\)</span>的一个子集,用<span class="math inline">\(| i
|\)</span>表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4>
<p>高维前缀和:<span class="math inline">\(c_i = \sum_{ j \subseteq i }
a_j \\\)</span>.</p>
<p>高维后缀和:<span class="math inline">\(c_i = \sum_{ j \supseteq i }
a_j \\\)</span>.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line"><span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\lor k = i ] a_j b_k \\\)</span>.</p>
<p>与卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\land k = i ] a_j b_k \\\)</span>.</p>
<p>二者求法类似,考虑如何求<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的或卷积:</p>
<p>引理:</p>
<p>若<span class="math inline">\(j , k \subseteq i\)</span>,则<span class="math inline">\(j \lor k \subseteq i\)</span>,逆命题同样成立.</p>
<p>若<span class="math inline">\(j , k \supseteq i\)</span>,则<span class="math inline">\(j \land k \supseteq i\)</span>,逆命题同样成立.</p>
<p>设<span class="math inline">\(a , b ,
c\)</span>的高维前缀和分别为<span class="math inline">\(A , B ,
C\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
A_i B_i &amp; = ( \sum_{ j \subseteq i } a_j ) ( \sum_{ k \subseteq i }
b_k ) \\
&amp; = \sum_{ j , k \subseteq i } a_i b_k \\
&amp; = \sum_{ k \lor j \subseteq i } a_i b_k \\
&amp; = C_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>现在考虑已知<span class="math inline">\(C\)</span>求<span class="math inline">\(c\)</span>,本质上是一个反演.注意到<span class="math inline">\(\sum_{ r \subseteq p } ( - 1 )^{ | r | } = \sum_{
k = 0 }^{ | p | } C_{ | p | }^k ( - 1 )^k = [ p = 0 ]
\\\)</span>,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
c ( p ) &amp; = \sum_{ q \subseteq p } [ p - q = 0 ] c ( q ) \\
&amp; = \sum_{ q \subseteq p } \sum_{ r \subseteq ( p - q ) } ( - 1 )^{
| r | } c ( q ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ | r | } \sum_{ q \subseteq ( p
- r ) } c ( q ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ r } C ( p - r ) \\
&amp; = \sum_{ r \subseteq p } ( - 1 )^{ | p | - | r | } C ( r ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是有<span class="math inline">\(c ( S ) = \sum_{ T \subseteq S } (
- 1 )^{ | S | - | T | } C ( T ) \\\)</span>(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度<span class="math inline">\(O ( 2^n n )\)</span>.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line"><span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4>
<p>异或卷积:<span class="math inline">\(c_i = \sum_j \sum_k [ j \oplus k
= i ] a_j b_k \\\)</span>.</p>
<p>引理:<span class="math inline">\(( i \oplus j ) \land k = ( i \land k
) \oplus ( j \land k )\)</span>.</p>
<p>证明的话考虑如果<span class="math inline">\(k =
0\)</span>,二者显然相等;当<span class="math inline">\(k =
1\)</span>的时候,左右都等价于<span class="math inline">\(( i \oplus j
)\)</span>.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数<span class="math inline">\(FWT ( a
)\)</span>,满足<span class="math inline">\(FWT ( a )_i = \sum_{ j = 0
}^{ 2^n - 1 } ( - 1 )^{ | i \land j | } a_j \\\)</span>.</p>
<p>那么有:</p>
$$
<span class="math display">\[\begin{aligned}
FWT ( c )_i &amp; = \sum_{ j = 0 }^{ 2^n - 1 } ( - 1 )^{ | i \land j | }
c_j \\
&amp; = \sum_{ j = 0 }^{ 2^n - 1 } ( - 1 )^{ | i \land j | } \sum_{ k =
0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } [ k \oplus l = j ] a_k b_l \\
&amp; = \sum_{ k = 0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } ( - 1 )^{
| ( k \oplus l ) \land i | } a_k b_l \\
&amp; = \sum_{ k = 0 }^{ 2^n - 1 } \sum_{ l = 0 }^{ 2^n - 1 } ( - 1 )^{
| k \land i | } a_k ( - 1 )^{ | l \land i | } b_l \\
&amp; = FWT ( a )_i FWT ( b )_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>时间复杂度<span class="math inline">\(O ( 2^n n )\)</span>.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4>
<h5><span id="线性代数角度">线性代数角度</span></h5>
<p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换<span class="math inline">\(FWT\)</span>,使得</p>
<ol type="1">
<li><p>若<span class="math inline">\(c_i = \sum_{ j \oplus k } a_j
b_k\)</span>,则<span class="math inline">\(FWT ( c ) = FWT ( a ) FWT ( b
)\)</span>.</p></li>
<li><p>这个线性变换是可逆的.</p></li>
<li><p>做这个线性变换和其逆变换的复杂度都可以接受.</p></li>
</ol>
<p>我们设<span class="math inline">\(FWT ( A )_i = \sum_{ j } w ( i , j
) A_j\)</span>,我们想要做的就是构造一组满足上述条件的<span class="math inline">\(w\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( C )_i &amp; = FWT ( A )_i FWT ( B )_i \\
\sum_{ j } w ( i , j ) C_j &amp; = \sum_{ j , k } w ( i , j ) w ( i , k
) A_j B_k
\end{aligned}
\]</span></p>
<p>再考虑:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; = A * B \\
C_i &amp; = \sum_{ k \oplus l = i } A_k B_l \\
\sum_{ j } w ( i , j ) C_j &amp; = \sum_j w ( i , j ) \sum_{ k \oplus l
= j } A_k B_l \\
\sum_{ j , k } w ( i , j ) w ( i , k ) A_j B_k &amp; = \sum_j w ( i , j
) \sum_{ k \oplus l = j } A_k B_l \\
\sum_{ j , k } w ( i , j ) w ( i , k ) A_j B_k &amp; = \sum_{ j , k }
A_j B_k w ( i , j \oplus k )
\end{aligned}
\]</span></p>
<p>比较两边系数,有<span class="math inline">\(w ( i , j ) w ( i , k ) =
w ( i , j \oplus k
)\)</span>.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于<span class="math inline">\(\oplus\)</span>是集合的运算,我们可以对二进制分开考虑.换句话说,如果<span class="math inline">\(a = \sum_{ i = 0 } a_i 2^i , b = \sum_{ i = 0 }
b_i 2^i\)</span>,那么<span class="math inline">\(w ( a , b ) = \prod_{ i
= 0 } w ( a_i , b_i )\)</span>一定是满足条件的.</p>
<p>这样我们就可以只求一个<span class="math inline">\(2 \times
2\)</span>的线性变换矩阵就好.我们接下来将对三种常见的基础位运算(<span class="math inline">\(\lor , \land , xor ( \oplus
)\)</span>)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出<span class="math inline">\(FWT ( a )\)</span>呢?</p>
<p>考虑和FFT一样折半,令<span class="math inline">\(i_0\)</span>为<span class="math inline">\(i\)</span>的最高位是否是<span class="math inline">\(1\)</span>,<span class="math inline">\(i
&#39;\)</span>为<span class="math inline">\(i\)</span>去掉最高位后的二进制数字,令<span class="math inline">\(n = 2^m\)</span>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_i &amp; = \sum_{ j = 0 }^{ 2^m - 1 } w ( i , j ) A_j \\
&amp; = \sum_{ j = 0 }^{ 2^{ m - 1 } - 1 } w ( i , j ) A_j + \sum_{ j =
2^{ m - 1 } }^{ 2^m - 1 } w ( i , j ) A_j \\
&amp; = w ( i_0 , 0 ) \sum_{ j = 0 }^{ 2^{ m - 1 } - 1 } w ( i &#39; , j
&#39; ) A_j + w ( i_0 , 1 ) \sum_{ j = 2^{ m - 1 } }^{ 2^m - 1 } w ( i
&#39; , j &#39; ) A_j
\end{aligned}
\]</span></p>
<p>这样就实现了规模减半,复杂度<span class="math inline">\(O ( mn
)\)</span>.</p>
<p>下面我们设FWT的变换矩阵为<span class="math inline">\(\begin{bmatrix}w
( 0 , 0 ) &amp; w ( 0 , 1 ) \\ w ( 1 , 0 ) &amp; w ( 1 , 1
)\end{bmatrix}\)</span>.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 0 \\ 1 &amp;
1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1 &amp; 0 \\ - 1 &amp;
1\end{bmatrix}\)</span>.</p>
<h6><span id="与卷积">与卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 1 \\ 0 &amp;
1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}1 &amp; - 1 \\ 0 &amp;
1\end{bmatrix}\)</span>.</p>
<h6><span id="异或卷积">异或卷积</span></h6>
<p>取矩阵<span class="math inline">\(\begin{bmatrix}1 &amp; 1 \\ 1 &amp;
- 1\end{bmatrix}\)</span>.其逆矩阵为<span class="math inline">\(\begin{bmatrix}\frac{ 1 }{ 2 } &amp; \frac{ 1 }{ 2
} \\ \frac{ 1 }{ 2 } &amp; - \frac{ 1 }{ 2 }\end{bmatrix}\)</span>.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5>
<p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:<span class="math inline">\(x^S x^T = x^{ S \oplus
T }\)</span>,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_S &amp; = \sum_{ T = 0 }^{ 2^n - 1 } ( - 1 )^{ | S \land T | }
a_T \\
IFWT ( A )_S &amp; = \frac{ 1 }{ 2^n } FWT ( A )_S
\end{aligned}
\]</span></p>
<p>这等价于:</p>
<p><span class="math display">\[
\begin{aligned}
[ x^S ] FWT ( A ) &amp; = \sum_{ T = 0 }^{ 2^n - 1 } ( - 1 )^{ | S \land
T | } a_T \\
[ x^S ] IFWT ( A ) &amp; = [ x^S ] \frac{ 1 }{ 2^n } FWT ( A )
\end{aligned}
\]</span></p>
<h4><span id="子集卷积">子集卷积</span></h4>
<p>子集卷积:<span class="math inline">\(c_i = \sum_{ j } \sum_{ k } [ j
\land k = \emptyset , j \lor k = i ] a_j b_k \\\)</span>.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些<span class="math inline">\([ j \land k \ne \emptyset ]\)</span>的答案,而<span class="math inline">\([ j \land k = \phi , j \lor k = i ] = [ | j | + |
k | = | i | , j \lor k = i ] \\\)</span>.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再<span class="math inline">\(n^2\)</span>次结合,并做IFMT,最终将结果累计,复杂度<span class="math inline">\(O ( 2^n n^2 )\)</span>.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4>
<p>其实就是设<span class="math inline">\(g_{ i , j } = z^i
f_j\)</span>,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1agc034f-rng-andxor">Example1([AGC034F] RNG and
XOR)</span></h5>
<p>设<span class="math inline">\(f_i ( n )\)</span>表示操作<span class="math inline">\(n\)</span>次后第一次变成<span class="math inline">\(i\)</span>的概率,<span class="math inline">\(g_i (
n )\)</span>表示操作<span class="math inline">\(n\)</span>次后变成<span class="math inline">\(i\)</span>的概率.<span class="math inline">\(F ,
G\)</span>分别是其生成函数.</p>
<p>注意到<span class="math inline">\(G_i = F_i G_0 , F_i = \frac{ G_i }{
G_0 }\)</span>,而<span class="math inline">\(F_i &#39; ( 1
)\)</span>就是期望.接下来的问题在于如何求<span class="math inline">\(G\)</span>.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把<span class="math inline">\(a_i \rightarrow \frac{ a_i }{ \sum a
}\)</span>,然后做<span class="math inline">\(A = FWT ( a
)\)</span>,注意这里<span class="math inline">\(A_0 = \sum a =
1\)</span>,FWT自身有很好的性质:<span class="math inline">\(a = \frac{ 1
}{ 2^N } FWT ( A )\)</span>.我们做<span class="math inline">\(n\)</span>次操作后得到的概率数组也就是<span class="math inline">\(\frac{ 1 }{ 2^N } FWT ( A^n
)\)</span>.展开FWT的式子,自然有:</p>
<p><span class="math display">\[
\begin{aligned}
g_i ( n ) &amp; = \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | }
A_j^n x^n \\
G_i &amp; = \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | } \frac{
1 }{ 1 - A_j x } \\
F_i &amp; = \frac{ G_i }{ G_0 } \\
F_i &#39; &amp; = \frac{ G_i &#39; G_0 - G_0 &#39; G_i }{ G_0^2 } \\
&amp; = \frac{ ( \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | }
\frac{ A_j }{ ( 1 - A_j x )^2 } ) ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ 1
}{ 1 - A_j x } ) - ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ A_j }{ ( 1 - A_j
x )^2 } ) ( \sum_{ j = 0 }^{ 2^N - 1 } ( - 1 )^{ | i \land j | } \frac{
1 }{ 1 - A_j x } ) }{ ( \sum_{ j = 0 }^{ 2^N - 1 } \frac{ 1 }{ 1 - A_j x
} )^2 }
\end{aligned}
\]</span></p>
<p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求<span class="math inline">\(F &#39;_i ( 1 )\)</span>,因此我们直接把<span class="math inline">\(x = 1\)</span>带入算一算就好.不过由于<span class="math inline">\(A_0 = 1\)</span>,我们必须要解决分母为<span class="math inline">\(0\)</span>的情况,解决的方法是分母乘上<span class="math inline">\(( 1 - x )\)</span>,这样就消掉了<span class="math inline">\(j =
0\)</span>的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5>
<p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边<span class="math inline">\(u \leftrightarrow v\)</span>就异或上<span class="math inline">\(( 2^u + 2^v )\)</span>.最后要求这个二进制数是<span class="math inline">\(0\)</span>.我们用一个二元组<span class="math inline">\(( a , F )\)</span>表示在集合幂级数上异或上<span class="math inline">\(a\)</span>,在多项式上乘上<span class="math inline">\(F\)</span>.显然一条边是<span class="math inline">\(( 0 , 1 ) + ( 2^u + 2^v , x
)\)</span>.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上<span class="math inline">\(1 + x\)</span>要么乘上<span class="math inline">\(1 - x\)</span>,做完FWT得到的每一个<span class="math inline">\(FWT_i\)</span>一定形如<span class="math inline">\(( 1 + x )^k ( 1 - x )^{ m - k
}\)</span>,做IFWT的时候直接求<span class="math inline">\(\frac{ 1 }{ 2^N
} \sum ( 1 + x )^k ( 1 - x )^{ m - k }\)</span>即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:<span class="math inline">\(( 0 , 1 )\)</span>和<span class="math inline">\((
2^u + 2^v , x )\)</span>,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个<span class="math inline">\(i\)</span>求<span class="math inline">\(k\)</span>,也就是对于每个<span class="math inline">\(i\)</span>求有多少条边满足<span class="math inline">\(| i \land ( 2^u + 2^v ) | =
1\)</span>,也就是求有多少条边一段链接在了<span class="math inline">\(i\)</span>的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-cloves-3-iii">Example3(CF1034E Little C
Loves 3 III)</span></h5>
<p>仍然是子集卷积,转化为<span class="math inline">\(c_i = \sum_{ j }
\sum_{ k } [ | j | + | k | = | i | , j \lor k = i ] a_j b_k
\\\)</span>.然后我们将<span class="math inline">\(a_j\)</span>乘上<span class="math inline">\(4^j\)</span>,将<span class="math inline">\(b_k\)</span>乘上<span class="math inline">\(4^k\)</span>,最后把<span class="math inline">\(c_i\)</span>除去<span class="math inline">\(4^i\)</span>对<span class="math inline">\(4\)</span>取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2chiori-and-doll-picking">Example4(CF1336E2
Chiori and Doll Picking)</span></h5>
<p>先考虑easy version.首先求出线性基,如果线性基的大小<span class="math inline">\(k\)</span>比较小,我们可以直接<span class="math inline">\(2^k\)</span>枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个<span class="math inline">\(1\)</span>取决于选了多少个元素,其他位置共有<span class="math inline">\(m -
k\)</span>个,可以直接状压进状态.这样复杂度就是<span class="math inline">\(O ( \min \{ 2^k , m^2 2^{ m - k } \}
)\)</span>.</p>
<p>那么我们怎么优化呢?首先<span class="math inline">\(k\)</span>较大的时候有点难做,我们看看能不能优化到<span class="math inline">\(2^{ m - k }\)</span>.</p>
<p>考虑设<span class="math inline">\(f_i^c = [ | i | = c
]\)</span>,将线性基能做出的线性空间设为<span class="math inline">\(A\)</span>,<span class="math inline">\(A_S =
1\)</span>当且仅当线性基能异或出<span class="math inline">\(S\)</span>(最后再把那些废元素贡献到答案里).那么<span class="math inline">\(popcount = c\)</span>的答案就是<span class="math inline">\(IFWT ( FWT ( F ) FWT ( A ) )_0\)</span>.考虑<span class="math inline">\(IFWT_0 = \frac{ 1 }{ 2^m } \sum_{ i = 0 }^{ 2^m -
1 } FWT ( F )_i FWT ( A )_i\)</span>,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:<span class="math inline">\(FWT ( A )\)</span>要么是<span class="math inline">\(2^k\)</span>,要么是<span class="math inline">\(0\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
A * A = A \times 2^k
\]</span></p>
<p>这句是为啥呢?因为对于右边的每一个数字<span class="math inline">\(x\)</span>和左边的一个数字<span class="math inline">\(y\)</span>,如果它们都在线性基中,一定存在一个数字<span class="math inline">\(z\)</span>满足<span class="math inline">\(y \oplus
z = x\)</span>,不然就是<span class="math inline">\(0\)</span>.</p>
<p>于是我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A )_i \cdot FWT ( A )_i &amp; = FWT ( A )_i \times 2^k \\
FWT ( A )_i &amp; = 0 \lor 2^k
\end{aligned}
\]</span></p>
<p>引理2:<span class="math inline">\(FWT ( A )_i = 2^k \Leftrightarrow
\forall x , A_x \ne 0 , | i \land x | \equiv 0 \pmod{ 2 }\)</span>.</p>
<p>直接展开上面的式子,用<span class="math inline">\(\sum_{ S \subseteq T
} ( - 1 )^{ | S | } = [ T = \emptyset ]\)</span>.</p>
<p>引理3:<span class="math inline">\(FWT ( A )\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果<span class="math inline">\(i\)</span>满足条件,<span class="math inline">\(j\)</span>满足条件,一开始做FWT时我们已经注意到:<span class="math inline">\(( i \oplus j ) \land x = ( i \land x ) \oplus ( j
\land x )\)</span>.于是这个引理也显然成立.</p>
<p>引理4:<span class="math inline">\(FWT ( A )\)</span>中值为<span class="math inline">\(2^k\)</span>的位置构成的线性基的大小是<span class="math inline">\(m - k\)</span>.</p>
<p>设这些位置构成的空间是<span class="math inline">\(B\)</span>,<span class="math inline">\(B_S = 1\)</span>当且仅当<span class="math inline">\(S\)</span>在这个空间中.我们有:</p>
<p><span class="math display">\[
\begin{aligned}
FWT ( A ) &amp; = B \times 2^k \\
A &amp; = IFWT ( B ) \times 2^k
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(a_0 = 1\)</span>,也就是<span class="math inline">\(\frac{ 2^k }{ 2^m } \sum b = 1 , \sum b = 2^{ m -
k }\)</span>,这就证明了引理.</p>
<p>引理5:将<span class="math inline">\(A\)</span>的线性基对应的矩阵从前往后消成最简,<span class="math inline">\(B\)</span>的线性基对应的矩阵从后往前消成最简,上<span class="math inline">\(A\)</span>下<span class="math inline">\(B\)</span>拼成一个<span class="math inline">\(m
\times m\)</span>的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据<span class="math inline">\(rank ( A ) + rank ( B ) = k + m -
k = m\)</span>可以知道主对角线一定全是<span class="math inline">\(1\)</span>,然后我们任取<span class="math inline">\(A\)</span>中的一个基<span class="math inline">\(x\)</span>和<span class="math inline">\(B\)</span>中的一个基<span class="math inline">\(y\)</span>,应该有<span class="math inline">\(| x
\land y | \equiv 0 \pmod{ 2
}\)</span>.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由<span class="math inline">\(A\)</span>得知<span class="math inline">\(B\)</span>长什么样.</p>
<p>引理6:<span class="math inline">\(FWT ( F^c )_i\)</span>只和<span class="math inline">\(| i |\)</span>有关.</p>
<p>因为<span class="math inline">\(F^c_i\)</span>只和<span class="math inline">\(| i
|\)</span>有关,这里考虑一下对称性就可以.因此设<span class="math inline">\(w_{ d }^c = FWT ( F^c )_i , | i | =
d\)</span>.</p>
<p>然后注意到<span class="math inline">\(w_d^c = \sum_{ i = 0 }^{ 2^m -
1 } ( - 1 )^{ | i \land ( 2^d - 1 ) | } [ | i | = c
]\)</span>.组合意义展开一下:</p>
<p><span class="math display">\[
w_d^c = \sum_{ j = 0 }^{ d } ( - 1 )^{ j } \binom{ d }{ j } \binom{ m -
d }{ c - j }
\]</span></p>
<p>接下来怎么做呢?令<span class="math inline">\(g_d = \sum_{ i = 0 }^{
2^m - 1 } [ A_i = 1 ] [ | i | = d ]\)</span>,这里可以<span class="math inline">\(O ( 2^{ m - k } )\)</span>,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5>
<p>首先发现”如果没有边那么是<span class="math inline">\(0\)</span>“这个限制太强了,如果我们能改为”如果是<span class="math inline">\(0\)</span>,那么可有边可无边”的话,整个序列就会被<span class="math inline">\(1\)</span>的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设<span class="math inline">\(g_{ len , S }\)</span>表示长度为<span class="math inline">\(len\)</span>,一段长度为<span class="math inline">\(len - 1\)</span>的连续的<span class="math inline">\(1\)</span>对应的集合是<span class="math inline">\(S\)</span>的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个<span class="math inline">\(0\)</span>).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5>
<p>首先可以类似数位dp设计一个<span class="math inline">\(dp_{ i , S
}\)</span>表示目前dp到了第<span class="math inline">\(i\)</span>位,然后前面的<span class="math inline">\(limit\)</span>是<span class="math inline">\(S\)</span>.接下来分类讨论当前的最大值限制是<span class="math inline">\(1\)</span>还是<span class="math inline">\(0\)</span>.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2>
<h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3>
<h4><span id="概念">概念</span></h4>
<p>我们定义一个幂级数形如<span class="math inline">\(A ( z ) = \sum_{ k
\geq 0 } a_k z^k\)</span>,并使<span class="math inline">\([ z^n ] A ( z
) = a_n\)</span>.则称<span class="math inline">\(A ( z )\)</span>是<span class="math inline">\(\langle a_0 , a_1 , . . .
\rangle\)</span>的生成函数.</p>
<h4><span id="运算">运算</span></h4>
<ol type="1">
<li><p><span class="math inline">\(\alpha A ( z ) + \beta B ( z ) =
\sum_{ n \geq 0 } ( \alpha f_n + \beta g_n ) z^n\)</span>.</p></li>
<li><p><span class="math inline">\(z^m A ( z ) = \sum_{ n \geq 0 } g_{ n
} z^{ n + m } = \sum_{ n \geq m } g_{ n - m } z^n\)</span>.</p></li>
<li><p><span class="math inline">\(A ( cz ) = \sum_{ n \geq 0 } c^n f_n
z^n\)</span>.</p></li>
<li><p><span class="math inline">\(A &#39; ( z ) = \sum_{ n \geq 1 }
ig_i z^{ i - 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(\int A ( z ) dz = \sum_{ n \geq 0 }
\cfrac{ 1 }{ n + 1 } g_n z^{ n + 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(A ( z ) B ( z ) = \sum_{ n \geq 0 } (
\sum_{ k = 0 }^n f_k g_{ n - k } ) z^n\)</span>.</p></li>
<li><p><span class="math inline">\(\cfrac{ 1 }{ 1 - z } A ( z ) = \sum_{
n \geq 0 } ( \sum_{ k = 0 }^n g_k ) z^n\)</span>.</p></li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4>
<ol type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ 1 - z } = \sum_{ k \geq 0 }
z^k \\\)</span>,<span class="math inline">\(\cfrac{ 1 }{ 1 - cz } =
\sum_{ k \geq 0 } c^k z^k \\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="2" type="1">
<li><span class="math inline">\(( 1 + z )^r = \sum_{ k \geq 0 } \binom{
r }{ k } z^k \\\)</span>,<span class="math inline">\(( 1 - z )^r =
\sum_{ k \geq 0 } ( - 1 )^k \binom{ r }{ k } z^k \\\)</span>.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ 1 - z^m } = \sum_{ n \geq 0
} [ n | m ] z^n \\\)</span>.</li>
</ol>
<p>证明显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\cfrac{ 1 }{ ( 1 - z )^{ n + 1 } } =
\sum_{ k \geq 0 } \binom{ n + k }{ n } z^k , n \in \mathbb{ N }
\\\)</span>,<span class="math inline">\(\cfrac{ z^n }{ ( 1 - z )^{ n + 1
} } = \sum_{ k \geq 0 } \binom{ k }{ n } z^k , n \in \mathbb{ N }
\\\)</span></li>
</ol>
<p>直接使用二项式定理展开<span class="math inline">\(( 1 - z )^{ - n - 1
}\)</span>,可以得到:</p>
<p><span class="math display">\[
( 1 - z )^{ - n - 1 } = \sum_{ k \geq 0 } ( - 1 )^k \binom{ - n - 1 }{ k
} z^k
\]</span></p>
<p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ 1 }{ ( 1 - z )^2 } &amp; = \sum_{ n \geq 0 } ( n + 1 ) z^n \\
\cfrac{ z }{ ( 1 - z )^2 } &amp; = \sum_{ n \geq 0 } nz^n
\end{aligned}
\]</span></p>
<p>根据<span class="math inline">\(( 1 )\)</span>求导即可得到此式.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(e^z = \sum_{ k \geq 0 } \cfrac{ z^k
}{ k ! } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( \cfrac{ 1 }{ 1 - z } ) = \sum_{
n \geq 1 } \cfrac{ 1 }{ n } z^n\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 + z ) = \sum_{ k \geq 0 } ( -
1 )^k \cfrac{ z^{ k + 1 } }{ k + 1 } \\\)</span>.</p></li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\frac{ 1 - \sqrt{ 1 - 4 x } }{ 2 x } =
\sum_{ k \geq 0 } \frac{ \binom{ 2 k }{ k } }{ k + 1 }
x^k\)</span>.</li>
</ol>
<p>也即卡特兰数<span class="math inline">\(C_k\)</span>的生成函数,证明考虑:</p>
<p><span class="math display">\[
xC^2 + 1 = C
\]</span></p>
<p>然后得到两个根,带入<span class="math inline">\(x =
0\)</span>舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3>
<p>https://zhuanlan.zhihu.com/p/53079223</p>
<p>序列<span class="math inline">\(\{ a
\}\)</span>的指数生成函数定义为形式幂级数<span class="math inline">\(\hat F ( x ) = \sum a_n \frac{ x^n }{ n !
}\)</span>.注意<span class="math inline">\([ x^n ] \hat F ( x ) =
a_n\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) \hat G ( x ) &amp; = \sum_{ j \geq 0 } a_j \frac{ x^j }{ j
! } \sum_{ k \geq 0 } b_k \frac{ x^k }{ k ! } \\
&amp; = \sum_{ k \geq 0 } x^k \sum_{ j = 0 }^k a_j b_{ k - j } \frac{ k
! }{ j ! ( k - j ) ! } \frac{ 1 }{ k ! } \\
&amp; = \sum_{ k \geq 0 } \frac{ x^k }{ k ! } \sum_{ j = 0 }^k a_j b_{ k
- j } \binom{ k }{ j }
\end{aligned}
\]</span></p>
<p>即<span class="math inline">\(\langle \sum_{ i = 0 }^n \binom{ n }{ i
} a_i b_{ n - i } \rangle\)</span>的EFG.</p>
<p>注意到有一个特例是<span class="math inline">\(x \hat F ( x
)\)</span>就是<span class="math inline">\(\langle \binom{ n }{ n - 1 }
a_i \rangle\)</span>的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(e^x = \sum_{ k \geq 0 } \frac{ x^k }{ k
! }\)</span></li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol start="2" type="1">
<li><span class="math inline">\(e^{ px } = \sum_{ k \geq 0 } p^k \frac{
x^k }{ k ! }\)</span></li>
</ol>
<p>换元后可以得到.一个经典特例是<span class="math inline">\(e^{ - x } =
\sum_{ k \geq 0 } ( - 1 )^k \frac{ x^k }{ k ! }\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\frac{ e^x + e^{ - x } }{ 2 } = \sum_{ k
\geq 0 } [ 2 | k ] \frac{ x^k }{ k ! }\)</span>.</li>
</ol>
<p>显然.</p>
<ol start="4" type="1">
<li><span class="math inline">\(( 1 + x )^n = \sum_{ k \geq 0 } n^{
\underline{ k } } \frac{ x^k }{ k ! }\)</span>.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\ln ( 1 + x ) = \sum_{ k \geq 1 } ( -
1 )^{ k - 1 } ( k - 1 ) ! \frac{ x^k }{ k ! }\)</span>.</p></li>
<li><p><span class="math inline">\(\ln ( 1 - x ) = \sum_{ k \geq 1 } ( k
- 1 ) ! \frac{ x^k }{ k ! }\)</span>.</p></li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4>
<p>我们设<span class="math inline">\(F_k ( n )\)</span>为<span class="math inline">\(n\)</span>个有标号元素划分成<span class="math inline">\(k\)</span>个非空无序集合的情况,<span class="math inline">\(f_i\)</span>为<span class="math inline">\(i\)</span>个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和<span class="math inline">\(| S |\)</span>有关的定义在集合上的函数),有:</p>
<p><span class="math display">\[
F_k ( n ) = \frac{ n ! }{ k ! } \sum_{ \sum_{ i = 1 }^k a_i = n }
\prod_{ j = 1 }^k \frac{ f_{ a_j } }{ a_j ! }
\]</span></p>
<p>设<span class="math inline">\(\hat{ F } ( x ) = \sum_{ n \geq 0 } f_n
\frac{ x^n }{ n ! }\)</span>,再设:</p>
<p><span class="math display">\[
\begin{aligned}
\hat G_k ( x ) &amp; = \sum_{ n \geq 0 } F_k ( n ) \frac{ x^n }{ n ! }
\\
&amp; = \sum_{ n \geq 0 } x^n \frac{ 1 }{ k ! } \sum_{ \sum_{ i = 1 }^k
a_i = n } \prod_{ j = 1 }^k \frac{ f_{ a_j } }{ a_j ! } \\
&amp; = \sum_{ n \geq 0 } \frac{ 1 }{ k ! } \sum_{ \sum_{ i = 1 }^k a_i
= n } \prod_{ j = 1 }^k \frac{ f_{ a_j } x^{ a_j } }{ a_j ! } \\
&amp; = \frac{ 1 }{ k ! } \hat F^k ( x )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\sum_{ k \geq 0 } \hat G_k ( x ) = \exp \hat F ( x )
\]</span></p>
<p>或者直接递推:</p>
$$
<span class="math display">\[\begin{aligned}
F_k ( x ) &amp; = \sum_{ i = 1 }^{ n - k + 1 } \binom{ n }{ i } F_{ k -
1 } ( n - i ) f_i \frac{ 1 }{ k } \\

\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{aligned}
\hat G_k ( x ) &amp; = \sum_{ n \geq 0 } \frac{ x^n }{ n ! } F_k ( n )
\\
&amp; = \sum_{ n \geq 0 } \frac{ x^n }{ n ! } \sum_{ i = 1 }^{ n - k + 1
} \binom{ n }{ i } F_{ k - 1 } ( n - i ) f_i \frac{ 1 }{ k } \\
&amp; = \frac{ 1 }{ k } \sum_{ n \geq 0 } \frac{ x^n }{ n ! } \sum_{ i =
1 }^{ n - k + 1 } \binom{ n }{ i } F_{ k - 1 } ( n - i ) f_i \\
&amp; = \frac{ 1 }{ k } \hat G_{ k - 1 } ( x ) \hat F ( x ) \\
&amp; = \frac{ 1 }{ k ! } \hat F^k ( x )
\end{aligned}
\]</span></p>
<p>简而言之,<span class="math inline">\([ x^n ] \hat F ( x
)\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素放到同一个无序集合的方案数,而<span class="math inline">\([ x^n ] \exp \hat F ( x )\)</span>是将<span class="math inline">\(n\)</span>个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1poj3734">Example1(POJ3734)</span></h5>
<p>对于红黄色砖块,其选取方案为<span class="math inline">\(\{ 1 , 0 , 1 ,
0 , \cdots \}\)</span>,对应的EGF是<span class="math inline">\(\frac{ e^x
+ e^{ - x } }{ 2 }\)</span>.</p>
<p>对于蓝绿色砖块,选取方案是<span class="math inline">\(e^x\)</span>.</p>
<p>乘起来有:</p>
<p><span class="math display">\[
\begin{aligned}
\hat F ( x ) &amp; = ( \frac{ e^x + e^{ - x } }{ 2 } )^2 e^{ 2 x } \\
&amp; = \frac{ ( e^{ 2 x } + 2 + e^{ - 2 x } ) e^{ 2 x } }{ 4 } \\
&amp; = \frac{ e^{ 4 x } + 2 e^{ 2 x } + 1 }{ 4 } \\
&amp; = \frac{ 1 }{ 4 } + \sum_{ k \geq 0 } \frac{ 4^i + 2^{ i + 1 } }{
4 } \frac{ x^i }{ i ! }
\end{aligned}
\]</span></p>
<p>于是有<span class="math inline">\([ x^n ] \hat F ( x ) = 4^{ n - 1 }
+ 2^{ n - 1 }\)</span>.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5>
<p>长度为<span class="math inline">\(n\)</span>的排列数的指数生成函数是<span class="math inline">\(\hat P ( x ) = \sum_{ n \geq 0 } \frac{ n ! x^n }{
n ! } = \frac{ 1 }{ 1 - x }\)</span>.</p>
<p>长度为<span class="math inline">\(n\)</span>的圆排列的指数生成函数是<span class="math inline">\(\hat Q ( x ) = \sum_{ n \geq 0 } \frac{ ( n - 1 )
! x^n }{ n ! } = \frac{ x^n }{ n } = - \ln ( 1 - x ) = \ln \frac{ 1 }{ 1
- x }\)</span>.</p>
<p>于是有<span class="math inline">\(\exp \hat Q ( x ) = \hat P ( x
)\)</span>.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5>
<p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为<span class="math inline">\(1\)</span>的置换环,其EGF显然是<span class="math inline">\(\sum_{ n \geq 2 } \frac{ x^n }{ n } = - \ln ( 1 -
x ) - x\)</span>,错排数的EGF对其取<span class="math inline">\(\exp\)</span>即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5>
<p>考虑如果<span class="math inline">\(n\)</span>个点带编号的无向连通图的EGF是<span class="math inline">\(\hat F ( x )\)</span>,那么<span class="math inline">\(n\)</span>个点带标号无向图的EGF就是<span class="math inline">\(\exp \hat F ( x
)\)</span>,后者直接计数,前者对后者做一次<span class="math inline">\(\ln\)</span>就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5>
<p>求有多少个映射<span class="math inline">\(f : \{ 1 , 2 , \cdots , n
\} \mapsto \{ 1 , 2 , \cdots , n \}\)</span>满足<span class="math inline">\(f \circ f \circ \cdots \circ f\)</span>(共<span class="math inline">\(k\)</span>个<span class="math inline">\(f\)</span>)<span class="math inline">\(= f \circ f
\circ \cdots \circ f\)</span>(共<span class="math inline">\(k -
1\)</span>个<span class="math inline">\(f\)</span>).</p>
<p>考虑将<span class="math inline">\(i \rightarrow
f_i\)</span>,这等价于对深度不超过<span class="math inline">\(k\)</span>的基环树(环的长度为<span class="math inline">\(1\)</span>)计数,等价于对深度不超过<span class="math inline">\(k\)</span>的有根树计数.注意到删去根节点后等价于对深度不超过<span class="math inline">\(k - 1\)</span>的有根树计数,因此<span class="math inline">\(\hat F_k ( x ) = x \exp \hat F_{ k - 1 } ( x
)\)</span>.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5>
<p>假设<span class="math inline">\(k\)</span>次操作后<span class="math inline">\(a_i\)</span>减少了<span class="math inline">\(b_i\)</span>,实际上要求的就是<span class="math inline">\(\prod_{ i = 1 }^n a_i - \prod_{ i = 1 }^n ( a_i -
b_i )\)</span>.</p>
<p>考虑对所有情况下的<span class="math inline">\(\prod_{ i = 1 }^n ( a_i
- b_i )\)</span>求和,注意到<span class="math inline">\(k\)</span>次操作,使得<span class="math inline">\(i\)</span>出现<span class="math inline">\(b_i\)</span>次的方案数是<span class="math inline">\(\frac{ k ! }{ \prod_{ i = 1 }^n b_i !
}\)</span>.直接设<span class="math inline">\(a_j\)</span>的EGF是</p>
<p><span class="math display">\[
\begin{aligned}
\hat F_{ j } ( x ) &amp; = \sum_{ i \geq 0 } ( a_j - i ) \frac{ x^i }{ i
! } \\
&amp; = \sum_{ i \geq 0 } a_j \frac{ x^i }{ i ! } - \sum_{ i \geq 1 }
\frac{ x^i }{ ( i - 1 ) ! } \\
&amp; = a_j e^x - xe^x = ( a_j - x ) e^x
\end{aligned}
\]</span></p>
<p>答案就是<span class="math inline">\([ x^k ] \prod_{ j = 1 }^n \hat
F_j ( x )\)</span>.</p>
<h5><span id="example7">Example7</span></h5>
<h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3>
<p>对于序列<span class="math inline">\(f_n\)</span>,定义其DGF为<span class="math inline">\(\tilde{ F } ( x ) = \sum_{ i \geq 1 } \frac{ f_i
}{ i^x }\)</span>.注意到若<span class="math inline">\(f\)</span>是积性函数,那么<span class="math inline">\(\tilde{ F } ( x ) = \prod_{ p \in \mathrm{ prime }
} \sum_{ i \geq 0 } \frac{ f_{ p^i } }{ p^{ ix } } \\\)</span>.</p>
<h4><span id="基本运算">基本运算</span></h4>
<p>对于两个序列<span class="math inline">\(f ,
g\)</span>,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ F } ( x ) \tilde{ G } ( x ) &amp; = \sum_{ i } \sum_{ j } \frac{
f ( i ) g ( j ) }{ ( ij )^x } \\
&amp; = \sum_{ i } \frac{ 1 }{ i^x } \sum_{ d | i } f ( d ) g ( \frac{ i
}{ d } )
\end{aligned}
\]</span></p>
<h4><span id="封闭式">封闭式</span></h4>
<ol type="1">
<li><span class="math inline">\(\epsilon ( x ) = [ x = 1
]\)</span>.</li>
</ol>
<p>显然为<span class="math inline">\(\tilde{ E } ( x ) = 1\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(I ( x ) = 1\)</span>.</li>
</ol>
<p>其封闭式是黎曼函数<span class="math inline">\(\zeta ( x
)\)</span>,事实上,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\zeta ( x ) &amp; = \prod_{ i \geq 1 } \frac{ 1 }{ i^x } \\
&amp; = \prod_{ p \in \mathrm{ prime } } \sum_{ i \geq 0 } \frac{ 1 }{
p^{ ix } } \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 }{ 1 - p^{ - x } }
\end{aligned}
\]</span></p>
<ol start="3" type="1">
<li><span class="math inline">\(\mu ( n )\)</span>.</li>
</ol>
<p>其DGF为<span class="math inline">\(\tilde{ M } ( x ) = \prod_{ p \in
\mathrm{ prime } } ( 1 - p^{ - x } )\)</span>.注意到<span class="math inline">\(\zeta ( x ) \tilde{ M } ( x ) = 1 , \tilde{ M } (
x ) = \frac{ 1 }{ \zeta ( x ) }\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(id ( n ) = n\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\tilde{ ID } ( n ) = \prod_{ i \geq 1 }
\frac{ i }{ i^x } = \prod_{ i \geq 1 } \frac{ 1 }{ i^{ x - 1 } } = \zeta
( x - 1 )\)</span>.</p>
<ol start="5" type="1">
<li><span class="math inline">\(I_k ( n ) = n^k\)</span>.</li>
</ol>
<p><span class="math display">\[
\tilde{ I_k } ( x ) = \prod_{ i \geq 1 } \frac{ 1 }{ i^{ x - k } } =
\zeta ( x - k )
\]</span></p>
<ol start="6" type="1">
<li><span class="math inline">\(\varphi ( n )\)</span>.</li>
</ol>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ \Phi } ( x ) &amp; = \prod_{ p \in \mathrm{ prime } } ( 1 +
\frac{ p - 1 }{ p^x } + \frac{ p ( p - 1 ) }{ p^{ 2 x } } + \cdots ) \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 - p^{ - x } }{ 1 - p^{
1 - x } } \\
&amp; = \tilde{ \Phi } ( x ) = \frac{ \zeta ( x - 1 ) }{ \zeta ( x ) }
\end{aligned}
\]</span></p>
<p>也注意到<span class="math inline">\(\tilde{ \Phi } ( x ) I ( x ) =
\zeta ( x - 1 ) = \tilde{ ID } ( x )\)</span>.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sigma_k ( n ) = \sum_{ d | n }
d^k\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(\sigma_k ( n ) = I_k ( n ) * I_0 (
n )\)</span>,也就是说<span class="math inline">\(\tilde{ S } ( x ) =
\zeta ( x - k ) \zeta ( x )\)</span>.</p>
<ol start="8" type="1">
<li><span class="math inline">\(u ( n ) = | \mu ( n ) |\)</span>.</li>
</ol>
<p><span class="math inline">\(\tilde{ u } ( n ) = \frac{ \zeta ( n ) }{
\zeta ( 2 n ) }\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5>
<p>考虑对于<span class="math inline">\(f ( n ) = n^2 \varphi ( n
)\)</span>构造积性函数<span class="math inline">\(g ( n ) , h ( n
)\)</span>使得<span class="math inline">\(f * g = h\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{ F } ( x ) &amp; = \prod_{ p \in \mathrm{ prime } } ( 1 + \sum_{
k \geq 1 } \frac{ p^{ 3 k - 1 } ( p - 1 ) }{ p^{ kx } } ) \\
&amp; = \prod_{ p \in \mathrm{ prime } } \frac{ 1 - p^{ 2 - x } }{ 1 -
p^{ 3 - x } } = \frac{ \zeta ( x - 3 ) }{ \zeta ( x - 2 ) }
\end{aligned}
\]</span></p>
<p>也就是<span class="math inline">\(f * I_2 = I_3\)</span>.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3>
<p>对于复数的阶乘,我们通常定义:</p>
<p><span class="math display">\[
\cfrac{ 1 }{ z ! } = \lim_{ n \rightarrow + \infin } \binom{ n + z }{ z
} n^{ - z }
\]</span></p>
<p>同时我们定义<span class="math inline">\(\Gamma ( z + 1 ) = z
!\)</span>,有:<span class="math inline">\(( - z ) ! \Gamma ( z ) =
\cfrac{ \pi }{ \sin ( \pi z ) }\)</span>.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<p><span class="math display">\[
\begin{aligned}
z^{ \underline{ w } } &amp; = \cfrac{ z ! }{ ( z - w ) ! } \\
z^{ \overline{ w } } &amp; = \cfrac{ \Gamma ( z + w ) }{ \Gamma ( z ) }
\end{aligned}
\]</span></p>
<p>通过以上我们还可以有二项式系数的定义:</p>
<p><span class="math display">\[
\binom{ z }{ w } = \lim_{ \zeta \rightarrow z , \omega \rightarrow w }
\cfrac{ \zeta ! }{ \omega ! ( \zeta - \omega ) ! }
\]</span></p>
<h3><span id="超几何级数">超几何级数</span></h3>
<h4><span id="超几何函数">超几何函数</span></h4>
<p>我们定义超几何函数<span class="math inline">\(F ( a_1 , . . . , a_m ;
b_1 , . . . b_n ; z ) = F \left ( \begin{array}{ r | } a_1 , . . . , a_m
\\ b_1 , . . . , b_n\end{array} z \right ) = \sum_{ k \geq 0 } \cfrac{
z^k \prod_{ i = 1 }^m a_i^{ \overline{ k } } }{ k ! \prod_{ i = 1 }^n
b_i^{ \overline{ k } } }\)</span>.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似<span class="math inline">\(\cfrac{
0 }{ 0 } = 1\)</span>之类的式子,可以发现当<span class="math inline">\(z
= 0\)</span>时任意超几何函数总是<span class="math inline">\(=
1\)</span>.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为<span class="math inline">\(0\)</span>或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4>
<h5><span id="合流超几何函数">合流超几何函数</span></h5>
<p>我们通常把形如<span class="math inline">\(M ( a ; b ; z ) = F \left (
\begin{array}{ r | } a \\ b\end{array} z \right ) = \sum_{ k \geq 0 }
\cfrac{ z^k a^{ \overline{ k } } }{ b^{ \overline{ k } } k !
}\)</span>的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r | } 1 \\
1
\end{array} z \right ) = e^z
\]</span></p>
<p>也即常见生成函数中的<span class="math inline">\(( 6 )\)</span>.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5>
<p>我们把形如<span class="math inline">\(F \left ( \begin{array}{ r | }
a , b \\ c\end{array} z \right ) = \sum_{ k \geq 0 } \cfrac{ z^k a^{
\overline{ k } } b^{ \overline{ k } } }{ c^{ \overline{ k } } k !
}\)</span>的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } 1 , 1 \\
1\end{array} z \right ) = \cfrac{ 1 }{ 1 - z }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 1 )\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } - a , 1
\\ 1\end{array} - z \right ) = ( 1 + z )^a\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 2 )\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } a , 1 \\
1\end{array} z \right ) = \cfrac{ 1 }{ ( 1 - z )^a }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 4 )\)</span>.</p>
<ol start="4" type="1">
<li><span class="math inline">\(F \left ( \begin{array}{ r | } 1 , 1 \\
2\end{array} - z \right ) = \cfrac{ \ln ( 1 + z ) }{ z }\)</span>.</li>
</ol>
<p>即常见生成函数<span class="math inline">\(( 7 )\)</span>.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4>
<p>我们先考虑改写超几何级数的形式:</p>
<p><span class="math inline">\(F \left ( \begin{array}{ r | } a_1 , . .
. , a_m \\ b_1 , . . . , b_n\end{array} z \right ) = \sum_{ k \geq 0 }
t_k , t_k = \cfrac{ z^k \prod_{ i = 1 }^m a_i^{ \overline{ k } } }{ k !
\prod_{ i = 1 }^n b_i^{ \overline{ k } } }\)</span>.</p>
<p>不难发现<span class="math inline">\(t_0 = 1\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ t_{ k + 1 } }{ t_k } &amp; = \cfrac{ z^{ k + 1 } }{ z^k }
\cfrac{ k ! }{ ( k + 1 ) ! } \cfrac{ \prod_{ i = 1 }^m a_i^{ \overline{
k + 1 } } }{ \prod_{ i = 1 }^m a_i^{ \overline{ k } } } \cfrac{ \prod_{
i = 1 }^n b_i^{ \overline{ k } } }{ \prod_{ i = 1 }^n b_i^{ \overline{ k
+ 1 } } } \\
&amp; = \cfrac{ \prod_{ i = 1 }^m ( k + a_i ) }{ \prod_{ i = 1 }^n ( k +
b_i ) } \cfrac{ z }{ k + 1 }
\end{aligned}
\]</span></p>
<p>换句话说,<span class="math inline">\(\cfrac{ t_{ k + 1 } }{ t_k
}\)</span>是关于<span class="math inline">\(k\)</span>的一个有理函数.而根据代数基本定理,任意<span class="math inline">\(k\)</span>的有理函数在<span class="math inline">\(\mathbb{ C
}\)</span>内都可以分解为以上的形式(如果缺少<span class="math inline">\(k
+ 1\)</span>项则需要上下同时乘以<span class="math inline">\(k +
1\)</span>以补上).</p>
<p>换句话说,对于一个无穷级数<span class="math inline">\(\sum_{ k \geq 0
} t_k\)</span>,我们先将<span class="math inline">\(\cfrac{ t_{ k + 1 }
}{ t_k }\)</span>表示回超几何函数,设为<span class="math inline">\(F\)</span>.</p>
<p>那么有:<span class="math inline">\(\sum_{ k \geq 0 } t_k = t_0
F\)</span>.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和<span class="math inline">\(\Gamma\)</span>函数的定义)来使这些公式全部成立.But
who
cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(\sum_{ k \leq n } \binom{ r + k }{ k
} = \binom{ r + n + 1 }{ n } \Leftrightarrow F \left ( \begin{array}{ r
| } 1 , - n \\ - n - r\end{array} 1 \right ) = \cfrac{ r + n + 1 }{ r +
1 } , n \in \mathbb{ N } \\\)</span>.</p>
<p>首先考虑:</p>
<p><span class="math display">\[
\sum_{ k \leq n } \binom{ r + k }{ k } = \sum_{ k \geq 0 } \binom{ r + n
- k }{ n - k }
\]</span></p>
<p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<p><span class="math display">\[
\binom{ r + n }{ n } F \left ( \begin{array}
{ r | } 1 , - n \\
- n - r
\end{array} 1 \right ) = \binom{ r + n + 1 }{ n }
\]</span></p>
<p>两边同时除以<span class="math inline">\(\binom{ r + n }{ n
}\)</span>得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5>
<p>通过范德蒙德卷积,不难验证:</p>
<p><span class="math display">\[
F \left ( \begin{array}
{ r | } a , b \\
c
\end{array} 1 \right ) = \cfrac{ \Gamma ( c - a - b ) \Gamma ( c ) }{
\Gamma ( c - a ) \Gamma ( c - b ) } , - b \in \mathbb{ N }
\]</span></p>
<p>这个公式的一个特例是:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r | } a , - n \\
c
\end{array} 1 \right ) &amp; = \cfrac{ ( c - a )^{ \overline{ n } } }{
c^{ \overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } }{ ( - c
)^{ \underline{ n } } } , n \in \mathbb{ N } \\
\sum_{ k \geq 0 } \cfrac{ a^{ \overline{ k } } ( - n )^{ \overline{ k }
} }{ c^{ \overline{ k } } k ! } &amp; = \cfrac{ ( c - a )^{ \overline{ n
} } }{ c^{ \overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } }{
( - c )^{ \underline{ n } } } , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
$$
<span class="math display">\[\begin{aligned}
F \left ( \begin{array}
{ r | } a , b , - n \\
c , a + b - n - c + 1
\end{array} 1 \right ) &amp; = \cfrac{ ( c - a )^{ \overline{ n } } ( c
- b )^{ \overline{ n } } }{ c^{ \overline{ n } } ( c - a - b )^{
\overline{ n } } } = \cfrac{ ( a - c )^{ \underline{ n } } ( b - c )^{
\underline{ n } } }{ ( - c )^{ \underline{ n } } ( a + b - c )^{
\overline{ n } } } , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3>
<h4><span id="example1luogu4931">Example1(luogu4931)</span></h4>
<p>二项式反演:</p>
<p><span class="math display">\[
\begin{aligned}
ans_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k }
\binom{ n }{ i } \binom{ n }{ i } i ! ( 2 n - 2 i ) ! 2^i \\
&amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \frac{ 1 }{ k ! ( i - k ) ! }
\frac{ n ! }{ ( n - i ) ! } \frac{ n ! }{ ( n - i ) ! } ( 2 n - 2 i ) !
2^i \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = k }^n ( - 1 )^{ i - k }
\frac{ 1 }{ ( i - k ) ! } \binom{ 2 n - 2 i }{ n - i } 2^{ i - k } \\
&amp; = ( n ! )^2 \frac{ 2^k }{ k ! } \sum_{ i = 0 }^{ n } \frac{ ( - 2
)^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到后者只与<span class="math inline">\(n -
k\)</span>有关,不妨设其为<span class="math inline">\(f_{ n } = \sum_{ i
= 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! } \binom{ 2 n - 2 i }{ n - i
}\)</span>,预处理一下就可以做到<span class="math inline">\(O ( n^2 + nT
)\)</span>.</p>
<p>加强版咋做?我们继续看看式子:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = ( n ! )^2 \frac{ 2^k }{ k ! } f_{ n - k } \\
f_{ n } &amp; = \sum_{ i = 0 }^{ n } \frac{ ( - 2 )^{ i } }{ i ! }
\binom{ 2 n - 2 i }{ n - i }
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(f\)</span>是一个卷积的形式,设其生成函数为<span class="math inline">\(F_n\)</span>,<span class="math inline">\(g_n =
\frac{ ( - 2 )^n }{ n ! } , h_n = \binom{ 2 n }{ n
}\)</span>,我们自然有<span class="math inline">\(F = GH\)</span>.</p>
<p>考虑<span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>的生成函数形式,先看<span class="math inline">\(G\)</span>,显然用泰勒展开:</p>
<p><span class="math display">\[
G = \sum_{ n \geq 0 } \frac{ ( - 2 x )^n }{ n ! } = e^{ - 2 x }
\]</span></p>
<p>再看<span class="math inline">\(H\)</span>,是卡特兰数的生成函数,有:</p>
<p><span class="math display">\[
H = \frac{ 1 }{ \sqrt{ 1 - 4 x } }
\]</span></p>
<p>这下简单了,答案是:</p>
<p><span class="math display">\[
( n ! )^2 \frac{ 2^k }{ k ! } [ x^{ n - k } ] \frac{ e^{ - 2 x } }{
\sqrt{ 1 - 4 x } }
\]</span></p>
<p>现在看<span class="math inline">\(F\)</span>,平方一下有:</p>
<p><span class="math display">\[
( 1 - 4 x ) F^2 = e^{ - 4 x }
\]</span></p>
<p>两边求导:</p>
$$
<span class="math display">\[\begin{aligned}
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 e^{ - 4 x } \\
- 4 F^2 + ( 1 - 4 x ) 2 F \times F &#39; &amp; = - 4 ( 1 - 4 x ) F^2 \\
( 2 - 8 x ) F &#39; &amp; = 16 xF \\

\end{aligned}\]</span>
<p>$$</p>
<p>得到了一个线性递推形式,更进一步地:</p>
<p><span class="math display">\[
\begin{aligned}
2 ( i + 1 ) f_{ i + 1 } - 8 if_i &amp; = 16 f_{ i - 1 } \\
if_i &amp; = 4 ( i - 1 ) f_{ i - 1 } + 8 f_{ i - 2 }
\end{aligned}
\]</span></p>
<p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3>
<h4><span id="求解递归关系">求解递归关系</span></h4>
<p>我们假设已经有了<span class="math inline">\(R ( z ) = \sum_{ k \geq 0
} g_k z^k\)</span>,并且<span class="math inline">\(R ( z ) = \cfrac{ P (
z ) }{ Q ( z ) }\)</span>,其中<span class="math inline">\(P ( z
)\)</span>和<span class="math inline">\(Q ( z
)\)</span>都是多项式,我们想要找到一种方式求解<span class="math inline">\([ z^n ] R ( z )\)</span>.</p>
<p>考虑有理函数<span class="math inline">\(S ( z ) = \sum_{ k = 1 }^m
\cfrac{ a_k }{ 1 - \rho_k z } \\\)</span>,不难发现<span class="math inline">\([ z^n ] S ( z ) = \sum_{ k = 1 }^m a_k \rho_k^n
\\\)</span>.</p>
<p>那么可以证明,只要<span class="math inline">\(Q ( z ) =
0\)</span>无重根并且无零根,那么就存在一组系数满足<span class="math inline">\(S ( z ) = R ( z )\)</span>.</p>
<p>我们这么定义”反射”运算,若<span class="math inline">\(Q ( z ) = \sum_{
k = 0 }^m q_k z^k \\\)</span>,则其反射多项式为<span class="math inline">\(Q^R ( z ) = \sum_{ k = 0 }^m q_k z^{ m - k }
\\\)</span>.</p>
<p>若<span class="math inline">\(Q ( z ) = q_0 \prod_{ k = 1 }^m ( 1 -
\rho_k z )\)</span>,则显然有<span class="math inline">\(Q^R ( z ) = q_0
\prod_{ k = 1 }^m ( z - \rho_k ) \\\)</span>.</p>
<p>那么显然这里求出来的这组数<span class="math inline">\(\rho\)</span>就是<span class="math inline">\(S ( z
)\)</span>中的那组<span class="math inline">\(\rho\)</span>.</p>
<p>而我们有<span class="math inline">\(a_k = \cfrac{ - \rho_k P (
\cfrac{ 1 }{ \rho_k } ) }{ Q &#39; ( \rho_k ) }\)</span>.</p>
<h4><span id="example1">Example1</span></h4>
<p>已知<span class="math inline">\(n ! = \sum_{ k } \binom{ n }{ k } g_{
n - k } , n \in \mathbb{ N } \\\)</span>,求<span class="math inline">\(g_n\)</span>.</p>
<p>首先两边同时除以<span class="math inline">\(n
!\)</span>并将组合数用阶乘形式展开,我们有:</p>
<p><span class="math display">\[
1 = \sum_{ k } \cfrac{ g_{ n - k } }{ k ! ( n - k ) ! } .
\]</span></p>
<p>如果我们令<span class="math inline">\(D ( z ) = \sum_{ k \geq 0 }
\cfrac{ g_{ k } }{ k ! } z^k\)</span>,则有:</p>
<p><span class="math display">\[
\begin{aligned}
\cfrac{ 1 }{ 1 - z } &amp; = e^z D ( z ) \\
D ( z ) &amp; = \cfrac{ 1 }{ 1 - z } e^{ - z } \\
D ( z ) &amp; = ( \sum_{ k \geq 0 } z^k ) ( \sum_{ k \geq 0 } ( - 1 )^k
\cfrac{ z^k }{ k ! } ) \\
[ z^n ] D ( z ) &amp; = \sum_{ k = 0 }^n \cfrac{ ( - 1 )^k }{ k ! }
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(g_n = n ! \sum_{ k = 0 }^n \cfrac{ (
- 1 )^k }{ k ! } \\\)</span>.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4>
<p>首先设<span class="math inline">\(F_i ( x )\)</span>为第<span class="math inline">\(i\)</span>家的生成函数,这个是显然可以快速预处理出来的.令<span class="math inline">\(M = 520\)</span>.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有<span class="math inline">\(n\)</span>个多项式,最高次数是<span class="math inline">\(M\)</span>,因此一共要插入<span class="math inline">\(nM\)</span>个值,又要处理每个后缀,复杂度来到<span class="math inline">\(O ( n^2 M^3
)\)</span>.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到<span class="math inline">\(O ( n^2 M^2 )\)</span>.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到<span class="math inline">\(O ( n^2 Mq )\)</span>.但<span class="math inline">\(n\)</span>如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下<span class="math inline">\(2^n\)</span>的答案,复杂度来到<span class="math inline">\(O ( nM 2^n q
)\)</span>.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到<span class="math inline">\(O ( \frac{ n }{ B } B 2^B MnM
)\)</span>,单次询问复杂度来到<span class="math inline">\(O ( \frac{ n }{
B } Mnq
)\)</span>.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以<span class="math inline">\(k\)</span>要大于<span class="math inline">\(m\)</span>,就直接输出<span class="math inline">\(0\)</span>.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要<span class="math inline">\(O ( ( nM )^2 q
)\)</span>的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到<span class="math inline">\(O ( nMq )\)</span>.</p>
<h4><span id="example3十二省联考-2019皮配">Example3([十二省联考 2019]
皮配)</span></h4>
<p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为<span class="math inline">\(xy , y , x ,
1\)</span>,这样最后判断幂在一个区间内的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是<span class="math inline">\(\prod ( x^{ s_i } y^{ s_i } + x^{ s_i } ) + \prod
( y^{ s_i } + 1 ) = ( \prod ( x^{ s_i } + 1 ) ) ( \prod ( y^{ s_i } + 1
) )\)</span>.也就是<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于<span class="math inline">\(O ( mk^2 s )\)</span>.最后两部分合并一下.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" class="post-title-link" itemprop="url">图论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="约定">约定</span></h3>
<p><span class="math inline">\(K_n\)</span>为<span class="math inline">\(n\)</span>个点的完全图</p>
<h3><span id="树的性质">树的性质</span></h3>
<h5><span id="example1hdu6035colorfultree">Example1([HDU6035]Colorful
Tree)</span></h5>
<p>考虑每种颜色的贡献,一种颜色的贡献显然是删去所有这个颜色的边后,剩下的联通块之间的路径.</p>
<h5><span id="example22022qbxt国庆day1tree">Example2([2022qbxt国庆Day1]tree)</span></h5>
<p>首先考虑分开处理每个点,在做每个点的时候假设它的所有子节点全部已经满足条件了,最终我们再通过计算组合数的方式计算即可.</p>
<p>那么最后,我们需要对于每个点进行处理,假设我们已知这个子树的集合是<span class="math inline">\(S\)</span>,那么我们需要用容斥计算如果当前子树集合是<span class="math inline">\(S\)</span>的子集的情况,不难发现容斥式子:</p>
<p><span class="math display">\[
ans = \sum_{ k = \max \{ f_v | x \rightarrow v \} }^{ f_x } ( - 1 )^{
f_x - k } k \binom{ f_x }{ k } \sum_{ x \rightarrow v } \binom{ k }{ f_v
}
\]</span></p>
<p>其实也就是个二项式反演的形式.</p>
<p>这题还需要一些技巧优化,我们首先发现由于<span class="math inline">\(f_v\)</span>有可能有重复的,我们可以提前把重复的<span class="math inline">\(f_v\)</span>压缩到一起再用快速幂求,于是后面的部分最多不过<span class="math inline">\(\sqrt{ n
}\)</span>级别.而前面是一个类似于树上启发式合并的东西,于是复杂度<span class="math inline">\(O ( n \sqrt{ n } \log n )\)</span>.</p>
<h5><span id="example3cf1628egroceries-in-meteor-town">Example3(CF1628E
Groceries in Meteor Town)</span></h5>
<p>因为要求路径最大值,所以先建Kruskal重构树.然后问题转化为求一个点和一群白点的LCA是谁.</p>
<p>树上多点LCA有个经典性质:也就相当于其中<span class="math inline">\(dfn\)</span>序最大的和最小的两个点的LCA.</p>
<p>至于区间覆盖可以用线段树.</p>
<h5><span id="example4loj3692">Example4(loj3692)</span></h5>
<p>注意到<span class="math inline">\(D\)</span>很小.</p>
<p>我们考虑处理邻域乘,设<span class="math inline">\(f_{ x , i
}\)</span>表示<span class="math inline">\(x\)</span>的<span class="math inline">\(i\)</span>级儿子需要乘上的答案.每次修改时,先将<span class="math inline">\(f_{ x , D }\)</span>和<span class="math inline">\(f_{ x , D - 1 }\)</span>乘上<span class="math inline">\(W\)</span>,然后令<span class="math inline">\(x =
fa_x\)</span>,<span class="math inline">\(D = D -
2\)</span>,继续此操作直到<span class="math inline">\(D\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>然后询问的时候直接暴力跳<span class="math inline">\(D\)</span>层父亲找答案,不难发现这样做是对的.</p>
<p>同样的思路可以脱离点分治处理很多邻域问题.</p>
<h4><span id="树的直径">树的直径</span></h4>
<ol type="1">
<li><p>定义:树中最长的一条简单路径.</p></li>
<li><p>树的直径可能有多个.</p></li>
<li><p>直径的两个端点一定是两个叶子节点.</p></li>
<li><p>如果树有多条直径,树的不同的直径的中点/中边一定是相同的.</p></li>
<li><p>到一个点距离最远的点一定是直径的一个端点.</p></li>
<li><p>对于两棵树,如果第一棵树直径两端点为<span class="math inline">\((
u , v )\)</span>,第二棵树直径两端点为<span class="math inline">\(( x , y
)\)</span>,用一条边将两棵树连接,那么新树的直径一定是<span class="math inline">\(u , v , x , y\)</span>中的两个点.</p></li>
</ol>
<p>上述的证明大都是考虑反证法:如果不成立,则一定存在一条更长的直径.</p>
<h5><span id="example1sdoi2013直径">Example1([SDOI2013]直径)</span></h5>
<p>有一个做法是:考虑找到直径的中点/中边,找到它到两边的最远距离的点,显然两边的点分别的以中点/中边的两个端点为根的LCA中间的部分就是一定会被包含的边.</p>
<h4><span id="树的重心">树的重心</span></h4>
<ol type="1">
<li><p>定义:树的重心是删去后所有剩余子树大小最大值最小的点.</p></li>
<li><p>树的重心是删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>的点.</p></li>
<li><p>树的重心只有可能有一个或两个.</p></li>
<li><p>如果树有两个重心,那么这两个重心相邻.</p></li>
<li><p>树的重心是所有点到其距离之和最小的点.</p></li>
<li><p>把一个树添加或删除一个叶子,那么它的重心最多只移动一条边的距离.</p></li>
<li><p>把两个树通过一条边相连得到一个新的树,那么新的树的重心在连接原来两个树的重心的路径上.</p></li>
</ol>
<p>(2)的证明如下:</p>
<p>如果重心是<span class="math inline">\(u\)</span>,且删去<span class="math inline">\(u\)</span>后剩余最大子树大小大于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,设这棵子树中与<span class="math inline">\(u\)</span>相邻的点为<span class="math inline">\(v\)</span>,则我们删去<span class="math inline">\(v\)</span>后,最大子树大小一定会减少,不满足假设,所以(2)得证.</p>
<p>另外,如果一个点删去后所有剩余子树大小全部小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,那它也一定是重心.因为不存在除了重心以外的满足条件的点:考虑调整法,与重心相邻的点一定都不满足条件,因为它们的子树大小全都小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,移动后最大子树一定不小于<span class="math inline">\(n -
\lfloor \cfrac{ n }{ 2 } \rfloor\)</span>.</p>
<p>(3)(4)的证明如下:</p>
<p>首先证明:如果有两个点都是重心,那它们一定相邻.</p>
<p>考虑如果二者不相邻,那删去它们后剩下的最大子树大小一定相等,设这两个点分别为<span class="math inline">\(x , y\)</span>,那删去<span class="math inline">\(x\)</span>后,剩下的最大子树一定包含了<span class="math inline">\(y\)</span>,而这个子树的大小一定小于等于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>.那删去<span class="math inline">\(y\)</span>后,剩下的最大子树大小必定大于<span class="math inline">\(\lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,一定不合法.</p>
<p>而树上不可能有超过两个点两两相邻,于是最多只有两个重心,且它们一定相邻.</p>
<p>(5)的证明如下:</p>
<p>考虑如果<span class="math inline">\(u\)</span>是树的重心,我们看能不能将<span class="math inline">\(u\)</span>调整到另一个点使得所有点到其距离之和更小.</p>
<p>由于调整是一步一步做的,显然只需要判断所有和<span class="math inline">\(u\)</span>相邻的点是否符合条件即可.设这个点为<span class="math inline">\(x\)</span>,那我们把<span class="math inline">\(u\)</span>改为<span class="math inline">\(x\)</span>,会使答案减小<span class="math inline">\(siz_x\)</span>,增加<span class="math inline">\(n -
siz_x\)</span>,由于<span class="math inline">\(siz_x \leq \lfloor
\cfrac{ n }{ 2 } \rfloor\)</span>,所以这么做一定不优.</p>
<p>(6)的证明如下:</p>
<p>首先,如果加入一个叶子节点后,各个子树大小仍然都<span class="math inline">\(&lt; \lfloor \cfrac{ n }{ 2 }
\rfloor\)</span>,那显然不必调整.</p>
<p>不然,显然是往叶子节点移动一格或者加入一个相邻的重心.</p>
<p>(7)的证明如下:</p>
<p>不妨设两棵树大小分别为<span class="math inline">\(siz_a \leq
siz_b\)</span>,然后令相连的两个点是这两棵树的根.</p>
<p>对于<span class="math inline">\(b\)</span>中的重心,肯定是会往根跳,并且不可能跳出<span class="math inline">\(b\)</span>原本的树.</p>
<h5><span id="example1csp-s2019树的重心">Example1([CSP-S2019]树的重心)</span></h5>
<p>首先取重心<span class="math inline">\(rt\)</span>为根,如果有两个就随便取一个.</p>
<p>接下来我们考虑对于每个点<span class="math inline">\(x\)</span>,它在什么情况下会成为重心.首先,删掉的边不可能在<span class="math inline">\(x\)</span>的子树内,不然一定不可能取到<span class="math inline">\(x\)</span>的.然后,我们假设删掉的子树大小为<span class="math inline">\(S\)</span>,<span class="math inline">\(x\)</span>的子树内最大的一个子树大小为<span class="math inline">\(g_x\)</span>,那么根据重心的性质有:</p>
$$
<span class="math display">\[\begin{aligned}
2 ( n - S - siz_x ) &amp; \leq n - S \\
2 g_x &amp; \leq n - S \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理得到:</p>
<p><span class="math display">\[
2 g_x \leq n - S \leq 2 siz_x
\]</span></p>
<p>考虑这个怎么计算:如果没有删边必须在<span class="math inline">\(x\)</span>子树外的限制,那显然可以直接遍历一遍存下<span class="math inline">\(n -
S\)</span>,然后统一使用值域树状数组做.而我们接下来考虑删去<span class="math inline">\(x\)</span>子树内的贡献,类似colorful
tree的做法,每次dfs到一个点,记录下来当前树状数组的答案,然后dfs子树,回溯时拿新答案减去旧答案就是子树内的答案.</p>
<p>接下来我们需要考虑<span class="math inline">\(x =
rt\)</span>怎么做.</p>
<p>考虑<span class="math inline">\(x\)</span>的子树中最大的那个和次大的那个,如果我们删去的节点不在最大的子树中,那只需要保证最大的子树大小满足条件;不然,只需保证次大的子树大小满足条件,也是好维护的.</p>
<h4><span id="树的结构的维护">树的结构的维护</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>给定一棵树,树上点有点权<span class="math inline">\(val\)</span>.现在有一个值<span class="math inline">\(sum\)</span>,初始为<span class="math inline">\(0\)</span>.从<span class="math inline">\(1\)</span>号点出发,每第一次到一个点<span class="math inline">\(u\)</span>,就会使<span class="math inline">\(sum +
= val_u\)</span>.求在时刻保证<span class="math inline">\(sum \geq
0\)</span>的前提下,<span class="math inline">\(sum\)</span>最终的最大值.</p>
<p>首先注意到为了保证<span class="math inline">\(sum \geq
0\)</span>这个性质,一个节点应该有两个值:<span class="math inline">\(lim\)</span>表示能走到这个点所需要的最小的<span class="math inline">\(sum\)</span>,<span class="math inline">\(val\)</span>表示到了这个点后能获得的价值.显然如果<span class="math inline">\(val \leq 0\)</span>则无意义.</p>
<p>如果我们能一开始处理出根的所有儿子的<span class="math inline">\(lim\)</span>和<span class="math inline">\(val\)</span>,我们就可以使用先走<span class="math inline">\(lim\)</span>小的点,并不断累计<span class="math inline">\(sum\)</span>的方式做.</p>
<p>所以考虑不断向上合并信息.不难发现此时一个点要处理出多对<span class="math inline">\(( lim , val
)\)</span>.考虑用一个左偏树维护这个东西.</p>
<p>但是,我们还需要保证不能跳着选点.也就是说我们要保证选中一个点,这个点的父亲必须选,怎么办呢?</p>
<p>一个方式是,我们把排序方法从只看<span class="math inline">\(lim\)</span>变成先判是否存在祖先后代关系,再判断<span class="math inline">\(lim\)</span>.</p>
<p>另一个方式是,我们每次直接把当前子树根节点扔到堆顶.但是需要满足堆的性质.不难发现如果这个点<span class="math inline">\(val &lt; 0\)</span>,我们可以将它与下面的<span class="math inline">\(lim\)</span>最的节点合并直到这个点<span class="math inline">\(val \geq 0\)</span>.而如果这个点的<span class="math inline">\(lim\)</span>太大,我们同样可以合并.注意到这样我们采取了一种很聪明的方式维护了树的形态.</p>
<h4><span id="dfs树的性质">dfs树的性质</span></h4>
<h5><span id="example1cf1361ejames-andthe-chase">Example1([CF1361E]James and
the Chase)</span></h5>
<p>如何判断一个点是否是好的呢?首先,如果要求是任意路径,那一个点是好的当且仅当它是一个叶向有根树的根.</p>
<p>现在要求是简单路径,那也就是说如果走了重复点是可以忽略的,这也就是说这个叶向有根树可以有反走边,而显然不能有横插边.不难发现这是充要条件.</p>
<p>另一个问题是:如何快速判断一个点是否满足上述条件呢?首先我们求出以一个好的点为根的dfs树(随机选取一定数量的点,如果一个都不是好点直接输出<span class="math inline">\(- 1\)</span>),然后我们发现:一个点<span class="math inline">\(u\)</span>是好的必要条件是它的子树内只有一条反走边,证明显然.假设<span class="math inline">\(u\)</span>通过这条反走边走到了点<span class="math inline">\(v\)</span>,那么<span class="math inline">\(u\)</span>是好的点当且仅当<span class="math inline">\(v\)</span>也是好的点.</p>
<p>这是为啥呢?首先,因为我们是以一个好点为根跑的dfs树,所以<span class="math inline">\(u\)</span>走到子树内的点必定只有一种方式.那子树外的点呢?走到<span class="math inline">\(v\)</span>后,显然就要从它走到其它点,而它到<span class="math inline">\(u\)</span>的子树内显然只有一种方案,那如果<span class="math inline">\(v\)</span>到其它点也只有一种方案,那么根据<span class="math inline">\(u \rightarrow v\)</span>这条路径,<span class="math inline">\(u\)</span>显然也是好点.</p>
<h5><span id="example2loj-6276">Example2(Loj 6276)</span></h5>
<p>找到所有颜色相同的点对<span class="math inline">\(( x , y
)\)</span>,经过它们的路径都不合法,显然经过它们的路径可以用dfs序刻画成矩阵,最后要求矩阵面积并.</p>
<h3><span id="圆方树的性质">圆方树的性质</span></h3>
<ol type="1">
<li><p>对于任意的非空无向图<span class="math inline">\(G\)</span>,一定存在一个<span class="math inline">\(G\)</span>的点双连通分量<span class="math inline">\(B\)</span>,使得<span class="math inline">\(B\)</span>中只有不超过<span class="math inline">\(1\)</span>个节点是<span class="math inline">\(G\)</span>的割点.其中,若<span class="math inline">\(B\)</span>中没有<span class="math inline">\(G\)</span>的割点,则有<span class="math inline">\(B
= G\)</span>.</p></li>
<li><p>若一个点双连通分量不为<span class="math inline">\(K_2\)</span>,则该点双连通分量中至少有一个简单环.</p></li>
<li><p>在仙人掌上的每个点双连通分量要么是<span class="math inline">\(K_2\)</span>,要么是一个简单环.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意一个点<span class="math inline">\(u\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u\)</span>在<span class="math inline">\(C\)</span>上.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双连通分量中的任意两个点<span class="math inline">\(u , v\)</span>,一定存在一个简单环<span class="math inline">\(C\)</span>使得<span class="math inline">\(u ,
v\)</span>在<span class="math inline">\(C\)</span>上.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给一点<span class="math inline">\(x\)</span>和一边<span class="math inline">\(e\)</span>,一定存在经过<span class="math inline">\(x , e\)</span>的简单环.</p></li>
<li><p>对于一个不是<span class="math inline">\(K_2\)</span>的点双,任给两点<span class="math inline">\(s , t\)</span>和一边<span class="math inline">\(e\)</span>,一定存在一条<span class="math inline">\(s - e - t\)</span>的简单路径.</p></li>
</ol>
<p>(6)的证明非常变魔术,你考虑把<span class="math inline">\(e : u
\leftrightarrow v\)</span>这条边给改成<span class="math inline">\(u
\leftrightarrow w \leftrightarrow v\)</span>,然后<span class="math inline">\(w\)</span>和<span class="math inline">\(x\)</span>在一个简单环上,意味着<span class="math inline">\(u , w , v , x\)</span>在一个简单环上.</p>
<p>(7)考虑(6)就行,先找到<span class="math inline">\(s\)</span>和<span class="math inline">\(e\)</span>所在的简单环,然后从这个环上连到<span class="math inline">\(t\)</span>.</p>
<h3><span id="任意图的性质">任意图的性质</span></h3>
<ol type="1">
<li>若一张无向连通图<span class="math inline">\(G\)</span>中存在<span class="math inline">\(3\)</span>个不同的一度点<span class="math inline">\(x , y , z\)</span>,则一定存在一个点<span class="math inline">\(u \notin \{ x , y , z \}\)</span>使得存在<span class="math inline">\(3\)</span>条两两没有公共边的简单路径满足其中一个端点均为<span class="math inline">\(u\)</span> 且另一个端点分别为<span class="math inline">\(x , y ,
z\)</span>.(证明考虑求生成树后讨论LCA)</li>
</ol>
<h3><span id="dsu-on-tree">dsu on tree</span></h3>
<h5><span id="exampleqoj5020">Example(QOJ5020)</span></h5>
<p>我们考虑树链剖分,这样将问题转化为三部分:</p>
<ol type="1">
<li><p>对于某个点而言,到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题可以使用点分治解决.</p></li>
<li><p>对于某条重链的上半部分而言,它连接的所有轻子树中,到它距离<span class="math inline">\(\leq d\)</span>的点数量.这个问题直接dsu on
tree.</p></li>
<li><p>对于某个点而言,在它子树内到它距离<span class="math inline">\(\leq
d\)</span>的点数量.这个问题也可以直接dsu on tree.</p></li>
</ol>
<p>为什么转化为三个部分就能求解呢?我们考虑一条链<span class="math inline">\(u \rightarrow w \rightarrow v\)</span>,其中<span class="math inline">\(w\)</span>是这条链上深度最浅的点.那么首先我们统计在<span class="math inline">\(w\)</span>子树外的,这一个部分可以由(1)和(3)做差求出来.然后我们要求的就是在<span class="math inline">\(w\)</span>子树内,到这条链的距离<span class="math inline">\(\leq
d\)</span>的点的数量.这个怎么求呢?我们考虑差分,求一下<span class="math inline">\(1 \rightarrow u\)</span>和<span class="math inline">\(1 \rightarrow
w\)</span>的答案然后做差.这样我们对这条到根的路径重链剖分,只需要处理重链的上半部分以及两条重链的连接处.不难发现两条重链的连接处会被多算一次,拿(3)减一下就好.以及这条路径所叉出去的重儿子也需要用(3).</p>
<p>现在的问题在于怎么求(2)和(3),先考虑(2),我们对于每一条重链从顶端走到低端不断地加入轻儿子,然后维护BIT就行.(3)是类似的,只不过是需要从底端走到顶端.</p>
<p>注意如果把重儿子和轻儿子分开处理,那么可能会在一些奇怪的地方算重,解决方法是特判<span class="math inline">\(w\)</span>处的答案,然后拆成两条互相之间完全没有影响的链,当然这也有可能会发生跳重链的时候轻儿子算重的情况,同样需要判断一下.</p>
<h3><span id="最小生成树">最小生成树</span></h3>
<h5><span id="example1cf1550f-jumpingaround">Example1(CF1550F Jumping
Around)</span></h5>
<p>首先考虑离线.注意到每次肯定跳到一个自己能跳到的点,而这个点应该是所需灵活度最小的点.</p>
<p>考虑boruvka算法,建立最小生成树并判断.</p>
<h3><span id="kruskal重构树">Kruskal重构树</span></h3>
<p>最小生成树时,每一次加边的时候把那个边变成虚点,两个点连到这条边上.任意两个点的LCA就是它们路径上的最小边权.</p>
<h3><span id="最短路">最短路</span></h3>
<h5><span id="example1cf1753d-the-beach">Example1(CF1753D The Beach)</span></h5>
<p>首先,自然的想法是把格子图黑白染色.</p>
<p>然后,我们注意到一个床是不可能被移动两次及以上的.因为如果是横着动两次,那不动自然就有一对空位置了;如果是转两次,考虑转的目的一定是为了空出某个位置或某两个位置(不可能为了空出三个位置,显然这么做很闲),一次操作足矣;如果是动一次转一次也是一样的,要么转的很闲要么原本就存在这么一对空位置.</p>
<p>我们再进行一步转化,考虑把动床改为动格子.换句话说,每个格子可以通过一定的代价移动到和它相邻的床的与它不相邻的那个位置上.注意到移动格子的过程只会把黑格子移动到黑格子,白格子移动到白格子.</p>
<p>于是建立超级源点跑两边最短路,枚举最后床放在哪里即可.不过这里有一点是一个床有没有可能被黑白最短路同时跑了一遍,是有可能的,但这么跑一定不优秀,不可能是最小答案.</p>
<h5><span id="example2cf843ddynamicshortest-path">Example2([CF843D]Dynamic
Shortest Path)</span></h5>
<p>注意到<span class="math inline">\(O ( nq
)\)</span>能过.而且每次修改只是对于若干条边<span class="math inline">\(+
1\)</span>,自然想到每次修改完后跑01bfs.</p>
<p>但是怎么跑呢?注意到维护每个点最短路的增量,并且在路径的增量上跑01bfs,自然可求.</p>
<h5><span id="example3同余最短路luogup2371墨墨的等式">Example3
同余最短路([luoguP2371]墨墨的等式)</span></h5>
<p>因为<span class="math inline">\(a_i\)</span>无序,假设<span class="math inline">\(a_1\)</span>最小,那么所有的数字都可以按<span class="math inline">\(\mod a_1\)</span>的结果分成<span class="math inline">\(a_1\)</span>类.我们按照余数设置<span class="math inline">\(a_1\)</span>个点,编号为<span class="math inline">\(0\)</span>至<span class="math inline">\(a_1 -
1\)</span>.</p>
<p>设<span class="math inline">\(dis_i\)</span>为所有能组成的数中且<span class="math inline">\(\mod a_1\)</span>余数为<span class="math inline">\(i\)</span>的最小数.那么,所有能表示出来的<span class="math inline">\(\bmod a_1\)</span>余数为<span class="math inline">\(i\)</span>的数都可以写作<span class="math inline">\(dis_i + k \times a_1 , k \in \mathbb{ N
}\)</span>的形式,求得<span class="math inline">\(dis_i\)</span>后可以很轻易算出.</p>
<p>那么怎么求<span class="math inline">\(dis_i\)</span>呢?我们考虑:对于任意一个数<span class="math inline">\(k\)</span>,它可以怎么得到.注意到如果<span class="math inline">\(k - a_j\)</span>(其中<span class="math inline">\(i
\ne j\)</span>)可行,那么<span class="math inline">\(k\)</span>一定可行.自然有:<span class="math inline">\(dis_i = \min \{ dis_j + a_k | 0 \leq j &lt; a_i ,
k \ne i \}\)</span>.</p>
<p>这显然是一个最短路问题.</p>
<h3><span id="差分约束">差分约束</span></h3>
<h5><span id="example1agc056c-01balanced">Example1([AGC056C] 01
Balanced)</span></h5>
<p>将<span class="math inline">\(1\)</span>看成<span class="math inline">\(- 1\)</span>,<span class="math inline">\(0\)</span>看成<span class="math inline">\(+
1\)</span>,不难发现字典序最小也就是让前缀和序列字典序最小,并且有<span class="math inline">\(sum_{ r_i } = sum_{ l_i - 1 }\)</span>以及<span class="math inline">\(- 1 \leq sum_{ i } - sum_{ i - 1 } \leq
1\)</span>,然后做<span class="math inline">\(01\)</span>bfs跑最短路,显然最短路可以保证每个<span class="math inline">\(sum\)</span>都尽可能小.</p>
<p>然后另一个问题在于这玩意为啥不会让<span class="math inline">\(sum_i =
sum_{ i - 1 }\)</span>,这个建图后观察一下就知道不会发生这种情况.</p>
<h3><span id="2-sat">2-SAT</span></h3>
<h5><span id="example1cf1697f">Example1(CF1697F)</span></h5>
<p>对每个点建立<span class="math inline">\(k\)</span>对点表示<span class="math inline">\(a_i \geq x\)</span>和<span class="math inline">\(a_i &lt; x\)</span>,就能做了.</p>
<h5><span id="example22021集训队互测-序列">Example2(2021集训队互测 序列)</span></h5>
<p>注意到如果<span class="math inline">\(a_i &lt; x\)</span>,那么<span class="math inline">\(a_j \geq x \land a_k \geq
x\)</span>,这样就可以刻画所有的条件.</p>
<p>而且一定可以刻画所有的条件.</p>
<h3><span id="对偶图">对偶图</span></h3>
<h5><span id="example1csp-s-2021交通规划">Example1([CSP-S 2021]
交通规划)</span></h5>
<p>先考虑如果附加点的颜色全都相同,那肯定输出<span class="math inline">\(0\)</span>即可.</p>
<p>考虑附加点的数量为<span class="math inline">\(2\)</span>的时候,那显然最优情况需要将整个图分成各自联通的两部分,一部分染成黑色,一部分染成白色.可以发现这就是一个对偶图.</p>
<p>而如果附加点的数量很多怎么做呢?稍微思考一下</p>
<h3><span id="广义串并联图三度化">广义串并联图/三度化</span></h3>
<h4><span id="定义">定义</span></h4>
<p>定义:不存在<span class="math inline">\(4\)</span>个点使得任意两点之间存在一条简单路径,且这六条路径不在<span class="math inline">\(4\)</span>个点之外的地方相交.</p>
<h4><span id="删一度点">删一度点</span></h4>
<p>经典问题引入:树上带权最大独立集.</p>
<p>首先dp是可以实现的,我们考虑是否存在贪心算法.</p>
<p>首先,如果不带权,我们显然可以每次选取一度点或零度点,并删去所有相连的点.这样做显然是最优的.</p>
<p>但怎么做带权的方法呢?我们注意到可以先删掉所有负点权的点,然后可以加入剩下的所有零度点.</p>
<p>那么对于一度点呢?对于一个一度点<span class="math inline">\(u\)</span>和它的相邻点<span class="math inline">\(v\)</span>,我们不能盲目选<span class="math inline">\(u\)</span>的原因是可能选取<span class="math inline">\(v\)</span>会更优秀.考虑做一个带悔贪心,我们先把<span class="math inline">\(u\)</span>选上,然后把<span class="math inline">\(v\)</span>的权值设为<span class="math inline">\(val_v - val_u\)</span>,相当于我们仍然可以选<span class="math inline">\(v\)</span>,但是要花费<span class="math inline">\(val_u\)</span>的代价把<span class="math inline">\(u\)</span>删去.</p>
<p>我们把类似这样的操作称为<strong>删一度点</strong>.</p>
<h4><span id="缩二度点">缩二度点</span></h4>
<p>问题引入:给定一个仙人掌,每个点可以染色为<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>,<span class="math inline">\(u\)</span>节点染成<span class="math inline">\(0\)</span>会有<span class="math inline">\(b_u\)</span>的贡献,不然有<span class="math inline">\(w_u\)</span>的贡献.若一条边<span class="math inline">\(e\)</span>相邻的两点颜色相同则有<span class="math inline">\(s_e\)</span>的贡献,不然有<span class="math inline">\(d_e\)</span>的贡献,求最大答案.</p>
<p>首先如果有一度点和零度点,我们仍然可以使用删一度点的操作.</p>
<p>如果没有,考虑仙人掌上的一个点双一定是一个简单环.而且一定存在一个点双<span class="math inline">\(B\)</span>满足<span class="math inline">\(B\)</span>只包含一个割点.</p>
<p>那么对于这个点双上的一个非割点<span class="math inline">\(x\)</span>以及和它相邻的两个点<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>,我们考虑<span class="math inline">\(x\)</span>的染色有可能改变<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的答案,那么怎么办呢?</p>
<p>冷静思考一下,我们想办法把<span class="math inline">\(x\)</span>给删掉.简单来说,我们把<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>之间连一条边权为<span class="math inline">\([ w_{ 0 , 0 } , w_{ 0 , 1 } , w_{ 1 , 0 } , w_{ 1
, 1 } ]\)</span>的边,分别表示<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>的染色为以上四种情况时这条边(也就是原本的<span class="math inline">\(x\)</span>)的最大贡献是什么,这显然可以通过讨论<span class="math inline">\(x\)</span>的取值而求得.这样初始边权实际上就是<span class="math inline">\([ s , d , d , s
]\)</span>,于是我们就可以删掉一个二度点并连起来与它相邻的两个点,我们把类似这样的操作称为<strong>缩二度点</strong>.</p>
<h4><span id="叠合重边">叠合重边</span></h4>
<p>注意到使用缩二度点的时候,会把一个三元环缩成两个点及链接它们的两条重边,但是我们可以直接把重边合起来,我们把类似这样的操作称为<strong>叠合重边</strong>.</p>
<h4><span id="正确性证明">正确性证明</span></h4>
<p>接下来我们证明:任何广义串并联图都可以通过以上三种操作缩为一个点.</p>
<h5><span id="引理1">引理1</span></h5>
<p>对于一个无向图<span class="math inline">\(G\)</span>,若进行若干次删一度点操作,缩<span class="math inline">\(2\)</span>度点操作以及叠合重边操作后得到的图不是广义串并联图,那么<span class="math inline">\(G\)</span>也不是广义串并联图.</p>
<p>考虑用逆操作还原原图.删一度点的逆操作是加入一个点,叠合重边的逆操作是将一条边变成两条边,这两个操作显然不会使一个不是广义串并联图的图变成广义串并联图.接下来考虑缩二度点的逆操作:删掉一条边<span class="math inline">\(( u , v )\)</span>并加入一个点<span class="math inline">\(w\)</span>和两条边<span class="math inline">\(( u
, w )\)</span>和<span class="math inline">\(( w , v )\)</span>.</p>
<p>由于这个图不是广义串并联图,所以一定存在一组反例点<span class="math inline">\(\{ a , b , c , d
\}\)</span>.如果我们删掉的边不在作为反例的六条边上,那显然不影响;如果在,由于新加入的两条边仍然可以作为路径,所以也不影响.</p>
<p>于是引理得证.</p>
<h5><span id="引理2">引理2</span></h5>
<p>任意一张所有点的度数都大于等于<span class="math inline">\(3\)</span>的简单无向连通图,一定不是广义串并联图.</p>
<p>这个引理的严格证明有些麻烦.我们冷静一下,一个四个点的完全图满足以上条件且不是广义串并联图.而其他的图感性理解一下应该可以通过缩路径的方式变成一个四个点的完全图.</p>
<p>结合引理1,我们得知任意一个操作后不能变成单个节点的图的无向连通图不是广义串并联图.</p>
<h5><span id="引理3">引理3</span></h5>
<p>任意一个满足<span class="math inline">\(m \leq n +
k\)</span>的图,通过删一度点,缩二度点,叠合重边操作后,<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>都会到达一个<span class="math inline">\(O ( k )\)</span>的量级.</p>
<p>考虑缩完点后,所有点的度数<span class="math inline">\(\geq
3\)</span>,于是有<span class="math inline">\(2 m \geq 3
n\)</span>,而在操作过程中,<span class="math inline">\(m -
n\)</span>的值显然是不增的,于是有<span class="math inline">\(m - n \leq
k\)</span>,解一下方程得到<span class="math inline">\(n \leq 2 k , m \leq
3 k\)</span>.</p>
<h4><span id="example122zr提高十连测day6摆件">Example1(22zr提高十连测day6摆件)</span></h4>
<p>首先考虑颜色之间没啥区别,所以对于一棵树来说,朴素的dp是可以的.</p>
<p>简单来说,设<span class="math inline">\(dp_i\)</span>表示第<span class="math inline">\(i\)</span>棵子树的答案.合并的时候考虑设<span class="math inline">\(f_v = \cfrac{ 1 }{ k } dp_v sam_e + \cfrac{ k - 1
}{ k } dp_v dif_e\)</span>,自然有<span class="math inline">\(dp_u =
\prod_{ u \rightarrow v } f_v \\\)</span>.</p>
<p>接下来考虑先随便找一棵生成树,然后暴力枚举多余的反走边的深度较低的叶子节点的颜色,再进行dp即可.</p>
<p>另外也可以缩点后做,不过对于这题没啥区别.</p>
<h4><span id="example2joi-open-2022放学路">Example2([JOI Open 2022]
放学路)</span></h4>
<p>广义串并联图的一个很重要的思想是:我们通过一些手段改变这个图的形态为一个好做的形态,但是答案又和原图相同.</p>
<p>在这个思想的指导下,我们考虑这个题能否进行三度化.不过注意起点和终点简单特判一下,别把他们给删了.这样我们最后如果得到了一个只有起点和终点的图,那就一定是no.</p>
<p>然后如果没有只得到起点和终点呢?对最短路图建DAG,考虑如果<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>在一个点双中,我们找到两个点<span class="math inline">\(u , v\)</span>,使得<span class="math inline">\(u
\rightarrow v\)</span>,并且<span class="math inline">\(u\)</span>的出度至少是<span class="math inline">\(2\)</span>,<span class="math inline">\(v\)</span>的入度至少是<span class="math inline">\(2\)</span>,显然只要找到就做完了.现在的问题就在于为啥这条边一定存在.这个考虑找一个入度至少为<span class="math inline">\(2\)</span>的点<span class="math inline">\(v\)</span>,找到它的入点<span class="math inline">\(u\)</span>,如果<span class="math inline">\(u\)</span>的出度不是<span class="math inline">\(2\)</span>,那么<span class="math inline">\(u\)</span>也是一个入度至少为<span class="math inline">\(2\)</span>的点.这样往前推一定至少能推到一个点(因为不可能<span class="math inline">\(S\)</span>贡献了俩入度).</p>
<p>如何保证<span class="math inline">\(S ,
T\)</span>在一个点双中呢?其实只需要添加一条边<span class="math inline">\(( S , T , dis_{ S \rightarrow T }
)\)</span>就行了.显然加了后不会对答案产生影响.然后不在<span class="math inline">\(S , T\)</span>这个边双内的点也没有用了.</p>
<h3><span id="点分治">点分治</span></h3>
<h5><span id="example1cfgym101002k">Example1(CFgym101002K)</span></h5>
<p>点分治,假设当前分治重心是<span class="math inline">\(g\)</span>,将每个数缩成一个二元组<span class="math inline">\(( w_i , d_i )\)</span>,所求就是<span class="math inline">\(w_i w_j + d_i +
d_j\)</span>最小,直接排序做斜率优化.</p>
<h4><span id="点分树的性质">点分树的性质</span></h4>
<ol type="1">
<li><p>点分树的高度是<span class="math inline">\(O ( \log n
)\)</span>级别.</p></li>
<li><p>两个点在原树上的路径一定经过其在点分树上的LCA.</p></li>
</ol>
<h5><span id="example1codechef-btree">Example1(codechef [BTREE])</span></h5>
<p>这题用到了一个经典套路:一个树形连通图的点数减去边数为<span class="math inline">\(1\)</span>,把虚树建出来,能到达一个点的守卫必然是一个树形连通图(虚树中原本没有守卫的点可以加个不同覆盖范围的守卫).于是我们只需要求出每个守卫能覆盖多少点以及两个守卫之间的那条路径能覆盖多少个点,前者用点分树轻松维护,后者的话找一下这条边上的某个满足条件的点就行.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一棵树,现在在上面选定<span class="math inline">\(m\)</span>对不同的点,要求每对点的距离之和最大.</p>
<p>考虑如果确定了<span class="math inline">\(2
m\)</span>个点,我们如何匹配他们.对每条边算贡献,假设这条边两侧分别有<span class="math inline">\(a , b\)</span>个点,那么这条边最大的贡献就是<span class="math inline">\(\min \{ a , b
\}\)</span>.不难发现这个上界可以取到,只需要取这<span class="math inline">\(2
m\)</span>个点的带权重心,由于不存在绝对众数,所以直接两两匹配.枚举带权重心是啥,这样复杂度<span class="math inline">\(O ( n^2 )\)</span>.</p>
<p>那么怎么优化呢?我们注意到如果以一个点<span class="math inline">\(x\)</span>作为根,而它有一个儿子<span class="math inline">\(y\)</span>,<span class="math inline">\(y\)</span>的子树中选了少于<span class="math inline">\(m\)</span>个点,那么我们以<span class="math inline">\(y\)</span>为根一定是不优秀的,不然一开始就不可能只选少于<span class="math inline">\(m\)</span>个点,再考虑带权重心这个东西,上点分树.</p>
<p>具体来说,我们建立点分树,然后从点分树的根开始枚举带权重心,如果当前没有一棵子树选了<span class="math inline">\(m\)</span>个点,就停止,不然往选了<span class="math inline">\(m\)</span>个点的那棵子树走(如果有两个的话选第<span class="math inline">\(m\)</span>大更大的那个),这样就只会选取<span class="math inline">\(O ( \log n )\)</span>个带权重心.</p>
<h3><span id="边分治">边分治</span></h3>
<p>需要建立虚点转二叉树.</p>
<h4><span id="边分树的性质">边分树的性质</span></h4>
<ol type="1">
<li><p>非叶子节点代表边,叶子节点代表点.</p></li>
<li><p>边分树的高度是<span class="math inline">\(O ( \log n
)\)</span>级别.</p></li>
<li><p>边分树上每棵子树中的叶子节点一定联通.</p></li>
<li><p>是一棵完全二叉树.</p></li>
<li><p>两个点在原树上的路径一定经过其在边分树上的LCA所代表的边.</p></li>
</ol>
<h3><span id="二分图">二分图</span></h3>
<h4><span id="定理">定理</span></h4>
<h5><span id="最大流-最小割定理">最大流-最小割定理</span></h5>
<h5><span id="hall定理">Hall定理</span></h5>
<p>对于二分图<span class="math inline">\(\langle V_1 , V_2 , E \rangle ,
| V_1 | \leq | V_2 |\)</span>,那么该图存在完备匹配的充要条件是<span class="math inline">\(\forall Q \subseteq V_1 , | Q | \leq | N ( Q )
|\)</span>,其中<span class="math inline">\(N ( Q
)\)</span>指的是所有与<span class="math inline">\(Q\)</span>中点有边相连的点的集合.</p>
<p>必要性很显然,接下来说明充分性.设<span class="math inline">\(T\)</span>为最小点覆盖,也就是最大匹配的数量,再设<span class="math inline">\(M\)</span>为最大匹配,此时自然有:</p>
<p><span class="math display">\[
| M | = | T | = | T_1 | + | T_2 | \geq | T_1 | + | N ( V_1 / T_1 ) |
\geq | T_1 | + | V_1 / T_1 | = | V_1 |
\]</span></p>
<p>显然<span class="math inline">\(| M | \leq | V_1 |\)</span>,于是<span class="math inline">\(| M | = | V_1 |\)</span>.</p>
<p>另外,Hall定理有一个推论:正则二分图一定存在完美匹配.什么叫正则二分图,就是所有的点的度数(不为<span class="math inline">\(0\)</span>)都相等的图.</p>
<p><span class="math inline">\(2^d\)</span>-正则二分图求完美匹配的话,可以不断求欧拉回路并给边定向,每次把一个方向的边全都删掉,这样就转化成了<span class="math inline">\(2^{ d - 1 }\)</span>-正则二分图,不断递归到<span class="math inline">\(d = 0\)</span>.</p>
<h5><span id="vizing定理">Vizing定理</span></h5>
<p>设<span class="math inline">\(f ( G )\)</span>表示将<span class="math inline">\(G\)</span>边染色,使得有公共点的边的颜色不同,最少需要的颜色数量.</p>
<p>设<span class="math inline">\(\delta ( G )\)</span>表示<span class="math inline">\(G\)</span>中的点的最大度数.</p>
<p>对于一般图,我们有:<span class="math inline">\(\delta ( G ) \leq f ( G
) \leq \delta ( G ) + 1\)</span>,对于二分图有<span class="math inline">\(\delta ( G ) = f ( G )\)</span>.</p>
<p>考虑这个的证明:我们每次将一对点<span class="math inline">\(( x , y
)\)</span>染色,考虑设它们当前没染色的最小的颜色是<span class="math inline">\(l_x , l_y ( l_x \leq l_y
)\)</span>,如果相等就直接选,不然类似增广路更新.</p>
<h4><span id="二分图最大权匹配">二分图最大权匹配</span></h4>
<p>假定二分图两边两两有边(不是的话可以补上<span class="math inline">\(-
\infty\)</span>的边),这样就一定存在完美匹配.</p>
<p>我们给每个点一个顶标权值<span class="math inline">\(v\)</span>,对于任意一条边<span class="math inline">\(e : a \leftrightarrow b\)</span>,它的权值是<span class="math inline">\(w_e\)</span>,我们要求<span class="math inline">\(v\)</span>满足<span class="math inline">\(v_a +
v_b \geq w_e\)</span>.</p>
<p>如果我们规定了一组顶标后,取出所有满足<span class="math inline">\(v_a
+ v_b =
w_e\)</span>的边后的图(称作相等子图)存在完美匹配,那这组完美匹配就一定是最大权匹配.</p>
<p>这是为啥呢?考虑此时的最大权其实也就是<span class="math inline">\(\sum
v\)</span>,而由于<span class="math inline">\(v_a + v_b \geq
w_e\)</span>,因此最大权匹配一定不会超过<span class="math inline">\(\sum
v\)</span>.这就是一个可达的上界.</p>
<p>那么我们该怎么得到一个相等子图呢?考虑先构造一组合法的顶标,让左部端点取边的最大值,右部端点取<span class="math inline">\(0\)</span>,然后开始增广.</p>
<p>从左侧任意一个非匹配点出发,在相等子图上走增广路并增广.如果增广失败,我们将访问过的左部端点全部减去<span class="math inline">\(d\)</span>,右部端点全部加上<span class="math inline">\(d\)</span>,注意到此时匹配边一定不会变化,因为匹配边要么两个端点都没被访问过,要么都被访问过.而左端点被访问过,右端点没被访问过的边有可能加入相等子图,我们考虑取所有这种边的需要的差值的最小值并进行更新.但是直接这么做的复杂度有点高.</p>
<p>使用bfs优化,可以发现只会扩大<span class="math inline">\(O ( n^2
)\)</span>次子图,每次复杂度<span class="math inline">\(O ( n
)\)</span>,增广的复杂度类似,于是总复杂度<span class="math inline">\(O (
n^3 )\)</span>.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-ofjapanopenstrain-contest-1489-bpoint-pairs">Example1([
XVII Open Cup named after E.V. Pankratiev. Grand Prix of
Japan(openstrain contest 1489) B]Point Pairs)</span></h5>
<p>看到这种要求横坐标或纵坐标相同的题,有一个自然的想法是建立二分图,对于点<span class="math inline">\(( x , y )\)</span>,将二分图左边的<span class="math inline">\(x\)</span>和右边的<span class="math inline">\(y\)</span>连一条边.那么配对等价于要每次找两条相邻的边删掉.那么如何删掉呢?</p>
<p>首先发现的是,二分图不同的连通块可以分开处理,我们接下来只讨论一个连通块的情况.如果这个连通块有奇数条边,显然一定不行.而又可以发现,如果这个连通块有一个点度数仅为<span class="math inline">\(1\)</span>,那这条边如何删是确定的,我们可以把它和另一条边删掉,不难发现怎么删最后得到的新图仍然联通.而如果不存在度数为<span class="math inline">\(1\)</span>的点呢?由于这是一个二分图,不存在奇环,所以我们可以找一个简单环删掉,之后显然也是一个连通块.我们到这里就可以发现问题了.运用数学归纳不难证明:只要一个连通块的边数是偶数就一定合法.</p>
<p>然后我们可以使用可撤销的分治解决这个问题.</p>
<h3><span id="网络流常见模型">网络流常见模型</span></h3>
<h4><span id="最大流">最大流</span></h4>
<h4><span id="最小费用最大流">最小费用最大流</span></h4>
<h4><span id="最小割">最小割</span></h4>
<p>最大流<span class="math inline">\(=\)</span>最小割,证明显然.</p>
<p>最小割求方案。这个是简单的，我们删去所有流量<span class="math inline">\(0\)</span>的边后从<span class="math inline">\(S\)</span>开始bfs，找到所有<span class="math inline">\(S\)</span>能到达的点，显然这些点（注意如果这个点一开始就不能到达<span class="math inline">\(T\)</span>，那它是废物，不用管它，下面只讨论它能到达<span class="math inline">\(T\)</span>的情况）组成一个SCC（为啥呢？首先<span class="math inline">\(S\)</span>能到达它们，其次由于是最小割，因此这个点一定到达不了<span class="math inline">\(T\)</span>，而原本是可以到达<span class="math inline">\(T\)</span>的，假设这个点是<span class="math inline">\(x\)</span>，那么一定是原本存在一条<span class="math inline">\(S \rightarrow x \rightarrow
T\)</span>的路径被割掉了，也就是现在一定存在一条<span class="math inline">\(x \rightarrow
S\)</span>的路径）。最小割包含的边一定是这个集合和其它集合交界处的边。这是为啥呢？首先这些边一定组成了原图的一个割，其次，我们发现割不可能存在<span class="math inline">\(S\)</span>所在SCC中，而割掉完全不连接<span class="math inline">\(S\)</span>的边可以发现不如割其中一个点在<span class="math inline">\(S\)</span>所在SCC的边。</p>
<h5><span id="example1luogup4313-文理分科">Example1(luoguP4313 文理分科)</span></h5>
<p>先把所有的满意值全部吃下,然后考虑放弃哪些.</p>
<p>对于每个人<span class="math inline">\(u\)</span>,将<span class="math inline">\(S\)</span>向他连一条流量为<span class="math inline">\(art\)</span>的边,它向<span class="math inline">\(T\)</span>连一条为<span class="math inline">\(science\)</span>的边,表示它自己要么放弃文科,要么放弃理科.</p>
<p>然后再对每个点建立一个虚点<span class="math inline">\(u
&#39;\)</span>,<span class="math inline">\(S\)</span>向<span class="math inline">\(u &#39;\)</span>连一条为<span class="math inline">\(sameart\)</span>的边,<span class="math inline">\(u
&#39;\)</span>向相邻的实点连<span class="math inline">\(\infty\)</span>的边,表示要么放弃<span class="math inline">\(sameart\)</span>,要么那些点全都放弃理科.<span class="math inline">\(samescience\)</span>是同理的.</p>
<p>从这也可以看出来,大部分最小割的题目其实就是将冲突的选项放到一条路径中,然后考虑放弃哪些,将这个限制用最小割表示出来.</p>
<h5><span id="example2hnoi2013切糕">Example2([HNOI2013]切糕)</span></h5>
<p>也是显然的最小割,唯一难处理的地方在于相差<span class="math inline">\(\leq D\)</span>.</p>
<p>这个怎么做呢?建图后先每一竖轴都变成了一条链,我们在链之间加一些<span class="math inline">\(\infty\)</span>的边,使得如果断开的两个点之差大于<span class="math inline">\(D\)</span>,那就可以通过这条边破坏最小割结构.</p>
<p>这题同样告诉我们:对于最小割题目中的限制条件,几乎都是需要考虑破坏最小割结构的(也有可能是用费用流限制).</p>
<h5><span id="example3uoj704">Example3(uoj704)</span></h5>
<p>二分图最小割计数.</p>
<p>先求出最小割,然后显然每个匹配的三条边一定会选择一条割掉.</p>
<p>不妨设<span class="math inline">\(a_i = 0 / 1 / 2\)</span>表示第<span class="math inline">\(i\)</span>对匹配割掉了哪一条边.</p>
<p>考虑每个非匹配边<span class="math inline">\(( u , v
)\)</span>对点权的限制:</p>
<ol type="1">
<li><p><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>不在.则<span class="math inline">\(a_i =
0\)</span>.</p></li>
<li><p><span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(u\)</span>不在,则<span class="math inline">\(a_i =
2\)</span>.</p></li>
<li><p><span class="math inline">\(u\)</span>在最大匹配<span class="math inline">\(i\)</span>中,<span class="math inline">\(v\)</span>在最大匹配<span class="math inline">\(j\)</span>中,则<span class="math inline">\(a_i =
0\)</span>或<span class="math inline">\(a_j = 2\)</span>.</p></li>
</ol>
<p>前两种是好处理的,考虑第三种:显然所有都选<span class="math inline">\(2\)</span>或所有都选<span class="math inline">\(0\)</span>是一种方案,更进一步地,我们将<span class="math inline">\(i \rightarrow
j\)</span>,那么在一个强连通分量中的点一定都是<span class="math inline">\(2\)</span>或都是<span class="math inline">\(0\)</span>.这样可以缩点,缩点后发现DAG上的每一条路径的染色都形如<span class="math inline">\(0 , 0 , 0 , \cdots , 0 , ( 1 ) , 2 , \cdots , 2 ,
2 , 2\)</span>.</p>
<p>不妨折半搜索,按照拓扑排序,确定前一半哪些是<span class="math inline">\(0\)</span>,剩下是<span class="math inline">\(1 /
2\)</span>,那他们的后继必然全都是<span class="math inline">\(2\)</span>,这样后面的是<span class="math inline">\(2\)</span>的集合一定是这个后继集合的超集,高维后缀和.</p>
<p>接下来只需要判断哪些位置可以选<span class="math inline">\(1\)</span>.相当于前驱全都是<span class="math inline">\(0\)</span>并且后继全都是<span class="math inline">\(2\)</span>.</p>
<h4><span id="二分图匹配">二分图匹配</span></h4>
<h4><span id="二分图最小点覆盖">二分图最小点覆盖</span></h4>
<p>二分图最小点覆盖<span class="math inline">\(=\)</span>二分图最小割.</p>
<p>问题在于如何求解方案.</p>
<p>我们从左侧的非匹配点开始dfs,走还有残留流量的路径.并将路径上所有的点全都打上标记.那么左侧所有的未标记点和右侧所有的标记点就是一组合法的方案.</p>
<p>这是为啥呢?首先我们注意到,左侧的非匹配点一定会被标记,右侧的非匹配点一定不会被标记.</p>
<p>为啥右侧的非匹配点一定不会被标记呢?因为如果被标记了,从左侧非匹配点到右侧非匹配点这条路径的起始边和终边就都是非匹配边,显然是一条增广路.</p>
<p>然后我们又注意到:对于一组匹配点,要么两者都被标记,要么两者都不被标记,因为一旦走到了右侧点,下一步必然走向左侧点.而如果走到了左侧点,也必然是从右侧点走过来的.</p>
<p>接下来我们讨论一下:</p>
<p>对于非匹配边,由于其必然连了一个左侧非匹配点,所以它的右边必然被选择了.</p>
<p>对于匹配边,不难发现它会被某个匹配点覆盖掉.</p>
<p>于是得证.</p>
<p>当然,上面的证明略显啰嗦.事实上我们这么考虑:</p>
<p>首先,我们按照套路,求出<span class="math inline">\(S\)</span>所有能到达的点.根据二分图的性质,这个点的集合必然不包括<span class="math inline">\(T\)</span>.</p>
<p>然后我们取所有不在这个点集的左侧点和所有在这个点集的右侧点,这样所有的点被分为了四个部分,边也自然被分为了四个部分,讨论一下就知道这四个部分中有一个部分是不存在边的.于是得证.</p>
<h4><span id="二分图最大独立集">二分图最大独立集</span></h4>
<p>二分图最大独立集<span class="math inline">\(= n
-\)</span>二分图最小点覆盖.</p>
<h5><span id="example1cf1404e">Example1(CF1404E)</span></h5>
<p>在两个可选矩形的边界处建立一个点,如果它被选了,那么说明这个矩形和上面那个矩形被一起覆盖了.然后注意到每有一个点被选,自然就多覆盖了一个矩形,显然一个矩形不可能又跟纵向的一起被覆盖又跟横向的一起被覆盖,在他俩之间连边跑最大独立集即可.</p>
<p>感觉还是类似于最小路径覆盖,将这种两个一起被覆盖就减少答案的东西转换成一整条流.</p>
<h4><span id="最大权闭合子图">最大权闭合子图</span></h4>
<p>原图的边流量设为<span class="math inline">\(+
\infty\)</span>,然后对于每个点<span class="math inline">\(x\)</span>,如果<span class="math inline">\(val_x
&gt; 0\)</span>,那么<span class="math inline">\(ans + =
val_x\)</span>,然后将<span class="math inline">\(S \rightarrow
x\)</span>,流量为<span class="math inline">\(val_x\)</span>;不然,<span class="math inline">\(x \rightarrow T\)</span>,流量为<span class="math inline">\(- val_x\)</span>,然后求出最小割<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(ans
- w\)</span>.</p>
<h5><span id="example1luogup4177">Example1(luoguP4177)</span></h5>
<p>只需要把中间的<span class="math inline">\(\infty\)</span>边改为租用的代价即可.</p>
<h4><span id="最小路径覆盖覆盖点">最小路径覆盖(覆盖点)</span></h4>
<p>将每个点<span class="math inline">\(x\)</span>拆为两个点<span class="math inline">\(A_x\)</span>,<span class="math inline">\(B_x\)</span>,将<span class="math inline">\(S\)</span>向所有<span class="math inline">\(A\)</span>连边,<span class="math inline">\(B\)</span>向<span class="math inline">\(T\)</span>连边,如果图中存在一条路径<span class="math inline">\(x \rightarrow y\)</span>,则连边<span class="math inline">\(A_x \rightarrow B_y\)</span>,流量均为<span class="math inline">\(1\)</span>,然后求出最大流<span class="math inline">\(w\)</span>,答案即为<span class="math inline">\(n -
w\)</span>.</p>
<p>还有一个版本是可以重复走点,做一遍传递闭包就行.因为可重复相当于原图上的可跳点,这个版本又叫最小链覆盖.</p>
<h5><span id="example1网络流24题魔术球问题">Example1([网络流24题]魔术球问题)</span></h5>
<p>枚举球数,不断在残联网络上加边并在新图跑最小路径覆盖即可.</p>
<h4><span id="最长反链">最长反链</span></h4>
<p>反链是一个点的集合,满足这个集合中的点两两不可达.</p>
<p>最长反链<span class="math inline">\(=\)</span>可重复走点的最小点覆盖(最小链覆盖).</p>
<p>为啥呢?因为发现做完传递闭包后等价于新图的最大独立集.当然图是有性质的,观察一下可重复走点的最小点覆盖就可以发现等价于传递闭包后在二分图上求最大独立集.</p>
<h5><span id="example1cf1630fmaking-itbipartite">Example1([CF1630F]Making It
Bipartite)</span></h5>
<p>首先显然的一点是,对于任意一个数字<span class="math inline">\(x\)</span>,这个序列中不能同时出现<span class="math inline">\(px\)</span>和<span class="math inline">\(pqx\)</span>,其中<span class="math inline">\(p ,
q\)</span>都是大于等于二的正整数.这是显然的.如果我们把图改为有向图,由<span class="math inline">\(x \rightarrow
px\)</span>,那么整个图就只会有两种点:只有出边的点和只有入边的点.</p>
<p>那么我们该怎么办呢?如果是只能出现<span class="math inline">\(x\)</span>就不能出现<span class="math inline">\(px\)</span>,那这就是一个经典的最长反链问题.但多了一层,我们可以考虑类似分层图的思想:建立和原图完全一样的图<span class="math inline">\(G &#39;\)</span>,并且将<span class="math inline">\(G\)</span>中的<span class="math inline">\(x\)</span>向<span class="math inline">\(G
&#39;\)</span>中的<span class="math inline">\(x
&#39;\)</span>连有向边,然后跑最长反链.不难发现这样做是正确的.</p>
<h4><span id="平面图最小割">平面图最小割</span></h4>
<p>平面图最小割<span class="math inline">\(=\)</span>对偶图最短路.</p>
<h4><span id="最小费用任意流">最小费用任意流</span></h4>
<p>一般费用流,但是当当前增广路代价为正的就停止增广.</p>
<p>和最小费用最大流不一样,这玩意是可以增量的.</p>
<p>只需要考虑所有新的从源到汇的增广路以及增加过程出现的负环即可.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<p>费用流模型很好建立,问题在于这个东西好像跑费用流有点慢.</p>
<p>那咋办呢?我们考虑到费用流是有凸性的.所以搭配一下wqs二分.</p>
<p>然后分一下三种情况讨论:</p>
<ol type="1">
<li><p>直接<span class="math inline">\(S \rightarrow
T\)</span>的负增广路,相当于选取最小的<span class="math inline">\(b\)</span>和当前的<span class="math inline">\(a\)</span>搭配.</p></li>
<li><p>有一条<span class="math inline">\(S \rightarrow a \rightarrow b
\rightarrow a \rightarrow S\)</span>的负环,相当于以当前的<span class="math inline">\(a\)</span>代替前面的某个较大的<span class="math inline">\(a\)</span>.</p></li>
<li><p>有一条<span class="math inline">\(S \rightarrow a \rightarrow b
\rightarrow T \rightarrow b \rightarrow a \rightarrow
S\)</span>的负环,注意到这个环必然没意义,因为不可能存在一条<span class="math inline">\(T \rightarrow
S\)</span>的负路径(不然反路径就是正的,而最小费用任意流不可能流正路径),所以这种情况不如直接选<span class="math inline">\(S \rightarrow T\)</span>的路径.</p></li>
</ol>
<p>讨论完拿堆模拟一下就行.</p>
<p>这引出了著名的模拟费用流算法.</p>
<h4><span id="负费用最小流">负费用最小流</span></h4>
<p>一般费用流,但是当增广当前增广路时费用变成正的就停止增广.</p>
<p>注意如果两条增广路代价相同选流量大的那条.</p>
<h4><span id="有负环的费用流">有负环的费用流</span></h4>
<p>首先注意到:如果初始图没有负环,那无论后面怎么流都不可能出来负环.因为这意味着要么是一开始流了个正环,要么是一开始有负路径不走走正路径,都不太可能.</p>
<p>对于所有的负边<span class="math inline">\(u \rightarrow
v\)</span>,我们建立两个新点<span class="math inline">\(S
&#39;\)</span>和<span class="math inline">\(T
&#39;\)</span>,我们先将这条负边反向权值取相反数并让答案加上<span class="math inline">\(f \times v\)</span>,之后令<span class="math inline">\(u \rightarrow T &#39; , S &#39; \rightarrow
v\)</span>,跑<span class="math inline">\(S &#39; \rightarrow T
&#39;\)</span>的费用流,这个时候再在残联网络上跑<span class="math inline">\(s \rightarrow t\)</span>的费用流就是答案.</p>
<p>为啥会这样呢?</p>
<p>首先先证明正确性,这个东西相当于一开始跑了一下<span class="math inline">\(T &#39; \rightarrow u \rightarrow v \rightarrow S
&#39;\)</span>的图.然后我们在跑<span class="math inline">\(S &#39;
\rightarrow T &#39;\)</span>的时候一定是可以把上面的那个东西所从<span class="math inline">\(T &#39; \rightarrow S
&#39;\)</span>的所有流量全都退回去,因为这是一个可以构造的上界.也就相当于我们跑了一个环流.而在费用流里跑环流显然是不会影响答案的.</p>
<p>好,那么为啥这么做就不会出现负环了呢?因为你不可能在跑<span class="math inline">\(S &#39; \rightarrow T
&#39;\)</span>的时候跑个正环出来,自然不可能出现负环.</p>
<p>另外有一点是,一个点可能向<span class="math inline">\(S
&#39;\)</span>或<span class="math inline">\(T
&#39;\)</span>连很多边,其实是可以拼掉的,因为这些边全都是零权边,而构造完后的图是非负权边.</p>
<h4><span id="模拟费用流">模拟费用流</span></h4>
<p>对于特殊的图,模拟EK费用流的增广过程并进行操作.</p>
<p>对着例题记吧.</p>
<h5><span id="example1luogup4694pa2013raper">Example1(luoguP4694
[PA2013]Raper)</span></h5>
<h4><span id="散题">散题</span></h4>
<h5><span id="example1cqoi2014危桥">Example1([CQOI2014]危桥)</span></h5>
<p>有一个朴素的想法是:我们直接按题意建图,然后<span class="math inline">\(S \rightarrow a_1 , b_1\)</span>,<span class="math inline">\(T \rightarrow a_2 ,
b_2\)</span>,跑最大流然后检查是否满流.</p>
<p>问题在于,这样有可能会出现<span class="math inline">\(a_1 \rightarrow
b_2\)</span>的流量,我们怎么避免这种情况呢?</p>
<p>做法是,我们交换<span class="math inline">\(b_1 ,
b_2\)</span>并重复上面的过程,如果还是满流,我们声明一定合法.</p>
<p>为什么呢?我们注意到此时网络上的流量分为四种:<span class="math inline">\(a_1 \rightarrow a_2\)</span>,<span class="math inline">\(a_1 \rightarrow b_2\)</span>,<span class="math inline">\(b_1 \rightarrow a_2\)</span>,<span class="math inline">\(b_1 \rightarrow b_2\)</span>.不难发现<span class="math inline">\(a_1 \rightarrow b_2\)</span>和<span class="math inline">\(b_1 \rightarrow a_2\)</span>的流量是相等的.</p>
<p>在第二次跑网络流时,我们不妨直接将<span class="math inline">\(a_1
\rightarrow a_2\)</span>和<span class="math inline">\(b_2 \rightarrow
b_1\)</span>的流量加入答案并将这两条路径反向.此时,如果<span class="math inline">\(a_1\)</span>还是要走到<span class="math inline">\(b_1\)</span>,你发现第一轮的时候已经找到了一条<span class="math inline">\(b_1 \rightarrow
a_2\)</span>的路径,我们一定可以走这条来构造出只有<span class="math inline">\(a_1 \rightarrow a_2\)</span>的路径,另一边同理.</p>
<h3><span id="图的计数问题">图的计数问题</span></h3>
<h4><span id="prufer序列">Prufer序列</span></h4>
<p>我们可以将一颗有编号<span class="math inline">\(n\)</span>个点(<span class="math inline">\(n \geq 2\)</span>)的无根树与一个长度为<span class="math inline">\(n -
2\)</span>的Prufer序列建立双射.换句话说,一颗有编号<span class="math inline">\(n\)</span>个节点的无根树总共有<span class="math inline">\(n^{ n - 2 }\)</span>种(Cayley公式).</p>
<p>首先证明一个树可以对应到一个序列:每次选择一个度数为<span class="math inline">\(1\)</span>的编号最小的点,把它连向的点加到序列中并把这个点删去,直到最后只剩下两个节点,这样我们就把一棵树对应到一个序列.不难发现每个点出现的次数是其度数<span class="math inline">\(- 1\)</span>.</p>
<p>然后证明一个序列可以还原成一棵树:</p>
<p>我们可以通过序列得知每个点的度数,每次找到度数中最小的那个点并把它与序列中的第一个元素连边并删去序列中的第一个元素,不断这么做显然可以还原树.</p>
<h5><span id="example">Example</span></h5>
<p>一个<span class="math inline">\(n\)</span>个点的图有<span class="math inline">\(k\)</span>个连通块,现在加入<span class="math inline">\(k - 1\)</span>条边使得图连通,求方案数.</p>
<p>令<span class="math inline">\(s_i\)</span>为第<span class="math inline">\(i\)</span>个连通块的点数,<span class="math inline">\(d_i\)</span>为第<span class="math inline">\(i\)</span>个连通块所新连上的边数,如果我们令<span class="math inline">\(\binom{ n }{ c_1 , c_2 , . . . , c_m } = \cfrac{ n
! }{ c_1 ! c_2 ! . . . c_m ! } , \sum_{ i = 1 }^m c_i = n
\\\)</span>,也即将<span class="math inline">\(n\)</span>个位置拆分成<span class="math inline">\(m\)</span>个集合,第<span class="math inline">\(i\)</span>个集合有<span class="math inline">\(c_i\)</span>个位置的方案数.</p>
<p>那我们所需要做的也就是枚举每个连通块所新连出的边数<span class="math inline">\(d_i\)</span>,于是答案即<span class="math inline">\(\sum_d [ \sum d_i = 2 k - 2 ] \binom{ k - 2 }{ d_1
- 1 , d_2 - 1 , . . . , d_k - 1 } \prod_{ i = 1 }^k s_i^{ d_i }
\\\)</span>.</p>
<p>注意到我们有多项式定理:<span class="math inline">\(( x_1 + x_2 + . .
. + x_m )^n = \sum_{ c } [ \sum c_i = n ] \binom{ n }{ c_1 , c_2 , . . .
, c_m } \prod_{ i = 1 }^m x_i^{ c_i } \\\)</span>.</p>
<p>于是原式<span class="math inline">\(= n^{ k - 2 } \prod_{ i = 1 }^k
s_i\)</span>.</p>
<h4><span id="prufer序列的矩阵树定理理解">Prufer序列的矩阵树定理理解</span></h4>
<p>事实上,Prufer序列其实是可以拿矩阵树定理代替的(但是更麻烦一点).</p>
<p>我们先考虑证明Cayley公式:构造矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>其主余子式为:</p>
<p><span class="math display">\[
\begin{bmatrix}
- n + 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>将所有行全部加到第一行:</p>
<p><span class="math display">\[
\begin{bmatrix}
- 1 &amp; - 1 &amp; \cdots &amp; - 1 \\
1 &amp; - n + 1 &amp; \cdots &amp; 1 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; 1 &amp; \cdots &amp; - n + 1
\end{bmatrix}
\]</span></p>
<p>全部加下来,然后就成了上三角矩阵,将对角线乘起来就是<span class="math inline">\(n^{ n - 2 }\)</span>.</p>
<p>连通块的结论是类似的.</p>
<h4><span id="lgv引理">LGV引理</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个有限的带权有向无环图,有点集<span class="math inline">\(V\)</span>的一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(A = \{
a_1 , a_2 , . . . , a_n \}\)</span>作为起点集合,一个大小为<span class="math inline">\(n\)</span>的子集<span class="math inline">\(B = \{
b_1 , b_2 , . . . , b_n \}\)</span>作为终点集合.</p>
<p>记边<span class="math inline">\(i\)</span>的权值为<span class="math inline">\(w_i\)</span>.对于有向路径<span class="math inline">\(p\)</span>,记路径上所有边的边权的乘积为<span class="math inline">\(W ( p )\)</span>.记<span class="math inline">\(e (
u , v ) = \sum_{ p : u \rightarrow v } W ( p )\)</span>,即从<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的所有路径的边权乘积之和.</p>
<p>记<span class="math inline">\(P : A \rightarrow B = ( p_1 , p_2 , . .
. , p_n )\)</span>,<span class="math inline">\(p_i\)</span>表示从<span class="math inline">\(a_i\)</span>到<span class="math inline">\(b_{
\sigma ( i ) }\)</span>的一条路径,其中<span class="math inline">\(\sigma\)</span>是一个排列,记<span class="math inline">\(sign ( \sigma )\)</span>为<span class="math inline">\(-
1\)</span>以这个排列的逆序对数量为幂的值.又记<span class="math inline">\(\sigma ( P )\)</span>为<span class="math inline">\(P\)</span>所对应终点的排列.若满足<span class="math inline">\(\forall 1 \leq i , j \leq n , i \ne
j\)</span>,<span class="math inline">\(p_i\)</span>与<span class="math inline">\(p_j\)</span>没有公共点,则记作<span class="math inline">\(P^u\)</span>,否则记作<span class="math inline">\(P^c\)</span>,若不作区分记作<span class="math inline">\(P\)</span>.记<span class="math inline">\(W_{ all }
( P ) = \prod_{ i = 1 }^n W ( p_i )
\\\)</span>,也就是所有路径的乘积.</p>
<p>设矩阵<span class="math inline">\(M\)</span>满足<span class="math inline">\(M_{ i , j } = e ( a_i , b_j )\)</span>,那么有:</p>
<p><span class="math display">\[
\det M = \sum_{ P^u : A \rightarrow B } sign ( \sigma ( P^u ) ) W_{ all
} ( P^u )
\]</span></p>
<p>证明:</p>
<p>根据行列式的定义,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det M &amp; = \sum_{ \sigma } sign ( \sigma ) \prod_{ i = 1 }^n e ( a_i
, b_{ \sigma ( i ) } ) \\
&amp; = \sum_{ \sigma } sign ( \sigma ) \prod_{ i = 1 }^n \sum_{ p_i :
a_i \rightarrow b_{ \sigma ( i ) } } w ( p_i ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑后面那部分,<span class="math inline">\(\prod_{ i = 1 }^n \sum_{
p_i : a_i \rightarrow b_{ \sigma ( i ) } } w ( p_i )
\\\)</span>形如一个卷积的形式,所以这个式子等价于所有对应排列为<span class="math inline">\(\sigma\)</span>的<span class="math inline">\(P\)</span>的<span class="math inline">\(w ( P
)\)</span>,所以有:</p>
<p><span class="math display">\[
\begin{aligned}
\det M &amp; = \sum_{ \sigma } sign ( \sigma ) ( \sum_{ P : \{ a_1 , . .
. , a_n \} \rightarrow \{ b_{ \sigma ( 1 ) } , . . . , b_{ \sigma ( n )
} \} } w ( P ) ) \\
&amp; = \sum_{ P : A \rightarrow B } sign ( \sigma ( P ) ) w ( P ) \\
&amp; = \sum_{ P^u : A \rightarrow B } sign ( \sigma ( P^u ) ) w ( P^u )
+ \sum_{ P^c : A \rightarrow B } sign ( \sigma ( P^c ) ) w ( P^c )
\end{aligned}
\]</span></p>
<p>接下来只需证明<span class="math inline">\(\sum_{ P^c : A \rightarrow
B } sign ( \sigma ( P^c ) ) w ( P^c ) = 0 \\\)</span>即可.</p>
<p>设所有<span class="math inline">\(P^c\)</span>组成的集合为<span class="math inline">\(E\)</span>,考虑构造一个映射<span class="math inline">\(f : E \rightarrow E\)</span>满足如下条件:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( P^c ) \ne P^c\)</span>.</p></li>
<li><p><span class="math inline">\(f ( f ( P^c ) ) =
P^c\)</span>.</p></li>
<li><p><span class="math inline">\(w ( f ( P^c ) ) = w ( P^c
)\)</span>.</p></li>
<li><p><span class="math inline">\(sign ( f ( P^c ) ) = - sign ( P^c
)\)</span>.</p></li>
</ol>
<p>上面的结论即得证.</p>
<p>我们不妨考虑<span class="math inline">\(P^c\)</span>中的第一对相交的路径<span class="math inline">\(p_i\)</span>和<span class="math inline">\(p_j\)</span>,并交换它们的终点.显然满足上述条件,于是结论得证.</p>
<h5><span id="example">Example</span></h5>
<p>现在有<span class="math inline">\(n\)</span>个点,第<span class="math inline">\(i\)</span>个点位于<span class="math inline">\((
a_i , 1 )\)</span>,需要走到<span class="math inline">\(( b_i , n
)\)</span>.一个在<span class="math inline">\(( x , y
)\)</span>的点可以走向<span class="math inline">\(( x + 1 , y
)\)</span>或<span class="math inline">\(( x , y + 1
)\)</span>.求路径不相交的方案数.</p>
<p>路径不相交,则终点排列只有可能是<span class="math inline">\(\{ 1 , 2 ,
. . . , n \}\)</span>,直接使用LGV引理即可.</p>
<h4><span id="矩阵树定理">矩阵树定理</span></h4>
<h5><span id="无向图情况">无向图情况</span></h5>
<p>定义无向图的度数矩阵<span class="math inline">\(D ( G
)\)</span>为:<span class="math inline">\(D ( G )_{ i , j } =
\begin{cases}0 &amp; i \ne j \\ \deg_{ i } &amp; i =
j\end{cases}\)</span>.</p>
<p>令<span class="math inline">\(w ( i , j )\)</span>为<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>之间直接相连的无向边个数,定义无向图的邻接矩阵<span class="math inline">\(A ( G )_{ i , j } = \begin{cases}0 &amp; i = j \\
w ( i , j ) &amp; i \ne j\end{cases}\)</span></p>
<p>定义无向图的基尔霍夫矩阵(又称拉普拉斯矩阵)<span class="math inline">\(L ( G ) = D ( G ) - A ( G )\)</span>.</p>
<p>记<span class="math inline">\(t ( G )\)</span>为图<span class="math inline">\(G\)</span>的生成树个数,那么有:<span class="math inline">\(t ( G
)\)</span>等于基尔霍夫矩阵任意一个主余子式.</p>
<p>引理:无向图的基尔霍夫矩阵的任意一个代数余子式都相等.</p>
<p>证明:考虑删去第<span class="math inline">\(i\)</span>行,设剩下的矩阵为<span class="math inline">\(A = [ \vec{ r }_1 , \vec{ r }_2 , . . . , \vec{ r
}_n ]\)</span>,根据基尔霍夫矩阵的性质,不难发现<span class="math inline">\(\sum{ \vec{ r }_i } = \vec{ 0 }\)</span>.<span class="math inline">\(\forall 1 \leq j &lt; k \leq
n\)</span>,如果我们删去第<span class="math inline">\(j\)</span>列,考虑将除了第<span class="math inline">\(k\)</span>列的其它列全部加到第<span class="math inline">\(k\)</span>列,于是得到矩阵<span class="math inline">\([ \vec{ r }_1 , . . . , \vec{ r }_{ j - 1 } ,
\vec{ r }_{ j + 1 } , . . . , \vec{ r }_{ k - 1 } , - \vec{ r }_j ,
\vec{ r }_{ k + 1 } , . . . , \vec{ r }_n
]\)</span>.我们接下来一路将第<span class="math inline">\(k\)</span>列交换到第<span class="math inline">\(j
+ 1\)</span>列之前并取反,我们就得到了删去第<span class="math inline">\(k\)</span>列的矩阵,于是有<span class="math inline">\(M_{ i , j } = ( - 1 )^{ 1 + ( k - 1 ) - ( j + 1 )
+ 1 } M_{ i , k }\)</span>,也就是<span class="math inline">\(C_{ i , j }
= C_{ i , k }\)</span>,同理可证明<span class="math inline">\(C_{ j , i }
= C_{ k , i }\)</span>.</p>
<p>接下来,用<span class="math inline">\(T\)</span>表示生成树的边的集合,设<span class="math inline">\(w ( T ) = \prod_{ e \in T } w ( e
)\)</span>,我们只需证明<span class="math inline">\(C_{ 1 , 1 } = \sum w
( T )\)</span>.</p>
<p>定义<span class="math inline">\(\zeta ( e , u ) = v , e = \{ u , v
\}\)</span>,考虑构造一个<span class="math inline">\(n \times
m\)</span>的矩阵<span class="math inline">\(A\)</span>满足<span class="math inline">\(A_{ i , j } = \begin{cases}1 &amp; i \in e_j \land
i &lt; \zeta ( e_j , i ) \\ - 1 &amp; i \in e_j \land i &gt; \zeta ( e_j
, i ) \\ 0 &amp; other\end{cases} \\\)</span>.</p>
<p>注意到:</p>
$$
<span class="math display">\[\begin{aligned}
AA^T ( i , j ) &amp; = \sum_{ k = 1 }^m A ( i , k ) A^T ( k , j ) \\
&amp; = \sum_{ k = 1 }^m A ( i , k ) A ( j , k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(i = j\)</span>时,不难发现<span class="math inline">\(AA^T ( i , j ) = \sum_{ k = 1 }^m [ i \in e_k ] =
\deg_i\)</span>.不然,注意到显然为<span class="math inline">\(- \sum_{ k
= 1 }^m [ i \in e_k ] [ j \in e_k ]\)</span>.也就是说,<span class="math inline">\(AA^T = L\)</span>.</p>
<p>定义<span class="math inline">\(A\)</span>删去第一行后得到的矩阵为<span class="math inline">\(B\)</span>,则<span class="math inline">\(BB^T =
M_{ 1 , 1 }\)</span>.此时我们带入Cauchy-Binet公式,得到:</p>
<p><span class="math display">\[
\begin{aligned}
M_{ 1 , 1 } &amp; = \sum_{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . .
, m \} } \det ( B [ S ] B^T [ S ] ) \\
&amp; = \sum_{ | S | = n - 1 , S \subseteq \{ 1 , 2 , . . . , m \} }
\det ( B [ S ] )^2
\end{aligned}
\]</span></p>
<p>接下来我们需要证明:如果<span class="math inline">\(S\)</span>集合构成了一棵生成树,那么<span class="math inline">\(\det B [ S ] = \pm 1\)</span>.反之,<span class="math inline">\(\det B [ S ] = 0\)</span>.</p>
<p>如果集合没有构成一个生成树,则至少存在一个简单环.如果有某个点是孤立点那么答案肯定是<span class="math inline">\(0\)</span>,因此只需考虑每个点都与边连通的情况即可.</p>
<p>考虑这种情况下,如果有两条边<span class="math inline">\(( u_1 , u_2
)\)</span>和<span class="math inline">\(( u_2 , u_3
)\)</span>被选上了,那么我们可以通过列变换将它们改为<span class="math inline">\(( u_1 , u_2 )\)</span>和<span class="math inline">\(( u_1 , u_3
)\)</span>.这样不断进行下去,如果存在环,一定会出现重边选择的情况,这个时候行列式的值为<span class="math inline">\(0\)</span>.如果不存在环,那么我们可以通过这个操作得到一个菊花图.所以行列式为<span class="math inline">\(\pm 1\)</span>.</p>
<p>所以定理得证.</p>
<h6><span id="example省选联考-2020-a卷作业题">Example([省选联考 2020 A
卷]作业题)</span></h6>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\(\gcd ( w_1 , . . . , w_{ n - 1 } ) \sum_{ i = 1
}^{ n - 1 } w_i\)</span>之和.</p>
<p>首先前面的<span class="math inline">\(\gcd\)</span>可以使用<span class="math inline">\(\varphi * I =
id\)</span>来处理.于是剩下的问题在于我们如何将一个生成树的边的和代替乘积作为贡献来求和.</p>
<p>不妨进行扩域,令<span class="math inline">\(j^2 = 0 , j \ne
0\)</span>,这样我们可以类比复数来将每个数写作<span class="math inline">\(a + bj\)</span>的模式.考虑将每条边的边权改为<span class="math inline">\(w_i j +
1\)</span>并定义新域的四则运算,取最后得到的数<span class="math inline">\(a + bj\)</span>的<span class="math inline">\(b\)</span>作为答案即可.</p>
<p>另外,注意到这样做复杂度<span class="math inline">\(wn^3\)</span>,很难通过.考虑每次只当边数大于等于<span class="math inline">\(n - 1\)</span>的时候再跑行列式.不妨设<span class="math inline">\(\sigma ( n )\)</span>为<span class="math inline">\(n\)</span>的因数个数,考虑如果因数很分散,那肯定复杂度很低,不然,我们有复杂度<span class="math inline">\(O ( n^3 \cfrac{ \sum_{ i = 1 }^m \sigma ( w_i ) }{
n - 1 } )\)</span>,可以通过.</p>
<h6><span id="example北京省选集训2019生成树计数">Example([北京省选集训2019]生成树计数)</span></h6>
<p>给定一个图,设第<span class="math inline">\(i\)</span>条边的权值为<span class="math inline">\(w_i\)</span>,求所有生成树的<span class="math inline">\(( \sum_{ i = 1 }^{ n - 1 } w_i
)^k\)</span>之和.</p>
<p>考虑将第<span class="math inline">\(e\)</span>条边边权改为<span class="math inline">\(\sum_{ i = 0 }^k \cfrac{ w_e^i x^i }{ i !
}\)</span>.根据多项式定理,显然最后取<span class="math inline">\([ x^k
]\)</span>并乘以<span class="math inline">\(k !\)</span>即可.</p>
<h5><span id="有向图情况">有向图情况</span></h5>
<p>定义有向图的出度矩阵<span class="math inline">\(D^{ out } ( G ) =
\begin{cases}0 &amp; i \ne j \\ \deg^{ out }_i &amp; i =
j\end{cases}\)</span>,类似地可以定义入度矩阵<span class="math inline">\(D^{ in } ( G )\)</span>.</p>
<p>令<span class="math inline">\(cnte ( i , j )\)</span>为从<span class="math inline">\(i\)</span>直接连向<span class="math inline">\(j\)</span>的有向边个数,定义有向图的邻接矩阵<span class="math inline">\(A ( G )_{ i , j } = \begin{cases}0 &amp; i = j \\
cnte ( i , j ) &amp; i \ne j\end{cases}\)</span></p>
<p>定义有向图的出度基尔霍夫矩阵<span class="math inline">\(L^{ out } ( G
) = D^{ out } ( G ) - A ( G
)\)</span>,同理可以定义其入度基尔霍夫矩阵<span class="math inline">\(L^{
in } ( G )\)</span>.</p>
<p>记<span class="math inline">\(t^{ root } ( r , G )\)</span>为图<span class="math inline">\(G\)</span>以<span class="math inline">\(r\)</span>为根的根向生成树(<span class="math inline">\(r\)</span>为根时,所有边都从儿子指向父亲)个数,同理可以定义叶向生成树个数<span class="math inline">\(t^{ leaf } ( r , G )\)</span>.</p>
<p>设<span class="math inline">\(M^{ out }_{ r , r }\)</span>为<span class="math inline">\(L^{ out }\)</span>的主余子式,有<span class="math inline">\(t^{ root } ( r , G ) = M^{ out }_{ r , r
}\)</span>.叶向同理.</p>
<p>下面只简单提到根向生成树的证明,叶向同理.</p>
<p>类似于无向图,我们考虑构造<span class="math inline">\(n \times
m\)</span>矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(( n - 1 ) \times m\)</span>矩阵<span class="math inline">\(B\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
A_{ i , j } &amp; = \begin{cases}
1 &amp; e_j &#39; s \ head \ is \ i \\
- 1 &amp; e_j &#39; s \ tail \ is \ i \\
0 &amp; other
\end{cases} \\
B_{ i , j } &amp; = \begin{cases}
1 &amp; e_j &#39; s \ head \ is \ i \\
0 &amp; other
\end{cases}
\end{aligned}
\]</span></p>
<p>剩下的部分与无向图类似.</p>
<h4><span id="best定理">BEST定理</span></h4>
<p>设<span class="math inline">\(ec ( G )\)</span>为有向图<span class="math inline">\(G\)</span>的欧拉回路个数,若其存在欧拉回路,则:</p>
<p><span class="math display">\[
ec ( G ) = t^{ root } ( G , x ) \prod_{ i = 1 }^n ( \deg_i - 1 ) !
\]</span></p>
<p>其中<span class="math inline">\(\deg_i = \deg^{ in }_i = \deg_i^{ out
}\)</span>.</p>
<p>考虑如果勒令以<span class="math inline">\(x\)</span>为起点,我们保留除了<span class="math inline">\(x\)</span>以外每个点的最后经过的出边,最后一定会形成一棵根向树.而其他点可以随便选(由于我们勒令了每个点存在一个出边,所以不可能走到死胡同),这样的答案是<span class="math inline">\(t^{ root } ( G , x ) \deg_x \prod_{ i = 1 }^n (
\deg_i - 1 ) !\)</span>.</p>
<p>但是如果没有规定起点,考虑循环重构,在我们选择不同的边当作初始边时,只需循环一下总体的顺序,就可以得到以另一条边为初始边的另一个图,所以答案要比规定起点的答案多除一个<span class="math inline">\(\deg_x\)</span>.</p>
<h4><span id="格路计数问题">格路计数问题</span></h4>
<h5><span id="定义">定义</span></h5>
<ol type="1">
<li><p>在平面直角坐标系中,横坐标和纵坐标都是整数的点称为格点,平面格路是指从一个格点到另一格点只走格点的路,格路的长度是指其所走的路的步数.</p></li>
<li><p>对于一条从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m )\)</span>的格路,若其只使用了上步<span class="math inline">\(U = ( 0 , 1 )\)</span>,右步<span class="math inline">\(L = ( 1 , 0 )\)</span>,则我们称其为<span class="math inline">\(( n , m )\)</span>自由路.</p></li>
<li><p>记<span class="math inline">\(\mathcal{ F } ( n , m
)\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路的集合,<span class="math inline">\(F ( n , m ) = \#
\mathcal{ F } ( n , m )\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路数量,即<span class="math inline">\(\mathcal{ F } ( n , m
)\)</span>的元素个数,显然<span class="math inline">\(F ( n , m ) =
\binom{ n + m }{ n } \\\)</span>.</p></li>
<li><p>对于一条从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m
)\)</span>的自由路,若其始终不经过对角线<span class="math inline">\(y =
\cfrac{ m }{ n } x\)</span>下方,则我们称之为<span class="math inline">\(( n , m ) - Dyck\)</span>路.</p></li>
<li><p>记<span class="math inline">\(\mathcal{ D } ( n , m
)\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路的集合,<span class="math inline">\(D ( n , m ) = \#
\mathcal{ D } ( n , m )\)</span>为<span class="math inline">\(( n , m
)\)</span>自由路数量,即<span class="math inline">\(\mathcal{ D } ( n , m
)\)</span>的元素个数.</p></li>
<li><p>对于从<span class="math inline">\(( 0 , 0 )\)</span>到<span class="math inline">\(( n , m )\)</span>的<span class="math inline">\(2\)</span>条格路<span class="math inline">\(P ,
Q\)</span>,其中<span class="math inline">\(P = u_1 u_2 . . . u_{ n + m }
, Q = v_1 v_2 . . . v_{ n + m } ( u_i , v_i \in{ L , U } , i = 1 , 2 , .
. . , n + m )\)</span>.若 <span class="math inline">\(\exists i , u_{ i
+ 1 } . . . u_{ n + m } u_1 . . . u_i = v_1 v_2 . . . v_{ n + m
}\)</span>,则我们称格路<span class="math inline">\(P ,
Q\)</span>等价.将<span class="math inline">\(P\)</span>的等价格路全集记为<span class="math inline">\([ P ]\)</span>.</p></li>
<li><p>对于任意格路<span class="math inline">\(P\)</span>,记<span class="math inline">\(P_k = u_{ k + 1 } . . . u_{ n + m } u_1 . . .
u_k\)</span>,则<span class="math inline">\([ P ] = \{ P_k | k = 1 , 2 ,
3 , · · · , n + m \}\)</span>.定义<span class="math inline">\(P\)</span>的周期为使得<span class="math inline">\(P = P_k\)</span>的最小数<span class="math inline">\(k\)</span>，用<span class="math inline">\(period (
P )\)</span>表示,则显然有<span class="math inline">\(\# [ P ] = period (
P )\)</span>.</p></li>
</ol>
<h5><span id="定理">定理</span></h5>
<h4><span id="散模型">散模型</span></h4>
<h5><span id="多叉堆计数">多叉堆计数</span></h5>
<p>有一棵树,要求给每个点一个<span class="math inline">\([ 1 , n
]\)</span>的权值且不同的点权值不同,满足父亲的权值小于儿子的权值,求方案数.</p>
<p>不妨设以<span class="math inline">\(u\)</span>为根节点的子树方案数为<span class="math inline">\(f_u\)</span>,<span class="math inline">\(u\)</span>的儿子是<span class="math inline">\(v_1
, . . . , v_k\)</span>,注意到<span class="math inline">\(f_u = \binom{
siz_u - 1 }{ siz_{ v_1 } , siz_{ v_2 } , . . . , siz_{ v_k } } \prod f_{
v_i } = ( siz_u - 1 ) ! \prod_{ u \rightarrow v } \frac{ f_{ v } }{
siz_v ! } \\\)</span>.</p>
<p>那么考虑根的答案<span class="math inline">\(f_1\)</span>,考虑不断将<span class="math inline">\(f_1\)</span>中含有的其它<span class="math inline">\(f_u\)</span>向下展开,自然的,除了<span class="math inline">\(1\)</span>号点外,每个点对答案都贡献了一个<span class="math inline">\(\frac{ 1 }{ siz }\)</span>,而根的贡献是<span class="math inline">\(( n - 1 ) !\)</span>.</p>
<p>也就是说,<span class="math inline">\(ans = ( n - 1 ) ! \prod_{ u = 2
}^n \frac{ 1 }{ siz_u } = n ! \prod_{ u = 1 }^n \frac{ 1 }{ siz_u }
\\\)</span>.</p>
<h6><span id="example1agc060c-large-heap">Example1([AGC060C] Large Heap)</span></h6>
<p>如果没有限制,就是一个简单的多叉堆计数.</p>
<p>而有了限制怎么做呢?我们考虑把<span class="math inline">\(u\)</span>到<span class="math inline">\(1\)</span>的路径和<span class="math inline">\(v\)</span>到<span class="math inline">\(1\)</span>的路径归并起来,会得到一条长链.我们只要确定了长链上的元素,通过组合数以及二叉堆计数,自然可以算出不在长链上的元素的答案.而对于长链上的元素,我们可以直接设计一个<span class="math inline">\(O ( n^2 )\)</span>的dp即可.</p>
<h6><span id="example2heoi2013sao">Example2([HEOI2013]SAO)</span></h6>
<p>显然给出的是一张树形图,然后每条边有一个限制表示这条边所连接的两个点哪个更大.现在给每个点一个<span class="math inline">\([ 1 , n
]\)</span>的权值且不同的点权值不同求方案数.</p>
<p>我们随便找一个点然后当成有根树做,然后如果只有父亲小于儿子的边就是简单的多叉堆计数.不然,我们可以做一个简单容斥.这样问题就又转化回多叉堆计数,容斥部分写一个树形dp就好.</p>
<p>补一下,这个树形dp没有那么简单.首先你注意到多叉堆计数是跟子树大小有关系的,所以你不能简单地设计<span class="math inline">\(f_{ i , j }\)</span>表示<span class="math inline">\(i\)</span>子树内选中了<span class="math inline">\(j\)</span>条边的代价,你必须加一维来处理子树大小,也就是设<span class="math inline">\(f_{ u , siz , cnt }\)</span>表示<span class="math inline">\(u\)</span>所在连通块大小为<span class="math inline">\(siz\)</span>,子树中总共选择了<span class="math inline">\(cnt\)</span>条边的代价.</p>
<p>但是注意到这题的容斥系数是<span class="math inline">\(( - 1
)^k\)</span>,其中<span class="math inline">\(k\)</span>是选择的儿子小于父亲的数量,然后其它的要求儿子大于父亲的边随便选.你发现你选中了一条边,无非是对答案乘以一个<span class="math inline">\(- 1\)</span>,这是没有必要记录的.因此直接以<span class="math inline">\(f_{ u , siz }\)</span>的状态转移就行.</p>
<p>这个故事告诉我们别什么容斥都最后算,你能在做的过程中把<span class="math inline">\(- 1\)</span>乘上去就别惦记最后统一求和了.</p>
<h5><span id="三元环计数">三元环计数</span></h5>
<p>我们对原图建立一个新的有向图,在新图中,如果<span class="math inline">\(u \rightarrow v\)</span>,则在原图中<span class="math inline">\(\deg u &lt; \deg v\)</span>或<span class="math inline">\(\deg u = \deg v \land u &lt;
v\)</span>.根据自然根号,每个点的出度不会超过<span class="math inline">\(O ( \sqrt{ n } )\)</span>.</p>
<p>接下来枚举原图的一条边<span class="math inline">\(u \leftrightarrow
v\)</span>,只要在新的图中找到<span class="math inline">\(w\)</span>满足<span class="math inline">\(u
\rightarrow v , u \rightarrow w , v \rightarrow
w\)</span>即可.打tag做一做,复杂度<span class="math inline">\(O ( n
\sqrt{ n } )\)</span>.</p>
<h5><span id="四元环计数">四元环计数</span></h5>
<p>仍然类似三元环计数那样建立新图.</p>
<p>考虑原图中的两条边<span class="math inline">\(u \leftrightarrow
v\)</span>和<span class="math inline">\(u \leftrightarrow v
&#39;\)</span>,我们考虑对四元环中度数最大的那个点<span class="math inline">\(w\)</span>计数,对于这个<span class="math inline">\(w\)</span>统计一个tag表示形如<span class="math inline">\(u \leftrightarrow v \rightarrow
w\)</span>的数量,每次改变<span class="math inline">\(u\)</span>的时候清空一下全图tag.</p>
<h5><span id="有标号dag计数">有标号DAG计数</span></h5>
<p>即:</p>
$$
<span class="math display">\[\begin{aligned}
f_n &amp; = \sum_{ k = 1 }^n \binom{ n }{ k } ( - 1 )^{ k - 1 } 2^{ k (
n - k ) } f_{ n - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明见反演与容斥-子集反演-Example2.</p>
<h6><span id="example1qoj5749">Example1(qoj5749)</span></h6>
<p>注意到一个环内部不能有任何边,那么其实也就是有标号DAG计数,只不过要乘上一个斯特林数.不妨设<span class="math inline">\(g_{ n , m }\)</span>为<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>条边的答案,再设<span class="math inline">\(G_n\)</span>为其生成函数.事实上,我们自然有:</p>
$$
<span class="math display">\[\begin{aligned}
G_n &amp; = \sum_{ k = 1 } \binom{ n }{ k } \sum_{ j = 1 }^k{ k \brack j
} ( - 1 )^{ j - 1 } ( 1 + z )^{ k ( n - k ) } G_{ n - k } \\
&amp; = \sum_{ k = 1 } \binom{ n }{ k } ( 1 + z )^{ k ( n - k ) } G_{ n
- k } \sum_{ j = 1 }^k{ k \brack j } ( - 1 )^{ j - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>逆用斯特林公式,如果<span class="math inline">\(n \geq 1\)</span>:</p>
<p><span class="math display">\[
\sum_{ i }{ n \brack i } ( - 1 )^{ i - 1 } = ( - 1 ) \times ( - 1 )^{
\overline{ n } } = [ n = 1 ]
\]</span></p>
<p>注意到<span class="math inline">\(G_1 = 1\)</span>,于是:</p>
<p><span class="math display">\[
\begin{aligned}
G_n &amp; = n ( 1 + z )^{ n - 1 } G_{ n - 1 } \\
&amp; = n ! ( 1 + z )^{ \frac{ n ( n - 1 ) }{ 2 } } \\
[ z^m ] G_n &amp; = n ! \binom{ \frac{ n ( n - 1 ) }{ 2 } }{ m }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" class="post-title-link" itemprop="url">反演与容斥</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="反演">反演</span></h2>
<p>假设有两个函数<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>满足:<span class="math inline">\(f ( n )
= \sum_{ k } a_{ n , k } g ( k )\)</span>,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( S ) &amp; = \sum_{ T \subseteq S } g ( T ) \Leftrightarrow g ( S ) =
\sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } f ( T ) \\
f ( S ) &amp; = \sum_{ S \subseteq T \subseteq U } g ( T )
\Leftrightarrow g ( S ) = \sum_{ S \subseteq T \subseteq U } ( - 1 )^{ |
T | - | S | } f ( T )
\end{aligned}
\]</span></p>
<p>证明:</p>
<p><span class="math display">\[
\begin{aligned}
g ( S ) &amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } f ( T )
\\
&amp; = ( - 1 )^{ | S | } \sum_{ T \subseteq S } ( - 1 )^{ | T | }
\sum_{ P \subseteq T } g ( P ) \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) \sum_{ T
\subseteq S / P } ( - 1 )^{ | T | + | P | } \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) ( - 1 )^{ | P |
} \sum_{ T \subseteq S / P } ( - 1 )^{ | T | } \\
&amp; = ( - 1 )^{ | S | } \sum_{ P \subseteq S } g ( P ) [ S = P ] ( - 1
)^{ | P | } \\
&amp; = g ( S )
\end{aligned}
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设<span class="math inline">\(cnt_S\)</span>为集合为<span class="math inline">\(S\)</span>的数量,然后设<span class="math inline">\(f_S = \sum_{ S &#39; \subseteq S } cnt_{ S &#39;
}\)</span>,有:<span class="math inline">\(ans = \sum_{ S } 2^{ f_S } ( -
1 )^{ n - | S | }\)</span>.</p>
<p>做一遍高维前缀和就好,复杂度<span class="math inline">\(O ( n 2^n
)\)</span>,应该也可以用分治FMT无脑做到<span class="math inline">\(O (
n^2 2^n )\)</span>.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设<span class="math inline">\(f_{ i , j }\)</span>表示<span class="math inline">\(i\)</span>个点,其中有<span class="math inline">\(j\)</span>个点的入度数为<span class="math inline">\(0\)</span>的方案数.(等一下,为撒子想到要记度数为<span class="math inline">\(0\)</span>的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这<span class="math inline">\(j\)</span>个点后,还剩下<span class="math inline">\(k\)</span>个零度点.于是自然有:</p>
<p><span class="math display">\[
f_{ i , j } = \binom{ i }{ j } \sum_{ k = 1 }^{ i - j } ( 2^j - 1 )^k
2^{ j ( i - j - k ) } f_{ i - j , k }
\]</span></p>
<p>等一下咧,这复杂度<span class="math inline">\(O ( n^3
)\)</span>了,这咋办啊?</p>
<p>好像转移优化不太了,因为<span class="math inline">\(k\)</span>很难省去(在指数上).但我们注意到我们定义的时候说:<span class="math inline">\(0\)</span>度点的数量恰好为<span class="math inline">\(k\)</span>,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少<span class="math inline">\(k\)</span>个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设<span class="math inline">\(f ( n , S )\)</span>表示<span class="math inline">\(n\)</span>个点,其中只有<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>;类似定义<span class="math inline">\(g (
n , S )\)</span>表示<span class="math inline">\(n\)</span>个点,至少<span class="math inline">\(S\)</span>中的点的入度为<span class="math inline">\(0\)</span>.显然我们所求也就是<span class="math inline">\(g ( n , \emptyset )\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n , S ) &amp; = 2^{ | S | ( n - | S | ) } g ( n - | S | , \emptyset
) \\
g ( n , S ) &amp; = \sum_{ S \subseteq T } f ( n , T )
\end{aligned}
\]</span></p>
<p>对第二个式子用子集反演,有:</p>
<p><span class="math display">\[
f ( n , S ) = \sum_{ S \subseteq T } ( - 1 )^{ | T | - | S | } g ( n , T
)
\]</span></p>
<p>接下来使用反复带入大法:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , \emptyset ) &amp; = \sum_{ \emptyset \ne T } f ( n , T ) \\
&amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } g ( n , S ) \\
&amp; = \sum_{ T \subseteq S } ( - 1 )^{ | S | - | T | } 2^{ | S | ( n -
| S | ) } g ( n - | S | , \emptyset ) \\
&amp; = \sum_{ m = 1 }^n \sum_{ | T | = m } \sum_{ T \subseteq S } ( - 1
)^{ | S | - | T | } 2^{ | S | ( n - | S | ) } g ( n - | S | , \emptyset
) \\
&amp; = \sum_{ m = 1 }^n \binom{ n }{ m } \sum_{ k = m }^n \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ m = 1 }^n \binom{ n }{ m } \sum_{ k = m }^n \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\
= &amp; \sum_{ k = 1 }^n \sum_{ m = 1 }^k \binom{ n }{ m } \binom{ n - m
}{ k - m } ( - 1 )^{ k - m } 2^{ k ( n - k ) } g ( n - k , \emptyset )
\\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) \sum_{ m = 1 }^k \binom{ k }{ m } ( - 1 )^{ k - m } \\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) ( ( 1 - 1 )^k - ( - 1 )^k ) \\
= &amp; \sum_{ k = 1 }^n \binom{ n }{ k } 2^{ k ( n - k ) } g ( n - k ,
\emptyset ) ( - 1 )^{ k - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到复杂度已经降到<span class="math inline">\(O ( n^2
)\)</span>了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个<span class="math inline">\(( - 1 )^{ k - 1
}\)</span>,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
$$
<span class="math display">\[\begin{aligned}
f_n &amp; = \sum_{ k = 1 }^n \binom{ n }{ k } ( - 1 )^{ k - 1 } 2^{ k (
n - k ) } f_{ n - k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是直接设,然后钦定其有至少<span class="math inline">\(j\)</span>个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 0 }^n C_n^k g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\
f ( n ) &amp; = \sum_{ k = 0 }^n ( - 1 )^k \binom{ n }{ k } g ( k )
\Leftrightarrow g ( n ) = \sum_{ k = 0 }^n ( - 1 )^k \binom{ n }{ k } f
( k ) \\
f ( n ) &amp; = \sum_{ k = n }^N C_k^n g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = n }^N ( - 1 )^{ k - n } C_k^n f ( k ) \\
f ( n ) &amp; = \sum_{ k = n }^N ( - 1 )^k \binom{ k }{ n } g ( k )
\Leftrightarrow g ( n ) = \sum_{ k = n }^N ( - 1 )^k \binom{ k }{ n } f
( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然以<span class="math inline">\(( - 1 )^n g ( n )\)</span>代替<span class="math inline">\(g ( n
)\)</span>即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\
&amp; = \sum_{ m = 0 }^n \sum_{ k = 0 }^{ n - m } ( - 1 )^k C_{ n - m
}^k C_n^m g ( m ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^k C_n^k \sum_{ m = 0 }^{ n - k } C_{ n
- k }^m g ( m ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^k C_n^k f ( n - k ) \\
&amp; = \sum_{ k = 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p><span class="math inline">\(n\)</span>个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设<span class="math inline">\(f ( n )\)</span>为<span class="math inline">\(n\)</span>个人随便站的方案数,<span class="math inline">\(g ( n )\)</span>为<span class="math inline">\(n\)</span>个人都站错的方案数.</p>
<p>如果知道<span class="math inline">\(g\)</span>的表达式,我们可以通过枚举有多少人站错位置来得到<span class="math inline">\(f\)</span>,即:<span class="math inline">\(f ( n )
= \sum_{ k = 0 }^n C_n^k g ( k )\)</span>.</p>
<p>显然就是一个二项式反演,<span class="math inline">\(g ( n ) = \sum_{ k
= 0 }^n ( - 1 )^{ n - k } C_n^k f ( k ) = \sum_{ k = 0 }^n ( - 1 )^{ n -
k } C_n^k k !\)</span>.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:<span class="math inline">\(g ( n ) = n ! \sum_{ 0 \leq k \leq n } \cfrac{ ( -
1 )^k }{ k ! } \\\)</span>.</p>
<p>不难发现<span class="math inline">\(n !\)</span>的后面形如<span class="math inline">\(e^{ - 1
}\)</span>的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n ) &amp; = \cfrac{ n ! }{ e } - n ! \sum_{ k &gt; n } \cfrac{ ( - 1
)^k }{ k ! } \\
&amp; = \cfrac{ n ! }{ e } - \cfrac{ ( - 1 )^{ n + 1 } }{ n + 1 } \sum_{
0 \leq k } ( - 1 )^k \cfrac{ ( n + 1 ) ! }{ ( k + n + 1 ) ! }
\end{aligned}
\]</span></p>
<p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有<span class="math inline">\(g ( n ) = \lfloor \cfrac{ n ! }{ e } + \cfrac{ 1
}{ 2 } \rfloor + [ n = 0 ]\)</span>.</p>
<p>另外,观察<span class="math inline">\(g\)</span>关于<span class="math inline">\(f\)</span>的表达式,不难求出<span class="math inline">\(g\)</span>的递推式:<span class="math inline">\(g (
n ) = ng ( n - 1 ) + ( - 1 )^n\)</span>.</p>
<p>下面证明<span class="math inline">\(g_n = ( n - 1 ) ( g_{ n - 1 } +
g_{ n - 2 } )\)</span>,事实上,右边等于:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; ( n - 1 ) ( g_{ n - 1 } + g_{ n - 2 } ) \\
= &amp; ( - 1 )^{ n - 1 } ( n - 1 ) + ( n - 1 ) \sum_{ k = 0 }^{ n - 2 }
( ( n - 1 ) ! \frac{ ( - 1 )^k }{ k ! } + ( n - 2 ) ! \frac{ ( - 1 )^k
}{ k ! } ) \\
= &amp; n ! \sum_{ k = 0 }^{ n - 2 } \frac{ ( - 1 )^k }{ k ! } - ( n - 1
) ( - 1 )^n \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为<span class="math inline">\(k\)</span>段,说明有<span class="math inline">\(n -
k\)</span>个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了<span class="math inline">\(x\)</span>个数字,<span class="math inline">\(y\)</span>个区间,那么钦定<span class="math inline">\(j\)</span>对的方案是<span class="math inline">\(\binom{ x - y }{ j } ( x - j )
!\)</span>.然后要乘上前面已经有了的,也就是乘上形如<span class="math inline">\(( 1 + z )^k\)</span>.这样复杂度<span class="math inline">\(O ( n^4 )\)</span>.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的<span class="math inline">\(x , y , k\)</span>有<span class="math inline">\(O
( 1 )\)</span>种不同的取值,因此不用枚举.这样就是<span class="math inline">\(O ( n^3
)\)</span>.但是那个多项式乘法也可以规避,考虑最后的答案形如<span class="math inline">\(\sum ( 1 + z )^k P_k ( x
)\)</span>,我们考虑写成<span class="math inline">\(P_{ n - 1 } ( z ) + =
( 1 + z ) P_n ( z )\)</span>,然后不断这么做,就只需要<span class="math inline">\(O ( n^2 )\)</span>.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(f_{
i , j }\)</span>,恰好有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列最小值为<span class="math inline">\(1\)</span>的答案是<span class="math inline">\(g_{
i , j }\)</span>,注意到:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>令<span class="math inline">\(h_{ n , m } = \sum_{ j = 0 }^m \binom{
m }{ j } g_{ n , j } \\\)</span>,则<span class="math inline">\(f_{ n , m
} = \sum_{ i = 0 }^n \binom{ n }{ i } h_{ i , m } \\\)</span>,而<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>.做两次二项式反演得到<span class="math inline">\(g\)</span>.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥<span class="math inline">\(f_{ n , m } \ne \binom{ N }{ n } \binom{ M }{ m }
k^{ nm } ( k - 1 )^{ NM - nm }\)</span>呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ S , T } &amp; = \sum_{ s \subseteq S } \sum_{ t \subseteq T } g_{ s
, t } \\
f_{ S , T } &amp; = \sum_{ s \subseteq S } h_{ s , T } \\
h_{ S , T } &amp; = \sum_{ t \subseteq T } g_{ S , t } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ S , T } &amp; = k^{ | S | \times | T | } ( k - 1 )^{ NM - | S | | T
| } \\
h_{ s , T } &amp; = \sum_{ S \subseteq s } ( - 1 )^{ | s | - | S | } f_{
S , T } \\
g_{ s , t } &amp; = \sum_{ T \subseteq t } ( - 1 )^{ | t | - | T | } h_{
s , T }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,<span class="math inline">\(g_{ n , m
}\)</span>本身就包含了所有<span class="math inline">\(| S | = n , | T |
= m\)</span>的情况的和,并且在组合数<span class="math inline">\(\binom{ m
}{ j }\)</span>那里就找到了唯一确定的<span class="math inline">\(f_{ s ,
t }\)</span>,因此<span class="math inline">\(f_{ n , m
}\)</span>是唯一确定的.这意味着这里<span class="math inline">\(f\)</span>的<span class="math inline">\(n ,
m\)</span>并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = 2^{ 2^{ n - i } } \binom{ n }{ i } \\
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\
g_k &amp; = \sum_{ i = k }^n ( - 1 )^{ i - k } \binom{ i }{ k } f_i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个问题其实非常显然,我们的<span class="math inline">\(g_{ i , j
}\)</span>定义为所有<span class="math inline">\(| S | = i , | T | =
j\)</span>的答案之和.<span class="math inline">\(f\)</span>也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ N - i }{ n - i } \sum_{ j = 0 }^m
\binom{ M - j }{ m - j } g_{ i , j }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求<span class="math inline">\(g_{ N , M }\)</span>,那此时<span class="math inline">\(g\)</span>怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f_k &amp; = \sum_{ i = k }^n \binom{ i }{ k } g_i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,<span class="math inline">\(g\)</span>是已知的集合,<span class="math inline">\(f\)</span>是未知的集合.我们乘上组合数就可以得到对于<span class="math inline">\(f\)</span>来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把<span class="math inline">\(f\)</span>的定义改成<span class="math inline">\(f_{ n , m } = k^{ nm } ( k - 1 )^{ NM - nm
}\)</span>就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f_{ n , m } = \sum_{ i = 0 }^n \binom{ n }{ i } \sum_{ j = 0 }^m \binom{
m }{ j } g_{ i , j }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的集合的前提下,从中选出<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列并求<span class="math inline">\(g\)</span>.那么你从哪知道的<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列呢?你得组合数啊!</p>
<p>所以,实际上的<span class="math inline">\(f\)</span>是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } \sum_{ i = 0 }^n
\binom{ n }{ i } \sum_{ j = 0 }^m \binom{ m }{ j } g_{ i , j } \\
f_{ n , m } &amp; = \binom{ N }{ n } \binom{ M }{ m } k^{ nm } ( k - 1
)^{ NM - nm }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = n }^N C_n^k g ( k ) \Leftrightarrow g ( n ) =
\sum_{ k = n }^N ( - 1 )^{ k - n } C_n^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设<span class="math inline">\(f &#39;_{ i , j }\)</span>为至少有<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列不满足条件的方案数,自然有<span class="math inline">\(f &#39;_{ i , j } = f_{ N - i , M - j
}\)</span>.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39;_{ n , m } = \sum_{ i = n }^N \binom{ i }{ n } \sum_{ j = m }^M
\binom{ j }{ m } g &#39;_{ i , j }
\]</span></p>
<p>最后答案就是<span class="math inline">\(g &#39;_{ 0 , 0
}\)</span>.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) = \sum_{ k = 0 }^n
\left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } f ( k ) \\
f ( n ) &amp; = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) = \sum_{ k = 0 }^n
\left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^{ n - k } f ( k ) \\
f ( m ) &amp; = \sum_{ n = m }^M ( - 1 )^{ m - n } \left [ \begin{array}
{ c } n \\
m
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) = \sum_{ k = 0 }^M
\left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} f ( k ) \\
f ( m ) &amp; = \sum_{ n = m }^M ( - 1 )^{ m - n } \left \{
\begin{array}
{ c } n \\
m
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) = \sum_{ k = 0 }^M
\left [ \begin{array}
{ c } k \\
m
\end{array} \right ] f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } &amp; = \sum_{ k = 0 }^n \left
\{ \begin{array}
{ c } n \\
k
\end{array} \right \} \left [ \begin{array}
{ c } k \\
m
\end{array} \right ] ( - 1 )^{ n - k } = [ m = n ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m = 0 }^n [ m = n ] g ( m ) \\
&amp; = \sum_{ m = 0 }^n \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } g ( m ) \\
&amp; = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } \sum_{ m = 0 }^k \left \{
\begin{array}
{ c } k \\
m
\end{array} \right \} g ( m ) = \sum_{ k = 0 }^n \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] ( - 1 )^{ n - k } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( m ) &amp; = \sum_{ n = m }^M [ n = m ] g ( n ) \\
&amp; = \sum_{ n = m }^M \sum_{ k = 0 }^M \left [ \begin{array}
{ c } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} ( - 1 )^{ n - k } g ( n ) \\
&amp; = \sum_{ k = 0 }^M \left \{ \begin{array}
{ c } k \\
m
\end{array} \right \} f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( n ) &amp; = \sum_{ d | n } g ( d ) \Leftrightarrow g ( n ) = \sum_{
d | n } \mu ( \frac{ n }{ d } ) f ( d ) \\
f ( n ) &amp; = \sum_{ n | d } g ( d ) \Leftrightarrow g ( n ) = \sum_{
n | d } \mu ( \frac{ d }{ n } ) f ( d ) \\
f ( x ) &amp; = \sum_{ 1 \leq d } g ( d ) \Leftrightarrow g ( x ) =
\sum_{ 1 \leq d } f ( \cfrac{ x }{ d } ) \mu ( d )
\end{aligned}
\]</span></p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m | n } [ \frac{ n }{ m } = 1 ] g ( m ) \\
&amp; = \sum_{ m | n } \sum_{ d | \frac{ n }{ m } } \mu ( d ) g ( m ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\([ d | \frac{ n }{ m } ] = [ md | n
] = [ m | \frac{ n }{ d } ] \\\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ d | n } \mu ( d ) \sum_{ m | \frac{ n }{ d } } g
( m ) \\
&amp; = \sum_{ d | n } \mu ( d ) f ( \frac{ n }{ d } ) \\
&amp; = \sum_{ d | n } \mu ( \frac{ n }{ d } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第二个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ n | d } [ \frac{ d }{ n } = 1 ] g ( d ) \\
&amp; = \sum_{ n | d } \sum_{ c | \frac{ d }{ n } } \mu ( c ) g ( d ) \\
&amp; = \sum_{ c | d } \sum_{ nc | d } \mu ( c ) g ( d ) \\
&amp; = \sum_{ c } \mu ( c ) f ( nc ) \\
&amp; = \sum_{ n | d } \mu ( \frac{ d }{ n } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 1 \leq d } g ( \cfrac{ x }{ d } ) \mu ( d ) &amp; = \sum_{ d \geq
1 } \mu ( d ) \sum_{ k \geq 1 } f ( \cfrac{ x }{ kd } ) \\
&amp; = \sum_{ m \geq 1 } f ( \cfrac{ x }{ m } ) \sum_{ d , k \geq 1 } [
m = dk ] \mu ( d ) \\
&amp; = \sum_{ m \geq 1 } f ( \cfrac{ x }{ m } ) \sum_{ d | m } \mu ( d
) \\
&amp; = f ( x )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>且仅包含小写英文字母且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>不妨设<span class="math inline">\(f ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的字符串个数,<span class="math inline">\(g ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>且循环节长度恰为<span class="math inline">\(n\)</span>的字符串个数.</p>
<p>有<span class="math inline">\(f ( n ) = \sum_{ d | n } g ( d
)\)</span>,根据莫比乌斯反演,<span class="math inline">\(g ( n ) = \sum_{
d | n } \mu ( \cfrac{ n }{ d } ) f ( d )\)</span>.</p>
<h4><span id="example2">Example2</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m
gcd ( i , j ) \\\)</span>.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m gcd ( i , j ) &amp; = \sum_{ i = 1
}^n \sum_{ j = 1 }^m id [ gcd ( i , j ) ] \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^m \sum_{ d | gcd ( i , j ) }
\varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n \sum_{ j = 1 }^m \sum_{ d | gcd ( i , j ) } \varphi ( d
) &amp; = \sum_{ d = 1 }^{ \min ( n , m ) } \sum^{ \lfloor \frac{ n }{ d
} \rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 }
\varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ d = 1 }^{ \min ( n , m ) } \sum^{ \lfloor \frac{ n }{ d } \rfloor
}_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 } \varphi (
d ) &amp; = \sum^{ \min ( n , m ) }_{ d = 1 } \varphi ( d ) \times
\lfloor \cfrac{ n }{ d } \rfloor \times \lfloor \cfrac{ m }{ d } \rfloor
\\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑使用数论分块,只需处理出<span class="math inline">\(\varphi ( d
)\)</span>的前缀和即可在<span class="math inline">\(O ( \sqrt{ n } +
\sqrt{ m } )\)</span>的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [
gcd ( i , j ) = 1 ] \\\)</span>.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从<span class="math inline">\(id\)</span>变为了<span class="math inline">\(\epsilon\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [
gcd ( i , j ) \in \mathrm{ prime } ] \\\)</span>.</p>
<p>考虑增加枚举量,则:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m [ gcd ( i , j ) &amp; \in \mathrm{
prime } ] = \sum_{ i = 1 }^{ n } \sum_{ j = 1 }^m \sum_{ p \in \mathrm{
prime } } [ gcd ( i , j ) = p ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum^{ \lfloor \frac{ n }{ d }
\rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ d } \rfloor }_{ j = 1 } [
gcd ( pi , pj ) = p ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum^{ \lfloor \frac{ n }{ p }
\rfloor }_{ i = 1 } \sum^{ \lfloor \frac{ m }{ p } \rfloor }_{ j = 1 } [
gcd ( i , j ) = 1 ] \\
&amp; = \sum_{ p \in \mathrm{ prime } } \sum_{ d = 1 }^{ \min ( \lfloor
\frac{ m }{ p } \rfloor , \lfloor \frac{ n }{ p } \rfloor ) } \mu ( d )
\lfloor \cfrac{ n }{ pd } \rfloor \lfloor \cfrac{ m }{ pd } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设<span class="math inline">\(x = pd\)</span>,则变为<span class="math inline">\(\sum_{ x = 1 }^{ \min ( n , m ) } \sum_{ p \in
\mathrm{ prime } \land p | x } \mu ( \frac{ x }{ p } ) \lfloor \frac{ n
}{ x } \rfloor \lfloor \frac{ m }{ x } \rfloor \\\)</span>.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4>
<p>首先先考虑去掉<span class="math inline">\(lcm\)</span>使得式子中只有<span class="math inline">\(i , j , \gcd ( i , j )\)</span>.</p>
<p>显然可以构造函数<span class="math inline">\(f ( x ) = x^{ c - d } , g
( x ) = x^d , h ( x ) = x^d \\\)</span>,然后将题目转化为<span class="math inline">\(\sum_{ j = 1 }^n f ( gcd ( i , j ) ) g ( i ) h ( j
) x_j \equiv b_i ( \mod p ) \\\)</span>.</p>
<p><span class="math inline">\(\gcd ( i , j
)\)</span>很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出<span class="math inline">\(f_r ( n )\)</span>使得<span class="math inline">\(f ( n ) = \sum_{ d | n } f_r ( d )
\\\)</span>,也即<span class="math inline">\(f_r ( n ) = \sum_{ d | n }
\mu ( \cfrac{ n }{ d } ) f ( d )\)</span>.</p>
<p>则原式即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ j = 1 }^n \sum_{ d } [ d | i ] [ d | j ] f_r ( d ) g ( i ) h ( j
) x_j &amp; \equiv b_i ( \mod p ) \\
\sum_{ d | i } f_r ( d ) \sum_{ j = 1 }^n [ d | j ] h ( j ) x_j &amp;
\equiv \frac{ b_i }{ g ( i ) } ( \mod p ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令<span class="math inline">\(z_d = \sum_{ j = 1 }^n [ d | j ] h ( j
) x_j \\\)</span>,有<span class="math inline">\(\sum_{ d | i } f_r ( d )
z_d \equiv \frac{ b_i }{ g ( i ) } ( \mod p ) \\\)</span>.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出<span class="math inline">\(z_d\)</span>.</p>
<p>而<span class="math inline">\(z_d = \sum_{ j = 1 }^n [ d | j ] h ( j
) x_j = \sum_{ d | j }^n h ( j )
x_j\)</span>,可以再次使用莫比乌斯反演求出<span class="math inline">\(h (
j ) x_j\)</span>,进而求<span class="math inline">\(x_j\)</span>.</p>
<p>无解条件显然是<span class="math inline">\(g_i = 0 \land x_i \ne
0\)</span>.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li><p>通过增加枚举量消掉<span class="math inline">\(lcm\)</span>以及<span class="math inline">\(\gcd\)</span>这些难以处理的项.</p></li>
<li><p>将<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>尽量分到式子两边.</p></li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p></li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有<span class="math inline">\(\mu ( x ) \ne 0\)</span>的<span class="math inline">\(x\)</span>,就可以得到全部信息,而这些<span class="math inline">\(x\)</span>的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \bigoplus_{ i \in A } i [ \gcd ( i , n ) = 1 ] \\
&amp; = \bigoplus_{ i \in A }^c i \sum_{ d | i , d | n } \mu ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(\sum_{ d | i } \mu ( d ) =
\bigoplus_{ d | i } | \mu ( d ) |\)</span>,于是:</p>
<p><span class="math display">\[
f ( n ) = \bigoplus_{ d | n } | \mu ( d ) | \bigoplus_{ d | i , i \in A
} i
\]</span></p>
<p>接下来只要我们形式上写作<span class="math inline">\(n\)</span>,我们就默认<span class="math inline">\(\mu ( n ) \ne 0\)</span>,又令<span class="math inline">\(g ( n ) = \bigoplus_{ n | i , i \in A }
i\)</span>,此时自然有<span class="math inline">\(f ( n ) = \bigoplus_{ d
| n } g ( d )
\\\)</span>.这是一个经典的莫反形式,我们再反演回去就可以得到<span class="math inline">\(g ( n ) = \bigoplus_{ d | n } \mu ( \frac{ n }{ d
} ) f ( d ) = \bigoplus_{ d | n } f ( d
)\)</span>,也就是说我们可以求得所有的<span class="math inline">\(g ( n
)\)</span>,也就是这个集合中所有是<span class="math inline">\(n\)</span>的倍数的异或值.</p>
<p>注意一个事实:如果我们设<span class="math inline">\(w ( m ) = \prod_{
p \in \mathrm{ prime } , p | m } p\)</span>,那么我们就可以按照<span class="math inline">\(w\)</span>的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进<span class="math inline">\(A\)</span>的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设<span class="math inline">\(S ( n ) = \{ x | w ( x ) = n \}\)</span>,又设<span class="math inline">\(h ( n ) = \bigoplus_{ i \in A , i \in S ( n ) }
i\)</span>.考虑用<span class="math inline">\(g ( n )\)</span>表示<span class="math inline">\(h ( n )\)</span>,我们有:</p>
<p><span class="math display">\[
g ( n ) = \bigoplus_{ n | d } | \mu ( \frac{ d }{ n } ) | h ( d )
\]</span></p>
<p>反演,有<span class="math inline">\(h ( n ) = \bigoplus_{ n | d } g (
d ) \\\)</span>.于是我们可以求得所有的<span class="math inline">\(h ( n
)\)</span>了.</p>
<p>现在的问题在于:对于数<span class="math inline">\(n , \mu ( n ) \ne
0\)</span>,我们要在<span class="math inline">\(S ( n
)\)</span>中选出若干个数,使得它们的异或和为<span class="math inline">\(h
( n )\)</span>,并且选出的数字总共有<span class="math inline">\(| A
|\)</span>个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设<span class="math inline">\(S\)</span>为可重集合.</p>
<p>一般形式:定义<span class="math inline">\(\mu ( S )\)</span>,若<span class="math inline">\(S\)</span>包含重复元素则为<span class="math inline">\(0\)</span>,否则为<span class="math inline">\(( - 1
)^{ | S | }\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
f ( S ) &amp; = \sum_{ T \subseteq S } g ( T ) \Leftrightarrow g ( S ) =
\sum_{ T \subseteq S } \mu ( S - T ) f ( T ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式(<span class="math inline">\(\omega_n = e^{ \frac{ 2 \pi i }{
n } }\)</span>):</p>
<p><span class="math display">\[
f_m = \sum_{ k = 0 }^{ n - 1 } \omega_n^{ mk } g_k \Leftrightarrow g_m =
\frac{ 1 }{ n } \sum_{ k = 0 }^{ n - 1 } \omega_n^{ - mk } f_k
\]</span></p>
<p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是<span class="math inline">\([ m | n ] \sum_{ d | \frac{ n }{ m } } \mu ( d ) =
[ n = m ] \\\)</span>.</p>
<p>令<span class="math inline">\(c = md\)</span>,左边<span class="math inline">\(= \sum_{ c | n } [ m | c ] \mu ( \frac{ c }{ m } )
= \sum ( [ c | n ] ) ( [ m | c ] \mu ( \frac{ c }{ m } ) )
\\\)</span>.</p>
<p>令<span class="math inline">\(A_{ c , n } = [ c | n ]\)</span>,<span class="math inline">\(B_{ m , c } = [ m | c ] \mu ( \frac{ c }{ m } )
\\\)</span>,那我们有<span class="math inline">\(BA = I\)</span>.</p>
<p>刚才的过程相当于:</p>
$$
<span class="math display">\[\begin{aligned}
Ax &amp; = b \\
x &amp; = Ix \\
x &amp; = ( BA ) x \\
x &amp; = B ( Ax ) \\
x &amp; = Bb \\

\end{aligned}\]</span>
<p>$$</p>
<p>无论是二项式反演还是莫比乌斯反演,他们都满足<span class="math inline">\(f ( n )\)</span>所依赖的<span class="math inline">\(g ( k )\)</span>有<span class="math inline">\(k
\leq n \\\)</span>.</p>
<p>根据上面的情况,我们发现<span class="math inline">\(A\)</span>是一个下三角矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(A^{ - 1
}\)</span>.</p>
<p>现在来推导满足<span class="math inline">\(k \leq
n\)</span>的一般情况反演:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum_{ k = 1 }^n a_{ n , k } g ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设算子<span class="math inline">\(\mu ( n , m
)\)</span>,满足<span class="math inline">\(\sum_{ k = 1 }^n a_{ n , k }
\mu ( k , m ) = \sum_{ k = 1 }^n \mu ( n , k ) a_{ k , m } = [ n = m ]
\\\)</span>.</p>
<p>即<span class="math inline">\(AB = BA = I \\\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum_{ m = 1 }^n [ n = m ] g ( m ) \\
&amp; = \sum_{ m = 1 }^n \sum_{ k = 1 }^n \mu ( n , k ) a_{ k , m } g (
m ) \\
&amp; = \sum_{ k = 1 }^n \mu ( n , k ) f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
$$
<span class="math display">\[\begin{aligned}
c_r &amp; = \sum_{ p , q } [ f ( p , q ) = r ] a_p b_q \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们需要把<span class="math inline">\(f\)</span>分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:<span class="math inline">\(\mid \bigcup_{ i = 1 }^n S_i \mid
= \sum_{ T \subseteq \{ 1 , . . . , n \} } ( - 1 )^{ | T - 1 | } \mid
\bigcap_{ p \in T } S_p \mid\)</span>.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属<span class="math inline">\(m\)</span>个集合<span class="math inline">\(T_1 ,
. . . , T_m\)</span>,而除了这些集合以外的集合,</p>
<p><span class="math display">\[
\begin{aligned}
cnt &amp; = \sum_{ i = 1 }^m ( - 1 )^{ i - 1 } \binom{ m }{ i } \\
&amp; = \binom{ m }{ 0 } - \sum_{ i = 0 }^m ( - 1 )^i \binom{ m }{ i }
\\
&amp; = 1 - [ m = 0 ]
\end{aligned}
\]</span></p>
<p>显然,当这个元素被包含的时候,贡献为<span class="math inline">\(1\)</span>,反之贡献为<span class="math inline">\(0\)</span>.</p>
<p>如果我们定义一类在集合上的函数<span class="math inline">\(F ( S ) =
\sum_{ p \in S } F ( p )\)</span>,那么自然也有:</p>
<p><span class="math display">\[
F ( \bigcup_{ i = 1 }^n S_i ) = \sum_{ T \subseteq \{ 1 , . . . , n \} }
( - 1 )^{ | T | - 1 } F ( \bigcap_{ p \in T } S_p )
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<p><span class="math display">\[
\mid \bigcap_{ i = 1 }^n S_i \mid = | U | - \mid \bigcup_{ i = 1 }^n
\overline{ S_i } \mid
\]</span></p>
<p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程<span class="math inline">\(\sum_{ i = 1 }^n x_i =
m\)</span>,和<span class="math inline">\(n\)</span>个限制条件<span class="math inline">\(x_i \leq b_i\)</span>,其中<span class="math inline">\(m\)</span>和<span class="math inline">\(b_i\)</span>都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><p><span class="math inline">\(U\)</span>是满足<span class="math inline">\(\sum_{ i = 1 }^n x_i =
m\)</span>的所有非负整数解;</p></li>
<li><p>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i = [ x_i \leq b_i ]\)</span>.</p></li>
</ol>
<p>设所有满足<span class="math inline">\(P_i\)</span>的解构成集合<span class="math inline">\(S_i\)</span>,那么我们需要求解的值就是<span class="math inline">\(\mid \bigcap_{ i = 1 }^n S_i \mid\)</span>.而<span class="math inline">\(\mid U \mid\)</span>显然是<span class="math inline">\(\binom{ m + n - 1 }{ n - 1 }\)</span>.我们有:<span class="math inline">\(\mid \bigcap_{ i = 1 }^n S_i \mid = | U | - \mid
\bigcup_{ i = 1 }^n \overline{ S_i } \mid\)</span>.考虑对<span class="math inline">\(\mid \bigcup_{ i = 1 }^n \overline{ S_i }
\mid\)</span>使用容斥原理,注意到<span class="math inline">\(\overline{
S_i }\)</span>的意义是满足<span class="math inline">\(x_{ i } \geq b_{ i
} +
1\)</span>的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件):</p>
<ol type="1">
<li><p><span class="math inline">\(U\)</span>是长度为<span class="math inline">\(n\)</span>的所有排列;</p></li>
<li><p>对于每个变量<span class="math inline">\(i\)</span>,都对应一个<span class="math inline">\(P_i = [ p_i \ne i ]\)</span>.</p></li>
</ol>
<p>注意到所求仍然是<span class="math inline">\(\mid \bigcap_{ i = 1 }^n
S_i \mid\)</span>.于是我们仍然试图<span class="math inline">\(|
\bigcap_{ k = 1 }^m \overline{ S_{ a_k } }
|\)</span>.考虑其意义,也即:有<span class="math inline">\(m\)</span>个位置被确定了,而其它位置没有限制,于是<span class="math inline">\(| \bigcap_{ k = 1 }^m \overline{ S_{ a_k } } | =
\binom{ n }{ m } ( n - m ) !\)</span>.根据容斥,自然有:<span class="math inline">\(d_n = n ! - \sum_{ m = 1 }^n ( - 1 )^{ m - 1 }
\binom{ n }{ m } ( n - m ) ! = n ! \sum_{ m = 0 }^n \cfrac{ ( - 1 )^m }{
m ! }\)</span>.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到<span class="math inline">\(f_i\)</span>表示勒令<span class="math inline">\(i\)</span>对满足条件的方案数.把<span class="math inline">\(k\)</span>的定义改为恰好<span class="math inline">\(k\)</span>对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集<span class="math inline">\(U\)</span>,以及刻画<span class="math inline">\(U\)</span>中元素的<span class="math inline">\(P_i\)</span>(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好<span class="math inline">\(a\)</span>对的方案会被恰好<span class="math inline">\(b\)</span>对的方案计算<span class="math inline">\(\binom{ b }{ a
}\)</span>次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为<span class="math inline">\(k\)</span>的方案贡献为<span class="math inline">\(1\)</span>,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为<span class="math inline">\(k + 1\)</span>的方案贡献为<span class="math inline">\(0\)</span>,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令<span class="math inline">\(ans = f_k\)</span>,第二步除去其中被多算的<span class="math inline">\(k + 1\)</span>,这一步令<span class="math inline">\(ans - = \binom{ k + 1 }{ k } f_{ k + 1
}\)</span>.这个时候,我们再考虑<span class="math inline">\(k +
2\)</span>的贡献:它将在<span class="math inline">\(f_k\)</span>时贡献<span class="math inline">\(\binom{ k + 2 }{ k }\)</span>次,在<span class="math inline">\(f_{ k + 1 }\)</span>时贡献<span class="math inline">\(- \binom{ k + 2 }{ k + 1 } \binom{ k + 1 }{ k } =
- \binom{ k + 2 }{ k } \binom{ 2 }{ 1
}\)</span>次,那它现在的贡献还有:<span class="math inline">\(- \binom{ k
+ 2 }{ k }\)</span>次.以此类推,可以得到<span class="math inline">\(ans =
\sum_{ i = k }^n f_i ( - 1 )^{ i - k } \binom{ i }{ k }\)</span>.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个<span class="math inline">\(P_i\)</span>.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画<span class="math inline">\(P_i\)</span>,因为只有这个时候,我们才能通过分析满不满足<span class="math inline">\(P_i\)</span>的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成<span class="math inline">\(1 / 0\)</span>就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是<span class="math inline">\(O
( 4 ns )\)</span>,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画<span class="math inline">\(P_i = [ use_i \leq d_i
]\)</span>,从而可以用容斥做.复杂度<span class="math inline">\(O ( 4 m +
n 2^4 )\)</span>.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个<span class="math inline">\(n\)</span>个点的无向完全图,设所有的边组成了集合<span class="math inline">\(E\)</span>,他们想取遍<span class="math inline">\(E\)</span>的所有非空子集,对某个集合<span class="math inline">\(S\)</span>有一个估价<span class="math inline">\(f
( S )\)</span>:考虑<span class="math inline">\(n\)</span>个点与<span class="math inline">\(S\)</span>中的边组成的图,我们用<span class="math inline">\(m\)</span>种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么<span class="math inline">\(f ( S
)\)</span>等于这个图的染色方案数.同时,Alice喜欢奇数,所以当<span class="math inline">\(| S |\)</span>为奇数时,Alice的分值加上<span class="math inline">\(f ( S )\)</span>,否则Alice的分值减去<span class="math inline">\(f ( S )\)</span>,求最后的分值.<span class="math inline">\(( n , m \leq 10^6 )\)</span>.</p>
<p>一开始抄题的时候没有写染色而是直接写”设<span class="math inline">\(k\)</span>为连通块个数,则<span class="math inline">\(f ( S ) = m^k\)</span>.”然后发现做不了,因为<span class="math inline">\(| S |\)</span>相同的<span class="math inline">\(f
( S
)\)</span>不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个<span class="math inline">\(m\)</span>,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那<span class="math inline">\(x
\leftrightarrow y \Rightarrow col_x =
col_y\)</span>.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与<span class="math inline">\(-
1\)</span>有关的单位元素(从一开始就是点)和与<span class="math inline">\(f\)</span>有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令<span class="math inline">\(F ( C
)\)</span>表示在<span class="math inline">\(C\)</span>情况下的染色方案,<span class="math inline">\(T_{ ( i , j ) }\)</span>表示满足边<span class="math inline">\(( i , j )\)</span>限制的解集:</p>
<p><span class="math display">\[
ans = \sum_{ \emptyset \ne S \subseteq E } ( - 1 )^{ | S | - 1 } F (
\bigcap_{ ( i , j ) \in S } T_{ ( i , j ) } )
\]</span></p>
<p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出<span class="math inline">\(ans\)</span>的意义:显然是<span class="math inline">\(F ( \bigcup_{ i = 1 }^{ m } P_i
)\)</span>.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是<span class="math inline">\(m^n - m^{ \underline{ n } }\)</span>.</p>
<h5><span id="example6">Example6</span></h5>
<p>求<span class="math inline">\(\varphi ( n )\)</span>.</p>
<p>考虑这么一个事实:假设<span class="math inline">\(n = \prod p_i^{ q_i
}\)</span>,注意到令<span class="math inline">\(P_i = [ \gcd ( i , n ) =
1 ]\)</span>,我们所求也就是<span class="math inline">\(\mid \bigcap_{ i
= 1 }^n S_i
\mid\)</span>.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如<span class="math inline">\(ABCABCAB . . .\)</span>这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于<span class="math inline">\(3\)</span>并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的<span class="math inline">\(1\)</span>,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是<span class="math inline">\(\sum_{ i = 0 }^{
\min ( n , m ) } ( - 1 )^i \binom{ n }{ i } \binom{ m }{ i } i ! ( m + 1
)^{ n - i } ( n + 1 )^{ m - i }\)</span>.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件<span class="math inline">\(( x , y
)\)</span>,表示<span class="math inline">\(a_x = y\)</span>和<span class="math inline">\(a_y = x\)</span>必须满足至少一个,求排列方案数.</p>
<p>首先<span class="math inline">\(i \rightarrow
p_i\)</span>把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为<span class="math inline">\(2\)</span>的链,它自己成环的话是不用<span class="math inline">\(\times 2\)</span>的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是<span class="math inline">\(\times 2\)</span>,所以一个有<span class="math inline">\(1\)</span>个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为<span class="math inline">\(2\)</span>的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:<span class="math inline">\(n^2 - i^2 \leq P_i^2 \leq ( 2 n
)^2 - i^2\)</span>.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为<span class="math inline">\(l_i\)</span>,那么只有上界的答案应该是什么呢?将<span class="math inline">\(l\)</span>从小到大排序,答案就是<span class="math inline">\(\prod_{ i = 0 }^{ 2 n - 1 } ( l_i - i
)\)</span>.(注意到必须满足<span class="math inline">\(l_{ 2 n - 1 } = 2
n - 1\)</span>.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个<span class="math inline">\(\frac{ 1 }{ 4
}\)</span>的圆弧.而通过圆弧的性质不难看出:最终的<span class="math inline">\(l\)</span>分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道<span class="math inline">\(l\)</span>按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照<span class="math inline">\(l\)</span>的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度<span class="math inline">\(O ( n^3 )\)</span>.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>反着写)</p>
<p>设<span class="math inline">\(p = \frac{ 2 k }{ n } , q = n -
p\)</span>.</p>
<p>首先注意到期望<span class="math inline">\(= P [ len \geq 1 ] + P [
len \geq 2 ] + \cdots\)</span>.</p>
<p>考虑如何计算<span class="math inline">\(P [ len \geq x
]\)</span>,如果我们设<span class="math inline">\(a_i\)</span>表示以<span class="math inline">\(i\)</span>作为开头的极长的带劲的长度大于等于<span class="math inline">\(x\)</span>的序列的集合,那么最后无非是要求所有<span class="math inline">\(a\)</span>的并.考虑用容斥做到求所有<span class="math inline">\(a\)</span>的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定<span class="math inline">\(n , k\)</span>和<span class="math inline">\(n\)</span>个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过<span class="math inline">\(k\)</span>.<span class="math inline">\(n \leq
300\)</span>.</p>
<p>著名结论:<span class="math inline">\(n\)</span>个点<span class="math inline">\(m\)</span>个连通块任意连边成树的方案数是<span class="math inline">\(n^{ m - 2 } \prod s\)</span>,其中<span class="math inline">\(s\)</span>是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过<span class="math inline">\(k\)</span>,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于<span class="math inline">\(k\)</span>的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过<span class="math inline">\(k\)</span>,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数<span class="math inline">\(( - 1 )^{ 块 数 - 1 }\)</span>.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于:</p>
<p><span class="math display">\[
\mid \bigcup_{ i = 1 }^n S_i \mid = \sum_{ T \subseteq \{ 1 , . . . , n
\} } ( - 1 )^{ | T - 1 | } \mid \bigcap_{ p \in T } S_p \mid
\]</span></p>
<p>考虑一个特例:<span class="math inline">\(S_i = \{ 1 , 2 , \cdots ,
a_i \}\)</span>,那么上面的式子导出min-max容斥(我们设<span class="math inline">\(S = \{ a_1 , a_2 , \cdots , a_n
\}\)</span>)(第二个式子可以把前缀改成后缀):</p>
<p><span class="math display">\[
\begin{aligned}
\max ( S ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1 )^{ |
T | - 1 } \min ( T ) \\
\min ( S ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1 )^{ |
T | - 1 } \max ( T )
\end{aligned}
\]</span></p>
<p>由于是集合,这个式子在期望意义下同样成立:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \max \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( -
1 )^{ | T | - 1 } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( -
1 )^{ | T | - 1 } E ( \max \{ S \} )
\end{aligned}
\]</span></p>
<p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<p><span class="math display">\[
\begin{aligned}
kth \max \{ S \} &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1
)^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } \min \{ T \} \\
kth \min \{ S \} &amp; = \sum_{ T \subseteq S , T \ne \emptyset } ( - 1
)^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } \max \{ T \} \\
E ( kth \max \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset }
( - 1 )^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } E ( \min \{ T \} ) \\
E ( kth \min \{ S \} ) &amp; = \sum_{ T \subseteq S , T \ne \emptyset }
( - 1 )^{ | T | - k } \binom{ | T | - 1 }{ k - 1 } E ( \max \{ T \} )
\end{aligned}
\]</span></p>
<p>原理是消掉前<span class="math inline">\(k -
1\)</span>大的数字,让他们的贡献为<span class="math inline">\(0\)</span>,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设<span class="math inline">\(tim_i\)</span>为<span class="math inline">\([ i , i + 1
]\)</span>第一次被覆盖的时间,答案就是:</p>
<p><span class="math display">\[
E ( \max_{ i = 1 }^{ n - 1 } \{ tim_i \} ) = \sum_{ T \subseteq \{ 1 , 2
, \cdots , n - 1 \} , T \ne \emptyset } ( - 1 )^{ | T | - 1 } E ( \min_{
j \in T } \{ tim_j \} )
\]</span></p>
<p>设<span class="math inline">\(f ( S
)\)</span>为有多少个区间能覆盖至少一个<span class="math inline">\([ i ,
i + 1 ] , i \in S\)</span>,考虑<span class="math inline">\(E = p_{ [ t
\geq 0 ] } + p_{ [ t \geq 1 ] } + p_{ [ t \geq 2 ] } +
\cdots\)</span>,于是<span class="math inline">\(E ( \min_{ j \in S } \{
tim_j \} ) = \frac{ m }{ f ( S ) }\)</span>.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum_{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne
\emptyset } ( - 1 )^{ | T | - 1 } f ( T ) \\
&amp; = \sum_{ k = 0 }^m \frac{ m }{ k } \sum_{ T \subseteq \{ 1 , 2 ,
\cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k } ( - 1 )^{ | T | - 1
}
\end{aligned}
\]</span></p>
<p>注意到<span class="math inline">\(f ( S
)\)</span>可能不那么好求,我们求<span class="math inline">\(g ( S ) = m -
f ( S )\)</span>,也就是不包含任何一个<span class="math inline">\([ i , i
+ 1 ] , i \in S\)</span>的区间个数,我们有:</p>
<p><span class="math display">\[
ans = \sum_{ k = 0 }^m \frac{ m }{ m - k } \sum_{ T \subseteq \{ 1 , 2 ,
\cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k } ( - 1 )^{ | T | - 1
}
\]</span></p>
<p>这里已经不难写出<span class="math inline">\(O ( n^3
)\)</span>的dp了.</p>
<p>那么怎么优化呢?设<span class="math inline">\(dp_{ i , j
}\)</span>表示只考虑<span class="math inline">\([ 1 , i
]\)</span>时(<span class="math inline">\([ i - 1 , i
]\)</span>必选),<span class="math inline">\(\sum_{ g ( T ) = j } ( - 1
)^{ | T | - 1 }\)</span>的答案,不难发现每次加入一个区间<span class="math inline">\([ l , r ]\)</span>就会让<span class="math inline">\(dp_{ i , j } , i &lt; = l\)</span>对<span class="math inline">\(dp_{ r , j + 1 }\)</span>的贡献乘一个<span class="math inline">\(1\)</span>.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度<span class="math inline">\(O ( nm \log n )\)</span>.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>,其中<span class="math inline">\(T\)</span>在<span class="math inline">\(S\)</span>的右方,给定两条线<span class="math inline">\(y = a\)</span>和<span class="math inline">\(y =
b\)</span>,每次可以向右上或者右下走一步,求不碰线的从<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的方案数.</p>
<p>我们不妨设<span class="math inline">\(A\)</span>表示一定碰了一次上界的方案数,<span class="math inline">\(B\)</span>表示一定碰了一次下界的方案数,<span class="math inline">\(AB\)</span>表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走<span class="math inline">\(- A - B + AB + BA -
ABA - BAB . . .\)</span>.</p>
<p>考虑设步数为<span class="math inline">\(n\)</span>,那显然长度最多为<span class="math inline">\(\cfrac{ n }{ a - b }\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="post-title-link" itemprop="url">博弈论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1
\leq x \leq m \\\)</span>,求<span class="math inline">\(A\)</span>是否能赢.</p>
<p>考虑直接令石子数量为状态,有<span class="math inline">\(SG ( x ) = mex
\{ SG ( y ) | \max \{ 0 , x - m \} \leq y \leq x - 1 \}
\\\)</span>,注意到<span class="math inline">\(SG ( x ) =
0\)</span>当且仅当<span class="math inline">\(x \equiv 0 ( \mod m + 1
)\)</span>.</p>
<p>我们使用数学归纳证明:</p>
<p>当<span class="math inline">\(0 \leq x \leq
m\)</span>时,显然成立.</p>
<p>而对于<span class="math inline">\(x\)</span>,如果<span class="math inline">\(x \equiv 0 ( \mod m + 1 )
\\\)</span>,那么集合<span class="math inline">\(S = \{ y \in \mathbb{ Z
} | \max \{ 0 , x - m \} \leq y \leq x - 1 \}\)</span>中一定<span class="math inline">\(\nexists y\)</span>满足<span class="math inline">\(y \equiv 0 ( \mod m + 1 ) \\\)</span>.</p>
<p>也就是<span class="math inline">\(\nexists y\)</span>满足<span class="math inline">\(SG ( y ) = 0\)</span>,那么<span class="math inline">\(SG ( n ) = 0\)</span>.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果<span class="math inline">\(x\)</span>均等于<span class="math inline">\(0\)</span>一定先手必败.考虑令<span class="math inline">\(w = x_1 \oplus x_2 \oplus . . . \oplus
x_n\)</span>(<span class="math inline">\(w\)</span>即为全游戏的<span class="math inline">\(SG\)</span>值),那么先手必败当且仅当<span class="math inline">\(w = 0 \\\)</span>.</p>
<p>证明:</p>
<p>只需证明当<span class="math inline">\(w \ne
0\)</span>时一定存在一种方法使得<span class="math inline">\(w = 0
\\\)</span>.</p>
<p>考虑<span class="math inline">\(w\)</span>的最高位为第<span class="math inline">\(k\)</span>位,那么一定存在一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>.将它改为<span class="math inline">\(0\)</span>,然后这个<span class="math inline">\(x_i\)</span>的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4>
<p><span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,有<span class="math inline">\(n\)</span>堆石子,第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(x_i\)</span>个石子.每次可以任选不超过<span class="math inline">\(k\)</span>堆取走若干个石子,最后不能取的人输.</p>
<p>将<span class="math inline">\(x_i\)</span>写成二进制,如果每一位的<span class="math inline">\(1\)</span>的个数均是<span class="math inline">\(k
+ 1\)</span>的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4>
<p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于<span class="math inline">\(2\)</span>的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p><span class="math inline">\(SG ( x ) = mex \{ \{ SG ( v ) | x
\rightarrow v \} , \{ SG ( x - i ) \oplus SG ( i ) | 1 \leq i &lt; x \}
\} \\\)</span>.</p>
<p>找一下规律可以发现:</p>
$$
<span class="math display">\[\begin{aligned}
SG ( x ) &amp; = \begin{cases}
x - 1 &amp; x \equiv 0 ( \mod 4 ) \\
x &amp; x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 &amp; x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设当<span class="math inline">\(x \leq 4
k\)</span>时结论成立.</p>
<p>当<span class="math inline">\(x = 4 k +
1\)</span>时,前半部分一定是取遍了<span class="math inline">\([ 1 , 4 k
]\)</span>.</p>
<p>但是一定不存在<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\(a + b =
4 k + 1\)</span>并且<span class="math inline">\(SG ( a ) \oplus SG ( b )
= 4 k + 1\)</span>.讨论一下<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>在<span class="math inline">\(\mod
4\)</span>意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3>
<p><span class="math inline">\(n\)</span>个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用<span class="math inline">\(SG ( u ) = mex \{ SG ( v ) | u
\rightarrow v \}\)</span>.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是<span class="math inline">\(0\)</span>.</p>
<p>首先如果<span class="math inline">\(SG ( u ) = x\)</span>,那么<span class="math inline">\(\forall 0 \leq y &lt; x\)</span>,<span class="math inline">\(\exists v\)</span>使得<span class="math inline">\(u \rightarrow v\)</span>且<span class="math inline">\(SG ( v ) =
y\)</span>.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能<span class="math inline">\(\exists y &gt;
x\)</span>,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个<span class="math inline">\(u
&#39;\)</span>使得<span class="math inline">\(SG ( u &#39; ) =
x\)</span>,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4>
<p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol type="1">
<li><p>游戏的SG函数不为<span class="math inline">\(0\)</span>且游戏中某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</p></li>
<li><p>游戏的SG函数为<span class="math inline">\(0\)</span>且游戏中没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>.</p></li>
</ol>
<p>如果没有单一游戏的SG函数大于<span class="math inline">\(1\)</span>,那么显然游戏的SG函数为<span class="math inline">\(0\)</span>就赢了,否则就输了.</p>
<p>而如果SG函数为<span class="math inline">\(0\)</span>且存在某个单一游戏的SG函数大于<span class="math inline">\(1\)</span>,一定是输的.</p>
<p>因为这个情况下,后手先按照正常<span class="math inline">\(SG\)</span>游戏压着先手,最后一定会剩两堆一样大于<span class="math inline">\(1\)</span>的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4>
<p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在<span class="math inline">\(DAG\)</span>上dp的时候除了<span class="math inline">\(SG\)</span>我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4>
<p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4>
<p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:<span class="math inline">\(SG ( u ) = \bigoplus_{ u \rightarrow
v } ( SG ( v ) + 1 )\)</span>.</p>
<p>考虑归纳假设.如果<span class="math inline">\(u\)</span>只有<span class="math inline">\(v\)</span>一个儿子.那么要么将<span class="math inline">\(v\)</span>子树全删,要么删一部分,有:</p>
<p><span class="math display">\[
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 &lt; SG ( v ) ) = SG ( v )
+ 1
\]</span></p>
<p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的<span class="math inline">\(SG\)</span>为<span class="math inline">\(0\)</span>,而显然<span class="math inline">\(SG\)</span>图中的其它节点的<span class="math inline">\(SG\)</span>均要<span class="math inline">\(+
1\)</span>.</p>
<h4><span id="example4">Example4</span></h4>
<p><span class="math inline">\(n\)</span>个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环<span class="math inline">\(SG = 1\)</span>,偶环<span class="math inline">\(SG = 0\)</span>.</p>
<p>这么考虑:边数为<span class="math inline">\(k\)</span>的链的<span class="math inline">\(SG\)</span>为<span class="math inline">\(k\)</span>.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到<span class="math inline">\(1\)</span>.偶环同理,不可能得到<span class="math inline">\(0\)</span>.</p>
<h4><span id="example5">Example5</span></h4>
<p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,<span class="math inline">\(SG\)</span>值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当<span class="math inline">\(N\)</span>是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当<span class="math inline">\(N\)</span>是斐波那契数时必败,不妨假设<span class="math inline">\(N = N_0 + N_1\)</span>,</p>
<p>考虑将<span class="math inline">\(N\)</span>看成两堆,因为如果第一次取走了大于<span class="math inline">\(N_1\)</span>颗石子,由于<span class="math inline">\(N_0 \leq N_1
\\\)</span>,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在<span class="math inline">\(N_0\)</span>堆取石子,原因是如果取了大于<span class="math inline">\(N_0\)</span>颗石子,由于<span class="math inline">\(N = N_0 + N_1 \leq 3 N_0
\\\)</span>.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取<span class="math inline">\(N_0\)</span>这一堆,如果在这一堆取的过程中,先手一直取得不超过<span class="math inline">\(N_0\)</span>剩下的数,那么根据归纳假设,后手一定可以取走<span class="math inline">\(N_0\)</span>堆的最后一个石子,此时局面变成了只剩<span class="math inline">\(N_1\)</span>颗石子.只要此时先手不能一次取走<span class="math inline">\(N_1\)</span>颗石子,先手就必败.而后手最后一步拿走石子最多会拿走<span class="math inline">\(\frac{ 2 }{ 3 } N_0\)</span>的石子,但是,<span class="math inline">\(\frac{ 4 }{ 3 } N_0 &lt;
N_1\)</span>,因此一定不可能.</p>
<p>否则,仍然是先手取走了<span class="math inline">\(N_0\)</span>全部石子,又当了先手取<span class="math inline">\(N_1\)</span>的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设<span class="math inline">\(N = \sum_{ i = 1 }^k f_{ p_i
}\)</span>,其中<span class="math inline">\(p_1 &lt; p_2 &lt; p_3 &lt; .
. . &lt; p_k \\\)</span>,先手取走<span class="math inline">\(f_{ p_1 }
\\\)</span>.由于<span class="math inline">\(2 f_{ p_1 } &lt; f_{ p_2
}\)</span>,因此后手接下来无论如何不可能取得大于等于<span class="math inline">\(f_{ p_2 } \\\)</span>,问题转化为一堆大小为<span class="math inline">\(f_{ p_2
}\)</span>的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3>
<p>给出一张二分图和起点<span class="math inline">\(S\)</span>,<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点<span class="math inline">\(S\)</span>,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含<span class="math inline">\(S\)</span>,那么<span class="math inline">\(A\)</span>只需要每次走到一个和<span class="math inline">\(S\)</span>匹配的点即可.<span class="math inline">\(B\)</span>无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含<span class="math inline">\(S\)</span>的点,与假设不符.</p>
<p>而如果存在一个匹配不包含<span class="math inline">\(S\)</span>,如果<span class="math inline">\(A\)</span>仍然第一步走到一个和<span class="math inline">\(S\)</span>匹配的点那么<span class="math inline">\(B\)</span>一定能想办法走到一个不在当前<span class="math inline">\(A\)</span>选择的最大匹配中的点而在一个不包含<span class="math inline">\(S\)</span>的最大匹配中的点,于是<span class="math inline">\(B\)</span>必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4>
<p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设<span class="math inline">\(dp_{ S , x } = 0 / 1\)</span>表示目前集合<span class="math inline">\(S\)</span>中的所有人都已经离场了,而目前金条在<span class="math inline">\(x\)</span>手中,金条会不会被抢.显然,如果<span class="math inline">\(\exists y\)</span>满足<span class="math inline">\(dp_{ S \cup \{ x \} , y } =
0\)</span>,也就是金条在<span class="math inline">\(y\)</span>手里不会被抢,那<span class="math inline">\(x\)</span>手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与<span class="math inline">\(S\)</span>匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果<span class="math inline">\(S\)</span>和<span class="math inline">\(x\)</span>并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断<span class="math inline">\(S\)</span>是否一定在其中,只需要先删去<span class="math inline">\(S\)</span>,跑dinic,再在残联网络上加上<span class="math inline">\(S\)</span>,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3>
<h4><span id="example1zr23省选10连-day1clashmas">Example1(zr[23省选10连 day1]
Clashmas)</span></h4>
<p>注意到删点对树形态的影响,考虑重心</p>
<ol type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol start="2" type="1">
<li><span class="math inline">\(n\)</span>为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为<span class="math inline">\(S_A\)</span>,B的点的集合为<span class="math inline">\(S_B\)</span>.以原重心为根建树,设其所有儿子组成的集合为<span class="math inline">\(S_C\)</span>,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当<span class="math inline">\(\sum_{ u \in S_A \cap S_C } siz_u \geq \sum_{ u
\in S_B \cap S_C } siz_u\)</span>.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中<span class="math inline">\(siz\)</span>最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol start="3" type="1">
<li><span class="math inline">\(n\)</span>为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时<span class="math inline">\(n\)</span>为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol start="4" type="1">
<li><span class="math inline">\(n\)</span>为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol start="5" type="1">
<li><span class="math inline">\(n\)</span>为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3>
<h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5>
<p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设<span class="math inline">\(f_i\)</span>为还剩<span class="math inline">\(i\)</span>条蛇的时候能不能吃,那<span class="math inline">\(f_i = 1\)</span>的话,要么<span class="math inline">\(i = 2\)</span>,要么吃完后不是最小的,要么<span class="math inline">\(f_{ i - 1 } = 0\)</span>.</p>
<p>递归做就好了.另外这题需要复杂度<span class="math inline">\(O ( n
)\)</span>,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5>
<p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5>
<p>首先考虑如果有人作为第<span class="math inline">\(n - p +
1\)</span>个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读<span class="math inline">\(n - p\)</span>个人.</p>
<p>继续思考,如果有人作为第<span class="math inline">\(n - 2 p +
1\)</span>个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有<span class="math inline">\(n \mod
p\)</span>个人复读,并且一定是前<span class="math inline">\(n \mod
p\)</span>在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5>
<p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录<span class="math inline">\(f_{ i , j }\)</span>表示当前的<span class="math inline">\(G\)</span>是<span class="math inline">\(i\)</span>,<span class="math inline">\(G\)</span>的倍数还剩下<span class="math inline">\(j\)</span>个,然后做转移,再进一步发现我们只关心<span class="math inline">\(j\)</span>的奇偶性.于是记<span class="math inline">\(f_{ i , 0 / 1 }\)</span>即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5>
<p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在<span class="math inline">\([ l_i , r_i
]\)</span>,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为<span class="math inline">\(0\)</span>.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为<span class="math inline">\(0\)</span>.</p>
<p>换句话说,我们现在有<span class="math inline">\(x_1 , x_2 ,
x_3\)</span>,我们要将其中一个<span class="math inline">\(x_i\)</span>改为<span class="math inline">\(y_i\)</span>,其他不变,使得他们仨异或值为<span class="math inline">\(0\)</span>.和Nim游戏类似,假设他们仨异或值的最高位为<span class="math inline">\(k\)</span>.那么一定有一个<span class="math inline">\(x_i\)</span>的第<span class="math inline">\(k\)</span>位为<span class="math inline">\(1\)</span>,将它改为<span class="math inline">\(0\)</span>,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的<span class="math inline">\([ l_i , r_i
]\)</span>求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5>
<p>Nim游戏,但是每堆石子有一个<span class="math inline">\(K_i\)</span>.如果这堆石子剩<span class="math inline">\(x_i\)</span>个每次最多取<span class="math inline">\(\lfloor \frac{ x_i }{ K_i }
\rfloor\)</span>个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-n k,k)&amp;n(k)\</p>
<p>n k&amp;n=0(k)\</p>
<p>\end{cases}\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于<span class="math inline">\(k\)</span>是否大于<span class="math inline">\(\sqrt{ n }\)</span>讨论一下,如果<span class="math inline">\(k &lt; \sqrt{ n }\)</span>暴力,最多只会做<span class="math inline">\(\sqrt{ n
}\)</span>次.否则,意识到此时可以通过求一个区间<span class="math inline">\([ l , r ]\)</span>,满足<span class="math inline">\(\forall x \in [ l , r ] , \lfloor \frac{ x }{ k }
\rfloor\)</span>均相等,加速一下.这种区间最多只会有<span class="math inline">\(\sqrt{ n }\)</span>个.</p>
<h5><span id="problem7">Problem7</span></h5>
<p>一个数<span class="math inline">\(N\)</span>,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当<span class="math inline">\(N =
2^k\)</span>,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5>
<p>A和B,有<span class="math inline">\(n\)</span>颗石子,每次可以取<span class="math inline">\(x\)</span>颗,其中<span class="math inline">\(1
\leq x \leq \lceil \frac{ n }{ 2 } \rceil \\\)</span>.</p>
<p>仍然令石子数量为状态,注意到<span class="math inline">\(SG ( x ) =
0\)</span>当且仅当<span class="math inline">\(x + 1 = 2^k -
1\)</span>,也即<span class="math inline">\(x = 2^k - 2
\\\)</span>.首先,注意到:</p>
$$
<span class="math display">\[\begin{aligned}
n - \lceil \frac{ n }{ 2 } \rceil &amp; = \lfloor \frac{ n }{ 2 }
\rfloor \\
SG ( n ) &amp; = mex \{ SG ( y ) | \lfloor \frac{ n }{ 2 } \rfloor \leq
y \leq n - 1 \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>设<span class="math inline">\(n = 2^k - w\)</span>,其中:</p>
$$
<span class="math display">\[\begin{aligned}
- 2^{ k - 1 } + 2 &amp; \leq w \leq 2 \\
\lfloor \frac{ 2^k - w }{ 2 } \rfloor &amp; = 2^{ k - 1 } - \lfloor
\frac{ w }{ 2 } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>当<span class="math inline">\(w = 2\)</span>时,原式<span class="math inline">\(= 2^{ k - 1 } - 1 &gt; 2^{ k - 1 } - 2
\\\)</span>.反之.<span class="math inline">\(2^k - 2
\leq\)</span>原式.因此数学归纳即可证明.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">北大相关选拔数学真题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3>
<h4><span id="problem4">Problem4</span></h4>
<p>设<span class="math inline">\(G ( x ) = ( x^2 + x - 1 )^{ 100 } =
\sum_{ k = 0 }^{ 200 } a_k x^k\)</span>,求<span class="math inline">\(2
a_0 - a_1 - a_2 + 2 a_3 - a_4 - a_5 + \cdots + 2 a_{ 198 } - a_{ 199 } -
a_{ 200 }\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑求出<span class="math inline">\(\sum_{ 0 \leq k \leq 66 }{ a_{ 3
k } }\)</span>.直接取三次单位根<span class="math inline">\(\omega_3 = -
\frac{ 1 }{ 2 } + \frac{ \sqrt{ 3 } }{ 2 } i\)</span>,自然有<span class="math inline">\(1 + \omega_3 + \omega_3^2 = 0\)</span>,所以<span class="math inline">\(G ( 1 ) + G ( \omega_3 ) + G ( \omega_3^2 ) = 3
\sum_{ 0 \leq k \leq 66 }{ a_{ 3 k } }\)</span>.</p>
<p>所以答案显然是<span class="math inline">\(G ( \omega_3 ) + G (
\omega_3^2 ) = ( - 2 )^{ 100 } + ( - 2 )^{ 100 } = 2^{ 101
}\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>等差数列中,<span class="math inline">\(a_1 &gt; 0\)</span>,公差<span class="math inline">\(d &lt; 0 , \frac{ a_{ 31 } }{ a_{ 30 } } &lt; -
1\)</span>,求最大的正整数<span class="math inline">\(n\)</span>,使得<span class="math inline">\(S_n
&gt; 0\)</span>.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>显然<span class="math inline">\(S_{ 60 } = 30 ( a_{ 30 } + a_{ 31 } )
&lt; 0 , S_{ 59 } = 59 a_{ 30 } &gt; 0\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>全为整数的等差数列,<span class="math inline">\(d =
4\)</span>,求所有满足<span class="math inline">\(S_n =
2024\)</span>的<span class="math inline">\(n\)</span>的和.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>则<span class="math inline">\(n ( 2 n - 2 + a_1 ) = 2024 = 2^3 \times
11 \times 23\)</span>.显然只要<span class="math inline">\(n |
2024\)</span>即可.</p>
<p>所有<span class="math inline">\(n\)</span>的和自然是<span class="math inline">\(( 1 + 2 + 4 + 8 ) ( 1 + 11 ) ( 1 + 23 ) = 15
\times 12 \times 24 = 4320\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>整数数列<span class="math inline">\(U_n\)</span>满足<span class="math inline">\(U_0 = 1\)</span>,且当<span class="math inline">\(n
\geq 1\)</span>的时候<span class="math inline">\(U_{ n + 1 } U_{ n - 1 }
= kU_n\)</span>,其中<span class="math inline">\(k\)</span>是一个正整数.问能让<span class="math inline">\(U_{ N } = N\)</span>的<span class="math inline">\(k\)</span>的个数有多少个,其中<span class="math inline">\(N = 2024\)</span>.</p>
<h5><span id="solution14">Solution14</span></h5>
<p>则<span class="math inline">\(U_{ n + 1 } = \frac{ kU_n }{ U_{ n - 1
} } , \frac{ U_{ n + 1 } }{ U_n } = k \frac{ U_n }{ U_{ n - 1 } } \frac{
1 }{ U_n }\)</span>.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设<span class="math inline">\(T_n = \prod_{ k = 1 }^n U_k , W_n = U_n \prod_{ k
= 1 }^{ n - 2 } U_k\)</span>.</p>
<p>注意到<span class="math inline">\(W_n = kW_{ n - 1 } , W_1 = U_1 ,
W_n = k^{ n - 1 } U_1\)</span>.又注意到<span class="math inline">\(T_n =
kU_{ n - 1 } W_{ n - 1 } = kW_{ n - 1 } \frac{ T_{ n - 1 } }{ T_{ n - 2
} } = k^{ n - 1 } U_1 \frac{ T_{ n - 1 } }{ T_{ n - 2 } } = ( k^{ n - 1
} U_1 ) ( k^{ n - 2 } U_1 ) \frac{ 1 }{ T_{ n - 3 } }\)</span>,<span class="math inline">\(T_{ n - 3 } = ( k^{ n - 4 } U_1 ) ( k^{ n - 5 }
U_1 ) \frac{ 1 }{ T_{ n - 6 } }\)</span>.所以<span class="math inline">\(T_{ n } = k^6 T_{ n - 6 }\)</span>,所以<span class="math inline">\(U\)</span>存在长度为<span class="math inline">\(6\)</span>的循环节.所以<span class="math inline">\(U_{ N } = \frac{ T_N }{ T_{ N - 1 } } = \frac{ T_2
}{ T_1 } = U_2 = kU_1\)</span>.(其实直接暴力找循环节也是可以的)</p>
<p>所以<span class="math inline">\(k\)</span>需要是<span class="math inline">\(N\)</span>的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设<span class="math inline">\(w = U_1\)</span>,则<span class="math inline">\(U\)</span>的前六项是:<span class="math inline">\(1
, w , kw , k^2 , \frac{ k^2 }{ w } , \frac{ k }{ w }\)</span>.要求<span class="math inline">\(kw = N , w | k\)</span>,所以<span class="math inline">\(( 11 \times 23 ) | k\)</span>,<span class="math inline">\(k \equiv 0 \pmod{ 4 }\)</span>.所以<span class="math inline">\(k = 4 \times 11 \times 23\)</span>或<span class="math inline">\(k = 8 \times 11 \times 23\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>求使方程<span class="math inline">\(\lfloor \frac{ 10^n }{ x }
\rfloor = N = 2024\)</span>恰有两个整数解的正整数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
N &amp; \leq \frac{ 10^n }{ x } &lt; N + 1 \\
xN &amp; \leq 10^n &lt; x ( N + 1 ) \\
\frac{ 10^n }{ N + 1 } &amp; &lt; x \leq \frac{ 10^n }{ N } \\
\lfloor \frac{ 10^n }{ N + 1 } \rfloor &amp; &lt; x \leq \lfloor \frac{
10^n }{ N } \rfloor \\
\lfloor \frac{ 10^n }{ N } \rfloor - \lfloor \frac{ 10^n }{ N + 1 }
\rfloor &amp; = 2 \\
\frac{ 10^n }{ N ( N + 1 ) } - \frac{ 10^n \bmod N }{ N } + \frac{ 10^n
\bmod{ ( N + 1 ) } }{ N + 1 } &amp; = 2
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(\lfloor \frac{ 10^n }{ N ( N + 1 ) }
\rfloor = 1 , 2 , 3\)</span>.而<span class="math inline">\(N ( N + 1 ) =
4098600\)</span>,所以只有<span class="math inline">\(n =
7\)</span>可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是<span class="math inline">\(5 \times 3 ! = 30\)</span>.</p>
<h4><span id="problem19">Problem19</span></h4>
<p><span class="math inline">\(f ( x ) = \lfloor 2 x \rfloor + \lfloor 4
x \rfloor + \lfloor 6 x \rfloor + \lfloor 8 x \rfloor , x \in \mathbb{ R
}\)</span>,求其不超过<span class="math inline">\(n =
2024\)</span>的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>显然<span class="math inline">\(f ( x + 1 ) = f ( x ) +
20\)</span>,因此我们先考虑<span class="math inline">\(x \in [ 0 , 1
)\)</span>的情况.</p>
<p>手动枚举一下知道此时<span class="math inline">\(f ( x
)\)</span>有<span class="math inline">\(12\)</span>种不同的取值,前六种是<span class="math inline">\(\{ 0 , 1 , 2 , 4 , 5 , 6
\}\)</span>,后六种对应了前六种<span class="math inline">\(+
10\)</span>.而<span class="math inline">\(2024 = 101 \times 20 +
4\)</span>,所以共有<span class="math inline">\(101 \times 12 - 1 + 4 =
1215\)</span>种取值.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>从<span class="math inline">\([ 1 , n ] , n =
2024\)</span>中分别独立随机两个正整数(可以相同)<span class="math inline">\(a , b\)</span>,则求<span class="math inline">\(3^a
+ 7^b \equiv 8 \pmod{ 10 }\)</span>的概率.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>考虑<span class="math inline">\(\varphi ( 10 ) =
4\)</span>,所以原题答案等价于<span class="math inline">\(n =
4\)</span>的时候的答案.在这<span class="math inline">\(16\)</span>中可能性中满足条件的只有三种,概率为<span class="math inline">\(\frac{ 3 }{ 16 }\)</span>.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3>
<h4><span id="problem3">Problem3</span></h4>
<p>已知<span class="math inline">\(a_1 = \frac{ 5 }{ 2 } , a_{ n + 1 } =
a_n^2 - 2\)</span>,求<span class="math inline">\(\lfloor a_n \rfloor
\bmod 7 , n = 2023\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>这个一看就不是好解的,想都别想直接数学归纳,注意到<span class="math inline">\(a_n = \frac{ 4^{ 2^{ n - 1 } } + 1 }{ 2^{ 2^{ n -
1 } } }\)</span>,那么<span class="math inline">\(\lfloor a_n \rfloor =
2^{ 2^{ n - 1 } }\)</span>.</p>
<p>而<span class="math inline">\(\varphi ( 7 ) = 6 , \varphi ( 6 ) =
2\)</span>.由扩展欧拉定理,立刻有:<span class="math inline">\(2^{ 2^{
2022 } } \equiv 2^{ 2^{ 2022 } \bmod 6 } \equiv 2^{ 2^{ 6 } } \equiv 16
\equiv 2 \pmod{ 7 }\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(50\)</span>个队伍两两打比赛,胜一场积分<span class="math inline">\(+ 1\)</span>,负一场积分不变,无平局.</p>
<p>且任取<span class="math inline">\(27\)</span>支队伍,其中一定有一支队伍负于其它的<span class="math inline">\(26\)</span>支,也一定有一支队伍胜于其它的<span class="math inline">\(26\)</span>支.</p>
<p>问<span class="math inline">\(50\)</span>支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>答案是<span class="math inline">\(50\)</span>.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都<span class="math inline">\(\leq
27\)</span>的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都<span class="math inline">\(&gt;
27\)</span>,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为<span class="math inline">\(k\)</span>的简单环,由鸽笼原理,剩下的<span class="math inline">\(n - k\)</span>个点中至少有<span class="math inline">\(\frac{ n - k }{ 2 }\)</span>个点对着<span class="math inline">\(k\)</span>个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要<span class="math inline">\(k + \frac{ n - k }{ 2 } \geq
27\)</span>即可,此时<span class="math inline">\(k \geq
4\)</span>即可.由于这是竞赛图,显然存在长度为<span class="math inline">\(4\)</span>的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为<span class="math inline">\(u\)</span>.我们任意取一个击败过它的点(如果有的话),假设为<span class="math inline">\(v\)</span>,再取<span class="math inline">\(25\)</span>个被<span class="math inline">\(u\)</span>击败的点(显然这些点存在),设这些点集为<span class="math inline">\(S\)</span>.则<span class="math inline">\(u , v ,
S\)</span>组成的集合中,有一个点可以击败其它所有点,根据假设,只能是<span class="math inline">\(v\)</span>.由此,可以知道,只要是<span class="math inline">\(u\)</span>能击败的点,<span class="math inline">\(v\)</span>一定能击败,而且<span class="math inline">\(v\)</span>能击败<span class="math inline">\(u\)</span>,因此<span class="math inline">\(\deg_v
&gt; \deg_u\)</span>,与假设不符.因此一定不存在一个<span class="math inline">\(v\)</span>可以击败<span class="math inline">\(u\)</span>.删掉<span class="math inline">\(u\)</span>后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>一只蚂蚁第一天在<span class="math inline">\(( 0 , 0
)\)</span>,第<span class="math inline">\(k +
1\)</span>天向上下左右随机一个方向移动<span class="math inline">\(\frac{
1 }{ 4^k }\)</span>单位,求第<span class="math inline">\(n\)</span>天的可能位置数量,<span class="math inline">\(n = 2023\)</span>.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>不妨设第<span class="math inline">\(n\)</span>天不同位置数量为<span class="math inline">\(S_n\)</span>,显然只要前面岔开了,后面永远无法走到一个点.所以<span class="math inline">\(S_1 = 1 , S_{ n + 1 } = 4 S_n , S_{ 2023 } = 4^{
2022 }\)</span>.</p>
<h4><span id="problem10">Problem10</span></h4>
<p>集合<span class="math inline">\(U = \{ 1 , 2 , \cdots , n \} , n =
10\)</span>,求<span class="math inline">\(U\)</span>中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5>
<p>集合是无序的,这个很难搞,我们先从<span class="math inline">\(U\)</span>中把<span class="math inline">\(1\)</span>去掉最后再加上.</p>
<p>先考虑可以重复放<span class="math inline">\(1\)</span>的情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n \sum_{ j = 1 }^{ n } \sum_{ k = 1 }^{ n } [ \gcd ( i ,
j ) &amp; = 1 ] [ \gcd ( i , k ) = 1 ] [ \gcd ( j , k ) = 1 ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从<span class="math inline">\(1 , 3 , 5 , 7
, 9\)</span>中选,答案应该是<span class="math inline">\(1 + 2 \binom{ 3
}{ 2 } = 7\)</span>.</p>
<p>接下来考虑选一个偶数,如果选<span class="math inline">\(2 , 4 ,
8\)</span>是等价的,答案此时是<span class="math inline">\(3 ( \binom{ 5
}{ 2 } - 1 ) = 27\)</span>.如果选<span class="math inline">\(6\)</span>的话答案是<span class="math inline">\(\binom{ 3 }{ 2 } = 3\)</span>.如果选<span class="math inline">\(10\)</span>的话方案数是<span class="math inline">\(\binom{ 4 }{ 2 } - 1 =
5\)</span>,加起来方案数是<span class="math inline">\(42\)</span>.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>集合<span class="math inline">\(U = \{ 1 , 2 , \cdots , n \} , n =
366\)</span>,则<span class="math inline">\(U\)</span>的互不相交且各元素之和为<span class="math inline">\(17\)</span>的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5>
<p>考虑<span class="math inline">\(\lfloor \frac{ 366 }{ 17 } \rfloor =
21 , 366 \equiv 9 \pmod{ 17 }\)</span>.答案显然是<span class="math inline">\(21 \times 8 + 10 + 1 = 179\)</span>个.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>三个互不相同的数的<span class="math inline">\(\gcd = 20 , \text{ lcm
} = 20000\)</span>,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然等价于<span class="math inline">\(\gcd = 1 , \text{ lcm } = 1000
= 2^3 \times 5^3\)</span>.先只分析其中一个质因子,方案应该是<span class="math inline">\(( 0 , 0 , 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , (
0 , 3 , 3 )\)</span>,打乱一下顺序的话就共有<span class="math inline">\(3
+ 6 + 6 + 3 = 18\)</span>种方案.如果可以重复,平方一下得到<span class="math inline">\(324\)</span>.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有<span class="math inline">\(2 \times 2 \times 3 =
12\)</span>种,于是答案为<span class="math inline">\(312\)</span>.</p>
<h4><span id="problem14">Problem14</span></h4>
<p>求<span class="math inline">\(\lfloor \frac{ k^2 }{ n } \rfloor , k
\in [ 1 , n ] , n = 2023\)</span>种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5>
<p><span class="math display">\[
\begin{aligned}
\lfloor \frac{ k^2 }{ n } \rfloor &amp; = d \\
d &amp; \leq \frac{ k^2 }{ n } &lt; d + 1 \\
nd &amp; \leq k^2 &lt; n ( d + 1 )
\end{aligned}
\]</span></p>
<p>由于两个完全平方数的差是固定的,不妨猜测存在一个<span class="math inline">\(k_0\)</span>,<span class="math inline">\(\leq
k_0\)</span>的<span class="math inline">\(k\)</span>会扎堆,但是这些<span class="math inline">\(d\)</span>全都能取到,<span class="math inline">\(&gt; k_0\)</span>的则不会有两个<span class="math inline">\(k\)</span>得到相同的元素.所以前者统计不同的<span class="math inline">\(d\)</span>,后者统计不同的<span class="math inline">\(k\)</span>考虑<span class="math inline">\(( k + 1
)^2 - k^2 = 2 k + 1\)</span>.分界线应该是<span class="math inline">\(k_0
= 1011\)</span>.</p>
<p>所以答案应该是<span class="math inline">\(n - k_0 + \lfloor \frac{
k_0^2 }{ 2 k_0 + 1 } \rfloor + 1 = 1012 + 506 = 1518\)</span>.</p>
<h4><span id="problem15">Problem15</span></h4>
<p>对四元组<span class="math inline">\(( a , b , c , d
)\)</span>计数,满足<span class="math inline">\(101 | ( a + b + c + d
)\)</span>且<span class="math inline">\(0 &lt; a &lt; b &lt; c &lt; d
\leq 101\)</span>.</p>
<h5><span id="solution15">Solution15</span></h5>
<p>这题真的厉害啊.</p>
<p>不妨设<span class="math inline">\(S_k\)</span>为满足<span class="math inline">\(( a + b + c + d ) \equiv k \pmod{ 101
}\)</span>的满足<span class="math inline">\(0 &lt; a &lt; b &lt; c &lt;
d \leq 101\)</span>的四元组数量.不难发现<span class="math inline">\(\sum
S_k = \binom{ 101 }{ 4 }\)</span>.</p>
<p>注意到<span class="math inline">\(( a , b , c , d ) \mapsto ( a + 1 ,
b + 1 , c + 1 , d + 1 )\)</span>,注意这里是<span class="math inline">\(\pmod{ 101
}\)</span>意义下的加法,这是一个双射,所以<span class="math inline">\(S_{
k } = S_{ k + 4 }\)</span>,下标同样也是<span class="math inline">\(\pmod{ 101 }\)</span>意义下进行的.又因为<span class="math inline">\(\gcd ( 101 , 4 ) = 1\)</span>,所以所有的<span class="math inline">\(S_k\)</span>均相等.<span class="math inline">\(S_0
= \frac{ \binom{ 101 }{ 4 } }{ 101 } = 40425\)</span>.</p>
<h4><span id="problem16">Problem16</span></h4>
<p>问方程<span class="math inline">\(x \lfloor x \rfloor =
6\)</span>的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5>
<p><span class="math inline">\(6 = x \lfloor x \rfloor \geq \lfloor x
\rfloor^2\)</span>,所以<span class="math inline">\(\lfloor x \rfloor =
\pm 1 , \pm 2\)</span>.显然都不可以.所以个数为<span class="math inline">\(0\)</span>.</p>
<h4><span id="problem17">Problem17</span></h4>
<p>设<span class="math inline">\(R ( n ) = \sum_{ k = 2 }^{ 10 } ( n
\bmod k )\)</span>,求满足<span class="math inline">\(R ( n ) = R ( n + 1
)\)</span>的十进制下的两位数<span class="math inline">\(n\)</span>的个数.</p>
<h5><span id="solution17">Solution17</span></h5>
<p>从<span class="math inline">\(R ( n )\)</span>到<span class="math inline">\(R ( n + 1 )\)</span>,应该是加了若干个<span class="math inline">\(1\)</span>,然后又丢了几个<span class="math inline">\(k -
1\)</span>这样的.那就一定需要丢掉的数字之和为<span class="math inline">\(9\)</span>.枚举一下,丢了的只有可能是以下情况:<span class="math inline">\(( 9 ) , ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 +
3 + 2 )\)</span>,分别对应了<span class="math inline">\(n +
1\)</span>应该是分别以下数的倍数<span class="math inline">\(( 9 ) , ( 14
) , ( 6 ) , ( 20 ) , ( 12
)\)</span>,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:<span class="math inline">\(( 7 + 2
)\)</span>,并且分别不能是以下数字的倍数<span class="math inline">\(( 3 ,
4 , 5 )\)</span>.</p>
<p>取一下的话<span class="math inline">\(n + 1\)</span>可以是:<span class="math inline">\(14 , 98\)</span>,<span class="math inline">\(n =
13 , 97\)</span>,验证一下均合法,所以答案为<span class="math inline">\(2\)</span>.</p>
<h4><span id="problem18">Problem18</span></h4>
<p>已知<span class="math inline">\(a &lt; b &lt; c &lt;
d\)</span>,而<span class="math inline">\(x , y , z , w\)</span>是<span class="math inline">\(a , b , c , d\)</span>的一个排列,求<span class="math inline">\(( x - y )^2 + ( y - z )^2 + ( z - w )^2 + ( w - x
)^2\)</span>得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5>
<p>圆排列个数是<span class="math inline">\(3 ! =
6\)</span>个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是<span class="math inline">\(( x , y , z , w ) , ( x , z , w , y ) , ( x , w ,
y , z )\)</span>.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( x - y )^2 + ( y - z )^2 + ( z - w )^2 + ( w - x )^2 \\
= &amp; 2 ( x^2 + z^2 + y^2 + w^2 ) - 2 ( xy + yz + zw + wx )
\end{aligned}
\]</span></p>
<p>显然只要<span class="math inline">\(xy + yz + zw +
wx\)</span>不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4>
<p>已知<span class="math inline">\(0 &lt; x_1 &lt; x_2 &lt; \cdots &lt;
x_9\)</span>且<span class="math inline">\(\sum_{ k = 1 }^9 x_k =
220\)</span>,在<span class="math inline">\(\sum_{ k = 1 }^5
x_k\)</span>最大的前提下,最小化<span class="math inline">\(x_9 -
x_1\)</span>.</p>
<h5><span id="solution19">Solution19</span></h5>
<p>不妨枚举一下<span class="math inline">\(x_5\)</span>选啥,设<span class="math inline">\(f ( S , m , k )\)</span>表示选出<span class="math inline">\(k\)</span>个互不相同的数,使得它们<span class="math inline">\(\leq m\)</span>且总和为<span class="math inline">\(S\)</span>,是否可行.不难发现<span class="math inline">\(f ( S , m , k ) = [ \frac{ k ( k + 1 ) }{ 2 } \leq
S \leq \frac{ k ( 2 m - k + 1 ) }{ 2 } ]\)</span>.</p>
<p>那我们要求的就是:</p>
<p><span class="math display">\[
\begin{aligned}
\max_{ 5 \leq x_5 } \{ S | f ( 220 - 4 x_5 - S , + \infty , 4 ) &amp; =
1 \land f ( S - x_5 , x_5 - 1 , 4 ) = 1 \} \\
&amp; = \max_{ 5 \leq x_5 } \{ S | 4 x_5 + S \leq 210 \land 10 + x_5
\leq S \leq 5 x_5 - 10 \} \\
&amp; = \max_{ 5 \leq x_5 } ( \min \{ 5 x_5 - 10 , 210 - 4 x_5 \} )
\end{aligned}
\]</span></p>
<p>立刻得到<span class="math inline">\(x_5 = 24 , 25 , S =
110\)</span>,那么后面的选法就一定了,后面四个数一定是<span class="math inline">\(26 , 27 , 28 , 29\)</span>,只需要让<span class="math inline">\(x_1\)</span>最大即可</p>
<p><span class="math inline">\(x_5 = 24\)</span>时,此时最优显然是<span class="math inline">\(20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 ,
29\)</span>,<span class="math inline">\(x_9 - x_1 = 9\)</span>.</p>
<h4><span id="problem20">Problem20</span></h4>
<p>有一个<span class="math inline">\(n\)</span>边形,其中有<span class="math inline">\(\binom{ n }{ 2
}\)</span>条对角线,不存在三线交于一点的情况,问这些对角线将该<span class="math inline">\(n\)</span>边形分成了多少个部分.<span class="math inline">\(n = 10\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了<span class="math inline">\(\binom{ n }{ 4
}\)</span>个点(任意四个点有且只有一种交法),每交一个点就会多出<span class="math inline">\(2\)</span>条边,所以多出来了<span class="math inline">\(2 \binom{ n }{ 4 } + \frac{ n ( n - 3 ) }{ 2
}\)</span>条边.</p>
<p>考虑内部的若干个部分一定是<span class="math inline">\(a_3\)</span>个三角形,<span class="math inline">\(a_4\)</span>个四边形,…,<span class="math inline">\(a_k\)</span>个<span class="math inline">\(k\)</span>边形,总之我们发现:</p>
<p><span class="math display">\[
\begin{cases}
\sum_{ j = 3 }^k ( j - 2 ) \pi a_j = ( n - 2 ) \pi + 2 \pi \binom{ n }{
4 } \\
\sum_{ j = 3 }^k ja_j = n + 4 \binom{ n }{ 4 } + n ( n - 3 )
\end{cases}
\]</span></p>
<p>两式得到:<span class="math inline">\(\sum_{ j = 3 }^k a_j = \frac{ (
n - 1 ) ( n - 2 ) }{ 2 } + \binom{ n }{ 4 }\)</span>.</p>
<p><span class="math inline">\(n = 10\)</span>的时候,答案为<span class="math inline">\(246\)</span>.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \lfloor \frac{ 19^i }{
20 } \rfloor \bmod 7 , n = 2024\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ i = 1 }^n \lfloor \frac{ 19^i }{ 20 } \rfloor \\
= &amp; \sum_{ i = 1 }^n \lfloor \frac{ \sum_{ k = 0 }^i 20^k ( - 1 )^{
i - k } \binom{ i }{ k } }{ 20 } \rfloor \\
= &amp; - \lfloor \frac{ n }{ 2 } \rfloor + \sum_{ i = 1 }^{ n } \frac{
19^i - ( - 1 )^i }{ 20 } \\
= &amp; - \lfloor \frac{ n }{ 2 } \rfloor + \frac{ \frac{ 19 }{ 18 } (
19^n - 1 ) - ( \frac{ ( - 1 )^n - 1 }{ 2 } ) }{ 20 }
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(n = 2024\)</span>并<span class="math inline">\(\bmod 7\)</span>,原式为:</p>
<p><span class="math display">\[
\equiv - 4 + \frac{ 5 }{ 4 } ( 1 - 5^n ) \equiv - 4 + 3 ( 1 - 5^n )
\]</span></p>
<p>注意到<span class="math inline">\(2024 \bmod 6 = 2\)</span>,原式<span class="math inline">\(\equiv - 4 - 9 \equiv 1\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>求长度为<span class="math inline">\(n\)</span>的排列个数,使得排列中<span class="math inline">\(\nexists i \in [ 1 , n - 1 ] , a_i = a_{ i + 1 } -
1\)</span>.<span class="math inline">\(n = 8\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>一眼容斥,也就是每个长度为<span class="math inline">\(k\)</span>的连续段的容斥系数应该是<span class="math inline">\(( - 1 )^{ k - 1 }\)</span>.那么设分成了<span class="math inline">\(w\)</span>个段,总的容斥系数应该是<span class="math inline">\(( - 1 )^{ n - w }\)</span>,答案就是<span class="math inline">\(f_{ n &#39; } = \sum_{ w = 1 }^n ( - 1 )^{ n - w }
w ! \binom{ n - 1 }{ w - 1 } = \sum_{ w = 0 }^{ n &#39; } ( - 1 )^{ n
&#39; - w } \binom{ n &#39; }{ w } ( w + 1 ) ! = n &#39; ! \sum_{ w = 0
}^{ n &#39; } \frac{ ( - 1 )^w }{ w ! } ( n &#39; - w + 1
)\)</span>,此时已经能算出答案是<span class="math inline">\(16687\)</span>.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设<span class="math inline">\(g_n\)</span>为错排数量,显然有<span class="math inline">\(f_{ n } = nf_{ n - 1 } + g_{ n
}\)</span>,立刻算出答案是<span class="math inline">\(16687\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>已知数列<span class="math inline">\(1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4
, 4 , \cdots\)</span>,求其第<span class="math inline">\(n\)</span>项<span class="math inline">\(\bmod
5\)</span>的值,<span class="math inline">\(n = 2024\)</span>.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑第一个值为<span class="math inline">\(k\)</span>的地方应该在哪里.显然<span class="math inline">\(a_{ \frac{ k ( k - 1 ) }{ 2 } + 1 } =
k\)</span>.注意到<span class="math inline">\(a_{ 2081 } =
65\)</span>,所以<span class="math inline">\(a_n = 64\)</span>,其<span class="math inline">\(\bmod 5 = 4\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>求四元组<span class="math inline">\(( a_1 , a_2 , a_3 , a_4
)\)</span>的个数,满足<span class="math inline">\(a_1 , a_2 , a_3 , a_4
\in \{ 1 , 2 , 3 \}\)</span>,且<span class="math inline">\(10 &lt; a_1
a_2 a_3 a_4 &lt; 20\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>排个序按照字典序开搜,只有三种可能:<span class="math inline">\(\{ 3 ,
3 , 2 , 1 \} , \{ 3 , 2 , 2 , 1 \} , \{ 2 , 2 , 2 , 2
\}\)</span>,打乱顺序的话就有<span class="math inline">\(25\)</span>种可能.</p>
<h4><span id="problem8">Problem8</span></h4>
<p>求<span class="math inline">\(\mathbb{ R }\)</span>上方程<span class="math inline">\(x^2 - 13 \lfloor x \rfloor + 11 =
0\)</span>的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5>
<p>首先注意到<span class="math inline">\(\lfloor x \rfloor = \frac{ x^2
+ 11 }{ 13 }\)</span>,那么自然有方程组:</p>
<p><span class="math display">\[
\begin{cases}
\frac{ x^2 + 11 }{ 13 } \leq x \\
x &lt; \frac{ x^2 + 11 }{ 13 } + 1
\end{cases}
\]</span></p>
<p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑<span class="math inline">\(x^2 \equiv 2 \pmod{ 13
}\)</span>这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设<span class="math inline">\(x = \sqrt{ 2 + 13 k
}\)</span>的形式,带入有不等式:</p>
<p><span class="math display">\[
\begin{aligned}
k - x + 1 &amp; \leq 0 &lt; k - x + 2 \\
1 &amp; \leq \sqrt{ 2 + 13 k } - k &lt; 2 \\
\begin{cases}
0 &lt; k^2 - 9 k + 2 \\
k^2 - 11 k - 1 \leq 0
\end{cases}
\end{aligned}
\]</span></p>
<p>冷静一下!注意到<span class="math inline">\(0 \leq k \leq
13\)</span>,又根据第一个不等式得知大部分<span class="math inline">\(k\)</span>应该会很大,开始暴力枚举一下,合法的情况有:<span class="math inline">\(k = 0 , 9 , 10 , 11\)</span>,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4>
<p>在一个体积为<span class="math inline">\(1\)</span>的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积<span class="math inline">\(\leq \frac{ 1 }{ 8 }\)</span>的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5>
<p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积<span class="math inline">\(\leq \frac{ 1 }{ 8 }\)</span>.考虑设这个点是<span class="math inline">\(( x , x , h )\)</span>,那么必然有<span class="math inline">\(\begin{cases}( 1 - h ) x^2 &gt; \frac{ 1 }{ 8 } \\
h ( 1 - x )^2 &gt; \frac{ 1 }{ 8 }\end{cases}\)</span>,化简,只要<span class="math inline">\(8 &gt; \frac{ 1 }{ x^2 } + \frac{ 1 }{ ( 1 - x )^2
}\)</span>即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取<span class="math inline">\(( 0 . 5
, 0 . 5 , 0 . 1 )\)</span>即可.那么是不是可以证明答案一定<span class="math inline">\(&gt; 3\)</span>呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积<span class="math inline">\(\leq \frac{ 1 }{ 8
}\)</span>的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为<span class="math inline">\(( x , y , h ) , x , y , h \leq \frac{ 1 }{ 2
}\)</span>,然后证明<span class="math inline">\(8 &gt; \frac{ 1 }{ xy } +
\frac{ 1 }{ ( 1 - x ) ( 1 - y ) } , x , y \leq \frac{ 1 }{ 2
}\)</span>这个不等式无解即可.</p>
<p>由基本不等式,<span class="math inline">\(\frac{ 1 }{ xy } + \frac{ 1
}{ ( 1 - x ) ( 1 - y ) } \geq 2 \sqrt{ \frac{ 1 }{ x ( 1 - x ) y ( 1 - y
) } } \geq 2 \sqrt{ 4 \times 4 } = 8\)</span>,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4>
<p>设<span class="math inline">\(S ( n )\)</span>表示正整数<span class="math inline">\(n\)</span>的十进制数码和,求满足<span class="math inline">\(S ( n ) \equiv S ( n + 1 ) \equiv 0 \pmod{ 5
}\)</span>的最小的<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution11">Solution11</span></h5>
<p>显然必须发生进位,不妨设<span class="math inline">\(n = 10^k a + 10^k
- 1\)</span>,<span class="math inline">\(a \ne 9 \pmod{ 10
}\)</span>,<span class="math inline">\(S ( n ) = S ( a ) + 9 k , S ( n +
1 ) = S ( a ) + 1\)</span>,</p>
<p>此时显然有<span class="math inline">\(9 k - 1 \equiv 0 \pmod{ 5
}\)</span>,<span class="math inline">\(k \equiv 4 \pmod{ 5
}\)</span>.<span class="math inline">\(n_{ \min } = 49999\)</span>.</p>
<h4><span id="problem12">Problem12</span></h4>
<p>求满足以下条件的最大的正整数<span class="math inline">\(n\)</span>:十进制下每一位数字互不相同,且<span class="math inline">\(\forall m , 10^m \leq n , \lfloor \frac{ n }{ 10^m
} \rfloor | n\)</span>.</p>
<h5><span id="solution12">Solution12</span></h5>
<p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是<span class="math inline">\(0\)</span>.</p>
<p>不妨设其为<span class="math inline">\(\overline{ ab
}\)</span>,其中<span class="math inline">\(b = 10 c\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(b\)</span>的因子,不妨枚举一下<span class="math inline">\(k = \frac{ b }{ a }\)</span>.注意到因为<span class="math inline">\(a\)</span>中不能有<span class="math inline">\(0\)</span>,所以<span class="math inline">\(k \in
\{ 2 , 4 , 5 , 8 \}\)</span>.取<span class="math inline">\(k =
2\)</span>试出来<span class="math inline">\(3570\)</span>是合法的,而且显然<span class="math inline">\(k \in \{ 4 , 5 , 8
\}\)</span>的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4>
<p><span class="math inline">\(a_1 = \sqrt{ 2 } , a_{ n + 1 } = \lfloor
a_n \rfloor + \frac{ 1 }{ a_n - \lfloor a_n \rfloor }\)</span>,求<span class="math inline">\(\sum_{ k = 1 }^{ n } a_k , n = 2024\)</span>.</p>
<h5><span id="solution20">Solution20</span></h5>
<p>这一看就是个环,设<span class="math inline">\(a_n = b_n + c_n \sqrt{ 2
}\)</span>.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<p><span class="math display">\[
\begin{cases}
a_1 = 0 + \sqrt{ 2 } \\
a_2 = 2 + \sqrt{ 2 } \\
a_3 = 4 + \sqrt{ 2 } \\
\cdots
\end{cases}
\]</span></p>
<p>容易猜测<span class="math inline">\(b_n = 2 ( n - 1 ) , c_n =
1\)</span>.也就是<span class="math inline">\(a_n = 2 ( n - 1 ) + \sqrt{
2 }\)</span>,数学归纳一下即可.</p>
<p>那么<span class="math inline">\(\sum_{ k = 1 }^n a_k = n ( n - 1 ) +
n \sqrt{ 2 }\)</span>,带入<span class="math inline">\(n =
2024\)</span>即可.</p>
<h3><span id="2022图选">2022图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol type="1">
<li><p>任意两个正方形至多有一个顶点重合</p></li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol type="1">
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p></li>
<li><p>边可以相交,放到正十二边形的边上.</p></li>
</ol>
<h4><span id="problem2">Problem2</span></h4>
<p>求<span class="math inline">\(\lfloor ( \frac{ 1 + \sqrt{ 5 } }{ 2 }
)^{ 12 } \rfloor\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>考虑<span class="math inline">\(( \frac{ 1 + \sqrt{ 5 } }{ 2 } )^3 =
2 + \sqrt{ 5 }\)</span>,<span class="math inline">\(\lfloor ( \frac{ 1 +
\sqrt{ 5 } }{ 2 } )^{ 12 } \rfloor = 161 + \lfloor 72 \sqrt{ 5 } \rfloor
= 321\)</span>.</p>
<p>也可以考虑类似斐波那契数列,取<span class="math inline">\(f_n = (
\frac{ 1 + \sqrt{ 5 } }{ 2 } )^{ n } + ( \frac{ 1 - \sqrt{ 5 } }{ 2 }
)^{ n }\)</span>,其满足<span class="math inline">\(f_n = f_{ n - 1 } +
f_{ n - 2 } , f_0 = 2 , f_1 = 1\)</span>,取<span class="math inline">\(f_{ 12 } - 1\)</span>就是答案<span class="math inline">\(321\)</span>.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于一个加法乘法环,要求你利用:</p>
<ol type="1">
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p></li>
<li><p>加法结合律、逆元.</p></li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>倒反天罡题.</p>
<p>注意到<span class="math inline">\(( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a
+ 1 )\)</span>,所以<span class="math inline">\(a + b = b +
a\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你<span class="math inline">\(n\)</span>个数集<span class="math inline">\(a_i\)</span>,其中<span class="math inline">\(| a_i
| = i + 1\)</span>,要你选出<span class="math inline">\(n\)</span>个两两不同的数字满足<span class="math inline">\(x_i \in a_i\)</span>,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是<span class="math inline">\(2^n\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice和Bob博弈.Alice先选一个数<span class="math inline">\(m\)</span>,然后Bob选一个数<span class="math inline">\(n ( n &gt; m )\)</span>,并构造一个<span class="math inline">\(n\)</span>个点的竞赛图.Alice如果能从中选出<span class="math inline">\(m\)</span>个不同的点,满足不存在某个点<span class="math inline">\(x\)</span>到这<span class="math inline">\(m\)</span>个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是<span class="math inline">\(( 1 - \frac{ 1 }{ 2^m } )^{ n - 2
}\)</span>,因此期望为<span class="math inline">\(E = \binom{ n }{ m } (
1 - \frac{ 1 }{ 2^m } )^{ n - 2 }\)</span>,只需<span class="math inline">\(n\)</span>足够大的时候期望<span class="math inline">\(&lt; 1\)</span>,则说明一定存在<span class="math inline">\(0\)</span>,也就是Bob总有必胜策略.</p>
<p>注意到只需证明<span class="math inline">\(\exists n\)</span>,<span class="math inline">\(\binom{ n }{ m } &lt; ( \frac{ 2^m }{ 2^m - 1 }
)^{ n - 2 }\)</span>,而<span class="math inline">\(\binom{ n }{ m } =
\frac{ n^{ \underline{ m } } }{ m ! } &lt; n^m\)</span>.下面证明<span class="math inline">\(\exists n , n^m &lt; ( \frac{ 2^m }{ 2^m - 1 } )^{
n - 2 }\)</span>.</p>
<p>两边取<span class="math inline">\(\ln\)</span>,不妨假设<span class="math inline">\(n \geq 3\)</span>,有<span class="math inline">\(m
\ln n &lt; ( n - 2 ) \ln ( \frac{ 2^m }{ 2^m - 1 } ) , \frac{ m }{ \ln (
\frac{ 2^m }{ 2^m - 1 } ) } &lt; \frac{ n - 2 }{ \ln n }\)</span>,<span class="math inline">\(\frac{ n - 2 }{ \ln n }\)</span>显然在<span class="math inline">\(n \geq
3\)</span>的时候单增,所以一定存在这么一个<span class="math inline">\(n\)</span>.</p>
<h3><span id="2023图选">2023图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>求正整数拆分成有序的<span class="math inline">\(1 ,
2\)</span>序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>定义<span class="math inline">\(*\)</span>为集合<span class="math inline">\(G\)</span>上的二元运算,已知:</p>
<ol type="1">
<li><p>满足结合律<span class="math inline">\(a ∗ b ∗ c = a ∗ ( b ∗ c
)\)</span>.</p></li>
<li><p>存在左单位元<span class="math inline">\(e\)</span>,对任意<span class="math inline">\(a\)</span>满足<span class="math inline">\(e ∗ a =
a\)</span>.</p></li>
<li><p>对任意<span class="math inline">\(a\)</span>存在左逆元<span class="math inline">\(b\)</span>,使<span class="math inline">\(b ∗ a =
e\)</span>.</p></li>
</ol>
<p>问:</p>
<ol type="1">
<li><p>左单位元是否也为右单位元.</p></li>
<li><p>左逆元是否也为右逆元.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>看(2),考虑设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的左逆元,<span class="math inline">\(c\)</span>是<span class="math inline">\(b\)</span>的左逆元,则<span class="math inline">\(cba = ce = a , ab = ceb = e\)</span>.</p>
<p>看(1),设<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的逆元,<span class="math inline">\(ea =
aba = ae\)</span>,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明<span class="math inline">\(ab\)</span>的时候<span class="math inline">\(b\)</span>不能彻底损失信息,而观察<span class="math inline">\(ab = eab\)</span>知道<span class="math inline">\(a\)</span>也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算<span class="math inline">\(( a_1 , b_1 ) ( a_2 , b_2
)\)</span>,想办法让其损失掉<span class="math inline">\(( a_1 , b_1
)\)</span>中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到<span class="math inline">\(( a_1 , b_1 ) ( a_2 , b_2 ) = ( a_1 + a_2 , b_2
)\)</span>即可,存在左幺元为<span class="math inline">\(( 0 , 0
)\)</span>,右逆元为<span class="math inline">\(( - a , 0 )\)</span>.</p>
<h4><span id="problem4">Problem4</span></h4>
<p><span class="math inline">\(f\)</span>的定义域和值域都是正整数并且<span class="math inline">\(f ( xy ) = f ( x ) + f ( y ) - 1\)</span>,求:</p>
<ol type="1">
<li><p>是否存在这样的函数.</p></li>
<li><p>是否存在无数个这样的函数.</p></li>
<li><p>是否存在严格递增的函数.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>令<span class="math inline">\(g ( x ) = f ( x ) - 1\)</span>,则<span class="math inline">\(g ( xy ) = g ( x ) + g ( y )\)</span>.</p>
<p>对于(1),取<span class="math inline">\(g ( x ) = 0 , f ( x ) =
1\)</span>即可.</p>
<p>对于(2),考虑<span class="math inline">\(g ( p^k ) = kg ( p
)\)</span>,只需要让<span class="math inline">\(g ( p
)\)</span>取不同的值即可.</p>
<p>对于(3),考虑<span class="math inline">\(g ( 2^a ) = ag ( 2
)\)</span>,<span class="math inline">\(g ( 3^b ) = bg ( 3
)\)</span>.</p>
<p>考虑构造<span class="math inline">\(a , b\)</span>,使得<span class="math inline">\(2^a &lt; 3^b\)</span>但是<span class="math inline">\(ag ( 2 ) \geq bg ( 3 )\)</span>.不妨取<span class="math inline">\(a = \lceil \frac{ bg ( 3 ) }{ g ( 2 ) }
\rceil\)</span>,那么必定有:</p>
$$
<span class="math display">\[\begin{aligned}
2^{ \lceil \frac{ bg ( 3 ) }{ g ( 2 ) } \rceil } &amp; &lt; 3^b \\
\lceil \frac{ bg ( 3 ) }{ g ( 2 ) } \rceil &amp; &lt; b \log_2 3 \\
\frac{ bg ( 3 ) }{ g ( 2 ) } + \Delta &amp; \leq b \log_2 3 \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是如果存在,必定需要<span class="math inline">\(\frac{ g ( p_1 ) }{
g ( p_2 ) } \geq \log_{ p_2 } p_1 \land \frac{ g ( p_2 ) }{ g ( p_1 ) }
\geq \log_{ p_1 } p_2\)</span>,也就是<span class="math inline">\(\frac{
g ( p_2 ) }{ g ( p_1 ) } = \log_{ p_1 }
p_2\)</span>.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于任意<span class="math inline">\(2 n -
1\)</span>个正整数(可重复),问其中是否一定有<span class="math inline">\(n\)</span>个数的和能被<span class="math inline">\(n\)</span>整除,这题<span class="math inline">\(n =
50\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑当<span class="math inline">\(n\)</span>是合数的时候,设<span class="math inline">\(n = pq\)</span>,则可以将其拆成<span class="math inline">\(q - 1\)</span>组每组<span class="math inline">\(2
p\)</span>个数以及一组<span class="math inline">\(2 p -
1\)</span>个数,因此只需要这些都可以找到<span class="math inline">\(p\)</span>个数使得其是<span class="math inline">\(p\)</span>的倍数,组合起来就行了.</p>
<p>只需要解决<span class="math inline">\(n\)</span>是质数的情况.</p>
<p>感觉场上的最优解应该是解决<span class="math inline">\(n =
2\)</span>和<span class="math inline">\(n =
5\)</span>的情况然后拼成<span class="math inline">\(n = 50\)</span>.</p>
<p><span class="math inline">\(n = 2\)</span>的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然<span class="math inline">\(S = \sum_{  }
( x_{ p_1 } + x_{ p_2 } + \cdots + x_{ p_n } )^{ p - 1 } \equiv \binom{
2 n - 1 }{ n } \equiv 1 \pmod{ n }\)</span>.</p>
<p>但是考虑左边那个多项式的每一项,形如<span class="math inline">\(c
\prod_{ i = 1 }^k x_{ p_i }^{ e_i }\)</span>.注意到<span class="math inline">\(c\)</span>一定是<span class="math inline">\(\binom{ 2 n - 1 - k }{ n - k
}\)</span>的倍数,而后者<span class="math inline">\(\bmod
n\)</span>为<span class="math inline">\(0\)</span>.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为<span class="math inline">\(1\)</span>并不是对称的,而左边是个对称式子,某个<span class="math inline">\(x\)</span>增大也无所谓,这意味着左边应该是为<span class="math inline">\(0\)</span>的,我们要做的就是去证明它是<span class="math inline">\(0\)</span>.</p>
<h3><span id="2024图选">2024图选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>问在双曲线<span class="math inline">\(xy =
1\)</span>上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>不会做,取个特殊值知道答案应该是<span class="math inline">\([ 2 \sqrt{
6 } , + \infty )\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(n , m\)</span>都是好的,那么<span class="math inline">\(nm\)</span>是好的.</p></li>
<li><p><span class="math inline">\(2024\)</span>不是好的.</p></li>
</ol>
<h5><span id="solution2">Solution2</span></h5>
<p>如果<span class="math inline">\(n = a^2 + b^2 , m = c^2 +
d^2\)</span>,那么<span class="math inline">\(nm = a^2 c^2 + a^2 d^2 +
b^2 c^2 + b^2 d^2 = ( ac - bd )^2 + ( ad + bc )^2\)</span>.</p>
<p><span class="math inline">\(2024 = 2^3 \times 11 \times
23\)</span>,使用反证法,不妨设其可以被表示为<span class="math inline">\(a^2 + b^2\)</span>.</p>
<p>讨论一下:如果<span class="math inline">\(a ,
b\)</span>均为奇数,那么<span class="math inline">\(a^2 + b^2 \equiv 2
\pmod{ 8 }\)</span>,不符题意.</p>
<p>于是<span class="math inline">\(a ,
b\)</span>应该均为偶数,那么就有<span class="math inline">\(a &#39;^2 + b
&#39;^2 = 506\)</span>.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>对于集合<span class="math inline">\(G\)</span>,<span class="math inline">\(e \in G\)</span>,定义域为<span class="math inline">\(G\)</span>的函数<span class="math inline">\(f\)</span>满足以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(e \in G\)</span>,但<span class="math inline">\(e\)</span>不在<span class="math inline">\(f\)</span>的值域中.</p></li>
<li><p><span class="math inline">\(G\)</span>关于<span class="math inline">\(f\)</span>封闭.</p></li>
<li><p>若<span class="math inline">\(\exists A \subseteq
G\)</span>,<span class="math inline">\(e \in A\)</span>且<span class="math inline">\(A\)</span>对<span class="math inline">\(f\)</span>封闭,则<span class="math inline">\(A =
G\)</span>.</p></li>
</ol>
<p>在<span class="math inline">\(G\)</span>上定义二元运算<span class="math inline">\(\circ\)</span>,满足<span class="math inline">\(ae
= a , af ( b ) = f ( ab )\)</span>.</p>
<p>求证:</p>
<ol type="1">
<li><p>存在幺元.</p></li>
<li><p>运算满足交换律.</p></li>
<li><p>运算满足结合律.</p></li>
</ol>
<h5><span id="solution3">Solution3</span></h5>
<p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往<span class="math inline">\(A\)</span>里面扔个<span class="math inline">\(e\)</span>,此时<span class="math inline">\(A\)</span>一定不满足条件.我们不断从<span class="math inline">\(A\)</span>中选出一个元素<span class="math inline">\(w\)</span>满足<span class="math inline">\(f ( w )
\notin A\)</span>,并把<span class="math inline">\(A : = A \cup \{ f ( w
) \}\)</span>.不断做这个过程显然最后会得到<span class="math inline">\(G\)</span>,这意味着任何一个元素<span class="math inline">\(a\)</span>可以写成<span class="math inline">\(f (
f ( f \cdots f ( e ) ) )\)</span>的形式.</p>
<p>不妨将<span class="math inline">\(f\)</span>函数嵌套<span class="math inline">\(k\)</span>次记作<span class="math inline">\(f^{ (
k ) }\)</span>,那么我们要证明的是<span class="math inline">\(a = f^{ ( A
) } ( e ) , b = f^{ ( B ) } ( e )\)</span>,<span class="math inline">\(ab = ba\)</span>.</p>
<p>考虑<span class="math inline">\(ab = f^{ ( A ) } ( e ) f^{ ( B ) } (
e ) = f^{ ( B ) } ( f^{ ( A ) } ( e ) e ) = f^{ ( A + B ) } ( e
)\)</span>,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给出一个具体函数满足:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( x + y ) = f ( x ) + f ( y ) +
xy\)</span>.</p></li>
<li><p><span class="math inline">\(f ( xy ) = f ( x ) f ( y ) + f ( x -
1 ) f ( y - 1 )\)</span>.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>先注意到<span class="math inline">\(f ( 0 ) = 0 , f ( 1 ) =
1\)</span>.</p>
<p>以<span class="math inline">\(x\)</span>为主元两边求导,立刻得到<span class="math inline">\(f &#39; ( x + y ) = f &#39; ( x ) +
y\)</span>,因此<span class="math inline">\(f &#39; ( x
)\)</span>是斜率为<span class="math inline">\(1\)</span>的一次函数,立刻得到<span class="math inline">\(f ( x ) = \frac{ x^2 }{ 2 } + \frac{ x }{ 2
}\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>对于<span class="math inline">\(r = \sqrt{ 2
}\)</span>,是否存在正整数<span class="math inline">\(p\)</span>和整数<span class="math inline">\(q\)</span>满足<span class="math inline">\(| pr - q
| &lt; \frac{ 1 }{ 2024 }\)</span>且<span class="math inline">\(p &lt;
2024\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>考虑取<span class="math inline">\(0 , \sqrt{ 2 } , 2 \sqrt{ 2 } , 3
\sqrt{ 2 } , \cdots 2023 \sqrt{ 2 }\)</span>的小数部分,记作<span class="math inline">\(a_0 , a_1 , \cdots a_{ 2023 }\)</span>.</p>
<p>由鸽笼原理,一定存在两个数<span class="math inline">\(0 \leq x &lt; y
\leq 2023\)</span>满足<span class="math inline">\(| a_x - a_y | &lt;
\frac{ 1 }{ 2024 }\)</span>,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>在一个数轴上,你站在<span class="math inline">\(0\)</span>点,并按照如下算法寻找<span class="math inline">\(x ( x &gt; 0 )\)</span>点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. <span class="math inline">\(3 x\)</span> B. <span class="math inline">\(5 x\)</span> C. <span class="math inline">\(7
x\)</span> D. <span class="math inline">\(9 x\)</span> E.
以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>考虑找到牛的时候<span class="math inline">\(step\)</span>为多少,应该为<span class="math inline">\(2^{ 2 k }\)</span>,其中<span class="math inline">\(k\)</span>满足<span class="math inline">\(2^{ 2 k
} \geq x &gt; 2^{ 2 ( k - 1 ) }\)</span>.此时走的步数应该是<span class="math inline">\(ans = 2 \sum_{ i = 0 }^{ 2 k - 1 } 2^i + x = 2^{ 2
k + 1 } - 1 + x\)</span>步.而<span class="math inline">\(x \leq 2^{ 2 k
} &lt; 4 x\)</span>,所以<span class="math inline">\(ans &lt; 9 x -
1\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定<span class="math inline">\(10\)</span>个实数变量<span class="math inline">\(x_1 , \cdots , x_{ 10 }\)</span>,满足它们均<span class="math inline">\(\geq 1\)</span>且两两不同.你要寻找一组<span class="math inline">\(\{ x \}\)</span>和一个实数<span class="math inline">\(a\)</span>,使得存在尽可能多组<span class="math inline">\(\langle b \rangle , b_i = \pm 1\)</span>,满足<span class="math inline">\(\sum_{ i = 1 }^{ 10 } b_i x_i \in ( a , a + 2
)\)</span>.</p>
<p>最多存在多少组<span class="math inline">\(\langle b
\rangle\)</span>?</p>
<p>A. <span class="math inline">\(512\)</span> B. <span class="math inline">\(252\)</span> C. <span class="math inline">\(504\)</span> D. <span class="math inline">\(684\)</span> E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>不妨猜测<span class="math inline">\(x\)</span>全取<span class="math inline">\(1\)</span>最优,此时的答案是<span class="math inline">\(\binom{ 10 }{ 5 } = 252\)</span>.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于<span class="math inline">\(x \geq 1\)</span>,所以如果存在两组<span class="math inline">\(\langle b \rangle\)</span>,使得<span class="math inline">\(A\)</span>组中选择取<span class="math inline">\(+
1\)</span>恰好是<span class="math inline">\(B\)</span>组的子集,那么<span class="math inline">\(S_A \leq S_B - 2\)</span>,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让<span class="math inline">\(x\)</span>尽可能接近<span class="math inline">\(1\)</span>,这样就是满足条件的.所以问题变为对于一个大小为<span class="math inline">\(10\)</span>的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取<span class="math inline">\(\binom{ 10 }{ 5
}\)</span>最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给定无向图<span class="math inline">\(G = ( V , E
)\)</span>,我们称一个图是好的,如果:</p>
<ol type="1">
<li><p>每个点的度数均为<span class="math inline">\(d\)</span>.</p></li>
<li><p>任何一个大小不超过<span class="math inline">\(\frac{ | V | }{ 2
}\)</span>的联通集合<span class="math inline">\(S\)</span>,其邻居(不属于<span class="math inline">\(S\)</span>但和<span class="math inline">\(S\)</span>中的某个点存在直接相连的边)的大小<span class="math inline">\(\geq \frac{ 5 }{ 4 } | S |\)</span>.</p></li>
</ol>
<p>求证:好的图中任意两个点<span class="math inline">\(u ,
v\)</span>之间的最短路径长度<span class="math inline">\(dis ( u , v ) =
O ( \log | V | )\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑以<span class="math inline">\(u\)</span>为起点一点一点往外扩张,这样一直扩张到<span class="math inline">\(\frac{ | V | }{ 2 } +
1\)</span>时,集合中每个点到<span class="math inline">\(u\)</span>的距离不超过<span class="math inline">\(O ( \log | V | )\)</span>.</p>
<p>然后以<span class="math inline">\(v\)</span>做同样的事,由于这两个集合大小之和大于<span class="math inline">\(| V
|\)</span>,说明一定有交,且存在一条路径长度为<span class="math inline">\(O ( \log | V |
)\)</span>的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>给你两个完全相同的鸡蛋和一个<span class="math inline">\(n =
100\)</span>层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有<span class="math inline">\(101\)</span>个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设<span class="math inline">\(f_{ i , 1 / 2 }\)</span>表示一棵有<span class="math inline">\(i\)</span>个叶子的树,最多向右走<span class="math inline">\(1 / 2\)</span>步,深度最低为多少.显然<span class="math inline">\(f_{ i , 1 } = i - 1\)</span>.</p>
<p>不妨设最后的最大深度为<span class="math inline">\(k\)</span>,需要满足<span class="math inline">\(1 +
\sum_{ i = 1 }^k i = 1 + \frac{ k ( k + 1 ) }{ 2 } \geq 101 , k ( k + 1
) \geq 200\)</span>,<span class="math inline">\(k_{ \min } =
14\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p><span class="math inline">\(n\)</span>个人要进行一场游戏.游戏设计者准备了<span class="math inline">\(n\)</span>张卡片,正面分别写着<span class="math inline">\(n\)</span>个人的名字,背面写了<span class="math inline">\([ 1 , n ]\)</span>共<span class="math inline">\(n\)</span>个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,<span class="math inline">\(n\)</span>个人可以经过充分的讨论,并依次进入房间,一张一张地翻开<span class="math inline">\(\lfloor \frac{ n }{ 2 }
\rfloor\)</span>张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有<span class="math inline">\(n\)</span>个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过<span class="math inline">\(0 . 1\)</span>的胜率.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a\)</span>就是自己的编号就下班;反之接下来翻开<span class="math inline">\(a\)</span>位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于<span class="math inline">\(\frac{ n }{ 2 }\)</span>的环.</p>
<p>考虑总方案数是<span class="math inline">\(n
!\)</span>.不妨枚举这个环的长度为<span class="math inline">\(K\)</span>,则存在一个长度<span class="math inline">\(= K &gt; \frac{ n }{ 2
}\)</span>的环的方案数是<span class="math inline">\(\binom{ n }{ K } ( K
- 1 ) ! ( n - K ) ! = \frac{ n ! }{ K }\)</span>.所以此时的概率为<span class="math inline">\(\frac{ 1 }{ K }\)</span>.</p>
<p>那么失败的概率就是<span class="math inline">\(H_n - H_{ \frac{ n }{ 2
} } \approx \ln 2\)</span>.</p>
<h3><span id="2022茶选">2022茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化<span class="math inline">\(z = 5 x_1 + 8 x_2 + 4
x_3\)</span>,其中:</p>
<ol type="1">
<li><p><span class="math inline">\(x_1 , x_2 , x_3 \geq
0\)</span></p></li>
<li><p><span class="math inline">\(\frac{ 1 }{ 2 } x_1 + 5 x_2 + 9 x_3
\leq 3\)</span></p></li>
<li><p><span class="math inline">\(4 x_1 + 7 x_2 + 3 x_3 \leq
6\)</span></p></li>
</ol>
<p>再提一个问题:最小化<span class="math inline">\(v = 3 y_1 + 6
y_2\)</span>,其中:</p>
<ol type="1">
<li><p><span class="math inline">\(y_1 , y_2 \geq 0\)</span></p></li>
<li><p><span class="math inline">\(\frac{ 1 }{ 2 } y_1 + 4 y_2 \geq
5\)</span></p></li>
<li><p><span class="math inline">\(5 y_1 + 7 y_2 \geq
8\)</span></p></li>
<li><p><span class="math inline">\(9 y_1 + 3 y_2 \geq
4\)</span></p></li>
</ol>
<p>现在请你证明:<span class="math inline">\(z \leq v\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设<span class="math inline">\(X = \begin{bmatrix}x_1
&amp; x_2 &amp; x_3\end{bmatrix} , A = \begin{bmatrix}0 . 5 &amp; 4 \\ 5
&amp; 7 \\ 9 &amp; 3\end{bmatrix} , Y = \begin{bmatrix}y_1 \\
y_2\end{bmatrix}\)</span>,不难发现<span class="math inline">\(z \leq XAY
\leq v\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>半径为<span class="math inline">\(R\)</span>的球里放点,要求两两之间距离不能小于<span class="math inline">\(1\)</span>,证明至多放<span class="math inline">\((
2 R + 1 )^3\)</span>个.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>要求两两距离不能小于<span class="math inline">\(1\)</span>等价于往其中放半径为<span class="math inline">\(0 . 5\)</span>的球,这种球体积为<span class="math inline">\(\frac{ 4 }{ 3 } \pi \frac{ 1 }{ 8
}\)</span>.然后原球要扩大一圈,所以原球体积变为<span class="math inline">\(\frac{ 4 }{ 3 } \pi ( R + 0 . 5
)^3\)</span>.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数<span class="math inline">\(n\)</span>.</p>
<p>它每秒以<span class="math inline">\(v\)</span>的速度行驶,其中<span class="math inline">\(v\)</span>是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数<span class="math inline">\(x\)</span>,你会得知此时车的坐标是否是<span class="math inline">\(x\)</span>(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>第<span class="math inline">\(t\)</span>秒的时候车应该在<span class="math inline">\(n +
vt\)</span>处.由于我们知道现在是第几秒,枚举<span class="math inline">\(n
, v\)</span>然后不断check即可.这个是经典的证明<span class="math inline">\(\mathbb{ Z }^2\)</span>和<span class="math inline">\(\mathbb{ N }\)</span>等势.按照<span class="math inline">\(| n | + | v |\)</span>排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对满足<span class="math inline">\(\forall i , | i - p_i | \leq
1\)</span>的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5>
<p>简单题,设<span class="math inline">\(f_n\)</span>为答案,考虑<span class="math inline">\(p_n\)</span>取什么.</p>
<p>当<span class="math inline">\(p_n = n\)</span>时,方案数为<span class="math inline">\(f_{ n - 1 }\)</span>.</p>
<p>当<span class="math inline">\(p_n = n - 1\)</span>时,<span class="math inline">\(p_{ n - 1 } = n\)</span>,方案数为<span class="math inline">\(f_{ n - 2 }\)</span>.</p>
<p>于是,<span class="math inline">\(f_1 = 1 , f_2 = 2\)</span>,<span class="math inline">\(f_n = f_{ n - 1 } + f_{ n - 2 }\)</span>.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>你有一个<span class="math inline">\(n \times
n\)</span>的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择<span class="math inline">\(k\)</span>个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数<span class="math inline">\(k\)</span>最小值是<span class="math inline">\(n\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是<span class="math inline">\(\frac{ 4 n }{ 4 } = n\)</span>个.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>设<span class="math inline">\(F = \{ S_1 , S_2 , S_3 , . . . , S_{ |
F | } \}\)</span>,定义一个集合<span class="math inline">\(T\)</span>能被<span class="math inline">\(F\)</span> shattered为:<span class="math inline">\(T\)</span>的任意一个子集(包括它自己和空集),都可以由<span class="math inline">\(T \cap S_{ i_1 } \cap S_{ i_2 } . .
.\)</span>表示.其中<span class="math inline">\(S_{ i_j }\)</span>是<span class="math inline">\(F\)</span>中的集合(就是说每个子集都等于<span class="math inline">\(T\)</span>和某些<span class="math inline">\(F\)</span>内集合的交.)</p>
<p>定义一个<span class="math inline">\(F\)</span>的”VC-Dimension”是,能被他shattered的集合<span class="math inline">\(T\)</span>的大小的最大值.</p>
<p><span class="math inline">\(F\)</span>中的集合们只会包含某<span class="math inline">\(n\)</span>种不同的元素.证明:</p>
<ol type="1">
<li><p>任意一个<span class="math inline">\(F\)</span>能shattered的<span class="math inline">\(T\)</span>至少有<span class="math inline">\(| F
|\)</span>个.</p></li>
<li><p>对于一个VC-Dimension的大小为<span class="math inline">\(k\)</span>的<span class="math inline">\(F\)</span>,其<span class="math inline">\(| F |
\leq \sum_{ i = 0 }^k \binom{ n }{ i }\)</span>.</p></li>
</ol>
<h5><span id="solution6">Solution6</span></h5>
<p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的<span class="math inline">\(S\)</span>,满足<span class="math inline">\(S , S
\cup \{ x \} \in F\)</span>,然后将这些<span class="math inline">\(S \cap
\{ x \}\)</span>拎出来,假设有<span class="math inline">\(t\)</span>个,左边删去<span class="math inline">\(x\)</span>后再进行数学归纳得到<span class="math inline">\(| F | -
t\)</span>个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有<span class="math inline">\(t\)</span>个集合,在这<span class="math inline">\(t\)</span>个集合添上<span class="math inline">\(x\)</span>这个元素即可.</p>
<p><span class="math inline">\(t =
0\)</span>怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为<span class="math inline">\(S\)</span>(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与<span class="math inline">\(S\)</span>有交的集合<span class="math inline">\(T\)</span>,根据上面的预处理,此集合显然存在.选出一个<span class="math inline">\(x \in S \setminus T\)</span>,不妨设<span class="math inline">\(S = S &#39; \cup \{ x \}\)</span>,令<span class="math inline">\(T &#39; = S &#39; \cap T\)</span>,然后用<span class="math inline">\(T &#39;\)</span>代替原本的<span class="math inline">\(T\)</span>即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>令<span class="math inline">\(p ( x )\)</span>表示<span class="math inline">\(x\)</span>的最大质因子,求所有<span class="math inline">\(( x , y , z )\)</span>使得:</p>
<ol type="1">
<li><p><span class="math inline">\(x &lt; y &lt; z\)</span>且<span class="math inline">\(x + z = 2 y\)</span>.</p></li>
<li><p><span class="math inline">\(p ( xyz ) \leq 3\)</span>.</p></li>
</ol>
<h5><span id="solution1">Solution1</span></h5>
<p>不妨令<span class="math inline">\(g = \gcd ( x , y , z
)\)</span>,令<span class="math inline">\(x &#39; = \frac{ x }{ g
}\)</span>,则只需要解:<span class="math inline">\(x &#39; + z &#39; = 2
y &#39;\)</span>.</p>
<p>我们有<span class="math inline">\(y - x = z - y\)</span>,则<span class="math inline">\(\gcd ( y &#39; , x &#39; ) = \gcd ( y &#39; , y
&#39; - x &#39; ) = \gcd ( y &#39; , z &#39; ) =
1\)</span>,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol type="1">
<li><p><span class="math inline">\(2 \nmid x &#39; , 2 \nmid z
&#39;\)</span>.</p></li>
<li><p><span class="math inline">\(2 \mid x &#39; , 2 \mid z &#39; , 2
\nmid y &#39;\)</span>.</p></li>
</ol>
<p>先看(1),设<span class="math inline">\(x &#39; = 3^a , z &#39; = 3^c ,
y &#39; = 2^b\)</span>.方程变为<span class="math inline">\(3^a ( 1 + 3^{
c - a } ) = 2^{ b + 1 }\)</span>,一定有<span class="math inline">\(a =
0\)</span>,只需解<span class="math inline">\(1 + 3^{ c } = 2^{ b + 1
}\)</span>.</p>
<p>当<span class="math inline">\(b \leq 2\)</span>的时候,经检验有<span class="math inline">\(\begin{cases}c = 0 \\ b =
0\end{cases}\)</span>(舍)和<span class="math inline">\(\begin{cases}c =
1 \\ b = 1\end{cases}\)</span>两组解.</p>
<p>当<span class="math inline">\(b \geq 3\)</span>的时候,注意到<span class="math inline">\(3^{ c } \equiv - 1 \pmod{ 4 }\)</span>,所以<span class="math inline">\(c\)</span>是偶数.又注意到<span class="math inline">\(3^{ c } \equiv - 1 \pmod{ 8
}\)</span>,但是奇数的平方<span class="math inline">\(\bmod
8\)</span>应该是<span class="math inline">\(1\)</span>,不符.</p>
<p>再看(2),设<span class="math inline">\(x &#39; = 2^d , z &#39; = 2^e ,
y &#39; = 3^b\)</span>.</p>
<p>当<span class="math inline">\(e = 1\)</span>时,显然不符.</p>
<p>当<span class="math inline">\(d = 1 , e &gt; 1\)</span>时,要解<span class="math inline">\(2^{ e - 1 } + 1 = 3^{ b }\)</span>.当<span class="math inline">\(e = 2\)</span>的时候有一组解<span class="math inline">\(\begin{cases}e = 2 \\ b =
1\end{cases}\)</span>.当<span class="math inline">\(e \geq
3\)</span>的时候,有<span class="math inline">\(3^b \equiv 1 \pmod{ 4
}\)</span>,说明<span class="math inline">\(b\)</span>是偶数.</p>
<p>那必然有<span class="math inline">\(2^{ e - 1 } = 3^b - 1 = ( 3^{
\frac{ b }{ 2 } } + 1 ) ( 3^{ \frac{ b }{ 2 } } - 1 )\)</span>.令<span class="math inline">\(t = 3^{ \frac{ b }{ 2 } } - 1\)</span>,则<span class="math inline">\(2^{ e - 1 } = t ( t + 2 )\)</span>.则要么<span class="math inline">\(t = 2\)</span>,要么<span class="math inline">\(t +
2 = 2\)</span>.解出<span class="math inline">\(b -
2\)</span>,此时有<span class="math inline">\(\begin{cases}e = 4 \\ b =
2\end{cases}\)</span>.</p>
<p>综上,解出来的解有<span class="math inline">\(\begin{cases}x &#39; = 2
\\ y &#39; = 3 \\ z &#39; = 4\end{cases} , \begin{cases}x &#39; = 1 \\ y
&#39; = 2 \\ z &#39; = 3\end{cases} , \begin{cases}x &#39; = 2 \\ y
&#39; = 9 \\ z &#39; = 16\end{cases}\)</span>.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程<span class="math inline">\(2^x + 1 =
3^y\)</span>,考虑两边<span class="math inline">\(\bmod
3\)</span>知道<span class="math inline">\(x\)</span>是奇数,于是<span class="math inline">\(v_3 ( 2^x + 1 ) = v_3 ( 3 ) + v_3 ( x ) = y , 3^{
y - 1 } | x , x \geq 3^{ y - 1 }\)</span>,用这个放缩一下就行.</p>
<p>再看方程<span class="math inline">\(2^x = 3^y +
1\)</span>.仍然考虑两边<span class="math inline">\(\bmod
4\)</span>,知道<span class="math inline">\(y\)</span>是奇数.<span class="math inline">\(x = v_2 ( 3^y + 1 ) = v_2 ( 3 + 1 ) =
2\)</span>,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>给定两个随机分布：</p>
<p><span class="math inline">\(x ∼ D_1\)</span>:从<span class="math inline">\({ 0 , 1 , … , p − 1
}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x = y   \bmod  { 2^k }\)</span>.</p>
<p><span class="math inline">\(x ∼ D_1\)</span>:从<span class="math inline">\({ 0 , 1 , … , 2^k - 1
}\)</span>中等概率随机一个<span class="math inline">\(y\)</span>,令<span class="math inline">\(x = y\)</span>.</p>
<p>定义二者的统计距离为:<span class="math inline">\(SD ( D_1 , D_2 ) =
\frac{ 1 }{ 2 } \sum_{ i = 0 }^{ 2^k - 1 } | P_{ D_1 } ( x = i ) - P_{
D_2 } ( x = i ) |\)</span>.</p>
<p>求证:<span class="math inline">\(SD ( D_1 , D_2 ) ≤ \frac{ 2^k }{ 4 p
}\)</span>.</p>
<h5><span id="solution2">Solution2</span></h5>
<p>令<span class="math inline">\(w = p \bmod{ 2^k }\)</span>.则<span class="math inline">\(SD ( D_1 , D_2 ) = \frac{ w }{ 2 } ( P_{ D_1 } ( x
= 0 ) - P_{ D_2 } ( x = 0 ) ) + \frac{ 2^k - w }{ 2 } ( P_{ D_2 } ( x =
w ) - P_{ D_1 } ( x = w ) )\)</span>.</p>
<p>令<span class="math inline">\(k = \lfloor \frac{ p }{ 2^k } \rfloor =
\frac{ p - w }{ 2^k }\)</span>不难发现<span class="math inline">\(P_{
D_1 } ( x = 0 ) = \frac{ k + 1 }{ p } , P_{ D_1 } ( x = w ) = \frac{ k
}{ p }\)</span>.</p>
<p>则<span class="math inline">\(SD ( D_1 , D_2 ) = \frac{ w }{ 2 } (
\frac{ p - w + 2^k }{ p 2^k } - \frac{ 1 }{ 2^k } ) + \frac{ 2^k - w }{
2 } ( \frac{ 1 }{ 2^k } - \frac{ p - w }{ p 2^k } ) = \frac{ 1 }{ 2^{ k
+ 1 } } ( \frac{ w ( 2^k - w ) }{ p } + \frac{ w ( 2^k - w ) }{ p } ) =
\frac{ w ( 2^k - w ) }{ p 2^k }\)</span>.</p>
<p>要证明<span class="math inline">\(\frac{ w ( 2^k - w ) }{ p 2^k }
\leq \frac{ 2^k }{ 4 p } \Leftrightarrow w ( 2^k - w ) \leq ( 2^{ k - 1
} )^2\)</span>.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>给你一个单增函数<span class="math inline">\(f\)</span>,满足定义域和值域都是<span class="math inline">\(\mathbb{ N }\)</span>,并且<span class="math inline">\(f ( f ( n ) ) = 3 n\)</span>,求<span class="math inline">\(f ( 2023 )\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>首先我们不妨先试一下<span class="math inline">\(f ( f ( 1 ) ) =
3\)</span>.由于<span class="math inline">\(f ( 1 ) \geq
2\)</span>,且<span class="math inline">\(f ( 1 ) \ne
3\)</span>,所以<span class="math inline">\(f ( 1 ) = 2 , f ( 2 ) =
3\)</span>.</p>
<p>考虑<span class="math inline">\(f ( 3 n )\)</span>,必然存在一个<span class="math inline">\(n &lt; m &lt; 3 n\)</span>,使得<span class="math inline">\(f ( n ) = m , f ( m ) = 3 n\)</span>.</p>
<p>用这个找前几项,发现规律是把<span class="math inline">\(n\)</span>写成三进制形式,如果首位是<span class="math inline">\(1\)</span>就变成<span class="math inline">\(2\)</span>,首位是<span class="math inline">\(2\)</span>就改为<span class="math inline">\(1\)</span>再在后面加个<span class="math inline">\(0\)</span>.容易验证这是合法的<span class="math inline">\(f\)</span>且<span class="math inline">\(f ( 2023 )
= 3882\)</span>.</p>
<p>但问题没有解决,需要证明它是唯一的<span class="math inline">\(f\)</span>.</p>
<p>考虑数学归纳假设现在<span class="math inline">\(f ( x ) , x \in [ 1 ,
3 k ]\)</span>都确定了.</p>
<p>注意到如果<span class="math inline">\(f ( n ) = m , f ( m ) = 3 n , f
( 3 n ) = 3 m , f ( 3 m ) = 9 n\)</span>.所以如果<span class="math inline">\(f ( n ) = m\)</span>,我们实际上有<span class="math inline">\(f ( 3^k m ) = 3^{ k + 1 } n , f ( 3^k n ) = 3^k
m\)</span>.数学归纳即可以证明<span class="math inline">\(f ( 3 k + 3
)\)</span>一定是确定的.</p>
<p>接下来要证明<span class="math inline">\(f ( 3 k + 1 )\)</span>和<span class="math inline">\(f ( 3 k + 2 )\)</span>一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( 3 k ) + 3 = f ( 3 k + 3
)\)</span>.</p></li>
<li><p><span class="math inline">\(\exists n , f ( n ) = 3 k + w ( w \in
\{ 1 , 2 \} )\)</span>.</p></li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当<span class="math inline">\(k\)</span>在三进制下首位如果是<span class="math inline">\(2\)</span>,则一定满足(2).</p>
<p>当<span class="math inline">\(k\)</span>在三进制下首位是<span class="math inline">\(1\)</span>,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>对于一个<span class="math inline">\(n \times n\)</span>的包含<span class="math inline">\([ 1 , n^2
]\)</span>各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol type="1">
<li><p>如果一个排列矩阵满足每行恰有模<span class="math inline">\(n\)</span>余<span class="math inline">\([ 0 , n -
1
]\)</span>的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列为<span class="math inline">\(( i - 1
) n + j\)</span>的矩阵(不妨称为有序矩阵).</p></li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列<span class="math inline">\(\bmod
n\)</span>不相同,可以先将每行按照<span class="math inline">\(\bmod
n\)</span>排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将<span class="math inline">\(\bmod
n\)</span>不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是<span class="math inline">\(n\)</span>正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>有<span class="math inline">\(n ( \geq 2
)\)</span>个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称<span class="math inline">\(n\)</span>是好的.求证:</p>
<ol type="1">
<li><p><span class="math inline">\(4\)</span>是好的.</p></li>
<li><p>如果<span class="math inline">\(n\)</span>是奇数,那么<span class="math inline">\(n\)</span>不是好的.</p></li>
<li><p>求出所有好的<span class="math inline">\(n\)</span>.</p></li>
</ol>
<h5><span id="solution5">Solution5</span></h5>
<p>首先可以证明<span class="math inline">\(2\)</span>是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要<span class="math inline">\(2^n\)</span>步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到<span class="math inline">\(1100\)</span>来一个<span class="math inline">\(1010\)</span>之后啥也不变,但是<span class="math inline">\(1010\)</span>来一个<span class="math inline">\(1010\)</span>一定赢了.所以上来先来一个<span class="math inline">\(1010\)</span>,如果赢了就下班,没赢就来个<span class="math inline">\(1100\)</span>,这样<span class="math inline">\(1100\)</span>要么下班,要么变成了<span class="math inline">\(1010\)</span>,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:<span class="math inline">\(0000 , 1111 ,
1010 , 1111 , 1100 , 1111 , 1010 , 1111 , 1000 , 1111 , 1010 , 1111 ,
1100 , 1111 , 1010 , 1111\)</span>.</p>
<p>上面的构造启发我们手玩一下<span class="math inline">\(n =
3\)</span>,注意到此时的问题在于<span class="math inline">\(100\)</span>和<span class="math inline">\(110\)</span>,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全<span class="math inline">\(0\)</span>;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全<span class="math inline">\(0\)</span>.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全<span class="math inline">\(0\)</span>的成功状态.我们不妨令一个成功状态的度为<span class="math inline">\(d\)</span>表示它可以经过<span class="math inline">\(d\)</span>步到达全<span class="math inline">\(0\)</span>,显然全<span class="math inline">\(1\)</span>的<span class="math inline">\(d =
1\)</span>,<span class="math inline">\(n = 4\)</span>的时候,<span class="math inline">\(1010\)</span>的<span class="math inline">\(d =
2\)</span>,因为其可以通过一次操作转化为全<span class="math inline">\(1\)</span>,<span class="math inline">\(1100\)</span>的<span class="math inline">\(d =
3\)</span>,因为其可以用一次操作转化为<span class="math inline">\(1010\)</span>.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向<span class="math inline">\(d\)</span>比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然<span class="math inline">\(n = 3\)</span>的时候,<span class="math inline">\(\{ 110 , 100 \}\)</span>就是失败状态.</p>
<p>而对于<span class="math inline">\(n\)</span>取任意来说,一定得存在一个<span class="math inline">\(d = 2\)</span>的成功状态.一个显然的<span class="math inline">\(d =
2\)</span>的成功状态要满足的条件是,假设它是<span class="math inline">\(a\)</span>,那么存在一个数<span class="math inline">\(b\)</span>,使得<span class="math inline">\(a
\oplus b\)</span>是全<span class="math inline">\(1\)</span>或者全<span class="math inline">\(0\)</span>.既然<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>旋转后只有两种结果,那么<span class="math inline">\(b\)</span>的循环节必定为<span class="math inline">\(2\)</span>,也就是<span class="math inline">\(b\)</span>一定要是<span class="math inline">\(101
\cdots 010\)</span>这样的,于是<span class="math inline">\(n\)</span>是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找<span class="math inline">\(d =
3\)</span>的成功状态,现在我们已知的四种成功状态是<span class="math inline">\(111 \cdots 111\)</span>,<span class="math inline">\(000 \cdots 000\)</span>,<span class="math inline">\(101 \cdots 010\)</span>,<span class="math inline">\(010 \cdots
101\)</span>,所以考虑构造一个循环节长度为<span class="math inline">\(4\)</span>的串,使得异或完它是这上面四种其一,注意到<span class="math inline">\(1100 \cdots 1100\)</span>就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明<span class="math inline">\(n =
2^k\)</span>一定是好的.考虑数学归纳,不妨这么干:构造一个长度为<span class="math inline">\(2^{ k - 1 }\)</span>的串<span class="math inline">\(b\)</span>,使得其<span class="math inline">\(b_i =
a_i \oplus a_{ i + 2^{ k - 1 } }\)</span>.然后由数学归纳,可以造出<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>的情况.而如果<span class="math inline">\(b\)</span>全<span class="math inline">\(0\)</span>,则原串一定存在长为<span class="math inline">\(2^{ k - 1
}\)</span>的循环节,并且消除循环节的过程不会改变<span class="math inline">\(b\)</span>的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设<span class="math inline">\(n = 2^k m\)</span>,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造<span class="math inline">\(b\)</span>数组,由于<span class="math inline">\(b\)</span>数组都不可能全<span class="math inline">\(0\)</span>,显然也不可能成立.</p>
<p>这个能不能顺便证明<span class="math inline">\(n\)</span>是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了<span class="math inline">\(n - 1\)</span>个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前<span class="math inline">\(n - 1\)</span>个位置的异或值为<span class="math inline">\(1\)</span>.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3>
<h4><span id="problem1">Problem1</span></h4>
<p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为<span class="math inline">\(50 \%\)</span>,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>简单题,设<span class="math inline">\(f_0 , f_1 , f_2 ,
f_3\)</span>,然后有<span class="math inline">\(\begin{cases}f_3 = 0 \\
f_2 = \frac{ 1 }{ 2 } f_3 + \frac{ 1 }{ 2 } f_0 + 1 \\ f_1 = \frac{ 1 }{
2 } f_2 + \frac{ 1 }{ 2 } f_0 + 1 \\ f_0 = \frac{ 1 }{ 2 } f_1 + \frac{
1 }{ 2 } f_0 + 1\end{cases}\)</span>,算出<span class="math inline">\(f_0
= 14\)</span>.</p>
<h4><span id="problem2">Problem2</span></h4>
<p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<p><span class="math display">\[
x^3 + □ x^2 + □ x + □ = 0
\]</span></p>
<h5><span id="solution2">Solution2</span></h5>
<p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为<span class="math inline">\(- A , - B , -
C\)</span>,方程应该可以写作<span class="math inline">\(( x + A ) ( x + B
) ( x + C ) = 0\)</span>.</p>
<p>拆开有<span class="math inline">\(x^3 + ( A + B + C ) x^2 + ( AB + AC
+ BC ) x + ABC = 0\)</span>.</p>
<p>这么对称,不妨猜一手Alice先选择<span class="math inline">\(0\)</span>,讨论一下:</p>
<ol type="1">
<li>Bob令<span class="math inline">\(ABC = 0\)</span>.不妨令<span class="math inline">\(C = 0\)</span>.</li>
</ol>
<p>此时方程变为<span class="math inline">\(x^2 + ( A + B ) x + AB =
0\)</span>.直接秒了,随便选一个数就行(比如选<span class="math inline">\(3\)</span>,如果Bob令<span class="math inline">\(AB
= 3\)</span>,就再选<span class="math inline">\(4\)</span>;如果令<span class="math inline">\(A + B = 3\)</span>,就再选<span class="math inline">\(2\)</span>)</p>
<ol start="2" type="1">
<li>Bob令<span class="math inline">\(A + B + C = 0 , C = - A -
B\)</span>.</li>
</ol>
<p>不妨令<span class="math inline">\(C &#39; = - C , D =
AB\)</span>,则<span class="math inline">\(AB + AC + BC = D - C &#39;^2 ,
ABC = DC &#39;\)</span>.</p>
<p>接下来Alice要选择一个数字<span class="math inline">\(k\)</span>,如果Bob又令<span class="math inline">\(D - C &#39;^2 = k\)</span>,发现在此时如果<span class="math inline">\(k\)</span>是一个负的完全平方数,并且Alice接下来选择<span class="math inline">\(0\)</span>,当场就下班了.</p>
<p>所以不妨直接让<span class="math inline">\(k = -
n^2\)</span>,然后看当<span class="math inline">\(DC &#39; = -
n^2\)</span>的时候如何去解.此时有<span class="math inline">\(AB ( A + B
) = n^2\)</span>.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择<span class="math inline">\(- 3^2 \times
4^2 \times 5^2\)</span>,这样就赢了.</p>
<ol start="3" type="1">
<li>Bob令<span class="math inline">\(AB + AC + BC = 0 , C = - \frac{ AB
}{ A + B }\)</span>.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择<span class="math inline">\(6^2 \times 7^3\)</span>,两种情况如下:</p>
<p><span class="math display">\[
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) &amp; = 0 \\
( x - 2 \times 6^2 \times 7^2 ) ( x + 3 \times 6^2 \times 7^2 ) ( x + 6
\times 6^2 \times 7^2 ) &amp; = 0
\end{aligned}
\]</span></p>
<p>后来又找人讨论了一下这个是咋得出来的啊.考虑<span class="math inline">\(ABC \ne 0\)</span>,我们有的条件其实是<span class="math inline">\(\frac{ 1 }{ A } + \frac{ 1 }{ B } + \frac{ 1 }{ C
} = 0\)</span>.方程现在是<span class="math inline">\(x^3 + ( A + B -
\frac{ AB }{ A + B } ) x^2 - \frac{ A^2 B^2 }{ A + B } =
0\)</span>.不妨令<span class="math inline">\(a = A + B , b =
AB\)</span>,方程实际上是<span class="math inline">\(x^3 + ( a - \frac{ b
}{ a } ) x^2 - \frac{ b^2 }{ a } = 0\)</span>.最好能让<span class="math inline">\(a\)</span>小一点,因此我们不妨直接取<span class="math inline">\(a = 1\)</span>,此时<span class="math inline">\(A =
- n , B = n + 1 , C = n ( n + 1 )\)</span>,只要能构造这样的两组<span class="math inline">\(A , B , C\)</span>使得它们的<span class="math inline">\(a_1 - \frac{ b_1 }{ a_1 } = - \frac{ b_2^2 }{ a_2
}\)</span>即可.直接造看上去没啥前途,但是不难发现<span class="math inline">\(A = - nk , B = ( n + 1 ) k , C = n ( n + 1 )
k\)</span>依然合法.此时有<span class="math inline">\(k_1 = a_1 , b_1 = -
n ( n + 1 ) a_1^2 , k_2 = a_2 , b_2 = - n ( n + 1 )
a_2^2\)</span>,我们有<span class="math inline">\(a_1 ( n^2 + n + 1 ) = -
n^2 ( n + 1 )^2 a_2^3\)</span>.取<span class="math inline">\(n =
2\)</span>试试看!此时有<span class="math inline">\(7 a_1 = - 36
a_2^3\)</span>.取<span class="math inline">\(a_2 = 7 , a_1 = - 6^2
\times 7^2\)</span>,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4>
<p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外<span class="math inline">\(3\)</span>个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌<span class="math inline">\(1\)</span>个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5>
<p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4>
<p>有公式:</p>
<p><span class="math display">\[
\sum_{ S \subseteq \{ 1 , 2 , \cdots , n \} } ( P ( f ( R ) \oplus
\bigoplus_{ i \in S } R_i = 0 ) - P ( f ( R ) \oplus \bigoplus_{ i \in S
} R_i = 1 ) )^2 = 1
\]</span></p>
<p>其中<span class="math inline">\(f\)</span>是任意一个将<span class="math inline">\(\{ 0 , 1 \}^n \rightarrow \{ 0 , 1
\}\)</span>的函数,<span class="math inline">\(\oplus\)</span>是二进制意义下的异或运算,<span class="math inline">\(R\)</span>是<span class="math inline">\(\{ 0 , 1
\}^n\)</span>上的均匀分布,<span class="math inline">\(R_i\)</span>表示第<span class="math inline">\(i\)</span>位.再定义<span class="math inline">\(\chi_S ( r ) = \prod_{ i \in S } ( - 1 )^{ r_i
}\)</span>.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol type="1">
<li><p><span class="math inline">\(\chi_S ( r ) \times \chi_S ( r &#39;
) = \chi_S ( r \oplus r &#39; )\)</span>.</p></li>
<li><p>当<span class="math inline">\(r \ne 0\)</span>时,<span class="math inline">\(\sum_{ S \subseteq \{ 1 , \cdots , n \} } \chi_S (
r ) = 0\)</span>.</p></li>
<li><p><span class="math inline">\([ f ( r ) \oplus \bigoplus_{ i \in S
} r_i = 0 ] - [ f ( r ) \oplus \bigoplus_{ i \in S } r_i = 1 ] = ( - 1
)^{ f ( r ) } \chi_S ( r )\)</span>.</p></li>
<li><p>证明原命题.</p></li>
</ol>
<h5><span id="solution4">Solution4</span></h5>
<p>(1)显然.</p>
<p>(2)也很经典,挑选一个<span class="math inline">\(j\)</span>,使得<span class="math inline">\(r_j =
1\)</span>,然后所有的集合分为两类:一类是包含<span class="math inline">\(j\)</span>,一类不包含,两类集合一一对应并且<span class="math inline">\(\chi\)</span>互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到<span class="math inline">\(P ( f ( R ) \oplus
\bigoplus_{ i \in S } R_i = 0 ) = \frac{ 1 }{ 2^n } \sum_{ r } [ f ( r )
\oplus \bigoplus_{ i \in S } r_i = 0 ]\)</span>,而<span class="math inline">\(\sum_{ r } [ f ( r ) \oplus \bigoplus_{ i \in S }
r_i = 0 ] - [ f ( r ) \oplus \bigoplus_{ i \in S } r_i = 1 ] = \sum_r (
- 1 )^{ f ( r ) } \chi_S ( r )\)</span>,要证明的只是<span class="math inline">\(\sum_{ S } \frac{ 1 }{ 4^n } ( \sum_r ( - 1 )^{ f
( r ) } \chi_S ( r ) )^2 = 1\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S } ( \sum_r ( - 1 )^{ f ( r ) } \chi_S ( r ) )^2 \\
= &amp; \sum_S \sum_{ r } \sum_{ r &#39; } ( - 1 )^{ f ( r ) + f ( r
&#39; ) } \chi_S ( r \oplus r &#39; ) \\
= &amp; \sum_{ r } \sum_{ r &#39; } ( - 1 )^{ f ( r ) + f ( r &#39; ) }
\sum_S \chi_S ( r \oplus r &#39; ) \\
= &amp; \sum_{ r } 2^n = 4^n
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4>
<p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于<span class="math inline">\(50 \%\)</span>.</p>
<h5><span id="solution5">Solution5</span></h5>
<p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数<span class="math inline">\(x\)</span>,然后随机一只手,看上面的数字<span class="math inline">\(a\)</span>,如果<span class="math inline">\(a \geq
x\)</span>就认为<span class="math inline">\(a\)</span>大,反之认为<span class="math inline">\(b\)</span>大.只要随机到一个区间内的实数的概率不为<span class="math inline">\(0\)</span>即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4>
<p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5>
<p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令<span class="math inline">\(p\)</span>为素数,把整个图形放大<span class="math inline">\(p\)</span>倍(也就是长度<span class="math inline">\(1\)</span>变成长度<span class="math inline">\(p\)</span>).下面把每个交叉点<span class="math inline">\(( x , y )\)</span>换成其整数部分<span class="math inline">\(( \lfloor x \rfloor , \lfloor y \rfloor
)\)</span>,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被<span class="math inline">\(p\)</span>整除.这样这个新的大矩形的面积也能被<span class="math inline">\(p\)</span>整除,所以它的有一边长能被<span class="math inline">\(p\)</span>整除.这条边只是被换成了它长度的整数部分,所以变化不超过<span class="math inline">\(1\)</span>,所以在放大之前这条边的长度和某个整数相差不超过<span class="math inline">\(1 /
p\)</span>.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有<span class="math inline">\(2\)</span>条边或者<span class="math inline">\(4\)</span>条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点<span class="math inline">\(( x , y )\)</span>染色:如果<span class="math inline">\(x\)</span>是整数,染X颜色.如果<span class="math inline">\(x\)</span>不是整数但<span class="math inline">\(y\)</span>是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为<span class="math inline">\([ 0 , a ] \times [ 0
, b ]\)</span>,并假设<span class="math inline">\(b\)</span>不是整数.把所有小矩形的下边界去掉,然后令<span class="math inline">\(f ( t )\)</span>为所有上边界<span class="math inline">\(y\)</span>坐标不是整数,并且与直线<span class="math inline">\(y = t\)</span>相交的小矩形的<span class="math inline">\(x\)</span>方向边长之和.那么<span class="math inline">\(f ( 0 ) = 0\)</span>,而且当<span class="math inline">\(f ( t
)\)</span>变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以<span class="math inline">\(f ( b )\)</span>是整数.而因为<span class="math inline">\(b\)</span>不是整数,<span class="math inline">\(f (
b )\)</span>就是最靠上的所有小矩形的宽之和,等于<span class="math inline">\(a\)</span>,所以<span class="math inline">\(a\)</span>是整数.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
