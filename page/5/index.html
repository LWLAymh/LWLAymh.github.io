<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js" defer></script>





  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://windgraham.art/" title="http:&#x2F;&#x2F;windgraham.art&#x2F;" rel="noopener" target="_blank">zhgg的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.hjcheng0602.cn/" title="https:&#x2F;&#x2F;www.hjcheng0602.cn&#x2F;" rel="noopener" target="_blank">jcgg的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://illusion.blog/" title="https:&#x2F;&#x2F;illusion.blog&#x2F;" rel="noopener" target="_blank">jjjj的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://blog.imyangty.com/" title="https:&#x2F;&#x2F;blog.imyangty.com&#x2F;" rel="noopener" target="_blank">tygg的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.chenquan-tutu.top/" title="https:&#x2F;&#x2F;www.chenquan-tutu.top&#x2F;" rel="noopener" target="_blank">cqgg的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">高等代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-13 11:32:16" itemprop="dateModified" datetime="2025-11-13T11:32:16+08:00">2025-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#抽象代数">抽象代数</a>
<ul>
<li><a href="#群">群</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#基本概念和事实">基本概念和事实</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#子群">子群</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8">Example8</a></li>
</ul></li>
<li><a href="#同态和同构">同态和同构</a></li>
<li><a href="#群的实例">群的实例</a>
<ul>
<li><a href="#全变换群对称群与交错群">全变换群,对称群与交错群</a></li>
<li><a href="#一般线性群">一般线性群</a></li>
<li><a href="#克莱因四元群">克莱因四元群</a></li>
<li><a href="#循环群">循环群</a></li>
</ul></li>
<li><a href="#相反群">相反群</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#群作用">群作用</a>
<ul>
<li><a href="#cayley定理">Cayley定理</a></li>
<li><a href="#burnside引理">Burnside引理</a>
<ul>
<li><a href="#共轭类计数">共轭类计数</a></li>
</ul></li>
<li><a href="#p-群"><span class="math inline">\(p\)</span>-群</a></li>
<li><a href="#sylow定理">Sylow定理</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#正规子群">正规子群</a>
<ul>
<li><a href="#正规子群的判定定理">正规子群的判定定理</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
<li><a href="#正规子群与同态">正规子群与同态</a></li>
<li><a href="#同态基本定理">同态基本定理</a></li>
<li><a href="#第一同构定理">第一同构定理</a></li>
<li><a href="#第二同构定理">第二同构定理</a></li>
<li><a href="#交换化">交换化</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a
href="#example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</a></li>
<li><a href="#example3-2">Example3</a></li>
</ul></li>
</ul></li>
<li><a href="#群的直和与直积">群的直和与直积</a>
<ul>
<li><a href="#直和">直和</a></li>
<li><a href="#半直积">半直积</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
<li><a href="#example2二面体群">Example2(二面体群)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#环">环</a>
<ul>
<li><a href="#子环">子环</a></li>
<li><a href="#理想">理想</a>
<ul>
<li><a href="#example1-7">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
<li><a href="#example3中国剩余定理">Example3(中国剩余定理)</a></li>
</ul></li>
<li><a href="#同态和同构-1">同态和同构</a>
<ul>
<li><a href="#同态基本定理-1">同态基本定理</a></li>
<li><a href="#第一同构定理-1">第一同构定理</a></li>
<li><a href="#第二同构定理-1">第二同构定理</a></li>
</ul></li>
<li><a href="#整环">整环</a>
<ul>
<li><a href="#特征">特征</a></li>
<li><a href="#整除性">整除性</a></li>
<li><a href="#唯一分解整环ufd">唯一分解整环(UFD)</a></li>
<li><a href="#主理想整环pid">主理想整环(PID)</a></li>
<li><a href="#欧几里得整环ed">欧几里得整环(ED)</a></li>
</ul></li>
</ul></li>
<li><a href="#多项式环">多项式环</a>
<ul>
<li><a href="#一元多项式环">一元多项式环</a></li>
<li><a href="#多元多项式环">多元多项式环</a></li>
<li><a href="#不可约多项式">不可约多项式</a>
<ul>
<li><a href="#本原多项式">本原多项式</a></li>
<li><a href="#一个判定不可约的算法">一个判定不可约的算法</a></li>
<li><a href="#不可约多项式上的扩域">不可约多项式上的扩域</a></li>
</ul></li>
<li><a href="#对称多项式">对称多项式</a>
<ul>
<li><a href="#牛顿公式">牛顿公式</a></li>
</ul></li>
<li><a href="#结式">结式</a></li>
<li><a href="#判别式">判别式</a></li>
</ul></li>
<li><a href="#域">域</a>
<ul>
<li><a href="#域同态">域同态</a></li>
<li><a href="#分式域">分式域</a></li>
<li><a href="#有限域">有限域</a></li>
<li><a href="#有限域上的多项式分解">有限域上的多项式分解</a></li>
<li><a href="#galois扩张">Galois扩张</a></li>
</ul></li>
</ul></li>
<li><a href="#线性代数">线性代数</a>
<ul>
<li><a href="#矩阵引入">矩阵引入</a>
<ul>
<li><a href="#矩阵运算">矩阵运算</a></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
</ul></li>
<li><a href="#线性方程组">线性方程组</a>
<ul>
<li><a href="#系数矩阵和增广矩阵">系数矩阵和增广矩阵</a></li>
<li><a href="#矩阵的初等行变换">矩阵的初等行变换</a></li>
<li><a href="#阶梯形矩阵">阶梯形矩阵</a>
<ul>
<li><a href="#简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</a></li>
</ul></li>
<li><a href="#解线性方程组">解线性方程组</a>
<ul>
<li><a href="#存在与唯一性定理">存在与唯一性定理</a></li>
</ul></li>
<li><a href="#矩阵方程">矩阵方程</a></li>
<li><a href="#齐次线性方程组">齐次线性方程组</a></li>
</ul></li>
<li><a href="#线性空间">线性空间</a>
<ul>
<li><a href="#相关运算">相关运算</a>
<ul>
<li><a href="#直积">直积</a></li>
<li><a href="#直和-1">直和</a></li>
<li><a href="#叉乘">叉乘</a></li>
</ul></li>
<li><a href="#线性无关与线性相关">线性无关与线性相关</a></li>
<li><a href="#子空间">子空间</a>
<ul>
<li><a href="#向量的线性组合">向量的线性组合</a></li>
<li><a href="#线性映射">线性映射</a></li>
<li><a href="#基和维数">基和维数</a></li>
</ul></li>
<li><a href="#可逆矩阵">可逆矩阵</a>
<ul>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#求解逆矩阵">求解逆矩阵</a>
<ul>
<li><a href="#example1lu分解">Example1(LU分解)</a></li>
</ul></li>
</ul></li>
<li><a href="#核与像与秩">核与像与秩</a>
<ul>
<li><a href="#sylvester秩不等式">Sylvester秩不等式</a></li>
<li><a href="#frobenius秩不等式">Frobenius秩不等式</a></li>
</ul></li>
<li><a href="#对偶空间">对偶空间</a></li>
<li><a href="#直和分解与分块矩阵">直和分解与分块矩阵</a></li>
<li><a href="#基的变换">基的变换</a>
<ul>
<li><a href="#矩阵的共轭相似">矩阵的共轭(相似)</a></li>
<li><a href="#矩阵的相抵">矩阵的相抵</a></li>
</ul></li>
<li><a href="#商空间">商空间</a>
<ul>
<li><a href="#同态基本定理-2">同态基本定理</a></li>
<li><a href="#第一同构定理-2">第一同构定理</a></li>
<li><a href="#第二同构定理-2">第二同构定理</a></li>
<li><a href="#旗">旗</a></li>
<li><a href="#不变子空间">不变子空间</a></li>
</ul></li>
</ul></li>
<li><a href="#行列式">行列式</a>
<ul>
<li><a href="#置换排列">置换(排列)</a></li>
<li><a href="#交错形式">交错形式</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#余子式与代数余子式">余子式与代数余子式</a></li>
<li><a href="#行列式定向">行列式定向</a></li>
<li><a href="#克拉默cramer法则">克拉默(Cramer)法则</a></li>
<li><a href="#一些特殊行列式">一些特殊行列式</a>
<ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#上三角矩阵">上三角矩阵</a></li>
<li><a href="#分块上三角矩阵">分块上三角矩阵</a></li>
<li><a
href="#范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</a></li>
<li><a href="#一类分块矩阵">一类分块矩阵</a></li>
</ul></li>
<li><a href="#特征多项式">特征多项式</a></li>
<li><a href="#cayley-hamilton定理">Cayley-Hamilton定理</a></li>
<li><a href="#矩阵的迹">矩阵的迹</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#binet-cauchy定理">Binet-Cauchy定理</a></li>
<li><a href="#特征值与特征向量">特征值与特征向量</a></li>
<li><a href="#极小多项式">极小多项式</a></li>
<li><a href="#同步对角化">同步对角化</a></li>
<li><a href="#上三角化">上三角化</a></li>
<li><a href="#广义特征子空间">广义特征子空间</a></li>
<li><a href="#特殊矩阵的特征值">特殊矩阵的特征值</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#双线性形式">双线性形式</a>
<ul>
<li><a href="#线性映射-1">线性映射</a></li>
<li><a href="#非退化形式">非退化形式</a></li>
<li><a href="#伴随映射">伴随映射</a></li>
<li><a href="#分类问题">分类问题</a></li>
<li><a href="#二次型">二次型</a>
<ul>
<li><a href="#实二次型">实二次型</a></li>
<li><a href="#惯性sylvester定理">惯性(Sylvester)定理</a></li>
</ul></li>
<li><a href="#辛空间">辛空间</a>
<ul>
<li><a href="#达布定理">达布定理</a></li>
</ul></li>
<li><a href="#回看对偶空间">回看对偶空间</a>
<ul>
<li><a href="#双重对偶">双重对偶</a></li>
<li><a href="#核余核与对偶映射">核,余核与对偶映射</a></li>
<li><a href="#像自对偶">像自对偶</a></li>
</ul></li>
</ul></li>
<li><a href="#实内积空间">实内积空间</a>
<ul>
<li><a href="#勾股定理">勾股定理</a></li>
<li><a href="#柯西不等式">柯西不等式</a></li>
<li><a href="#三角不等式">三角不等式</a></li>
<li><a href="#距离相关">距离相关</a></li>
<li><a href="#正交向量族">正交向量族</a></li>
<li><a href="#gram-schmidt-正交化">Gram-Schmidt 正交化</a>
<ul>
<li><a href="#example1ru分解">Example1(RU分解)</a></li>
<li><a href="#example2legendre多项式">Example2(Legendre多项式)</a></li>
</ul></li>
<li><a href="#正交算子">正交算子</a></li>
<li><a href="#正交补空间">正交补空间</a></li>
<li><a href="#投影矩阵">投影矩阵</a></li>
<li><a href="#自伴算子">自伴算子</a>
<ul>
<li><a href="#实sylvester-判准">(实)Sylvester 判准</a></li>
<li><a href="#实正定矩阵的二次根">(实)正定矩阵的二次根</a>
<ul>
<li><a href="#example1-8">Example1</a></li>
<li><a href="#example2-4">Example2</a></li>
</ul></li>
<li><a href="#极分解">极分解</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
</ul></li>
<li><a href="#奇异值分解">奇异值分解</a></li>
<li><a href="#moore-penrose-广义逆">Moore-Penrose 广义逆</a></li>
<li><a
href="#极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</a></li>
<li><a href="#perron-frobenius定理">Perron-Frobenius定理</a>
<ul>
<li><a href="#collatz-wielandt公式">Collatz-Wielandt公式</a></li>
<li><a href="#perron定理">Perron定理</a></li>
</ul></li>
<li><a href="#实正交变换的标准型">实正交变换的标准型</a>
<ul>
<li><a href="#欧拉角">欧拉角</a></li>
<li><a href="#四元数">四元数</a></li>
</ul></li>
</ul></li>
<li><a href="#复内积空间">复内积空间</a>
<ul>
<li><a href="#共轭空间">共轭空间</a></li>
<li><a href="#复半双线性形式">(复)半双线性形式</a></li>
<li><a href="#伴随映射-1">伴随映射</a></li>
<li><a href="#hermite形式">Hermite形式</a>
<ul>
<li><a href="#正规线性映射">正规线性映射</a></li>
<li><a href="#二次型-1">二次型</a></li>
</ul></li>
<li><a href="#复内积空间-1">复内积空间</a>
<ul>
<li><a href="#酉变换">酉变换</a></li>
<li><a
href="#正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</a></li>
<li><a href="#相关实内积空间定理推广">相关实内积空间定理推广</a></li>
<li><a href="#复矩阵范数实例">复矩阵范数实例</a></li>
</ul></li>
</ul></li>
<li><a href="#模">模</a>
<ul>
<li><a href="#自由模">自由模</a>
<ul>
<li><a href="#example1非自由模">Example1(非自由模)</a></li>
</ul></li>
<li><a href="#线性映射和模结构">线性映射和模结构</a></li>
<li><a href="#主理想环上的有限生成模">主理想环上的有限生成模</a>
<ul>
<li><a href="#自由模与其子模">自由模与其子模</a></li>
<li><a href="#smith标准型">Smith标准型</a></li>
<li><a href="#结构定理">结构定理</a></li>
<li><a href="#有限生成交换群的分类">有限生成交换群的分类</a></li>
</ul></li>
<li><a href="#有理标准型">有理标准型</a>
<ul>
<li><a href="#example1-9">Example1</a></li>
</ul></li>
<li><a href="#jordan标准型">Jordan标准型</a>
<ul>
<li><a
href="#加性jordan-chevalley分解">加性Jordan-Chevalley分解</a></li>
<li><a
href="#乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</a></li>
</ul></li>
</ul></li>
<li><a href="#张量积">张量积</a>
<ul>
<li><a href="#张量积与直和">张量积与直和</a></li>
<li><a href="#kronecker积">Kronecker积</a></li>
<li><a href="#张量积与对偶空间">张量积与对偶空间</a></li>
<li><a href="#张量代数">张量代数</a>
<ul>
<li><a href="#另一种构造">另一种构造</a></li>
<li><a href="#又看对偶空间">又看对偶空间</a>
<ul>
<li><a href="#example1-10">Example1</a></li>
<li><a href="#example2-5">Example2</a></li>
</ul></li>
<li><a href="#简单应用">简单应用</a></li>
</ul></li>
<li><a href="#域的变换">域的变换</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" class="post-title-link" itemprop="url">递归式与和式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="汉诺塔问题">汉诺塔问题</span></h3>
<p>三个柱子,<span class="math inline">\(n\)</span>个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端,要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数,使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令<span class="math inline">\(T_n\)</span>表示答案,显然<span class="math inline">\(T_0 = 0 , T_1 = 1\)</span>.</p>
<p>而我们一定可以找到一种方案,使得前<span class="math inline">\(n -
1\)</span>个圆盘先移动到其中一根柱子上,然后将最下面的圆盘移动到目标柱子,最后再把<span class="math inline">\(n -
1\)</span>个圆盘移动到目标柱子.由于这是一个可行解而不一定是最优解,我们有:<span class="math inline">\(T_n \leq 2 T_{ n - 1 } + 1\)</span>.</p>
<p>而如果我们要移动最大的圆盘,一定要保证前n-1个圆盘已经移走到一根柱子上.因此一定有:<span class="math inline">\(2 T_{ n - 1 } + 1 \leq T_n\)</span>.于是有<span class="math inline">\(T_n = 2 T_{ n - 1 } + 1\)</span>.</p>
<h4><span id="example1具体数学12">Example1(《具体数学》1.2)</span></h4>
<p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4><span id="solution-1">Solution 1</span></h4>
<p>考虑设<span class="math inline">\(T_n\)</span>为n个圆盘时的最小操作次数.假设已知<span class="math inline">\(T_{ n - 1 }\)</span>,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:<span class="math inline">\(T_{ n } = 3 T_{ n - 1 } + 2 , T_0 =
0\)</span>.</p>
<p>考虑如何求该式子的封闭形式,令<span class="math inline">\(W_n = T_n +
1\)</span>,显然有<span class="math inline">\(W_n = 3 W_{ n - 1 } , W_0 =
1\)</span>,显然<span class="math inline">\(W_n = 3^n\)</span>,有<span class="math inline">\(T_n = 3^n - 1\)</span>.</p>
<p>注意到<span class="math inline">\(T_n\)</span>刚好是三根柱子上所有合法排列的数量,并且这个过程中不可能出现某两个时刻的情况是相同的,因此1.3也可以证明.</p>
<h4><span id="example2具体数学14">Example2(《具体数学》1.4)</span></h4>
<p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于<span class="math inline">\(2^n - 1\)</span>.</p>
<h4><span id="solution-2">Solution 2</span></h4>
<p>不存在.</p>
<p>证明方式类似原初问题的证明,考虑最大的那个圆盘是否到达终点.如果到达则可以去掉它,用数学归纳证明不存在;如果还未到达,同样用数学归纳得到不等式.</p>
<h4><span id="example3具体数学110">Example3(《具体数学》1.10)</span></h4>
<p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4><span id="solution-3">Solution 3</span></h4>
<p>令<span class="math inline">\(Q_n\)</span>为将n个圆盘从A移动到B的最小操作次数,令<span class="math inline">\(R_n\)</span>为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,<span class="math inline">\(Q_0 = 0 , R_0 =
0\)</span>.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此<span class="math inline">\(Q_n\)</span>的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,<span class="math inline">\(R_n\)</span>的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有<span class="math inline">\(Q_n = 2 R_{ n - 1 } + 1 , 1 \leq
n\)</span>.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有<span class="math inline">\(R_n = R_{ n - 1 } + 1 + Q_{ n - 1 } + 1
+ R_{ n - 1 } = Q_n + Q_{ n - 1 } + 1 , 1 \leq n\)</span>.</p>
<h4><span id="example4具体数学111">Example4(《具体数学》1.11)</span></h4>
<p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4><span id="solution-4">Solution 4</span></h4>
<p>a.仍然令<span class="math inline">\(T_n\)</span>为n对圆盘的最小操作次数,显然<span class="math inline">\(T_n = 2 T_{ n - 1 } + 2 , T_0 =
0\)</span>,可解得<span class="math inline">\(T_n = 2^{ n + 1 } -
2\)</span>.</p>
<p>b.令<span class="math inline">\(Q_n\)</span>为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现<span class="math inline">\(Q_n = T_{ n - 1 } + 1 + T_{ n - 1 } + 1 + T_{ n -
1 } + 1 + T_{ n - 1 } = 4 T_{ n - 1 } + 3 = 2^{ n + 2 } -
5\)</span>.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的<span class="math inline">\(Q_n\)</span>就是答案.</p>
<h4><span id="example5具体数学112">Example5(《具体数学》1.12)</span></h4>
<p>类似Problem11,但第<span class="math inline">\(i\)</span>大的圆盘有<span class="math inline">\(k_i\)</span>个.</p>
<h4><span id="solution-5">Solution 5</span></h4>
<p>无区别,只是<span class="math inline">\(T_n = 2 T_{ n - 1 } + k_n ,
T_0 = 0\)</span>.</p>
<p>如果求封闭形式的话,显然有<span class="math inline">\(T_n = \sum_{ i =
1 }^n 2^{ n - i } k_i\)</span>.</p>
<h3><span id="递归式的封闭形式">递归式的封闭形式</span></h3>
<p>在上述问题中，我们已经有了以下式子：</p>
<p><span class="math inline">\(T_n = 2 T_{ n - 1 } + 1 , n &gt; 0 , T_0
= 0\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出<span class="math inline">\(T_n\)</span>的方法.</p>
<p>换句话说，我们想要把<span class="math inline">\(T_n\)</span>表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4><span id="寻找循环节">寻找循环节</span></h4>
<h5><span id="example具体数学18">Example(《具体数学》1.8)</span></h5>
<p>解递归式:<span class="math inline">\(Q_n = \begin{cases}\alpha &amp;
n = 0 \\ \beta &amp; n = 1 \\ \frac{ ( 1 + Q_{ n - 1 } ) }{ Q_{ n - 2 }
} &amp; n &gt; 1\end{cases}\)</span>,保证<span class="math inline">\(\forall n , Q_n &gt; 0\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>注意到<span class="math inline">\(Q_2 = \frac{ \beta + 1 }{ \alpha }
, Q_3 = \frac{ \beta + \alpha + 1 }{ \beta \alpha } , Q_4 = \frac{ 1 +
\alpha }{ \beta } , Q_5 = \alpha , Q_6 = \beta\)</span>.</p>
<p>显然该递归式存在长度为<span class="math inline">\(5\)</span>的循环节.</p>
<h4><span id="数学归纳法">数学归纳法</span></h4>
<p>观察T序列的前几项，可以发现似乎有<span class="math inline">\(T_n =
2^n - 1\)</span>.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于<span class="math inline">\(n =
0\)</span>成立，显然可验证.</p>
<p>2.若该公式对<span class="math inline">\(n =
k\)</span>时成立，那该公式必然对<span class="math inline">\(n = k +
1\)</span>成立.</p>
<p>因为有<span class="math inline">\(T_{ k + 1 } = 2 T_k + 1 = 2 \times
2^k + 2 - 1 = 2^{ k + 1 } - 1\)</span>.</p>
<p>以上过程被称为数学归纳法.</p>
<h5><span id="example具体数学19">Example(《具体数学》1.9)</span></h5>
<p>求证:<span class="math inline">\(\prod_{ i = 1 }^n x_i \leq ( \frac{
\sum_{ i = 1 }^n x_i }{ n } )^n , \forall i \in N_+ , 1 \leq i \leq n ,
0 \leq x_i\)</span>.</p>
<h5><span id="solution">Solution</span></h5>
<p>使用反向归纳法.</p>
<p>1.<span class="math inline">\(n =
2\)</span>时,即基本不等式,显然成立.</p>
<p>2.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对n=2k时也成立.</p>
<p>不妨令<span class="math inline">\(A_1 = \sqrt[k]{ \prod_{ i = 1 }^k
x_i } , B_1 = \sqrt[k]{ \prod_{ i = k + 1 }^{ 2 k } x_i } , A_2 = (
\frac{ \sum_{ i = 1 }^k x_i }{ k } ) , B_2 = ( \frac{ \sum_{ i = k + 1
}^{ 2 k } x_i }{ k } )\)</span>,显然有<span class="math inline">\(A_1
\leq A_2 , B_1 \leq B_2\)</span>.</p>
<p>同时有<span class="math inline">\(( \frac{ A_2 + B_2 }{ 2 } ) \geq
\sqrt{ A_2 B_2 } \geq \sqrt{ A_1 B_1 }\)</span>.</p>
<p>3.若该式子对<span class="math inline">\(n =
k\)</span>时成立,则该式子对<span class="math inline">\(n = k -
1\)</span>的时候也成立.</p>
<p>令<span class="math inline">\(x_k = \frac{ \sum_{ i = 1 }^{ k - 1 }
x_i }{ k - 1 }\)</span>,有<span class="math inline">\(x_k \prod_{ i = 1
}^{ k - 1 } x_i \leq ( x_k )^k\)</span>.</p>
<p>则显然<span class="math inline">\(n = k - 1\)</span>时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4><span id="换元">换元</span></h4>
<p>考虑令<span class="math inline">\(U_n = T_n + 1\)</span>,显然有:<span class="math inline">\(T_n + 1 = 2 T_{ n - 1 } + 2\)</span>.即<span class="math inline">\(U_n = 2 U_{ n - 1 }\)</span>,显然<span class="math inline">\(U_n = 2^n\)</span>,则<span class="math inline">\(T_n = 2^n - 1\)</span>.</p>
<p>这个做法可以做掉所有形如<span class="math inline">\(a_{ n + 1 } =
pa_n + q\)</span>的递归式.我们有:</p>
<p><span class="math display">\[
a_{ n + 1 } + \frac{ q }{ p - 1 } = p ( a_n + \frac{ q }{ p - 1 } )
\]</span></p>
<p>换元做掉这个式子.</p>
<h4><span id="转化和式">转化和式</span></h4>
<p>考虑递归式<span class="math inline">\(a_n T_n = b_n T_{ n - 1 } +
c_n\)</span>.如果我们能找到一个不为0的求和因子<span class="math inline">\(s_n\)</span>并满足<span class="math inline">\(s_n
b_n = s_{ n - 1 } a_{ n - 1 }\)</span>.那么我们两面同时乘以<span class="math inline">\(s_n\)</span>,显然有：<span class="math inline">\(s_n a_n T_n = s_{ n - 1 } a_{ n - 1 } T_{ n - 1 }
+ c_n s_n\)</span>.</p>
<p>令<span class="math inline">\(S_n = s_n a_n T_n\)</span>.显然有<span class="math inline">\(S_n = s_0 a_0 T_0 + \sum_{ i = 1 }^n s_i
c_i\)</span>,则<span class="math inline">\(T_n = \frac{ S_n }{ s_n a_n
}\)</span>.</p>
<p>而我们也会发现<span class="math inline">\(s_n = \frac{ \prod_{ i = 1
}^{ n - 1 } a_i }{ \prod_{ i = 1 }^n b_i }\)</span>.</p>
<h5><span id="example1快速排序时间复杂度">Example1(快速排序时间复杂度)</span></h5>
<p>结论:排序<span class="math inline">\(n\)</span>个数时,其期望复杂度满足:</p>
<p><span class="math display">\[
C_n = \begin{cases}
0 &amp; n = 0 , 1 \\
n + 1 + \frac{ 2 }{ n } \sum_{ i = 0 }^{ n - 1 } C_k &amp; n &gt; 1
\end{cases}
\]</span></p>
<p>不妨考虑两边同时乘以<span class="math inline">\(n\)</span>,有 <span class="math inline">\(nC_n = n^2 + n + 2 \sum_{ i = 0 }^{ n - 1 } C_i ,
n &gt; 1\)</span> .</p>
<p>显然也有<span class="math inline">\(( n - 1 ) C_{ n - 1 } = ( n - 1
)^2 + n - 1 + 2 \sum_{ i = 0 }^{ n - 2 } C_i , n &gt; 2\)</span>.</p>
<p>二式相消,有<span class="math inline">\(nC_n - ( n - 1 ) C_{ n - 1 } =
2 n + 2 C_{ n - 1 } , n &gt; 2\)</span>.</p>
<p>而同时有<span class="math inline">\(C_2 = 3\)</span>.即:<span class="math inline">\(nC_n = ( n + 1 ) C_{ n - 1 } + 2 n , n &gt;
2\)</span>,可以使用转化和式的方法,两边乘以<span class="math inline">\(\frac{ 1 }{ n ( n + 1 ) }\)</span>解决.</p>
<h5><span id="example2">Example2</span></h5>
<p>已知<span class="math inline">\(a_1 = 1\)</span>,<span class="math inline">\(a_n = \sqrt{ S_n } + \sqrt{ S_{ n - 1 }
}\)</span>,求<span class="math inline">\(a_n\)</span>.</p>
<p>注意到<span class="math inline">\(a_n = S_n - S_{ n - 1
}\)</span>,则有<span class="math inline">\(\sqrt{ S_n } - \sqrt{ S_{ n -
1 } } = 1\)</span>,于是<span class="math inline">\(\sqrt{ S_n } =
n\)</span>,<span class="math inline">\(S_n = n^2\)</span>,<span class="math inline">\(a_n = 2 n - 1\)</span>.</p>
<h4><span id="成套方法">成套方法</span></h4>
<p>如果我们有</p>
<p>&amp; n=1\</p>
<p>2f(n 2)+&amp; n=2k,k\</p>
<p>2f(2)+&amp;n=2k+1,k</p>
<p>\end{cases}</p>
<p>其中<span class="math inline">\(n = 2^m + l\)</span>且<span class="math inline">\(2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>该如何求出<span class="math inline">\(f ( n
)\)</span>的封闭形式呢?</p>
<p>由于所有的未知数都是以加法运算连接,显然有<span class="math inline">\(f ( n ) = A ( n ) \alpha + B ( n ) \beta + C ( n )
\gamma\)</span>,而有<span class="math inline">\(A 、 B 、
C\)</span>互不影响且<span class="math inline">\(\alpha \beta
\gamma\)</span>与<span class="math inline">\(ABC\)</span>无关.</p>
<p>那无论<span class="math inline">\(\beta\)</span>和<span class="math inline">\(\gamma\)</span>的取值如何,<span class="math inline">\(A ( n )\)</span>都不会受到影响,我们考虑<span class="math inline">\(\beta = \gamma =
0\)</span>的特殊情况,此时显然有<span class="math inline">\(A ( n ) =
2^m\)</span>.</p>
<p>接下来,我们考虑取<span class="math inline">\(\alpha \beta
\gamma\)</span>的特殊值,去得到ABC之间的关系.</p>
<p>例如，当<span class="math inline">\(f ( n ) =
1\)</span>时，由递推式可知<span class="math inline">\(\alpha = 1 , \beta
= \gamma = - 1\)</span>,那么有<span class="math inline">\(A ( n ) - B (
n ) - C ( n ) = f ( n ) = 1\)</span>.</p>
<p>同理，<span class="math inline">\(f ( n ) = n\)</span>时，可知<span class="math inline">\(\alpha = 1 , \beta = 0 , \gamma =
1\)</span>,此时有<span class="math inline">\(A ( n ) + C ( n ) = f ( n )
= n\)</span>.</p>
<p>显然可以通过解方程求得<span class="math inline">\(B ( n
)\)</span>和<span class="math inline">\(C ( n )\)</span>.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明<span class="math inline">\(ABC\)</span>互不影响且<span class="math inline">\(\alpha \beta \gamma\)</span>与<span class="math inline">\(ABC\)</span>无关,我们就可以使用这个方法.</p>
<p>这个东西的原理是什么呢?显然是因为其中存在一个线性无关性对吧.</p>
<h4><span id="线性递推">线性递推</span></h4>
<p>一个常系数的<span class="math inline">\(k\)</span>阶线性递推关系形如:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = P_n + \sum_{ i = 1 }^k c_i a_{ n - i } , n \geq k \\
a_0 &amp; = C_0 , a_1 = C_1 , . . . , a_{ k - 1 } = C_{ k - 1 }
\end{aligned}
\]</span></p>
<p>当<span class="math inline">\(P = 0\)</span>时,称作齐次线性递推.</p>
<h5><span id="特征方程">特征方程</span></h5>
<p>我们称方程<span class="math inline">\(r^k = \sum_{ i = 1 }^k c_i r^{
k - i
}\)</span>是该递推关系的特征方程,方程的解叫做该递推关系的特征根.</p>
<h5><span id="二阶线性齐次递推">二阶线性齐次递推</span></h5>
<p>若其特征方程有两个不同的根<span class="math inline">\(r_1\)</span>和<span class="math inline">\(r_2\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r_1^n + \alpha_2
r_2^n\)</span>.</p>
<p>若其特征方程有两个相同的根<span class="math inline">\(r\)</span>,那么存在两个常数<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>,满足<span class="math inline">\(a_n = \alpha_1 r^n + \alpha_2 nr^n\)</span>.</p>
<p>先考虑前者的证明,首先考虑对于<span class="math inline">\(n =
0\)</span>或者<span class="math inline">\(n =
1\)</span>的情况,我们考虑求出一组<span class="math inline">\(\alpha_1\)</span>和<span class="math inline">\(\alpha_2\)</span>来满足:</p>
<p><span class="math display">\[
\begin{aligned}
C_0 &amp; = \alpha_1 + \alpha_2 \\
C_1 &amp; = \alpha_1 r_1 + \alpha_2 r_2
\end{aligned}
\]</span></p>
<p>若<span class="math inline">\(r_1 \ne r_2\)</span>,可以解得:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha_1 &amp; = \cfrac{ C_1 - C_0 r_2 }{ r_1 - r_2 } \\
\alpha_2 &amp; = C_0 - \alpha_1
\end{aligned}
\]</span></p>
<p>接下来考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r_1^{ n - 1 } + \alpha_2 r_2^{ n - 1 } ) + c_2 (
\alpha_1 r_1^{ n - 2 } + \alpha_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 ( c_1 r_1^{ n - 1 } + c_2 r_1^{ n - 2 } ) + \alpha_2 (
c_1 r_2^{ n - 1 } + c_2 r_2^{ n - 2 } ) \\
&amp; = \alpha_1 r_1^n + \alpha_2 r_2^n
\end{aligned}
\]</span></p>
<p>接下来考虑后者,首先我们有<span class="math inline">\(\Delta = c_1^2 +
4 c_2 = 0\)</span>,考虑初始条件:</p>
$$
<span class="math display">\[\begin{aligned}
C_0 &amp; = \alpha_1 \\
C_1 &amp; = \alpha_1 r + \alpha_2 r \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来我们考虑数学归纳:</p>
<p><span class="math display">\[
\begin{aligned}
a_n &amp; = c_1 a_{ n - 1 } + c_2 a_{ n - 2 } \\
&amp; = c_1 ( \alpha_1 r^{ n - 1 } + \alpha_2 nr^{ n - 1 } - \alpha_2
r^{ n - 1 } ) + c_2 ( \alpha_1 r^{ n - 2 } + \alpha_2 nr^{ n - 2 } - 2
\alpha_2 r^{ n - 2 } ) \\
&amp; = a_n - c_1 \alpha_2 r^{ n - 1 } - 2 c_2 \alpha_2 r^{ n - 2 }
\end{aligned}
\]</span></p>
<p>我们接下来只需证明<span class="math inline">\(c_1 r + 2 c_2 =
0\)</span>即可.根据方程,不难发现<span class="math inline">\(r = \cfrac{
c_1 }{ 2 }\)</span>,根据<span class="math inline">\(\Delta =
0\)</span>,自然得证.</p>
<h5><span id="更一般的情况">更一般的情况</span></h5>
<p>直接在复数域上定义<span class="math inline">\(f_k ( x ) = \{ n^k x^n
\}_{ n = 0 }^\infty\)</span>,此时我们规定<span class="math inline">\(0^0
= 1\)</span>.特别地,当<span class="math inline">\(x =
0\)</span>的时候,定义<span class="math inline">\(f_k ( x
)\)</span>的第<span class="math inline">\(k\)</span>项是<span class="math inline">\(1\)</span>,其余项是<span class="math inline">\(0\)</span>.在此基础上定义线性映射<span class="math inline">\(T : ( a_n )_{ n = 0 }^\infty \mapsto ( a_{ n + 1 }
)_{ n = 0 }^\infty\)</span>,立刻见到:<span class="math inline">\(( T - x
)^{ k + 1 } f_k ( x ) = 0 , ( T - x )^k f_k ( x ) \ne
0\)</span>.原因只需简单数学归纳.而此还可以引出<span class="math inline">\(f_0 ( x ) , f_1 ( x ) ,
\cdots\)</span>线性无关.</p>
<p>在此基础上观察线性递推<span class="math inline">\(a_{ n + d } = c_{ d
- 1 } a_{ n + d - 1 } + \cdots + c_0 a_n\)</span>,不妨取<span class="math inline">\(G ( x ) = x^d - c_{ d - 1 } x^{ d - 1 } - \cdots -
c_0\)</span>,立刻应当见到如果<span class="math inline">\(a\)</span>是<span class="math inline">\(G\)</span>的根并且重数为<span class="math inline">\(e ( a )\)</span>,那么<span class="math inline">\(f_{ 0 } ( x ) , \cdots , f_{ e ( a ) - 1 } ( a
)\)</span>都在<span class="math inline">\(\ker f ( T
)\)</span>中.这恰好是该线性递推空间的维数个.我们需要说明它们线性无关,不妨反证,假设出现了形如<span class="math inline">\(\sum_j w_i f_i ( y ) = \sum_j w_j f_j ( x
)\)</span>的情况,此时对右边直接操作若干次<span class="math inline">\(( T
- x )\)</span>就可以把右边全部消成<span class="math inline">\(0\)</span>,在对着左边消几次就可以使得左边只留下最高次项,这个时候发现最高次项是消不掉的,原因是将每一个位置看作关于<span class="math inline">\(n\)</span>的多项式右边的<span class="math inline">\(( T - x
)\)</span>是不会改变左边这边的每一个位置多项式的<span class="math inline">\(\deg\)</span>,这当然意味着不可能消干净.</p>
<h6><span id="再再进一步">再再进一步</span></h6>
<p>我们都知道矩阵加速:也就是<span class="math inline">\(\vec{ x }_{ k +
1 } = A \vec{ x }\)</span>,<span class="math inline">\(\vec{ x }_{ n } =
A^n \vec{ x }_0\)</span>.而我们又知道CH定理:<span class="math inline">\(p ( A ) = 0\)</span>,我们用多项式取膜,有<span class="math inline">\(A^n = p ( A ) F ( A ) + G ( A ) = G ( A
)\)</span>,这就是解.</p>
<h3><span id="约瑟夫问题">约瑟夫问题</span></h3>
<p>考虑n个人围成一圈,从第一个人开始,每隔一个人就杀掉一个人.如10个人围成一圈时,杀人的顺序是<span class="math inline">\(2 , 4 , 6 , 8 , 10 , 3 , 7 , 1 ,
9\)</span>.问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.考虑第一遍杀掉n号或者n-1号之后,对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时,我们有<span class="math inline">\(J ( 2 n ) = 2 J
( n ) - 1\)</span>;当人数是奇数时,我们杀掉一号,然后有<span class="math inline">\(J ( 2 n + 1 ) = 2 J ( n ) + 1\)</span>.</p>
<p>整理得到:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>仍然可以使用数学归纳，如果令<span class="math inline">\(n = 2^m + l
且 2^m \leq n &lt; 2^{ m + 1 }\)</span>.</p>
<p>有<span class="math inline">\(J ( n ) = 2 l + 1\)</span>.</p>
<p>要是注意力没有那么集中怎么办呢?考虑到这个东西显然和取膜有着不可分割的关系,我们不妨从<span class="math inline">\(0\)</span>开始编号:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
0 &amp; n = 1 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 1 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>这下相信<span class="math inline">\(J ( n
)\)</span>是多少就很显然了,将<span class="math inline">\(n\)</span>写成二进制的形式,这个就相当于把首位<span class="math inline">\(1\)</span>抹去然后在末尾加个<span class="math inline">\(0\)</span>.</p>
<h4><span id="example具体数学115">Example(《具体数学》1.15)</span></h4>
<p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4><span id="solution">Solution</span></h4>
<p>显然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
2 &amp; n = 2 \\
1 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) - 1 &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 1 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>从<span class="math inline">\(0\)</span>开始编号,自然有:</p>
<p><span class="math display">\[
J ( n ) = \begin{cases}
1 &amp; n = 2 \\
0 &amp; n = 3 \\
2 J ( \frac{ n }{ 2 } ) &amp; n = 2 k + 2 , k \in \mathbb{ N_+ } \\
2 J ( \frac{ n - 1 }{ 2 } ) + 2 &amp; n = 2 k + 3 , k \in \mathbb{ N_+ }
\end{cases}
\]</span></p>
<p>显然<span class="math inline">\(J ( n
)\)</span>也可以用二进制表达其形式.</p>
<h2><span id="和式">和式</span></h2>
<h3><span id="和式的基本运算">和式的基本运算</span></h3>
<p>分配律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ca_i = c \sum_{ i \in S } a_i
\]</span></p>
<p>一般分配律:</p>
<p><span class="math display">\[
\sum_{ i } \sum_{ j } a_{ i } b_j = ( \sum_{ i } a_i ) ( \sum_j b_j )
\]</span></p>
<p>结合律:</p>
<p><span class="math display">\[
\sum_{ i \in S } ( a_i + b_i ) = \sum_{ i \in S } a_i + \sum_{ i \in S }
b_i
\]</span></p>
<p>交换律:</p>
<p><span class="math display">\[
\sum_{ i \in S } a_i = \sum_{ p ( i ) \in S } a_{ p ( i ) }
\]</span></p>
<p>交换求和顺序:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i } \sum_{ j } a_{ i , j } [ P ( i , j ) ] &amp; = \sum_{ j }
\sum_{ i } a_{ i , j } [ P ( i , j ) ] \\
\sum_{ i = 1 }^n \sum_{ j = i }^n a_{ i , j } &amp; = \sum_{ j = 1 }^n
\sum_{ i = 1 }^j a_{ i , j }
\end{aligned}
\]</span></p>
<h3><span id="和式的封闭形式">和式的封闭形式</span></h3>
<h4><span id="交换顺序法">交换顺序法</span></h4>
<h5><span id="example1等差数列求和">Example1(等差数列求和)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ( ai + b ) = \sum_{ i = 0 }^n ( a ( n - i )
+ b ) \\
2 S_n &amp; = \sum_{ i = 0 }^n ( an + 2 b ) = an ( n + 1 ) + 2 b ( n + 1
) \\
S_n &amp; = ( n + 1 ) ( \frac{ an }{ 2 } + b )
\end{aligned}
\]</span></p>
<h5><span id="example2切比雪夫单调不等式">Example2(切比雪夫单调不等式)</span></h5>
<p>令<span class="math inline">\(S = \sum_{ 1 \leq i &lt; j \leq n } (
a_j - a_i ) ( b_j - b_i ) = \sum_{ 1 \leq j &lt; i \leq n } ( a_j - a_i
) ( b_j - b_i )\)</span>.</p>
<p>考虑恒等式<span class="math inline">\([ 1 \leq j &lt; i \leq n ] + [
1 \leq i &lt; j \leq n ] = [ 1 \leq j , i \leq n ] - [ 1 \leq i = j \leq
n ]\)</span>.</p>
<p>那么我们有:</p>
<p><span class="math display">\[
\begin{aligned}
2 S &amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) -
\sum_{ 1 \leq i = j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = \sum_{ 1 \leq i , j \leq n } ( a_j - a_i ) ( b_j - b_i ) \\
&amp; = 2 n \sum_{ i = 1 }^n a_i b_i - 2 ( \sum_{ i = 1 }^n a_i ) (
\sum_{ j = 1 }^n b_j ) \\
( \sum_{ i = 1 }^n a_i ) ( \sum_{ j = 1 }^n b_j ) &amp; = n \sum_{ i = 1
}^n a_i b_i - \sum_{ 1 \leq i &lt; j \leq n } ( a_j - a_i ) ( b_j - b_i
)
\end{aligned}
\]</span></p>
<p>显然有以下式子:</p>
<p>(_{i=1}<sup>na_i)(<em>{j=1}^nb_j)n</em>{i=1}</sup>na_ib_i，i&lt;j，a_ia_j且b_ib_j\</p>
<p>上式被称为切比雪夫单调不等式.</p>
<p>值得一提的是,切比雪夫单调不等式其实是排序不等式的一个特化版本.</p>
<h5><span id="example3拉格朗日恒等式">Example3(拉格朗日恒等式)</span></h5>
<p>证明:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 &amp; = ( \sum_{
i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - ( \sum_{ i = 1 }^n a_i
b_i )^2 \\

\end{aligned}\]</span>
<p>$$</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ 1 \leq j &lt; k \leq n } ( a_j b_k - a_k b_j )^2 \\
2 S_n &amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j b_k - a_k b_j )^2
\\
&amp; = \sum_{ j = 1 }^n \sum_{ k = 1 }^n ( a_j^2 b_k^2 - 2 a_j a_k b_j
b_k + a_k^2 b_j^2 ) \\
&amp; = 2 ( \sum_{ i = 1 }^n a_i^2 ) ( \sum_{ i = 1 }^n b_i^2 ) - 2 (
\sum_{ i = 1 }^n a_i b_i )^2
\end{aligned}
\]</span></p>
<h4><span id="扰动法">扰动法</span></h4>
<h5><span id="example1等比数列求和">Example1(等比数列求和)</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n ax^i \\
&amp; = a + \sum_{ i = 1 }^n ax^i \\
&amp; = a + x \sum_{ i = 0 }^{ n - 1 } ax^i \\
&amp; = a + xS_{ n - 1 }
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(S_{ n - 1 } + ax^n = S_n = a + xS_{ n -
1 }\)</span>,有<span class="math inline">\(S_n + ax^{ n + 1 } = a + xS_n
, S_n = a \frac{ x^{ n + 1 } - 1 }{ x - 1 }\)</span>，其中<span class="math inline">\(x \ne 1\)</span>.</p>
<h5><span id="example2平方和公式">Example2(平方和公式)</span></h5>
<p>如果直接对该公式使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 0 }^n i^2 = \sum_{ i = 0 }^{ n - 1 } i^2 + n^2 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^2 + n^2 \\
&amp; = S_n - 2 \sum_{ i = 1 }^n i + n + n^2
\end{aligned}
\]</span></p>
<p>我们无法得到<span class="math inline">\(S_n\)</span>的封闭形式,但我们发现我们得到了<span class="math inline">\(\sum_{ i = 1 }^n i\)</span>的封闭形式.</p>
<p>那以此类推,我们设<span class="math inline">\(W_n = \sum_{ i = 0 }
i^3\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
W_n &amp; = \sum_{ i = 0 }^{ n - 1 } i^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n ( i - 1 )^3 + n^3 \\
&amp; = \sum_{ i = 1 }^n i^3 - 3 \sum_{ i = 1 }^n i^2 + 3 \sum_{ i = 1
}^n i - n + n^3 \\
&amp; = W_n - 3 S_n + 3 \frac{ n + n^2 }{ 2 } - n + n^3 \\
S_n &amp; = \frac{ n + n^2 }{ 2 } - \frac{ n - n^3 }{ 3 } \\
&amp; = \frac{ n + 3 n^2 + 2 n^3 }{ 6 } \\
&amp; = \frac{ n ( 1 + 3 n + 2 n^2 ) }{ 6 } \\
&amp; = \frac{ n ( 2 n + 1 ) ( n + 1 ) }{ 6 }
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学220">Example3(《具体数学》2.20)</span></h5>
<p>令<span class="math inline">\(H_n = \sum_{ k = 1 }^n \frac{ 1 }{ k
}\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^n
H_i\)</span>.</p>
<h5><span id="solution3">Solution3</span></h5>
<p>不妨考虑<span class="math inline">\(\sum_{ i = 0 }^n iH_{ i
}\)</span>的值.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 0 }^n iH_{ i } &amp; = \sum_{ i = 1 }^n [ ( i - 1 + 1 ) H_{ i
- 1 } + 1 ] \\
&amp; = n + \sum_{ i = 0 }^{ n - 1 } H_i + \sum_{ i = 0 }^{ n } iH_i -
nH_n \\
\sum_{ i = 0 }^{ n - 1 } H_i &amp; = n ( H_n - 1 ) \\
\sum_{ i = 0 }^n H_i &amp; = ( n + 1 ) ( H_{ n + 1 } - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example4具体数学221">Example4(《具体数学》2.21)</span></h5>
<p>求<span class="math inline">\(S_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i
} , T_n = \sum_{ i = 0 }^n ( - 1 )^{ n - i } i , U_n = \sum_{ i = 0 }^n
( - 1 )^{ n - i } i^2\)</span>.</p>
<h5><span id="solution-4">Solution 4</span></h5>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ i = 1 }^{ n } ( - 1 )^{ n - i } + ( - 1 )^n \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{
n - 1 - i } \\
- S_{ n - 1 } + 1 &amp; = ( - 1 )^n + S_{ n - 1 } \\
S_{ n - 1 } &amp; = \frac{ 1 - ( - 1 )^n }{ 2 } \\
S_n &amp; = \frac{ 1 + ( - 1 )^n }{ 2 }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
T_{ n } &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) +
\sum_{ i = 1 }^n ( - 1 )^{ n - i } \\
- T_{ n - 1 } + n &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 }
i + \sum_{ i = 0 }^n ( - 1 )^{ n - i } - ( - 1 )^n \\
- T_{ n - 1 } + n &amp; = T_{ n - 1 } + S_n - ( - 1 )^n \\
n - \frac{ 1 - ( - 1 )^n }{ 2 } &amp; = 2 T_{ n - 1 } \\
T_n &amp; = \frac{ 1 }{ 2 } ( n + 1 + \frac{ - 1 - ( - 1 )^n }{ 2 } ) =
\frac{ 1 }{ 2 } ( n + \frac{ 1 - ( - 1 )^n }{ 2 } )
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
U_n &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } i^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 +
1 )^2 \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1
)^2 + 2 \sum_{ i = 1 }^n ( - 1 )^{ n - i } ( i - 1 ) + \sum_{ i = 1 }^n
( - 1 )^{ n - i } \\
- U_{ n - 1 } + n^2 &amp; = \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1
} i^2 + 2 \sum_{ i = 0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } i + \sum_{ i =
0 }^{ n - 1 } ( - 1 )^{ n - i - 1 } \\
- U_{ n - 1 } + n^2 &amp; = U_{ n - 1 } + 2 T_{ n - 1 } + S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - 2 T_{ n - 1 } - S_{ n - 1 } \\
2 U_{ n - 1 } &amp; = n^2 - ( n - \frac{ 1 - ( - 1 )^n }{ 2 } ) - \frac{
1 - ( - 1 )^n }{ 2 } \\
2 U_{ n - 1 } &amp; = n^2 - n \\
U_n &amp; = \frac{ n ( n + 1 ) }{ 2 }
\end{aligned}
\]</span></p>
<h4><span id="转化为递归式">转化为递归式</span></h4>
<p>考虑和式<span class="math inline">\(S_n = \sum_{ i = 0 }^n f ( i ) =
S_{ n - 1 } + f ( n ) \\\)</span>，显然是递归式形式.</p>
<p>因此递归式所可以使用的方法同样可以在和式中使用.</p>
<h5><span id="example1具体数学213">Example1(《具体数学》2.13)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 0 }^n ( - 1 )^i i^2
\\\)</span>.</p>
<h5><span id="solution1">Solution1</span></h5>
<p>令<span class="math inline">\(S ( n ) = \sum_{ i = 0 }^n ( - 1 )^i
i^2 = S ( n - 1 ) + ( - 1 )^n n^2\)</span>,考虑使用成套方法.</p>
<p>不妨令<span class="math inline">\(S ( n ) = S ( n - 1 ) + ( - 1 )^n (
\alpha + \beta n + \gamma n^2 ) = \alpha A ( n ) + \beta B ( n ) +
\gamma C ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n , 可 以 解 得
\alpha = - 1 , \beta = 2 , \gamma = 0\)</span>,有<span class="math inline">\(( - 1 )^n n = - A ( n ) + 2 B ( n )\)</span>.</p>
<p>令<span class="math inline">\(S ( n ) = ( - 1 )^n n^2 , 可 以 解 得
\alpha = 1 , \beta = - 2 , \gamma = 2\)</span>,有<span class="math inline">\(( - 1 )^n n^2 = A ( n ) - 2 B ( n ) + 2 C ( n
)\)</span>.</p>
<p>显然可解得<span class="math inline">\(2 C ( n ) = ( - 1 )^n n^2 + ( -
1 )^n n , C ( n ) = ( - 1 )^n \frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<p>而原式中,<span class="math inline">\(S ( n ) = C ( n ) = ( - 1 )^n
\frac{ n ( n + 1 ) }{ 2 }\)</span>.</p>
<h5><span id="example2具体数学219">Example2(《具体数学》2.19)</span></h5>
<p>有<span class="math inline">\(2 T_n = nT_{ n - 1 } + 3 n ! , T_0 =
5\)</span>,求<span class="math inline">\(T_n\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p>令<span class="math inline">\(s_n = \frac{ 2^{ n - 1 } }{ n !
}\)</span>,两边同时乘以<span class="math inline">\(s_n\)</span>,有<span class="math inline">\(\frac{ 2^n }{ n ! } T_n = \frac{ 2^{ n - 1 } }{ (
n - 1 ) ! } T_{ n - 1 } + 3 \times 2^{ n - 1 } \\\)</span>.</p>
<p>令<span class="math inline">\(S_n = \frac{ 2^n }{ n ! }
T_n\)</span>,有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = S_{ n - 1 } + 3 \times 2^{ n - 1 } \\
&amp; = 5 + 3 \sum_{ i = 0 }^{ n - 1 } 2^i \\
&amp; = 5 + 3 \times 2^{ n + 1 } - 3 \\
&amp; = 3 \times 2^{ n } + 2 \\
T_n &amp; = 3 n ! + \frac{ n ! }{ 2^{ n - 1 } }
\end{aligned}
\]</span></p>
<h4><span id="转化为积分形式">转化为积分形式</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>考虑先求出一个近似解,然后再求误差.</p>
<p>考虑函数<span class="math inline">\(f ( x ) = x^2\)</span>,显然<span class="math inline">\(\int_0^n x^2 dx = \frac{ n^3 }{ 3 } \sim S_n
\\\)</span>.</p>
<p>接下来,我们考虑求得二者之间的误差,设<span class="math inline">\(E_n =
S_n - \frac{ n^3 }{ 3 } \\\)</span>,对其使用扰动法:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \frac{ n^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 + 1 )^3 }{ 3 } \\
&amp; = S_{ n - 1 } + n^2 - \frac{ ( n - 1 )^3 }{ 3 } - ( n - 1 )^2 - (
n - 1 ) - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n^2 - n^2 + 2 n - 1 - n + 1 - \frac{ 1 }{ 3 } \\
&amp; = E_{ n - 1 } + n - \frac{ 1 }{ 3 }
\end{aligned}
\]</span></p>
<p>这样就得到了递归式,可以求得封闭形式.</p>
<p>还有一种方法是:</p>
<p><span class="math display">\[
\begin{aligned}
E_n &amp; = S_n - \int_0^n x^2 dx \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \int_{ k - 1 }^k x^2 dx ) \\
&amp; = \sum_{ k = 1 }^n ( k^2 - \frac{ k^3 - ( k - 1 )^3 }{ 3 } ) \\
&amp; = \sum_{ k = 1 }^n ( k - \frac{ 1 }{ 3 } )
\end{aligned}
\]</span></p>
<p>这是一个简单的和式.而<span class="math inline">\(S_n = E_n + \frac{
n^3 }{ 3 } \\\)</span>,显然也可以求得.</p>
<h5><span id="example2某浙江高考题">Example2(某浙江高考题)</span></h5>
<p>已知<span class="math inline">\(a_1 = 1 , a_{ n + 1 } - a_n = -
\frac{ 1 }{ 3 } a_n^2\)</span>,估计<span class="math inline">\(a_n\)</span>的值.</p>
<p>考虑构造一个函数<span class="math inline">\(f ( n )\)</span>使得<span class="math inline">\(f ( n ) \approx a_n\)</span>,那我们就可以将<span class="math inline">\(a_{ n + 1 } - a_n \approx f_n\)</span>.</p>
<p>这个第一眼看上去就很有道理,而事实上也确实很有道理,原因是根据拉格朗日中值定理,<span class="math inline">\(\exists x_0 \in [ n , n + 1 ] , f &#39; ( x_0 ) =
f ( n + 1 ) - f ( n )\)</span>,而对于增长率变化不大的函数,直接认为<span class="math inline">\(f &#39; ( x_0 ) = f &#39; ( n
)\)</span>是有理可循的!</p>
<p>然后,原式子就变成了一个微分方程了,带入<span class="math inline">\(f (
1 ) = 1\)</span>解得<span class="math inline">\(f ( n ) = \frac{ 3 }{ n
+ 2 }\)</span>.这个精度已经足够选出来原本的放缩题的答案了.</p>
<p>令<span class="math inline">\(a_n = \frac{ 3 }{ n + 2 } -
b_n\)</span>,带入化简,得到<span class="math inline">\(\{ b_n
\}\)</span>的递推式:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{ 3 }{ n + 3 } - b_{ n + 1 } &amp; = ( \frac{ 3 }{ n + 2 } - b_n )
( 1 - \frac{ 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_{ n + 1 } - \frac{ 3 }{ n + 3 } &amp; = ( b_n - \frac{ 3 }{ n + 2 } )
( \frac{ n + 1 }{ n + 2 } + \frac{ b_n }{ 3 } ) \\
b_1 &amp; = 0 , b_{ n + 1 } = \frac{ b_n^2 }{ 3 } + \frac{ n }{ n + 2 }
b_n + \frac{ 3 }{ ( n + 2 )^2 ( n + 3 ) }
\end{aligned}
\]</span></p>
<p>算到这里,我们可以很轻易使用数学归纳法算出<span class="math inline">\(b_n \leq \frac{ 1 }{ 4 n
}\)</span>,这个精度已经挺不错的了,但是也让人觉得很不满意,因为这个误差项怎么和估计项是同阶的啊.</p>
<p>然后我开始估计了一下这个<span class="math inline">\(b_n\)</span>的阶,因为我其实没学过什么高超的高数技巧,所以我使用了OI的一些技巧来估计,不妨假设<span class="math inline">\(b_n^2 &lt; &lt; b_n\)</span>:</p>
<p>那么这个<span class="math inline">\(b_n\)</span>是<span class="math inline">\(O ( \frac{ \ln n }{ n^2 } )\)</span>级别的.</p>
<p>如何理解这个级别?考虑别乱动<span class="math inline">\(b_n\)</span>的系数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
b_{ n + 1 } &amp; = \frac{ n }{ n + 2 } b_n + \frac{ 1 }{ n ( n + 1 ) (
n + 2 ) } \\
( n + 1 ) ( n + 2 ) b_{ n + 1 } &amp; = n ( n + 1 ) b_n + \frac{ 1 }{ n
} \\
g ( n ) &amp; = n ( n + 1 ) b_n , g &#39; ( n ) = \frac{ 1 }{ n } , g (
n ) = \ln n \\
b_n &amp; = \frac{ \ln n }{ n^2 }
\end{aligned}
\]</span></p>
<p>这警戒我们以后乱估计的时候千万别把<span class="math inline">\(O ( n^{
\epsilon } )\)</span>和<span class="math inline">\(O ( 1
)\)</span>搞混了,警钟长鸣.</p>
<p>这个时候大概估计一下会发现<span class="math inline">\(b_n \leq \frac{
3 \ln n }{ n ( n + 1 ) }\)</span>.</p>
<h4><span id="展开和收缩">展开和收缩</span></h4>
<h5><span id="example1平方和公式">Example1(平方和公式)</span></h5>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_n &amp; = \sum_{ k = 1 }^n k^2 \\
&amp; = \sum_{ k = 1 }^n \sum_{ i = 1 }^k k \\
&amp; = \sum_{ i = 1 }^n \sum_{ k = i }^n k \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( i + n ) ( n - i + 1 ) \\
&amp; = \sum_{ i = 1 }^n \frac{ 1 }{ 2 } ( in - i^2 + i + n^2 - ni + n )
\\
&amp; = \frac{ 1 }{ 2 } ( \sum_{ i = 1 }^n i - \sum_{ i = 1 }^n i^2 +
n^3 + n^2 ) \\
&amp; = \frac{ 1 }{ 4 } n ( n + 1 ) - \frac{ 1 }{ 2 } S_n + \frac{ n^3 +
n^2 }{ 2 }
\end{aligned}
\]</span></p>
<p>整理得到<span class="math inline">\(S_n\)</span>.</p>
<h5><span id="example2具体数学214">Example2(《具体数学》2.14)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i 2^i \\\)</span>.</p>
<h5><span id="solution-2">Solution 2</span></h5>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n i 2^i &amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i 2^i \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n 2^i \\
&amp; = \sum_{ j = 1 }^n ( 2^{ n + 1 } - 2^j ) \\
&amp; = n 2^{ n + 1 } - ( 2^{ n + 1 } - 2 ) \\
&amp; = ( n - 1 ) 2^{ n + 1 } + 2
\end{aligned}
\]</span></p>
<h5><span id="example3具体数学215">Example3(《具体数学》2.15)</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n i^3 \\\)</span>.</p>
<h5><span id="solution-3">Solution 3</span></h5>
<p><span class="math display">\[
\begin{aligned}
S ( n ) &amp; = \sum_{ i = 1 }^n i^3 \\
&amp; = \sum_{ i = 1 }^n \sum_{ j = 1 }^i i^2 \\
&amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n i^2 \\
&amp; = \sum_{ j = 1 }^n ( \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 6 } -
\frac{ ( j - 1 ) j ( 2 j - 1 ) }{ 6 } ) \\
&amp; = \frac{ n^2 ( n + 1 ) ( 2 n + 1 ) }{ 6 } - \frac{ 1 }{ 3 } S ( n
) + \frac{ n ( n + 1 ) ( 2 n + 1 ) }{ 12 } - \frac{ n ( n + 1 ) }{ 12 }
\\
S ( n ) &amp; = \frac{ n^2 ( n + 1 )^2 }{ 4 }
\end{aligned}
\]</span></p>
<h5><span id="exampleex">ExampleEX</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n iq^i ( q \ne 1
)\)</span>.</p>
<h5><span id="solutionex">SolutionEX</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum_{ i = 1 }^n iq^i &amp; = \sum_{ j = 1 }^n \sum_{ i = j }^n q^i \\
&amp; = \sum_{ j = 1 }^n \frac{ q^j - q^{ n + 1 } }{ 1 - q } \\
&amp; = \frac{ 1 }{ q - 1 } \sum_{ j = 1 }^n ( q^{ n + 1 } - q^j ) \\
&amp; = \frac{ 1 }{ q - 1 } ( nq^{ n + 1 } - \frac{ q^{ n + 1 } - q }{ q
- 1 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="exampleex2">ExampleEX2</span></h5>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n ( ai + b ) q^{ i - 1 }
( q \ne 1 )\)</span>.</p>
<h5><span id="solutionex2">SolutionEX2</span></h5>
<p>令<span class="math inline">\(A = \frac{ a }{ q - 1 } , B = \frac{ b
- A }{ q - 1 }\)</span>,答案为<span class="math inline">\(( An + B ) q^n
- B\)</span>.</p>
<h4><span id="有限微积分">有限微积分</span></h4>
<h5><span id="移位算子">移位算子</span></h5>
<p>定义移位算子<span class="math inline">\(E\)</span>，使得<span class="math inline">\(Ef ( x ) = f ( x + 1 )\)</span>.</p>
<h5><span id="差分算子">差分算子</span></h5>
<p>定义差分算子<span class="math inline">\(\Delta f ( x ) = f ( x + 1 )
- f ( x )\)</span>，类似于无限微积分中的D算子.</p>
<p>另外,不难发现有<span class="math inline">\(\Delta = E -
1\)</span>.</p>
<h5><span id="逆差分算子">逆差分算子</span></h5>
<p>定义逆差分算子<span class="math inline">\(\Sigma\)</span>,可以得到有限微积分的基本定理:</p>
$$
<span class="math display">\[\begin{aligned}
g ( x ) &amp; = \Delta f ( x ) \Leftrightarrow \sum g ( x ) \delta x = f
( x ) + C \\

\end{aligned}\]</span>
<p>$$</p>
<p>这里的<span class="math inline">\(\Sigma\)</span>又被称为不定和式,是差分等于<span class="math inline">\(g\)</span>的一个函数类.</p>
<p>值得一提的是,这里的<span class="math inline">\(C\)</span>与无限微积分中的<span class="math inline">\(C\)</span>有一定区别,这里的<span class="math inline">\(C\)</span>可以是满足<span class="math inline">\(p
( x ) = p ( x + 1 )\)</span>的任意一个函数而不非得是常数函数.</p>
<h5><span id="定和式">定和式</span></h5>
<p>如果<span class="math inline">\(g ( x ) = \Delta f ( x
)\)</span>,那么有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = f ( x ) |^{ b }_a = f ( b ) - f ( a ) \\\)</span>.</p>
<p>值得一提的是,如果<span class="math inline">\(a \leq
b\)</span>,显然有<span class="math inline">\(\sum \nolimits_{ a }^b g (
x ) \delta x = \sum_{ x = a }^{ b - 1 } g ( x ) \\\)</span>.</p>
<p>但如果<span class="math inline">\(a &gt; b\)</span>,那么<span class="math inline">\(\sum \nolimits_{ a }^b g ( x ) \delta x = - \sum
\nolimits_b^a g ( x ) \delta x \\\)</span>.</p>
<p>事实上,我们一定有:<span class="math inline">\(\sum \nolimits_a^b g (
x ) \delta x + \sum \nolimits_b^c g ( x ) \delta x = \sum \nolimits_a^c
g ( x ) \delta x \\\)</span>.</p>
<h5><span id="一些基本的公式">一些基本的公式</span></h5>
<p>类比无限微积分中的<span class="math inline">\(D ( x^m ) = mx^{ m - 1
}\)</span>，有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( x^{ \underline{ m } } ) &amp; = mx^{ \underline{ m - 1 } } \\
\sum mx^{ \underline{ m - 1 } } \delta x &amp; = x^{ \underline{ m } } +
C , m \ne 0 \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( \ln x ) = \frac{ 1
}{ x }\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( H ( x ) ) &amp; = x^{ \underline{ - 1 } } = \frac{ 1 }{ x + 1 }
\\
\sum x^{ \underline{ - 1 } } \delta x &amp; = H ( x ) + C \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>类比无限微积分中的<span class="math inline">\(D ( e^x ) =
e^x\)</span>,有:</p>
$$
<span class="math display">\[\begin{aligned}
\Delta ( 2^x ) &amp; = 2^x , \sum 2^x \delta x = 2^x + C \\
\Delta ( c^x ) &amp; = ( c - 1 ) c^x , \sum c^x \delta x = \frac{ c^x }{
c - 1 } + C , c \ne 1 \\
\Delta ( c^{ \underline{ x } } ) &amp; = \frac{ c^{ \underline{ x + 2 }
} }{ c - x } , \sum \frac{ c^{ \underline{ x + 2 } } }{ c - x } \delta x
= c^{ \underline{ x } } + C , c - x \ne 0 \\

\end{aligned}\]</span>
<p>$$</p>
<p>根据组合数公式,有:</p>
<p><span class="math display">\[
\begin{aligned}
\Delta ( \binom{ x }{ k } ) &amp; = \binom{ x }{ k - 1 } \\
\sum \binom{ x }{ k - 1 } \delta x &amp; = \binom{ x }{ k } + C
\end{aligned}
\]</span></p>
<h6><span id="example平方和公式">Example(平方和公式)</span></h6>
<p>我们有:<span class="math inline">\(k^2 = k^{ \underline{ 2 } } + k^{
\underline{ 1 } } \\\)</span>.</p>
<p>那么:</p>
<p><span class="math display">\[
\begin{aligned}
S_{ n - 1 } &amp; = \sum_{ i = 0 }^{ n - 1 } i^2 \\
&amp; = \sum_{ i = 0 }^{ n - 1 } ( i^{ \underline{ 2 } } + i^{
\underline{ 1 } } ) \\
&amp; = \sum \nolimits_{ 0 }^n x^{ \underline{ 2 } } \delta x + \sum
\nolimits_{ 0 }^n x^{ \underline{ 1 } } \delta x \\
&amp; = \frac{ n^\underline{ 3 } }{ 3 } + \frac{ n^{ \underline{ 2 } }
}{ 2 }
\end{aligned}
\]</span></p>
<p>整理即可得到封闭形式.</p>
<p>值得一提的是:</p>
<p>与前面的方法不同，这里没有使用三次的二项式公式，而是使用了二次的斯特林公式负责将一般幂转化为下降幂.</p>
<h5><span id="高阶差分">高阶差分</span></h5>
<p>考虑一阶差分是<span class="math inline">\(\Delta f ( x ) = f ( x + 1
) - f ( x )\)</span>,那么二阶差分就是<span class="math inline">\(\Delta^2 f ( x ) = f ( x + 2 ) - 2 f ( x + 1 ) + f
( x )\)</span>.</p>
<p>类似地,我们可以通过归纳法证明<span class="math inline">\(\Delta^n f (
x ) = \sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } f ( x + k )
\\\)</span>.</p>
<p>事实上有一种更简单的证明方法,由于<span class="math inline">\(\Delta =
E - 1\)</span>,于是<span class="math inline">\(\Delta^n = ( E - 1 )^n =
\sum_{ k } \binom{ n }{ k } ( - 1 )^{ n - k } E^k \\\)</span>,由于<span class="math inline">\(E^k f ( x ) = f ( x + k
)\)</span>,即可证明原式.</p>
<p>另外,不难发现如果<span class="math inline">\(f ( x
)\)</span>是一个关于<span class="math inline">\(x\)</span>的<span class="math inline">\(d\)</span>次多项式,那么<span class="math inline">\(\Delta f ( x )\)</span>是一个<span class="math inline">\(d - 1\)</span>次多项式.同理,<span class="math inline">\(\Delta^d f ( x )\)</span>会是一个常数而<span class="math inline">\(\Delta^{ d + 1 } f ( x )\)</span>会是<span class="math inline">\(0\)</span>,这个发现引出了牛顿级数.</p>
<h6><span id="exampleyloi2020灼">Example([yLOI2020]灼)</span></h6>
<p>首先不难发现对于一个位置,有意义的只有相邻的两个虫洞,设这两个位置分别为<span class="math inline">\(x_1 , x_2\)</span>.</p>
<p>不难写出期望转移式子:<span class="math inline">\(f_i = \cfrac{ 1 }{ 2
} ( f_{ i - 1 } + f_{ i + 1 } ) + 1\)</span>,并且<span class="math inline">\(f_{ x_1 } = f_{ x_2 } = 0\)</span>.</p>
<p>接下来如何做呢?</p>
<p>我们先对第一个式子进行变形:</p>
<p><span class="math display">\[
\begin{aligned}
f_i &amp; = \cfrac{ 1 }{ 2 } ( f_{ i - 1 } + f_{ i + 1 } ) + 1 \\
2 f_i &amp; = f_{ i - 1 } + f_{ i + 1 } + 2 \\
f_i - f_{ i - 1 } &amp; = f_{ i + 1 } - f_i + 2 \\
\Delta f_{ i - 1 } &amp; = \Delta f_{ i } + 2 \\
\Delta f_i - \Delta f_{ i - 1 } &amp; = - 2 \\
\Delta^2 f_{ i - 1 } &amp; = - 2
\end{aligned}
\]</span></p>
<p><span class="math inline">\(f\)</span>的二阶差分是常数,也就是说<span class="math inline">\(f\)</span>是二次多项式,不难求得其二次项系数为<span class="math inline">\(- 1\)</span>又知道两个零点,显然可以得到<span class="math inline">\(f\)</span>的表达式.</p>
<h5><span id="牛顿级数">牛顿级数</span></h5>
<p>令<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } a_i
x^i
\\\)</span>.而由于有斯特林数可以进行幂和下降幂的转换,则我们可以将其改写为<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } b_i x^{
\underline{ i } } \\\)</span>.</p>
<p>我们设<span class="math inline">\(c_i = i ! b_i\)</span>,于是有:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } c_i \binom{ x
}{ i } \\\)</span>.</p>
<p>也就是说,任何多项式都可以表示为二项式系数的倍数之和,我们称这样的展开式为<span class="math inline">\(f ( x )\)</span>的牛顿级数.</p>
<p>于是不难发现有:<span class="math inline">\(\Delta^n f ( x ) = \sum_{
0 \leq i \leq d } c_i \binom{ x }{ i - n } \\\)</span>.如果我们令<span class="math inline">\(x = 0\)</span>,则有:<span class="math inline">\(\Delta^n f ( 0 ) = \begin{cases}c_n &amp; n \leq d
\\ 0 &amp; n &gt; d\end{cases}\)</span>.那么牛顿级数的另一种表示即:<span class="math inline">\(f ( x ) = \sum_{ 0 \leq i \leq d } \Delta^i f ( 0
) \binom{ x }{ d } \\\)</span>.</p>
<p>另外,如果我们展开一下<span class="math inline">\(c_n = \Delta^n f ( 0
)\)</span>,我们可以得到公式:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } c_i \binom{ k }{ i } ) = ( - 1 )^n c_n , n \in
\mathbb{ N } \\\)</span>.</p>
<p>如果我们将多项式还原,由于<span class="math inline">\(a_n =
b_n\)</span>,有:</p>
<p><span class="math inline">\(\sum_{ k } \binom{ n }{ k } ( - 1 )^k (
\sum_{ 0 \leq i \leq n } a_i k^i ) = ( - 1 )^n n ! a_n , n \in \mathbb{
N } \\\)</span>.</p>
<p>另外,如果<span class="math inline">\(x \in \mathbb{ N
}\)</span>,那么我们有:<span class="math inline">\(f ( x ) = \sum_{ 0
\leq k } \Delta^k f ( 0 ) \binom{ x }{ 0
}\)</span>,根据多项式推理法,这个公式对<span class="math inline">\(\forall x \in \mathbb{ Z }\)</span>都成立.</p>
<p>于是我们可以类似泰勒级数写出无限牛顿级数:</p>
<p><span class="math display">\[
g ( a + x ) = \sum_{ 0 \leq k } \cfrac{ \Delta^k g ( a ) }{ k ! } x^{
\underline{ k } }
\]</span></p>
<h6><span id="example">Example</span></h6>
<p>求<span class="math inline">\(\sum_{ k } \binom{ n }{ k } \binom{ r -
sk }{ n } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果我们令<span class="math inline">\(f ( k ) = \binom{ r - sk }{ n }
= \sum_{ 0 \leq i \leq n } a_i k^i \\\)</span>,不难发现<span class="math inline">\(a_n = \cfrac{ ( - 1 )^n s^n }{ n !
}\)</span>,于是显然原式<span class="math inline">\(= s^n\)</span>.</p>
<h5><span id="分部求和法则abel求和法">分部求和法则(Abel求和法)</span></h5>
$$
<span class="math display">\[\begin{aligned}
\Delta ( uv ) &amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x ) \\
&amp; = u ( x + 1 ) v ( x + 1 ) - u ( x ) v ( x + 1 ) + u ( x ) v ( x +
1 ) - u ( x ) v ( x ) \\
&amp; = v ( x + 1 ) \Delta u + u ( x ) \Delta v = Ev \Delta u + u \Delta
v \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边取不定和，即可得到分部求和法则:</p>
<p><span class="math inline">\(\sum u \Delta v = uv - \sum Ev \Delta u
\\\)</span>.</p>
<p>分部求和用一般和式表达如下,下式又被称为Abel求和法:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = l }^{ r - 1 } ( a_{ i + 1 } - a_i ) b_i &amp; = a_r b_r - a_l
b_l - \sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( b_{ i + 1 } - b_i ) \\
\sum_{ i = l }^{ r - 1 } ( \Delta a_i ) b_i &amp; = a_r b_r - a_l b_l -
\sum_{ i = l }^{ r - 1 } a_{ i + 1 } ( \Delta b_i )
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(l = 0 , r = n , a_0 = b_0 =
0\)</span>的特殊情况,应当有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } ( \Delta a_i ) b_i &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } a_{ i + 1 } ( \Delta b_i ) \\
\sum_{ i = 1 }^n a_i ( b_{ i + 1 } - b_i ) &amp; = a_n b_n - \sum_{ i =
0 }^{ n - 1 } ( \Delta a_i ) b_i
\end{aligned}
\]</span></p>
<p>取两组数列<span class="math inline">\(\alpha ,
\beta\)</span>,并令<span class="math inline">\(\sum_{ i = 1 }^n \beta_i
= B_i\)</span>,立刻有:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \alpha_i \beta_i = \alpha_n B_n - \sum_{ i = 1 }^{ n -
1 } ( \alpha_{ i + 1 } - \alpha_i ) B_i
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k 2^k \\\)</span>.</p>
<p>根据分部求和法则，我们有:</p>
<p><span class="math inline">\(\sum x 2^x \delta x = x 2^x - \sum 2^{ x
+ 1 } \delta x = x 2^x - 2^{ x + 1 } + C \\\)</span>.</p>
<p>改为定和式形式，显然有:</p>
<p><span class="math inline">\(\sum_{ k = 0 }^n k 2^k = \sum
\nolimits_0^{ n + 1 } x 2^x \delta x = ( n + 1 ) 2^{ n + 1 } - 2^{ n + 2
} + 2 = ( n - 1 ) 2^{ n + 1 } + 2 \\\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>求<span class="math inline">\(\sum_{ k = 0 }^{ n - 1 } kH_k
\\\)</span>.</p>
<p>令<span class="math inline">\(u ( x ) = H_x , v ( x ) = \frac{ 1 }{ 2
} x^{ \underline{ 2 } } \\\)</span>.</p>
<p>带入分部求和法则，显然有:</p>
<p><span class="math inline">\(\sum xH_x \delta x = \frac{ x^\underline{
2 } }{ 2 } H_x - \frac{ x^\underline{ 2 } }{ 4 } + C \\\)</span>.</p>
<p>带入即可求出原式<span class="math inline">\(= \frac{ n^\underline{ 2
} }{ 2 } ( H_n - \frac{ 1 }{ 2 } ) \\\)</span>.</p>
<h6><span id="example3具体数学223">Example3(《具体数学》2.23)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i (
i + 1 ) } \\\)</span>.</p>
<h6><span id="solution-3">Solution 3</span></h6>
<p>令<span class="math inline">\(u = ( 2 n + 1 ) , v = - \frac{ 1 }{ i
}\)</span>,则<span class="math inline">\(\Delta u = 2 , \Delta v =
\frac{ 1 }{ i ( i + 1 ) }\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 1 }^n \frac{ 2 i + 1 }{ i ( i + 1 ) } &amp; = ( 2 n + 3 )
\times ( - \frac{ 1 }{ n + 1 } ) + 3 - \sum_{ i = 1 }^n ( - \frac{ 2 }{
i + 1 } ) \\
&amp; = - \frac{ 2 n + 3 }{ n + 1 } + 2 H_n + \frac{ n + 3 }{ n + 1 } =
2 H_n - \frac{ n }{ n + 1 }
\end{aligned}
\]</span></p>
<h6><span id="problem-4具体数学224">Problem 4(《具体数学》2.24)</span></h6>
<p>求<span class="math inline">\(\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{
( k + 1 ) ( k + 2 ) } \\\)</span>.</p>
<h6><span id="solution-4">Solution 4</span></h6>
<p>令<span class="math inline">\(u = H_n , v = - \frac{ 1 }{ n + 1 } ,
\Delta u = \frac{ 1 }{ n + 1 } , \Delta v = \frac{ 1 }{ ( n + 1 ) ( n +
2 ) } \\\)</span>.</p>
<p>根据分部求和法则,有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ i = 0 }^{ n - 1 } \frac{ H_k }{ ( k + 1 ) ( k + 2 ) } &amp; = -
\frac{ H_n }{ n + 1 } - \sum_{ i = 0 }^{ n - 1 } ( - \frac{ 1 }{ ( i + 2
) ( i + 1 ) } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + \sum_{ i = 0 }^{ n - 1 } ( \frac{ 1 }{
i + 1 } - \frac{ 1 }{ i + 2 } ) \\
&amp; = - \frac{ H_n }{ n + 1 } + H_n - ( H_n - 1 + \frac{ 1 }{ n + 1 }
) \\
&amp; = 1 - \frac{ H_n + 1 }{ n + 1 }
\end{aligned}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">贪心与构造</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了<span class="math inline">\(t\)</span>个消息<span class="math inline">\(a_1 ,
a_2 , . . . , a_t\)</span>,那么答案就是<span class="math inline">\(\sum
[ \exists j , m_i = a_j ] \cfrac{ \min ( t , k_i ) }{ t
}\)</span>.显然如果<span class="math inline">\(t\)</span>固定,那么每个<span class="math inline">\(a_j\)</span>的贡献是独立的.于是只需要枚举<span class="math inline">\(t\)</span>然后取贡献最大的.</p>
<p>但是,如果<span class="math inline">\(t &gt; \max \{ k_i
\}\)</span>,这个时候<span class="math inline">\(t -
1\)</span>的答案是<span class="math inline">\(t -
1\)</span>个数之和除以<span class="math inline">\(t - 1\)</span>,<span class="math inline">\(t\)</span>的答案是这<span class="math inline">\(t
- 1\)</span>个数之和加上另一个更小的数除以<span class="math inline">\(t\)</span>,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度<span class="math inline">\(O ( n \max \{ k_i \}
)\)</span>.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分(<span class="math inline">\(b_{ i , j } = a_{ i
, j } \oplus a_{ i + 1 , j } \oplus a_{ i , j + 1 } \oplus a_{ i + 1 , j
+ 1
}\)</span>)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是<span class="math inline">\(0\)</span>了,那么矩阵外不可能是<span class="math inline">\(1\)</span>,也就是原矩阵也全都是<span class="math inline">\(0\)</span>了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成<span class="math inline">\(0\)</span>才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对<span class="math inline">\(( x , y
)\)</span>使用操作四,那我们不可能再对一个<span class="math inline">\(( x
, i )\)</span>使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有<span class="math inline">\(b_{ x , y } ,
b_{ n , y } , b_{ x , m }\)</span>都是<span class="math inline">\(1\)</span>的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个<span class="math inline">\(1\)</span>,所以一定不如直接用一操作来的划算.不然,如果三个都是<span class="math inline">\(1\)</span>,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后<span class="math inline">\(b_{ n , m }\)</span>变成<span class="math inline">\(1\)</span>了,再不行也可以使用一次<span class="math inline">\(1\)</span>操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果<span class="math inline">\(b_{ x , y } , b_{ n , y } , b_{ x , m
}\)</span>都是<span class="math inline">\(1\)</span>,我们就把<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对<span class="math inline">\(( l ,
r )\)</span>,我们想给每一个点对赋值:<span class="math inline">\(a_l = i
, a_r = n - i + 1\)</span>(注意如果<span class="math inline">\(n\)</span>是奇数,那么中心点应该是<span class="math inline">\(a_{ mid } = \frac{ n + 1 }{ 2
}\)</span>),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对<span class="math inline">\(( l_1 , r_1
)\)</span>,<span class="math inline">\(( l_2 , r_2
)\)</span>之间的三种可能的关系:不交,包含,相交且不包含.会发现若<span class="math inline">\(l\)</span>小则让<span class="math inline">\(a_l\)</span>尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个<span class="math inline">\(\pm
1\)</span>操作很奇怪.我们不妨这么考虑:设最后的答案序列为<span class="math inline">\(b\)</span>,那么答案其实就是<span class="math inline">\(\sum | b_i - a_i
|\)</span>.这实际上是什么呢?实际上是数轴上<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>之间的距离.既然这样,那么我们同时反转<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个<span class="math inline">\(a\)</span>,将它和<span class="math inline">\(x\)</span>同时反转,那么答案不变.这么做后我们可以直接清空所有<span class="math inline">\(a\)</span>的最高位,只剩下<span class="math inline">\(x\)</span>可能有最高位.</p>
<p>那<span class="math inline">\(x\)</span>的最高位一定会让若干<span class="math inline">\(a\)</span>往上变成它.注意到最多只会有一个<span class="math inline">\(a\)</span>会向上满足<span class="math inline">\(x\)</span>的最高位.证明的话同样考虑取反,如果有两个<span class="math inline">\(a\)</span>满足<span class="math inline">\(a_i
\oplus b_i\)</span>和<span class="math inline">\(a_j \oplus
b_j\)</span>这一位是<span class="math inline">\(1\)</span>,我们仍然考虑数轴,有<span class="math inline">\(| not ( b_i ) - a_i | \leq | a_i - b_i
|\)</span>,这由<span class="math inline">\(a_i \oplus
b_i\)</span>最高位是<span class="math inline">\(1\)</span>导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个<span class="math inline">\(a\)</span>上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的<span class="math inline">\(a\)</span>可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作<span class="math inline">\([ l , r , k
]\)</span>表示可以将<span class="math inline">\(a [ l \cdots r
]\)</span>减一进行至多<span class="math inline">\(k\)</span>次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个<span class="math inline">\(- 1\)</span>,另一个<span class="math inline">\(-
2\)</span>,求使得整个序列都小于等于<span class="math inline">\(0\)</span>的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.我们通过样例以及其它栗子发现:有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀,这启发我们:能不能在做后面位置的时候将前面的<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个<span class="math inline">\(( - 2 , - 1
)\)</span>操作,那么我可以在这个位置进行一个<span class="math inline">\((
0 , - 3 )\)</span>操作.显然<span class="math inline">\(( 0 , - 3 ) + ( -
2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>.我们完成了反悔的操作!</p>
<p>但是,我们直接认为<span class="math inline">\(( - 1 , - 2
)\)</span>不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑<span class="math inline">\(( - 3 , 0
)\)</span>怎么反悔.这个看上去很疑惑:我们为了使<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在<span class="math inline">\(( - 2 , - 1
)\)</span>的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:<span class="math inline">\(( - 3 , 0
)\)</span>这个技能的发动是有前提条件的:前面必须有<span class="math inline">\(( - 2 , - 1
)\)</span>才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个<span class="math inline">\(( - 2 , - 1
)\)</span>,也很清楚每个地方用了几个<span class="math inline">\(( - 3 , 0
)\)</span>.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , -
1 ) = ( - 3 , 0 ) + ( 0 , - 3 )\)</span>,或者<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , -
2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3
)\)</span>.</p>
<p>最后遇到一个点,能用<span class="math inline">\(( 0 , - 3
)\)</span>就用<span class="math inline">\(( 0 , - 3
)\)</span>,不够用的再补齐.这个原因也很简单:如果我们在这里不用<span class="math inline">\(( - 3 , 0
)\)</span>而用其它的代替的话,你会发现无论如何都等价于<span class="math inline">\(( - 3 , 0 )\)</span>然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的<span class="math inline">\(( - 2 , - 1 )\)</span>和<span class="math inline">\(( - 1 , - 2
)\)</span>的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的<span class="math inline">\(( - 3 , 0
)\)</span>操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,保证<span class="math inline">\(a_1 =
a_n = 1\)</span>.每次你可以选择一个<span class="math inline">\(i ( 1
&lt; i &lt; n )\)</span>将<span class="math inline">\(a_i\)</span>删去并付出<span class="math inline">\(a_{ i - 1 } a_i a_{ i + 1
}\)</span>的代价.删去<span class="math inline">\(a_i\)</span>后序列两端会接起来,求删成两个<span class="math inline">\(1\)</span>的最小代价.</p>
<p>首先注意到,如果有一个<span class="math inline">\(1 &lt; i &lt;
n\)</span>满足<span class="math inline">\(a_i =
1\)</span>,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要<span class="math inline">\(1\)</span>的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个<span class="math inline">\(1\)</span>所划分.接下来我们只考虑中间所有数<span class="math inline">\(\geq 2\)</span>的情况.</p>
<p>再思考一个事实:当<span class="math inline">\(a , b \geq
2\)</span>时,一定有<span class="math inline">\(ab \geq a +
b\)</span>.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是<span class="math inline">\(\sum_{ i = 2 }^{ n - 2 } a_i a_{ i + 1 } + \min_{
i = 2 }^{ n - 1 }{ a_i
}\)</span>.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造<span class="math inline">\(a\)</span>数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值<span class="math inline">\(a_i\)</span>,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑<span class="math inline">\(a_i\)</span>互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数<span class="math inline">\(\leq\)</span>还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在<span class="math inline">\(a_i\)</span>相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的<span class="math inline">\(( a_i , a_{ i + 1 } )\)</span>,然后这么选:<span class="math inline">\(a_i , a_{ i + 1 } , a_n , a_{ i - 1 } , a_{ n - 1
} , a_{ i - 2 } . .
.\)</span>,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在<span class="math inline">\(a_i\)</span>上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,其中<span class="math inline">\(2 a
&lt;
b\)</span>.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果<span class="math inline">\(b\)</span>之前吃过别的鱼,假设是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>(不妨假设<span class="math inline">\(d
\geq c\)</span>),有<span class="math inline">\(b = c +
d\)</span>,由鸽笼原理,发现<span class="math inline">\(d &gt;
a\)</span>.这意味着:如果<span class="math inline">\(a\)</span>都没被操作掉,那么<span class="math inline">\(d\)</span>必不可能被操作掉,这也就是说<span class="math inline">\(b\)</span>不可能出现.因此<span class="math inline">\(b\)</span>在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于<span class="math inline">\(b\)</span>,且<span class="math inline">\(a\)</span>就是所有一开始小于<span class="math inline">\(b\)</span>的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是<span class="math inline">\(w_i &gt; 2 \sum_{ j = 1 }^{ i - 1 }
w_j\)</span>,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多<span class="math inline">\(\log
w\)</span>个,我们考虑一下这个两倍的用处,我们按照值域<span class="math inline">\([ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , .
. . , [ 2^{ k - 1 } + 1 , 2^k
]\)</span>将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>表示标准球.</p></li>
<li><p><span class="math inline">\(&lt; A , B
&gt;\)</span>表示称量集合<span class="math inline">\(A\)</span>和集合<span class="math inline">\(B\)</span>,<span class="math inline">\(&lt; A , B
&gt; = 0\)</span>表示平衡,<span class="math inline">\(&lt; A , B &gt; =
A\)</span>表示<span class="math inline">\(A\)</span>较重,<span class="math inline">\(&lt; A , B &gt; = B\)</span>表示<span class="math inline">\(B\)</span>较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量<span class="math inline">\(x\)</span>有<span class="math inline">\(n\)</span>种取值,出现概率分别为<span class="math inline">\(p_1 , p_2 , \cdots , p_n\)</span>,则其熵为<span class="math inline">\(H ( x ) = f ( p_1 , p_2 , \cdots , p_n ) = \sum{ C
p_i \ln \frac{ 1 }{ p_i } }\)</span>,<span class="math inline">\(C\)</span>为正整数,通常取<span class="math inline">\(1\)</span>.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量<span class="math inline">\(x\)</span>的一个熵为<span class="math inline">\(h\)</span>的信息后,<span class="math inline">\(x\)</span>的熵会减少<span class="math inline">\(h\)</span>.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有<span class="math inline">\(n\)</span>个球,每个球等概率成为次品,因此总熵是<span class="math inline">\(\ln
n\)</span>,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是<span class="math inline">\(\ln 3\)</span>,也就是说我们至少要猜<span class="math inline">\(\frac{ \ln n }{ \ln 3 } = \log_3
n\)</span>次.如果我们不知道次品的轻重,那么至少要猜<span class="math inline">\(\frac{ \ln 2 n }{ \ln 3 } = \log_3 2
n\)</span>次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p><span class="math inline">\(n\)</span>个叶子的树的最小深度是<span class="math inline">\(\lceil \log_3 n
\rceil\)</span>,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设<span class="math inline">\(f ( n )\)</span>表示有<span class="math inline">\(n\)</span>个球的最少次数,注意到<span class="math inline">\(f ( 3 ) = 1\)</span>.</p>
<p>根据信息论,<span class="math inline">\(f ( n ) \geq \lceil \log_3 n
\rceil\)</span>,下面证明等号成立:</p>
<p>首先考虑证明<span class="math inline">\(f ( 3^m ) = m\)</span>,<span class="math inline">\(m = 1\)</span>时已经得证.<span class="math inline">\(m &gt;
1\)</span>时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此<span class="math inline">\(f ( 3^m ) \leq f ( 3^{ m - 1 } ) +
1\)</span>.综合信息论下界<span class="math inline">\(f ( 3^m ) \geq
m\)</span>,我们不难得出以上结论.至于<span class="math inline">\(n \ne
3^m\)</span>的情况,我们类似这个过程按照<span class="math inline">\(n
\bmod 3\)</span>的值讨论一下即可,于是有<span class="math inline">\(f ( n
) \leq f ( \lceil \frac{ n }{ 3 } \rceil ) + 1\)</span>.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,<span class="math inline">\(f ( n ) \geq \lceil \log_3
2 n \rceil\)</span>.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有<span class="math inline">\(n\)</span>个球,第二堆有<span class="math inline">\(m\)</span>个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是<span class="math inline">\(g ( n , m )\)</span>,则<span class="math inline">\(g ( n , m ) = \lceil \log_3 ( n + m )
\rceil\)</span>.</p>
<p>先证明信息论下界,不难发现仍然是<span class="math inline">\(g ( n , m
) = \lceil \log_3 ( n + m ) \rceil\)</span>.</p>
<p>首先不难发现,<span class="math inline">\(g ( 1 , 0 ) = g ( 0 , 1 ) =
0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1\)</span>.</p>
<p>仍然使用数学归纳,假设<span class="math inline">\(n + m &lt; k ( k
\geq 3 )\)</span>的时候成立,我们接下来证明<span class="math inline">\(n
+ m = k\)</span>的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若<span class="math inline">\(n = 3 p , m = 3 q\)</span>,我们将<span class="math inline">\(n\)</span>分成等数量的三堆:<span class="math inline">\(A_1 , B_1 , C_1\)</span>,将<span class="math inline">\(m\)</span>分成等质量的三堆<span class="math inline">\(A_2 , B_2 , C_2\)</span>.</p>
<p>接下来称量<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>.</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = 0\)</span>,那么答案在<span class="math inline">\(C_1 \cup
C_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g (
\frac{ n }{ 3 } , \frac{ m }{ 3 } ) + 1\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = A_1 + A_2\)</span>,由于若次品在<span class="math inline">\(A_2\)</span>中,那么它不可能是重球,因此次品不可能在<span class="math inline">\(A_2\)</span>中,同理不可能在<span class="math inline">\(B_1\)</span>中,只可能在<span class="math inline">\(A_1 \cup B_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g ( \frac{ n }{ 3 } , \frac{ m }{ 3
} ) + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2 \rangle
= B_1 + B_2\)</span>,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p><span class="math inline">\(n = 3 p + 1 , m = 3 q +
2\)</span>.此时我们将第一堆分成<span class="math inline">\(A_1 ( p ) ,
B_1 ( p ) , C_1 ( p + 1 )\)</span>,将第二堆分成<span class="math inline">\(A_2 ( q + 1 ) , B_2 ( q + 1 ) , C_2 ( q
)\)</span>,然后<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>,接下来和情况1一样,于是有<span class="math inline">\(g (
n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log_3
\frac{ n + m }{ 3 } \rceil + 1\)</span>.</p>
<p>同理,当<span class="math inline">\(n , m \bmod
3\)</span>的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论<span class="math inline">\(n
\bmod 3\)</span>的值.</p>
<p><strong>情况1</strong></p>
<p>当<span class="math inline">\(n = 3 p\)</span>时,直接分成<span class="math inline">\(A ( p ) , B ( p ) , C ( p )\)</span>,然后<span class="math inline">\(\langle A , B
\rangle\)</span>.如果平衡则接下来需要<span class="math inline">\(f ( p )
= \lceil \log_3 2 p \rceil\)</span>次,不然根据引理,需要<span class="math inline">\(\lceil \log_3 ( p + p )
\rceil\)</span>次,因此<span class="math inline">\(f ( n ) = \lceil
\log_3 2 p \rceil + 1 = \lceil \log_3 6 p \rceil = \lceil \log_3 2 n
\rceil\)</span>.</p>
<p><strong>情况2</strong></p>
<p>当<span class="math inline">\(n = 3 p +
1\)</span>时,一种自然的想法是分成<span class="math inline">\(A ( p + 1 )
, B ( p ) , C ( p
)\)</span>,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了<span class="math inline">\(2 p + 2 , 2 p , 2
p\)</span>,这显然是不优秀的.正确的做法是分成<span class="math inline">\(A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots
2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1
\}\)</span>.由于存在标准球,此时如果<span class="math inline">\(\langle A
, B \rangle = A \ or \ B\)</span>,那么转化成<span class="math inline">\(g ( p , p + 1 ) = \lceil \log_3 ( 2 p + 1 )
\rceil\)</span>,不然转化成<span class="math inline">\(f ( p ) = \lceil
\log_3 2 p \rceil\)</span>.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有<span class="math inline">\(n \bmod 3 =
1\)</span>的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题<span class="math inline">\(f ( n ) = \lceil \log_3 ( 2 n + 2 )
\rceil\)</span>.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将<span class="math inline">\(a\)</span>个球放左边,<span class="math inline">\(b\)</span>个球放右边,<span class="math inline">\(a
\leq b\)</span>,在左边补上<span class="math inline">\(b -
a\)</span>个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要<span class="math inline">\(\lceil \log_3 ( a + b ) \rceil +
1\)</span>步.</p></li>
<li><p>如果天平平衡,需要<span class="math inline">\(f ( n - a - b ) +
1\)</span>步.</p></li>
</ol>
<p>我们有<span class="math inline">\(f ( n ) = \min_{ a , b } \{ \max \{
f ( n - a - b ) , \lceil \log_3 ( a + b ) \rceil \} \} + 1\)</span>.</p>
<p>注意到接下来的步数只与<span class="math inline">\(a +
b\)</span>有关,取<span class="math inline">\(b - a \leq
1\)</span>,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到<span class="math inline">\(f ( n ) = \lceil
\log_3 ( 2 n - 1 ) \rceil\)</span>.</p>
<p>接下来归纳法就简单了,只需要对于<span class="math inline">\(n \bmod
3\)</span>的余数讨论一下,然后再讨论一下<span class="math inline">\(a\)</span>的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求<span class="math inline">\(n\)</span>所在位置.要求询问次数<span class="math inline">\(\leq \lceil 1 . 5 \log_2 n
\rceil\)</span>,询问区间总长度<span class="math inline">\(\leq 3
n\)</span>.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设<span class="math inline">\(T ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程<span class="math inline">\(T ( n ) = \min_{ m &lt;
n } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \}\)</span>.</p>
<p>当然有<span class="math inline">\(m_n \leq m_{ n + 1
}\)</span>,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,定义域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,表达式<span class="math inline">\(F (
\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_n } \} )\)</span>最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个二元正整数对<span class="math inline">\(( a_i , b_i
)\)</span>,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的<span class="math inline">\(a\)</span>乘上序列中这个二元组之后的所有二元组的<span class="math inline">\(b\)</span>之和的总和,求最小代价.<span class="math inline">\(n , a_i , b_i \leq 10^6\)</span>.</p>
<p>转化为上面的形式,也即:<span class="math inline">\(F ( \{ ( a_1 , b_1
) , . . . , ( a_n , b_n ) \} ) = \sum_{ 1 \leq i &lt; j \leq k } a_i
b_j\)</span>.</p>
<p>考虑调整法,令排列<span class="math inline">\(( q_1 , . . . , q_n ) =
( p_1 , . . . , p_{ i - 1 } , p_{ i + 1 } , p_i , p_{ i + 2 } , . . . ,
p_n )\)</span>.则:</p>
<p><span class="math display">\[
F ( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \}
) - F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n } )
\} ) = a_{ p_i } b_{ p_{ i + 1 } } - a_{ p_{ i + 1 } } b_{ p_i }
\]</span></p>
<p>因而如果<span class="math inline">\(a_{ p_i } b_{ p_{ i + 1 } } - a_{
p_{ i + 1 } } b_{ p_i } &gt; 0\)</span>,则<span class="math inline">\(F
( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \} )
&gt; F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n }
) \} )\)</span>,也就是说<span class="math inline">\(( p_1 , . . . , p_n
)\)</span>不是最优解.因此只有满足<span class="math inline">\(\forall 1
\leq i &lt; n\)</span>,<span class="math inline">\(\cfrac{ a_{ p_i } }{
b_{ p_i } } \leq \cfrac{ a_{ p_{ i + 1 } } }{ b_{ p_{ i + 1 } }
}\)</span>可能是最优解.</p>
<p>如果一个<span class="math inline">\(p\)</span>满足这样的性质,则所有<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的两个位置,是不会使答案改变的.因此直接按照<span class="math inline">\(\cfrac{ a }{ b }\)</span>排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为<span class="math inline">\(S\)</span>,定义<span class="math inline">\(S\)</span>上的一种二元比较关系<span class="math inline">\(\leq\)</span>,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:<span class="math inline">\(\forall a , b \in
S\)</span>,<span class="math inline">\(a \leq b \lor b \leq a =
1\)</span>.</p></li>
<li><p>传递性:<span class="math inline">\(\forall a , b , c \in
S\)</span>,<span class="math inline">\(a \leq b , b \leq c \Rightarrow a
\leq c\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in
S\)</span>,如果<span class="math inline">\(a \leq
b\)</span>,则对于任意一个包含<span class="math inline">\(\{ a , b
\}\)</span>作为子段的元素序列<span class="math inline">\(\{ s_1 , . . .
, s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \}\)</span>和<span class="math inline">\(\{ s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 }
, . . . , s_n \}\)</span>都有:<span class="math inline">\(F ( \{ s_1 , .
. . , s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \} ) \leq F ( \{
s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 } , . . . , s_n \}
)\)</span>.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义<span class="math inline">\(\leq\)</span>后自然也就定义了<span class="math inline">\(=\)</span>,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到<span class="math inline">\(\leq\)</span>的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个包含小写字符的字符串<span class="math inline">\(s_1 , . . . , s_n\)</span>,找到一个<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,将<span class="math inline">\(s_{ p_1 }
, s_{ p_2 } , . . . , s_{ p_n }\)</span>顺序拼接得到<span class="math inline">\(S\)</span>,使<span class="math inline">\(S\)</span>的字典序最小.</p>
<p>令<span class="math inline">\(s \leq t\)</span>当且仅当<span class="math inline">\(s + t\)</span>的字典序<span class="math inline">\(\leq\)</span>t+s</p>
<p>此时我们注意到:<span class="math inline">\(s +
t\)</span>的字典序小于等于<span class="math inline">\(t +
s\)</span>的字典序当且仅当<span class="math inline">\(s^{ \infty } \leq
t^{ \infty }\)</span>.原因是:不妨设<span class="math inline">\(s\)</span>的长度<span class="math inline">\(\leq
t\)</span>的长度.若<span class="math inline">\(s\)</span>不是<span class="math inline">\(t\)</span>的前缀,那显然只需比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(s\)</span>的字典序即可,此时上面两个条件等价;若<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的前缀,则我们需要比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(t\)</span>的后缀,注意到<span class="math inline">\(t\)</span>的前缀还是<span class="math inline">\(s\)</span>,于是需要比较<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有<span class="math inline">\(n\)</span>个箱子,第<span class="math inline">\(i\)</span>个箱子有重量<span class="math inline">\(w_i\)</span>和承载量<span class="math inline">\(v_i\)</span>,<span class="math inline">\(( w_i ,
v_i &gt; 0
)\)</span>,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化<span class="math inline">\(\min_{ i = 1 }^n \{ v_i -
\sum_{ j = 1 }^{ i - 1 } w_j \}\)</span>,并判断是否<span class="math inline">\(\geq 0\)</span>.</p>
<p>我们令<span class="math inline">\(b_i = - ( v_i + w_i ) , a_i = -
v_i\)</span>,则我们要最大化<span class="math inline">\(\min \{ \sum_{ j
= 1 }^{ i - 1 } b_i - \sum_{ j = 1 }^i a_i \}\)</span>.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义<span class="math inline">\(x \leq y\)</span>当且仅当<span class="math inline">\(F ( \{ x , y \} ) \leq F ( \{ y , x \}
)\)</span>,那么对于两个元素<span class="math inline">\(( a_1 , b_1 ) , (
a_2 , b_2 )\)</span>,显然<span class="math inline">\(( a_1 , b_1 ) \leq
( a_2 , b_2 )\)</span>当且仅当<span class="math inline">\(\min \{ - a_1
, b_1 - a_1 - a_2 \} \geq \min \{ - a_2 , b_2 - a_1 - a_2
\}\)</span>.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于<span class="math inline">\(a_1 \leq
a_2 \land b_1 - a_1 \geq 0\)</span>.</p></li>
<li><p>都大于等于第二个元素,则相当于<span class="math inline">\(b_1 \geq
b_2 \land b_2 - a_2 \leq 0\)</span>.</p></li>
</ol>
<p>可能这里后面和<span class="math inline">\(0\)</span>比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对<span class="math inline">\(b -
a\)</span>的符号进行讨论:</p>
<ol type="1">
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) &gt; sgn ( b_2 -
a_2 )\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 1\)</span>,则不等式成立当且仅当<span class="math inline">\(a_1 \leq
a_2\)</span>.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 0\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = - 1\)</span>,则不等式成立当且仅当<span class="math inline">\(b_1
\geq b_2\)</span>.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时<span class="math inline">\(b_1 = a_1\)</span>,<span class="math inline">\(b_2
= a_2\)</span>,两条件必有一真.(1)则是因为此时满足<span class="math inline">\(b_1 - a_1 &gt; b_2 - a_2 \land sgn ( b_1 - a_1 )
\geq 0 \land sgn ( b_2 - a_2 ) \leq 0\)</span>.也就有<span class="math inline">\(a_2 - a_1 &gt; b_2 - b_1 \land b_1 \geq a_1 \land
b_2 \leq a_2\)</span>.怎么着都能成立.</p>
<p>由此发现,对于<span class="math inline">\(sgn ( b - a
)\)</span>相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a_1 , b_1 ) &amp; \leq ( a_2 , b_2 ) \\
\Updownarrow \\
( sgn ( b_1 - a_1 ) &amp; &gt; sgn ( b_2 - a_2 ) ) \\
\lor ( sgn ( b_1 - a_1 ) &amp; = sgn ( b_2 - a_2 ) \land F ( \{ 1 , 2 \}
) \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,值域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于给定整数<span class="math inline">\(k\)</span>,所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>的长度为<span class="math inline">\(k\)</span>的子序列,表达式<span class="math inline">\(F ( \{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\} )\)</span>最小值.</p>
<p>如果<span class="math inline">\(k =
n\)</span>,则就是模型1.不然,我们考虑先选出一个大小为<span class="math inline">\(k\)</span>的子集,然后使用模型1.不难发现,我们最后取出的<span class="math inline">\(\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\}\)</span>一定是<span class="math inline">\(n =
k\)</span>时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有<span class="math inline">\(n\)</span>个物品,第<span class="math inline">\(i\)</span>个物品有非负费用<span class="math inline">\(c_i\)</span>和价值<span class="math inline">\(v_i\)</span>,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出<span class="math inline">\(c_i\)</span>的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行<span class="math inline">\(k\)</span>次);也可以选择不操作,此时第一个人获得<span class="math inline">\(v_i\)</span>的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.<span class="math inline">\(( n \leq 1 . 5 \times 10^5 , k \leq 9
)\)</span></p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择<span class="math inline">\(k + 1\)</span>个,然后收益为<span class="math inline">\(\min_{ i = 1 }^{ k - 1 } \{ v_{ x_i } - \sum_{ j =
1 }^i c_{ x_j }
\}\)</span>(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度<span class="math inline">\(O ( n \log n + nk )\)</span>.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有<span class="math inline">\(n\)</span>条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有<span class="math inline">\(n\)</span>条直线的答案,求<span class="math inline">\(n +
1\)</span>条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度<span class="math inline">\(a_1 , \cdots , a_n \in \{
90 \degree , 270 \degree \}\)</span>,要求构造一个<span class="math inline">\(n\)</span>边形(边必须平行于坐标轴),使得其内角依次是<span class="math inline">\(a_1 , \cdots , a_n\)</span>.</p>
<p>首先有解条件显然是判定它们的和是否是<span class="math inline">\(180
\degree ( n - 2 )\)</span>.</p>
<p>注意到相邻的<span class="math inline">\(90 \degree\)</span>和<span class="math inline">\(270
\degree\)</span>无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让<span class="math inline">\(S \rightarrow
T\)</span>.这个时候可以找一个中间状态<span class="math inline">\(A\)</span>,让<span class="math inline">\(S
\rightarrow A , T \rightarrow A\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有<span class="math inline">\(( X , 0
)\)</span>亮着,每次把<span class="math inline">\(( x , y
)\)</span>,<span class="math inline">\(( x , y + 1 )\)</span>,<span class="math inline">\(( x + 1 , y
)\)</span>状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p><span class="math inline">\(n \leq 10^5\)</span>,坐标的绝对值均<span class="math inline">\(\leq 10^{ 17 }\)</span>.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线<span class="math inline">\(y = - inf\)</span>,然后比对.我们注意到<span class="math inline">\(( X , 0
)\)</span>向下推的过程类似一个组合数递推的过程,由经典公式<span class="math inline">\(\binom{ S }{ T } \equiv [ T \subseteq S ] \bmod
2\)</span>可知,我们取<span class="math inline">\(inf = 2^{ 63 } -
1\)</span>即可.然后最后在这条线上一定是有一个区间是<span class="math inline">\(1\)</span>,我们需要找到区间左端点,我们选择在直线上随便找到一个<span class="math inline">\(1\)</span>,由于<span class="math inline">\(inf\)</span>很大,大于<span class="math inline">\(10^{ 17
}\)</span>,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,<span class="math inline">\(n \leq
10^4\)</span>,但是初始点可能是<span class="math inline">\(( X , Y
)\)</span>.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点<span class="math inline">\(( j , - inf )\)</span>和<span class="math inline">\(( k , - inf
)\)</span>是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>.而上述条件满足当且仅当<span class="math inline">\([ j - X \subseteq Y + inf ]\)</span>.</p>
<p>如果我们随便找一个点<span class="math inline">\(( p , - inf
)\)</span>满足条件,那我们接下来只需要枚举<span class="math inline">\(w\)</span>,判断<span class="math inline">\(( p -
2^w , - inf
)\)</span>是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间<span class="math inline">\([ l , r
]\)</span>中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" class="post-title-link" itemprop="url">计算几何</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二维计算几何">二维计算几何</span></h2>
<p>参考:https://www.luogu.com.cn/blog/command-block/ji-suan-ji-he-suan-fa-hui-zong.</p>
<p>这一部分比较常用,知识点也比较简单,会主要聚焦于写法.</p>
<h3><span id="基本函数">基本函数</span></h3>
<h4><span id="eps">eps</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-10</span></span><br></pre></td></tr></table></figure>
<p>浮点数计算存在误差,因此大部分时候不能直接进行大小是否相等的判断,我们需要通过规定精度来减少这种误差.</p>
<h4><span id="sign">sign</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;eps&amp;&amp;-x&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;eps)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断一个浮点数是正数还是负数.</p>
<h4><span id="myabs">myabs</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">myabs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>)<span class="keyword">return</span> -x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求绝对值.</p>
<h4><span id="mysqr">mysqr</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">mysqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来求平方.</p>
<h4><span id="pointvector">Point/Vector</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">double</span> X,<span class="type">double</span> Y)&#123;</span><br><span class="line">x=X;y=Y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="comment">//判断到原点的距离</span></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">que</span><span class="params">()</span></span>&#123;<span class="comment">//判断点的象限</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)== <span class="number">1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)== <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(x)==<span class="number">-1</span>&amp;&amp;<span class="built_in">sign</span>(y)==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> +(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> -(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> <span class="type">double</span> &amp;c,<span class="type">const</span> Point &amp;A)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(c*A.x,c*A.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Point <span class="keyword">operator</span> /(<span class="type">const</span> Point &amp;A,<span class="type">const</span> <span class="type">double</span> &amp;c)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(A.x/c,A.y/c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">mysqr</span>(A.x-B.x)+<span class="built_in">mysqr</span>(A.y-B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储基本的点的信息.也可以看作一个二维向量.</p>
<h4><span id="向量内积">向量内积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="keyword">operator</span> *(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \cdot \vec{ b } = | \vec{
a } | | \vec{ b } | \cos \theta = x_a x_b + y_a
y_b\)</span>.也就等于<span class="math inline">\(\vec{ a
}\)</span>在<span class="math inline">\(b\)</span>上的投影与<span class="math inline">\(\vec{ b }\)</span>的模长的乘积.</p>
<p>内积可以用来判断夹角:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } =
0\)</span>,则说明<span class="math inline">\(\vec{ a } \bot \vec{ b
}\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &gt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角小于<span class="math inline">\(90 \degree\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \cdot \vec{ b } &lt;
0\)</span>,则说明<span class="math inline">\(\vec{ a }\)</span>和<span class="math inline">\(\vec{ b }\)</span>正方向的夹角大于<span class="math inline">\(90 \degree\)</span>.</p></li>
</ol>
<p>两个向量同时旋转相同角度,其内积结果不变.</p>
<h4><span id="向量叉积">向量叉积</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="keyword">operator</span> ^(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B)&#123;</span><br><span class="line"><span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(\vec{ a } \times \vec{ b } = x_a
y_b - y_a x_b\)</span>.也就等于<span class="math inline">\(\vec{ a } ,
\vec{ b }\)</span>两个向量张成的平行四边形(有向)的面积.</p>
<p>叉积可以用来判断方向:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } =
0\)</span>,说明二者共线.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &lt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是顺时针.</p></li>
<li><p>如果<span class="math inline">\(\vec{ a } \times \vec{ b } &gt;
0\)</span>,说明从<span class="math inline">\(\vec{ a }\)</span>到<span class="math inline">\(\vec{ b }\)</span>的方向是逆时针.</p></li>
</ol>
<h4><span id="向量旋转">向量旋转</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入Point内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> theta)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> st=std::<span class="built_in">sin</span>(theta),<span class="type">double</span> ct=std::<span class="built_in">cos</span>(theta);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Point</span>(x*ct-A.y*st,A.x*st+A.y*ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将这个竖向量乘左乘旋转矩阵<span class="math inline">\(\begin{bmatrix}\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta\end{bmatrix}\)</span>.</p>
<h4><span id="line">Line</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">Point a,b;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dist</span>(a,b);<span class="comment">//计算线段长度,直线和射线基本没用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断点是否在直线上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">sign</span>((A-L.a)^(A-L.b))==<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">min</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.x-std::<span class="built_in">max</span>(L.a.x,L.b.x))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">min</span>(L.a.y,L.b.y))&gt;=<span class="number">0</span>)&amp;&amp;</span><br><span class="line">(<span class="built_in">sign</span>(A.y-std::<span class="built_in">max</span>(L.a.y,L.b.y))&lt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//判断点是否在线段上</span></span><br></pre></td></tr></table></figure>
<p>用来维护直线/射线/线段的基本信息.</p>
<h4><span id="判断线段相交">判断线段相交</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isinter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.x,L1.b.x)&lt;std::<span class="built_in">min</span>(L2.a.x,L2.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.x,L2.b.x)&lt;std::<span class="built_in">min</span>(L1.a.x,L1.b.x))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L1.a.y,L1.b.y)&lt;std::<span class="built_in">min</span>(L2.a.y,L2.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(std::<span class="built_in">max</span>(L2.a.y,L2.b.y)&lt;std::<span class="built_in">min</span>(L1.a.y,L1.b.y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L1.a-L2.b)^(L2.a-L2.b))*((L1.b-L2.b)^(L2.a-L2.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(((L2.a-L1.b)^(L1.a-L1.b))*((L2.b-L1.b)^(L1.a-L1.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四行被称为快速排斥实验,后两行被称为跨立实验,也就是相交的两线段,对于其中一个线段而言,它的两个端点必然在另一个线段的两侧.但我们注意到共线线段也会通过跨立实验,因此拿快速排斥实验来判掉这种情况.</p>
<p>注意,线段交点不同于直线交点,两条共线的交点是有可能在端点上的.这个需要特判一下.</p>
<p>当然一般判断线段是否相交可以直接求直线交点,然后判断在不在线段上.</p>
<h4><span id="求直线交点">求直线交点</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">inter</span><span class="params">(<span class="type">const</span> Line &amp;L1,<span class="type">const</span> Line &amp;L2)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> ls=(L1.b-L1.a)^(L2.a-L1.a);</span><br><span class="line"><span class="type">double</span> rs=(L1.b-L1.a)^(L2.b-L1.a);</span><br><span class="line"><span class="keyword">return</span> L2.a+(L2.b-L2.a)*ls/(ls-rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理在于,画一下<span class="math inline">\(x_{ L_1 } , x_{ L_2 } ,
y_{ L_1 } , y_{ L_2
}\)</span>围成的四边形,计算面积后用等高不等底计算.注意<span class="math inline">\(ls\)</span>和<span class="math inline">\(rs\)</span>所代表的面积一正一负(不一定谁是正),因此需要减一下.</p>
<h4><span id="点到线的最短距离">点到线的最短距离</span></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl0</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myabs</span>(((L.a-A)^(L.b-A))/<span class="built_in">dis</span>(L.a,L.b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">disl2</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Line &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.a)*(L.b-L.a))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.a);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>((A-L.b)*(L.a-L.b))&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dist</span>(A,L.b);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">disl0</span>(A,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直线好做,直接算垂线段长度,用面积除以底长.</p>
<p>线段用点积判一下夹角即可.</p>
<h4><span id="凸多边形面积">凸多边形面积</span></h4>
<p>利用叉乘,任取平面上一点<span class="math inline">\(O\)</span>,则<span class="math inline">\(S = \frac{ 1 }{ 2 } \sum_{ i = 1 }^n
\overrightarrow{ OP_i } \times \overrightarrow{ OP_{ i + 1 }
}\)</span>.证明的话考虑分<span class="math inline">\(O\)</span>在内部和<span class="math inline">\(O\)</span>在外部两种情况分类讨论.注意此时的<span class="math inline">\(P\)</span>必须逆时针排列.</p>
<p>另外有皮克定理:在一个平面直角坐标系内,以整点为顶点的简单多边形(任两边不交叉),它内部整点数为<span class="math inline">\(a\)</span>,它的边上(包括顶点)的整点数为<span class="math inline">\(b\)</span>,则它的面积<span class="math inline">\(S
= a + \frac{ b }{ 2 } - 1\)</span>.</p>
<h3><span id="基本算法">基本算法</span></h3>
<h4><span id="排序算法">排序算法</span></h4>
<h5><span id="极角排序">极角排序</span></h5>
<p>定义原点<span class="math inline">\(O\)</span>并建立坐标系,所有点按照和<span class="math inline">\(O\)</span>所连直线与<span class="math inline">\(x\)</span>轴正方向的夹角排序.</p>
<p>极角排序通常使用叉乘来实现,因为叉乘可以快速计算两个向量的方向.但是注意到需要先判断象限,再判断叉乘.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;<span class="comment">//判断A能否在B前面</span></span><br><span class="line">A=A-O,B=B-O;<span class="comment">//O=(0,0)的时候可以省略</span></span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">qua</span>()!=B.<span class="built_in">qua</span>())&#123;</span><br><span class="line"><span class="keyword">return</span> A.<span class="built_in">qua</span>()&lt;B.<span class="built_in">qua</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A^B)==<span class="number">0</span>)<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(B^A)==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="水平序排序">水平序排序</span></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Point A,Point B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sign</span>(A.x-B.x)==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">sign</span>(A.y-B.y)==<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>(A.x-B.x)==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是<span class="math inline">\(x\)</span>相同比<span class="math inline">\(y\)</span>,否则比<span class="math inline">\(x\)</span>.</p>
<h4><span id="二维凸包">二维凸包</span></h4>
<h5><span id="定义">定义</span></h5>
<p>包住平面上某个点集的周长最小的简单多边形,一定是凸多边形.</p>
<h5><span id="实现">实现</span></h5>
<p>用水平序排序,然后从左往右扫一遍得到上凸壳,从右往左扫一遍得到下凸壳.</p>
<p>用一下以下函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">anticlock</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isline</span><span class="params">(<span class="type">const</span> Point &amp;A,<span class="type">const</span> Point &amp;B,<span class="type">const</span> Point &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sign</span>((A-B)^(B-C))==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前者判断是否<span class="math inline">\(ABC\)</span>三点是一个上凸的(注意<span class="math inline">\(ABC\)</span>三点横坐标应该不降).后者判断三点共线.</p>
<h4><span id="旋转卡壳">旋转卡壳</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义凸包上的对踵点对,也就是拿两条平行直线卡着凸包转,这两条直线会卡住凸包的两个点,这些点对组成的集合就是对踵点对集合.</p>
<h5><span id="实现">实现</span></h5>
<p>逆时针枚举边,然后看对面有什么被卡住了.由于凸包的凸性,在边逆时针转的时候,另一边的对踵点也会逆时针转.只要找到距离这条边所在直线最远的点即可.但这样的点可能有俩.可以简单特判,也可以加上微小随机扰动量使得这种情况可以忽略.</p>
<h4><span id="闵可夫斯基和">闵可夫斯基和</span></h4>
<p>一般只讨论凸包的闵可夫斯基和.</p>
<h5><span id="定义">定义</span></h5>
<p>两个区域<span class="math inline">\(A ,
B\)</span>的闵可夫斯基和定义为<span class="math inline">\(\{ a + b \mid
a \in A , b \in B \}\)</span>.</p>
<h5><span id="实现">实现</span></h5>
<p>事实上,新的区域所形成的凸包,一定是原本<span class="math inline">\(A ,
B\)</span>的凸包的边按照某种顺序连接起来得到的结果.</p>
<p>我们考虑旋转一下<span class="math inline">\(A , B\)</span>,使得<span class="math inline">\(B\)</span>有一条边成为最右边的直上直下的一条边,然后考虑答案区域的最右边的边,这条边一定是<span class="math inline">\(B\)</span>这个边加上<span class="math inline">\(A\)</span>的最右边的点.这样这条边必定还在最终的凸包上.就算<span class="math inline">\(A\)</span>最右边的是一条边,你也会发现最终的凸包最右边也一定是由<span class="math inline">\(A\)</span>的这条边和<span class="math inline">\(B\)</span>的这条边拼起来的.</p>
<p>显然,逆时针转一遍整个凸壳,将每条边改为向量(按照逆时针转的方向)然后极角排序,最后顺次链接就是答案.</p>
<h4><span id="半平面交">半平面交</span></h4>
<h5><span id="定义">定义</span></h5>
<p>定义半平面为满足<span class="math inline">\(ax + by + c &gt;
0\)</span>或<span class="math inline">\(ax + by + c \geq
0\)</span>的点对<span class="math inline">\(( x , y
)\)</span>组成的集合,感性理解就是一条直线的一侧.</p>
<h5><span id="实现">实现</span></h5>
<p>首先直线不好描述左右侧,我们把直线改成向量,这样方便描述左右侧.并不妨假设所有的向量所表示的半平面在向量的左侧.如果两条向量方向相同,则取更靠左的那一条,也就是所在直线截距更大的那个,另一个直接删了就是了.当然你不想删可以把那个废物放前面,这样根据下面的操作过程中它会被弹掉.</p>
<p>我们这么实现:按照上面的顺序一个一个插入,维护一个单调队列.如果前两条向量的交点不在当前这条向量的控制范围,不难发现上一条向量是废物,弹掉它.这样做到最后,队首和队尾可能都有一些废物向量,把它们判掉弹掉即可.</p>
<h2><span id="三维计算几何">三维计算几何</span></h2>
<p>这一部分知识点比较困难,而几乎用不到,因此只讲简单知识点,就当是高中立体几何知识补档!</p>
<h3><span id="基本概念">基本概念</span></h3>
<h4><span id="直线">直线</span></h4>
<p>使用直线的方向向量<span class="math inline">\(\vec{ s } = ( n , m , p
)\)</span>和直线上一点<span class="math inline">\(M_0 = ( x_0 , y_0 ,
z_0 )\)</span>.那么方程显然为:</p>
<p><span class="math display">\[
\frac{ x - x_0 }{ n } = \frac{ y - y_0 }{ m } = \frac{ z - z_0 }{ p }
\]</span></p>
<p>如果换元,我们还有参数方程:</p>
<p><span class="math display">\[
\begin{cases}
x = x_0 + nt \\
y = y_0 + mt \\
z = z_0 + pt
\end{cases}
\]</span></p>
<h4><span id="平面">平面</span></h4>
<p>使用平面上的一点<span class="math inline">\(P_0 ( x_0 , y_0 , z_0
)\)</span>和该平面的法向量<span class="math inline">\(\vec{ n
}\)</span>来表示一个平面,不妨设<span class="math inline">\(\vec{ n } = (
A , B , C )\)</span>,则该平面的方程显然为:</p>
<p><span class="math display">\[
A ( x - x_0 ) + B ( y - y_0 ) + C ( z - z_0 ) = 0
\]</span></p>
<p>如果我们令<span class="math inline">\(D = - ( Ax_0 + By_0 +
Cz_)\)</span>,那么平面方程为:</p>
<p><span class="math display">\[
Ax + By + Cz + D = 0
\]</span></p>
<h4><span id="夹角">夹角</span></h4>
<h5><span id="两直线夹角">两直线夹角.</span></h5>
<p>直接求方向向量的夹角,然后取正值.</p>
<p>对于方向向量分别是<span class="math inline">\(\vec{ s_1 } = ( n_1 ,
m_1 , p_1 ) , \vec{ s_2 } = ( n_2 , m_2 , p_2 )\)</span>,也就有<span class="math inline">\(\varphi = \arccos ( \frac{ | \vec{ s }_1 \cdot
\vec{ s }_2 | }{ | \vec{ s }_1 | | \vec{ s }_2 | } ) \\\)</span>.</p>
<h5><span id="直线与平面的夹角">直线与平面的夹角</span></h5>
<p>同样使用向量,不妨设方向向量<span class="math inline">\(\vec{ s } = (
n , m , p )\)</span>,法向量<span class="math inline">\(\vec{ f } = ( a ,
b , c )\)</span>,那么<span class="math inline">\(\varphi = \arcsin (
\frac{ | \vec{ s } \cdot \vec{ f } | }{ | \vec{ s } | | \vec{ f } | }
)\)</span>.</p>
<p>另外,由上面这个式子,不难得到一些特殊情况下的判定标准:</p>
<ol type="1">
<li><p>若直线与平面平行,则<span class="math inline">\(am + bn + cp =
0\)</span>.</p></li>
<li><p>若直线与平面垂直,则<span class="math inline">\(\frac{ a }{ m } =
\frac{ b }{ n } = \frac{ c }{ p }\)</span>.注意这里分母可能除以<span class="math inline">\(0\)</span>,我们实际上应该是三个形如<span class="math inline">\(a = mt\)</span>的参数方程,这里简化了.</p></li>
</ol>
<h4><span id="交点">交点</span></h4>
<p>联立方程硬解.</p>
<h3><span id="基本定理">基本定理</span></h3>
<p>参考:https://zhuanlan.zhihu.com/p/401766934</p>
<h4><span id="三余弦定理最小角定理">三余弦定理(最小角定理)</span></h4>
<p>这个定理说明直线与平面的夹角,是所有包含直线的平面与这个平面形成的夹角中最小的那一个.并且偏移量决定了差距.</p>
<h4><span id="三正弦定理最大角定理">三正弦定理(最大角定理)</span></h4>
<p>这个定理说明二面角是另一个平面上的直线与平面的夹角中最大的那个,并且偏移量决定了差距.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">组合数学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="二项式系数">二项式系数</span></h2>
<h3><span id="上升幂和下降幂">上升幂和下降幂</span></h3>
<p>定义下降幂<span class="math inline">\(x^{ \underline{ k } } = \prod_{
i = 0 }^{ k - 1 } ( x - i ) = \frac{ x ! }{ ( x - k ) ! }\)</span>.</p>
<p>定义上升幂<span class="math inline">\(x^{ \overline{ k } } \prod_{ i
= 0 }^{ k - 1 } ( x + i ) = \frac{ ( x + k - 1 ) ! }{ ( x - 1 ) !
}\)</span>.</p>
<p>上升幂和下降幂的定义是可以引申到复数域的.</p>
<p>例如我们有加倍公式:<span class="math inline">\(r^{ \underline{ k } }
( r - 0 . 5 )^{ \underline{ k } } = \cfrac{ ( 2 r )^{ \underline{ 2 k }
} }{ 2^{ 2 k } } , k \in \mathbb{ N }\)</span>.</p>
<p>他们之间存在转换:<span class="math inline">\(x^{ \underline{ n } } =
( - 1 )^n ( - x )^{ \overline{ n } }\)</span>.</p>
<p>同时存在大小关系:<span class="math inline">\(x^{ \underline{ n } }
\leq x^n \leq x^{ \overline{ n } }\)</span>,其中<span class="math inline">\(0 \leq n &lt; x\)</span>.</p>
<h3><span id="二项式系数的定义">二项式系数的定义</span></h3>
<p>考虑令<span class="math inline">\(\binom{ n }{ m
}\)</span>表示从一个大小为<span class="math inline">\(n\)</span>的子集中选出大小为<span class="math inline">\(m\)</span>的子集的方案数.第一次有<span class="math inline">\(n\)</span>个选择,第二次有<span class="math inline">\(n - 1\)</span>个选择……第m次有<span class="math inline">\(n - m +
1\)</span>个选择.而由于可能可以选择重复的,但一个排列被重复选择的次数显然是<span class="math inline">\(m !\)</span>,因此显然有<span class="math inline">\(\binom{ n }{ m } = \cfrac{ n^{ \underline{ m } }
}{ m ! }\)</span>.</p>
<p>如果我们把它的定义拓展到复数域,我们有:</p>
<p><span class="math inline">\(\binom{ r }{ k } = \begin{cases}\cfrac{
r^{ \underline{ k } } }{ k ! } &amp; k \geq 0 \\ 0 &amp; k &lt;
0\end{cases} , r \in \mathbb{ C } , k \in \mathbb{ Z }\)</span>.</p>
<p>值得一提的是,如果我们这么定义,本质上其实是把<span class="math inline">\(\binom{ r }{ k }\)</span>看作了一个关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式.</p>
<p>另外根据定义,<span class="math inline">\(r \in \mathbb{ Z } \land r
&lt; k\)</span>时,该公式给出<span class="math inline">\(0\)</span>.</p>
<p>值得一提的是,为了使二项式系数在面对<span class="math inline">\(0\)</span>的时候更加简洁,通常直接定义<span class="math inline">\(0 ! = 1 , 0^0 = 1\)</span>.</p>
<p>另外不难发现<span class="math inline">\(\binom{ 2 n }{ n
}\)</span>是所有<span class="math inline">\(\binom{ 2 n }{ k
}\)</span>中最大的.事实上我们有Wallis公式:<span class="math inline">\(\lim_{ n \rightarrow \infty } \frac{ ( \frac{ 2^{
2 n } }{ \binom{ 2 n }{ n } } )^2 }{ 2 n + 1 } = \frac{ \pi }{ 2
}\)</span>.</p>
<h3><span id="基本的二项式恒等式">基本的二项式恒等式</span></h3>
<ol type="1">
<li>阶乘展开式:<span class="math inline">\(\binom{ n }{ k } = \cfrac{ n
! }{ k ! ( n - k ) ! } , n , k \in \mathbb{ N } , n \geq k
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="2" type="1">
<li>对称恒等式:<span class="math inline">\(\binom{ n }{ k } = \binom{ n
}{ n - k } , n \in \mathbb{ N } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 1 )\)</span>,<span class="math inline">\(0 \leq k \leq
n\)</span>时是显然的.而其他情况两边都会给出<span class="math inline">\(0\)</span>,因此也是成立的.</p>
<ol start="3" type="1">
<li>吸收恒等式:<span class="math inline">\(\binom{ r }{ k } = \cfrac{ r
}{ k } \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \land k \ne 0
\\\)</span>.</li>
</ol>
<p>证明根据定义是显然的.</p>
<ol start="4" type="1">
<li>吸收恒等式的变式:<span class="math inline">\(k \binom{ r }{ k } = r
\binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>根据<span class="math inline">\(( 3 )\)</span>,只需要验证<span class="math inline">\(k = 0\)</span>的情况即可,也是显然的.</p>
<ol start="5" type="1">
<li>相伴恒等式:<span class="math inline">\(( r - k ) \binom{ r }{ k } =
r \binom{ r - 1 }{ k } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
( r - k ) \binom{ r }{ k } &amp; = ( r - k ) \binom{ r }{ r - k } \\
&amp; = r \binom{ r - 1 }{ r - k - 1 } \\
&amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<p>问题在于:我们在上述描述中并未提到<span class="math inline">\(r\)</span>的范围,但是推导过程要求<span class="math inline">\(r \in \mathbb{ N
}\)</span>.不过,我们已经说明了二项式系数是关于<span class="math inline">\(r\)</span>的<span class="math inline">\(k\)</span>次多项式,因此只需要有<span class="math inline">\(k + 1\)</span>个<span class="math inline">\(r\)</span>满足这个公式即可.而根据推导过程显然有无限个<span class="math inline">\(r\)</span>满足,因此这个公式对<span class="math inline">\(r \in \mathbb{ C }\)</span>也是成立的.</p>
<p>不过事实上,直接用吸收恒等式就可以证明:</p>
<p><span class="math display">\[
\begin{aligned}
k \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k - 1 } \\
( r - k ) \binom{ r }{ r - k } &amp; = r \binom{ r - 1 }{ r - k - 1 } \\
( r - k ) \binom{ r }{ k } &amp; = r \binom{ r - 1 }{ k }
\end{aligned}
\]</span></p>
<ol start="6" type="1">
<li>加法公式:<span class="math inline">\(\binom{ r }{ k } = \binom{ r -
1 }{ k } + \binom{ r - 1 }{ k - 1 } , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用定义,也可以先用<span class="math inline">\(r \in \mathbb{
N }\)</span>的情况给出组合意义,再使用多项式推理法证明.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\binom{ r }{ m } \binom{ m }{ k } =
\binom{ r }{ k } \binom{ r - k }{ m - k } , n , k \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<ol start="8" type="1">
<li>平行求和法:<span class="math inline">\(\sum_{ k \leq n } \binom{ r +
k }{ k } = \binom{ r + n + 1 }{ n } , n \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>我们不妨考虑不断使用加法公式:</p>
<p><span class="math inline">\(\binom{ r + n + 1 }{ n } = \binom{ r + n
}{ n } + \binom{ r + n }{ n - 1 } = \binom{ r + n }{ n } + \binom{ r + n
- 1 }{ n - 1 } + \binom{ r + n - 1 }{ n - 2 } = . . .
\\\)</span>,最终下标会减成负数,这样后面的项就全都是<span class="math inline">\(0\)</span>了.</p>
<p>也可以考虑组合意义:如果<span class="math inline">\(r \in \mathbb{ N
}\)</span>,那么我们考虑从右到左第一个没有被选上的数,假设它是<span class="math inline">\(r + k +
1\)</span>,那么在它右边的数全部选择了,一共是<span class="math inline">\(n - k\)</span>个数,而还需要在左边的<span class="math inline">\(r + k\)</span>中选择<span class="math inline">\(k\)</span>个数.</p>
<ol start="9" type="1">
<li>上指标求和法:<span class="math inline">\(\sum_{ 0 \leq k \leq n }
\binom{ k }{ m } = \binom{ n + 1 }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>.</li>
</ol>
<p>可以组合意义解释:我们不妨假设选的最大数是<span class="math inline">\(k + 1\)</span>,接下来就还需要在<span class="math inline">\([ 1 , k ]\)</span>中选择<span class="math inline">\(m\)</span>个.</p>
<p>如果我们将这个公式两边同时乘以<span class="math inline">\(m
!\)</span>,我们可以得到公式:<span class="math inline">\(\sum_{ 0 \leq k
\leq n } k^{ \underline{ m } } = \cfrac{ ( n + 1 )^{ \underline{ m + 1 }
} }{ m + 1 } , n , m \in \mathbb{ N }
\\\)</span>,这也就是有限微积分的公式中的一个.</p>
<ol start="10" type="1">
<li>二项式定理:<span class="math inline">\(( x + y )^r = \sum_{ k }
\binom{ r }{ k } x^k y^{ r - k } , r \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以使用组合意义证明.</p>
<p>二项式定理有一些有用的特殊情况:</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } \binom{ n }{ k } &amp; = 2^n , n \in \mathbb{ N
} \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = y =
1\)</span>即可证明.</p>
$$
<span class="math display">\[\begin{aligned}
\sum_{ 0 \leq k \leq n } ( - 1 )^k \binom{ n }{ k } &amp; = 0^n = [ n =
0 ] , n \in \mathbb{ N } \\

\end{aligned}\]</span>
<p>$$</p>
<p>在二项式定理中令<span class="math inline">\(x = - 1 , y =
1\)</span>即可证明,值得一提的是,当<span class="math inline">\(n =
0\)</span>的时候这个式子给出<span class="math inline">\(1\)</span>,并在其他情况下给出<span class="math inline">\(0\)</span>,这个式子是二项式反演的基础.</p>
<ol start="11" type="1">
<li>三项式定理:<span class="math inline">\(( x + y + z )^n = \sum_{ 0
\leq a , b , c \leq n } [ a + b + c = n ] \cfrac{ n ! }{ a ! b ! c ! }
x^a y^b z^c , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.值得一提的是,<span class="math inline">\(\cfrac{
n ! }{ a ! b ! c ! } = \binom{ n }{ b + c } \binom{ b + c }{ c
}\)</span>.</p>
<ol start="12" type="1">
<li>多项式定理:<span class="math inline">\(( \sum_{ i = 1 }^m x_i )^n =
\sum_{ \forall i \in [ 1 , m ] , 0 \leq a_i \leq n } [ \sum_{ i = 1 }^m
a_i = n ] \cfrac{ n ! }{ \prod_{ i = 1 }^m a_i ! } \prod_{ i = 1 }^m
x_i^{ a_i } , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>证明与二项式定理类似.</p>
<ol start="13" type="1">
<li>范德蒙德卷积:<span class="math inline">\(\sum_{ k } \binom{ r }{ m +
k } \binom{ s }{ n - k } = \binom{ r + s }{ n + m } , n , m \in \mathbb{
Z } \\\)</span>.</li>
</ol>
<p>证明可以使用组合意义和多项式推理法.</p>
<p>另外,这个式子可以直接使用生成函数证明.</p>
<ol start="14" type="1">
<li>范德蒙德卷积的变式:<span class="math inline">\(\sum_{ k } \binom{ l
}{ m + k } \binom{ s }{ n + k } = \binom{ l + s }{ l - m + n } , l \in
\mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>有<span class="math inline">\(\binom{ l }{ m + k } = \binom{ l }{ l -
m - k }\)</span>,然后运用范德蒙德卷积即可得到答案.</p>
<ol start="15" type="1">
<li>上指标反转公式:<span class="math inline">\(\binom{ r }{ k } = ( - 1
)^k \binom{ k - r - 1 }{ k } \\\)</span>.</li>
</ol>
<p>根据定义显然.</p>
<h3><span id="扩展的二项式恒等式整数范围内">扩展的二项式恒等式(整数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } ( - 1
)^k = ( - 1 )^m \binom{ r - 1 }{ m } , m \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ r }{ k } ( - 1 )^k &amp; = \sum_{ k \leq m }
\binom{ k - r - 1 }{ k } \\
&amp; = \binom{ - r + m }{ m } = ( - 1 )^m \binom{ r - 1 }{ m }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><span class="math inline">\(\sum_{ - q \leq k \leq l } \binom{ l - k
}{ m } \binom{ q + k }{ n } = \binom{ l + q + 1 }{ m + n + 1 } , n , m
\in \mathbb{ N } , l + q \geq 0 \\\)</span>.</li>
</ol>
<p>可以组合意义与多项式推理法证明.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ a + b }{ a + k }
\binom{ a + b }{ b + k } ( - 1 )^k = \binom{ a + b }{ a } , a , b \in
\mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k
} }{ \binom{ n }{ k } } = \cfrac{ n + 1 }{ n + 1 - m } , n , m \in
\mathbb{ N } , n \geq m \\\)</span>.</li>
</ol>
<p>我们有<span class="math inline">\(\binom{ n }{ m } \binom{ m }{ k } =
\binom{ n }{ k } \binom{ n - k }{ m - k } \\\)</span>,两边同时除以<span class="math inline">\(\binom{ n }{ m } \binom{ n - k }{ m - k }
\\\)</span>,于是我们得到了<span class="math inline">\(\cfrac{ \binom{ m
}{ k } }{ \binom{ n }{ k } } = \cfrac{ \binom{ n - k }{ m - k } }{
\binom{ n }{ m } } \\\)</span>.</p>
<p>有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^m \cfrac{ \binom{ m }{ k } }{ \binom{ n }{ k } } &amp; =
\sum_{ k = 0 }^m \cfrac{ \binom{ n - k }{ m - k } }{ \binom{ n }{ m } }
\\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - k
}{ m - k } \\
&amp; = \cfrac{ 1 }{ \binom{ n }{ m } } \sum_{ k = 0 }^m \binom{ n - m +
k }{ k } \\
&amp; = \cfrac{ \binom{ n + 1 }{ m } }{ \binom{ n }{ m } } \\
&amp; = \cfrac{ n + 1 }{ n + 1 - m }
\end{aligned}
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(( - 1 )^m \binom{ - n - 1 }{ m } = ( - 1
)^n \binom{ - m - 1 }{ n } , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>根据上指标反转公式,这个公式两边都等于<span class="math inline">\(\binom{ n + m }{ m } \\\)</span>.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ r }{ k } (
\cfrac{ r }{ 2 } - k ) = \cfrac{ m + 1 }{ 2 } \binom{ r }{ m + 1 } , m
\in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以使用归纳法证明这个公式.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + r }{ k }
x^k y^{ m - k } = \sum_{ k \leq m } \binom{ - r }{ k } ( - x )^k ( x + y
)^{ m - k } , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>不妨令左边的值为<span class="math inline">\(S_m\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
S_m &amp; = \sum_{ k \leq m } \binom{ m + r }{ k } x^k y^{ m - k } =
\sum_{ k \leq m } \binom{ m + r - 1 }{ k } x^k y^{ m - k } + \sum_{ k
\leq m } \binom{ m + r - 1 }{ k - 1 } x^k y^{ m - k } \\
&amp; = y \sum_{ k &lt; m } \binom{ m - 1 + r }{ k } x^k y^{ m - 1 - k }
+ \binom{ m + r - 1 }{ m } x^m + x \sum_{ k \leq m } \binom{ m + r - 1
}{ k - 1 } x^{ k - 1 } y^{ m - k } \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ m + r - 1 }{ m } x^m \\
&amp; = ( x + y ) S_{ m - 1 } + \binom{ r }{ m } ( - x )^m
\end{aligned}
\]</span></p>
<p>左右两边满足相同递归式,通过数学归纳法不难证明二者相等.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k \leq m } \binom{ m + k }{ k }
2^{ - k } = 2^m , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(( 7 )\)</span>,将<span class="math inline">\(x = y = 1 , r = m + 1\)</span>带入,得到:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \leq m } \binom{ 2 m + 1 }{ k } &amp; = \sum_{ k \leq m }
\binom{ m + k }{ k } 2^{ m - k } \\
2^{ 2 m } &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ m - k } \\
2^m &amp; = \sum_{ k \leq m } \binom{ m + k }{ k } 2^{ - k }
\end{aligned}
\]</span></p>
<ol start="9" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ l }{ m + k } \binom{
s + k }{ n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m }{ n - l } , l
\in \mathbb{ N } , n , m \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\sum_{ k \leq l } \binom{ l - k }{ m }
\binom{ s }{ k - n } ( - 1 )^k = ( - 1 )^{ l + m } \binom{ s - m - 1 }{
l - n - m } , l , n , m \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>可以数学归纳证明.</p>
<h3><span id="拓展的二项式恒等式实数范围内">拓展的二项式恒等式(实数范围内)</span></h3>
<ol type="1">
<li><span class="math inline">\(\binom{ r }{ k } \binom{ r - \cfrac{ 1
}{ 2 } }{ k } = \cfrac{ \binom{ 2 r }{ 2 k } \binom{ 2 k }{ k } }{ 2^{ 2
k } } , k \in \mathbb{ Z } \\\)</span>.</li>
</ol>
<p>将加倍公式两边同时除以<span class="math inline">\(k
!^2\)</span>即可得到这个公式.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\binom{ n - \cfrac{ 1 }{ 2 } }{ n } =
\cfrac{ \binom{ 2 n }{ n } }{ 2^{ 2 n } } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>将<span class="math inline">\(( 1 )\)</span>中令<span class="math inline">\(r = k = n\)</span>即可得到这个公式.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\binom{ - \cfrac{ 1 }{ 2 } }{ n } = (
\cfrac{ - 1 }{ 4 } )^n \binom{ 2 n }{ n } , n \in \mathbb{ Z }
\\\)</span>.</li>
</ol>
<p>即<span class="math inline">\(( 2 )\)</span>的变形.</p>
<ol start="4" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ 2 k } \binom{ 2
k }{ k } 2^{ - 2 k } = \binom{ n - \cfrac{ 1 }{ 2 } }{ \lfloor \cfrac{ n
}{ 2 } \rfloor } , n \in \mathbb{ N } \\\)</span></li>
</ol>
<p>首先根据<span class="math inline">\(( 1 )\)</span>,左边<span class="math inline">\(= \sum_{ k } \binom{ \cfrac{ n }{ 2 } }{ k }
\binom{ \cfrac{ n - 1 }{ 2 } }{ k } \\\)</span>,而考虑到<span class="math inline">\(\cfrac{ n }{ 2 }\)</span>和<span class="math inline">\(\cfrac{ n - 1 }{ 2
}\)</span>必有一个是自然数,因此可以直接用范德蒙德卷积的变形.</p>
<ol start="5" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ - \cfrac{ 1 }{ 2 } }{
k } \binom{ - \cfrac{ 1 }{ 2 } }{ n - k } = ( - 1 )^n , n \in \mathbb{ N
} \\\)</span>.</li>
</ol>
<p>直接使用范德蒙德卷积即可证明.</p>
<ol start="6" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ 2 k }{ k } \binom{ 2
n - 2 k }{ n - k } = 4^n , n \in \mathbb{ N } \\\)</span>.</li>
</ol>
<p>由<span class="math inline">\(( 5 )\)</span>和<span class="math inline">\(( 3 )\)</span>不难推出.</p>
<ol start="7" type="1">
<li><span class="math inline">\(\sum_{ k } \binom{ n }{ k } \cfrac{ ( -
1 )^k }{ x + k } = x^{ - 1 } \binom{ x + n }{ n }^{ - 1 } , x \notin \{
0 , - 1 , . . . , - n \} \\\)</span>.</li>
</ol>
<p>令<span class="math inline">\(f ( x ) = ( x - 1 )^{ \underline{ - 1 }
}\)</span>,直接做高阶差分即可得到这个式子.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\sum_{ k = 0 }^n \binom{ r }{ k }
\binom{ r }{ n - k } ( - 1 )^k = [ n \ is \ \mathrm{ even } ] ( - 1 )^{
\cfrac{ n }{ 2 } } \binom{ r }{ \cfrac{ n }{ 2 } } \\\)</span>.</li>
</ol>
<p>首先不难发现,<span class="math inline">\(( 1 - z )^r = \sum_{ k \geq
0 } ( - 1 )^k \binom{ r }{ k } \\\)</span>.</p>
<p>考虑<span class="math inline">\(( 1 - z )^r ( 1 + z )^r = ( 1 - z^2
)^r\)</span>.</p>
<p>我们有<span class="math inline">\([ z^n ] ( 1 - z )^r ( 1 + z )^r = [
z^n ] ( 1 - z^2 )^r\)</span>,不难发现即上式.</p>
<h3><span id="卡特兰数">卡特兰数</span></h3>
<p>卡特兰数<span class="math inline">\(f_n\)</span>表示:长度为<span class="math inline">\(2 n\)</span>的合法括号序列个数.</p>
<p>卡特兰数的前几项为<span class="math inline">\(1 , 1 , 2 , 5 , 14 , 42
, 132 \cdots\)</span>.</p>
<p>接下来,我们通过这个定义来证明以下其他定义方式.</p>
<p>递归定义:<span class="math inline">\(f_n = \sum_{ i = 0 }^{ n - 1 }
f_i f_{ n - 1 - i }\)</span>.</p>
<p>不妨考虑枚举一个括号序列的第一个断点,则该括号序列应形如<span class="math inline">\(( A ) B\)</span>.</p>
<p>考虑将其删成<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,则<span class="math inline">\(A\)</span>一定合法,因为若<span class="math inline">\(A\)</span>不合法,那么这里一定不是第一个断点.</p>
<p>通项公式:<span class="math inline">\(f_n = \frac{ 1 }{ n + 1 } C_{ 2
n }^n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>考虑平面直角坐标系,我们将’(‘认为是向右上走一单位长度,将’)’认为是向右下走一单位长度.</p>
<p>那么卡特兰数就相当于从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>不经过第四象限的方案数.</p>
<p>考虑反射容斥,如果只是走到<span class="math inline">\(( 2 n , 0
)\)</span>的方案数是<span class="math inline">\(C_{ 2 n
}^n\)</span>.</p>
<p>而如果到达第四象限,说明在这条这线上存在一个点<span class="math inline">\(( x , - 1 )\)</span>.</p>
<p>考虑将<span class="math inline">\(x\)</span>以后的折线以直线<span class="math inline">\(y = - 1\)</span>为对称轴反转,那么终点到了<span class="math inline">\(( 2 n , - 2 )\)</span>.</p>
<p>不难发现,任意从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>的方案一定唯一对应了一种从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , 0
)\)</span>的不合法方案.因为从<span class="math inline">\(( 0 , 0
)\)</span>走到<span class="math inline">\(( 2 n , - 2
)\)</span>一定会经过直线<span class="math inline">\(y = -
1\)</span>,将后半部分对称后就是其对应方案.而从<span class="math inline">\(( 0 , 0 )\)</span>走到<span class="math inline">\(( 2 n , - 2 )\)</span>的方案数为<span class="math inline">\(C_{ 2 n }^{ n - 1 }\)</span>.</p>
<p>因而<span class="math inline">\(f_n = C_{ 2 n }^n - C_{ 2 n }^{ n - 1
} \\\)</span>.</p>
<p>而<span class="math inline">\(C_{ 2 n }^n - C_{ 2 n }^{ n - 1 } =
\frac{ ( 2 n ) ! }{ n ! n ! } - \frac{ ( 2 n ) ! }{ ( n - 1 ) ! ( n + 1
) ! } = \frac{ ( 2 n ) ! }{ n ! ( n + 1 ) ! } = \frac{ C_{ 2 n }^n }{ n
+ 1 } \\\)</span>.</p>
<p>递推定义:<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 }
f_{ n - 1 } \\\)</span>.</p>
<p>使用一下上一步的通项公式:</p>
<p>f_n=\</p>
<p>f_{n-1}=</p>
<p>\end{cases}\</p>
<p>不难发现<span class="math inline">\(f_n = \frac{ ( 2 n - 1 ) ( 2 n )
}{ n ( n + 1 ) } f_{ n - 1 } \\\)</span>.整理,得到<span class="math inline">\(f_n = \frac{ 4 n - 2 }{ n + 1 } f_{ n - 1 }
\\\)</span>.</p>
<p>换个记号,设<span class="math inline">\(C_n\)</span>为卡特兰数的第<span class="math inline">\(n\)</span>项,卡特兰数有一个著名的结论是<span class="math inline">\(k\)</span>次卷积:</p>
<p><span class="math display">\[
C^{ ( k ) }_n = \sum_{ \sum_{ j = 1 }^k a_j = n } \prod C_{ a_i } =
\frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\]</span></p>
<p>我们可以这么理解它:它指的是一个长度为<span class="math inline">\(n +
k - 1\)</span>的括号序列,前<span class="math inline">\(k -
1\)</span>个必须是左括号的方案数.为啥呢?因为这样这个括号序列必须写成<span class="math inline">\(( ( ( A ) B ) C )
D\)</span>之类的形式,等价于卷积.</p>
<p>那么证明就很简单了,类似反射容斥,有:</p>
<p><span class="math display">\[
\begin{aligned}
C^{ ( k ) }_n &amp; = \binom{ 2 n + k - 1 }{ n } - \binom{ 2 n + k - 1
}{ n - 1 } \\
&amp; = \frac{ k }{ n + k } \binom{ 2 n + k - 1 }{ n }
\end{aligned}
\]</span></p>
<h5><span id="examplehnoi2009有趣的数列">Example([HNOI2009]有趣的数列)</span></h5>
<p>首先,如果没有第三条限制,那显然奇数位置和偶数位置互不影响,直接随便选,答案就是<span class="math inline">\(\binom{ 2 n }{ n }\)</span>.</p>
<p>而有了限制呢,我们还是想随便选然后顺序排起来,但是这次不能排列的时候使奇数位置大于偶数位置,可以发现这就是括号序列需要满足的条件,于是答案就是卡特兰数.</p>
<p>至于处理,这题因为模数不是质数,需要做质因数分解来维护除法.</p>
<h5><span id="example223省选10连测day7b">Example2([23省选10连测day7]b)</span></h5>
<p>给定<span class="math inline">\(x , n\)</span>,对<span class="math inline">\(y \in [ 1 , n ]\)</span>,固定<span class="math inline">\(p_x =
y\)</span>做笛卡尔树的<strong>形态</strong>计数.<span class="math inline">\(n \leq 5 \times 10^5\)</span>.</p>
<p>由于是对树的形态计数,其实根本就不在乎每个点具体的取值,只要这个取值有解就行.事实上,容易发现<span class="math inline">\(a_x = y\)</span>只要满足:</p>
<ol type="1">
<li><p><span class="math inline">\(x\)</span>节点的祖先数量不超过<span class="math inline">\(y - 1\)</span>个(深度小于等于<span class="math inline">\(y\)</span>).</p></li>
<li><p><span class="math inline">\(x\)</span>节点的子树大小不超过<span class="math inline">\(n - y + 1\)</span>.</p></li>
</ol>
<p>发现合法不太好记,经典补集转化,然后两个不合法情况无关,分别算.</p>
<p>我们考虑直接算出<span class="math inline">\(f_p\)</span>表示<span class="math inline">\(x\)</span>的深度为<span class="math inline">\(p\)</span>的答案,<span class="math inline">\(g_p\)</span>表示<span class="math inline">\(x\)</span>的子树大小为<span class="math inline">\(p\)</span>的答案,然后就可以完成这个题.</p>
<p>这两部分怎么算呢?</p>
<p>先看深度:<span class="math inline">\(x\)</span>的祖先有两种:一种在序列中在<span class="math inline">\(x\)</span>的左边,一种在<span class="math inline">\(x\)</span>的右边.我们设前者为<span class="math inline">\(0 = l_0 &lt; l_1 &lt; l_2 &lt; \cdots l_p &lt; l_{
p + 1 } = x\)</span>,设后者为<span class="math inline">\(n + 1 = r_0
&gt; r_1 &gt; r_2 &gt; \cdots &gt; r_{ q } &gt; r_{ q + 1 } =
x\)</span>.这么分类有什么用呢?我们考虑<span class="math inline">\(( l_{
i - 1 } , l_{ i } )\)</span>这一段数能放在哪里,它只能是<span class="math inline">\(l_{ i
}\)</span>的左儿子,独立于整棵树,因此这一段的答案就是<span class="math inline">\(C_{ l_i - l_{ i - 1 } - 1 }\)</span>.</p>
<p>记:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = \sum_{ l } \prod_{ i = 1 }^{ p + 1 } C_{ l_i - l_{ i - 1 } -
1 } \\
R_q &amp; = \sum_{ r } \prod_{ i = 1 }^{ q + 1 } C_{ r_{ i - 1 } - r_i -
1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到这等价于卡特兰数的<span class="math inline">\(k\)</span>次卷积,有:</p>
$$
<span class="math display">\[\begin{aligned}
L_p &amp; = C_{ x - p - 1 }^{ ( p + 1 ) } \\
R_q &amp; = C^{ ( q + 1 ) }_{ n - x - q } \\

\end{aligned}\]</span>
<p>$$</p>
<p>此时的答案自然是<span class="math inline">\(f_{ p + q + 1 } = L_p R_q
\binom{ p + q }{ q }\)</span>,做卷积.</p>
<p>儿子怎么算呢?二叉搜索树有一个经典性质:确定根后每个点插在哪里是固定的.也就是说我们把<span class="math inline">\(x\)</span>的子树从原树中删去,然后插入<span class="math inline">\(x\)</span>一定会插回原位置,这是一个双射.而子树内随便做,设左子树大小为<span class="math inline">\(p\)</span>,右子树大小为<span class="math inline">\(q\)</span>,我们有<span class="math inline">\(g_{ p
+ q + 1 } = C_p C_q C_{ n - ( p + q + 1 ) } = C_{ n - 1 }^{ ( 3 )
}\)</span>,同样是简单的卷积.</p>
<h3><span id="二项式系数的处理">二项式系数的处理</span></h3>
<h4><span id="通过恒等式变形求解">通过恒等式变形求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n k \binom{ m - k - 1 }{
m - n - 1 } , n , m \in \mathbb{ N } \land m &gt; n \\\)</span>.</p>
<p>这个式子乘了个系数<span class="math inline">\(k\)</span>导致很难处理,一个自然的想法是使用吸收恒等式将<span class="math inline">\(k\)</span>消去,然后对后面的式子使用上指标求和.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n m \binom{ m - k - 1 }{ m - n - 1 } - \sum_{ k = 0 }^n ( m - k )
\binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = m \sum_{ k = 0 }^{ m - 1 } \binom{ m - k - 1 }{ m - n - 1 } - (
m - n ) \sum_{ k = 0 }^m \binom{ m - k }{ m - n }
\end{aligned}
\]</span></p>
<p>不妨令<span class="math inline">\(S_m = \sum_{ k = 0 }^m \binom{ m -
k }{ m - n } \\\)</span>,不难发现我们有:</p>
<p><span class="math display">\[
S_m = \sum_{ k = 0 }^m \binom{ k }{ m - n } = \binom{ m + 1 }{ m - n + 1
}
\]</span></p>
<p>于是原式<span class="math inline">\(= mS_{ m - 1 } - ( m - n ) S_m =
\cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n } \\\)</span>.</p>
<p>不过事实上,我们有另一种方式来处理这个等式,我们直接将<span class="math inline">\(k = \binom{ k }{ 1 }\)</span>带入:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n k \binom{ m - k - 1 }{ m - n - 1 } &amp; = \sum_{ k = 0
}^n \binom{ k }{ 1 } \binom{ m - k - 1 }{ m - n - 1 } \\
&amp; = \binom{ m }{ m - n + 1 } \\
&amp; = \cfrac{ n }{ m - n + 1 } \binom{ m }{ m - n }
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{ k } k \binom{ n }{ k } \binom{ s
}{ k } , n \in \mathbb{ N } \\\)</span>.</p>
<p>第一反应仍然是使用吸收恒等式,但是注意到<span class="math inline">\(n\)</span>和<span class="math inline">\(s\)</span>的范围不一样,由于吸收恒等式的范围很松,因此应选择一个范围更松的数吸收,这样才能保证另一个数范围的特殊性,于是有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k } k \binom{ n }{ k } \binom{ s }{ k } &amp; = s \sum_{ k }
\binom{ n }{ k } \binom{ s - 1 }{ k - 1 } \\
&amp; = s \binom{ n + s - 1 }{ n - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(\sum_{ 0 \leq k } \binom{ n + k }{ 2 k
} \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N }
\\\)</span>.</p>
<p>我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ 0 \leq k } \binom{ n + k }{ 2 k } \binom{ 2 k }{ k } \cfrac{ ( -
1 )^k }{ k + 1 } &amp; = \sum_{ 0 \leq k } \binom{ n + k }{ k } \binom{
n }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n \in \mathbb{ N } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ n + k }{ k }
\binom{ n + 1 }{ k + 1 }{ ( - 1 )^k } \\
&amp; = \cfrac{ 1 }{ n + 1 } \sum_{ 0 \leq k } \binom{ - n - 1 }{ k }
\binom{ n + 1 }{ k + 1 } \\
&amp; = \cfrac{ 1 }{ n + 1 } \binom{ 0 }{ n } \\
&amp; = [ n = 0 ]
\end{aligned}
\]</span></p>
<h5><span id="example4">Example4</span></h5>
<p>求<span class="math inline">\(\sum_{ k \geq 0 } \binom{ n + k }{ m +
2 k } \binom{ 2 k }{ k } \cfrac{ ( - 1 )^k }{ k + 1 } , n , m \in
\mathbb{ N_+ } \\\)</span>.</p>
<p>考虑恒等式扩展的二项式恒等式(整数范围内)的<span class="math inline">\(( 1 )\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k \geq 0 } \binom{ n + k }{ m + 2 k } \binom{ 2 k }{ k } \cfrac{
( - 1 )^k }{ k + 1 } &amp; = \sum_{ k \geq 0 } \sum_{ 0 \leq j \leq n +
k - 1 } \binom{ n + k - 1 - j }{ 2 k } \binom{ j }{ m - 1 } \binom{ 2 k
}{ k } \cfrac{ ( - 1 )^k }{ k + 1 } \\
&amp; = \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 -
n \leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 }
\end{aligned}
\]</span></p>
<p>注意到如果<span class="math inline">\(j + 1 - n \geq
0\)</span>,则<span class="math inline">\(\binom{ n + k - 1 - j }{ 2 k }
\\\)</span>应为<span class="math inline">\(0\)</span>.所以有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ 0 \leq j \leq n - 1 } \binom{ j }{ m - 1 } \sum_{ j + 1 - n
\leq k , 0 \leq k } \binom{ n + k - 1 - j }{ 2 k } \binom{ 2 k }{ k }
\cfrac{ ( - 1 )^k }{ k + 1 } \\
= &amp; \sum_{ 0 \leq j &lt; n } \binom{ j }{ m - 1 } [ n - 1 - j = 0 ]
= \binom{ n - 1 }{ m - 1 }
\end{aligned}
\]</span></p>
<h5><span id="example5">Example5</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 0 }^n ( C_n^k
)^2\)</span>.</p>
<p><span class="math display">\[
\sum_{ k = 0 }^n ( C_n^k )^2 = \sum_{ k = 0 }^n C_{ n }^k \times C_{ n
}^{ n - k } = C_n^{ 2 n }
\]</span></p>
<h4><span id="转化为递归式和式求解">转化为递归式/和式求解</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(Q_n = \sum_{ k \leq 2^n } \binom{ 2^n -
k }{ k } ( - 1 )^k , n \in \mathbb{ N } \\\)</span>.</p>
<p>如果要转化为递归式的话,我们所掌握的只有加法恒等式,但加法恒等式只给出了杨辉三角中相邻两行的关系.但由于<span class="math inline">\(Q_n\)</span>的式子中实际上只与<span class="math inline">\(2^n\)</span>有关,我们不妨令<span class="math inline">\(R_n = \sum_{ k \leq n } \binom{ n - k }{ k } ( - 1
)^k \\\)</span>,显然有<span class="math inline">\(Q_n = R_{ 2^n
}\)</span>.</p>
<p>而我们有:</p>
<p><span class="math display">\[
\begin{aligned}
R_n &amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\sum_{ k \leq n } \binom{ n - 1 - k }{ k - 1 } ( - 1 )^k \\
&amp; = \sum_{ k \leq n } \binom{ n - 1 - k }{ k } ( - 1 )^k + \sum_{ k
\leq n - 1 } \binom{ n - k - 2 }{ k } ( - 1 )^{ k + 1 } \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k +
\binom{ - 1 }{ n } ( - 1 )^n - ( \sum_{ k \leq n - 2 } \binom{ n - 2 - k
}{ k } ( - 1 )^k + \binom{ - 1 }{ n - 1 } ( - 1 )^{ n - 1 } ) \\
&amp; = \sum_{ k \leq n - 1 } \binom{ n - 1 - k }{ k } ( - 1 )^k -
\sum_{ k \leq n - 1 } \binom{ n - 2 - k }{ k } ( - 1 )^k \\
&amp; = R_{ n - 1 } - R_{ n - 2 } \\
&amp; = R_{ n - 2 } - R_{ n - 3 } - R_{ n - 2 } \\
&amp; = - R_{ n - 3 } \\
&amp; = R_{ n - 6 }
\end{aligned}
\]</span></p>
<p>也即<span class="math inline">\(R_n\)</span>具有周期性,不难计算前几项答案,最后有<span class="math inline">\(Q_n \begin{cases}1 &amp; n = 0 \\ 0 &amp; n \ is \
\mathrm{ odd } \\ - 1 &amp; n &gt; 0 \land n \ is \ \mathrm{ even
}\end{cases}\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(( \sum^{ + \infty }_{ i = 0 } C^{ ik +
r }_{ nk } ) \mod p\)</span>.</p>
<p>考虑设<span class="math inline">\(f ( n , r ) = \sum^{ + \infty }_{ i
= 0 } C^{ ik + r }_{ nk } \\\)</span>,则有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n , r ) &amp; = \sum^{ + \infty }_{ i = 0 } C^{ ik + r }_{ nk } \\
&amp; = \sum_{ i = 0 }^{ + \infty } \sum_{ j = 0 }^k C_{ nk - k }^{ ik +
r - j } \times C_k^j \\
&amp; = \sum^k_{ j = 0 } C_k^j \sum_{ i = 0 }^{ + \infty } C_{ nk - k
}^{ ik + r - j } \\
&amp; = \sum_{ j = 0 }^k C_k^j f ( n - 1 , r - j ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>整理上式,得到:<span class="math inline">\(f ( n , r ) = \sum_{ j = 0
}^k C_k^j f ( n - 1 , r - j ) \\\)</span>.</p>
<p>于是我们得到了关于<span class="math inline">\(f\)</span>的转移方程,可以矩阵加速.</p>
<h4><span id="利用微积分求解">利用微积分求解</span></h4>
<h5><span id="example">Example</span></h5>
<p>求<span class="math inline">\(\sum_{ k = 1 }^n k^2
C_n^k\)</span>.</p>
$$
<span class="math display">\[\begin{aligned}
( ( 1 + x )^n ) &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) \\
( ( 1 + x )^n ) &#39; &amp; = ( \sum_{ k = 0 }^n C_n^k x^{ k } ) &#39;
\\
n ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k - 1 } \\
nx ( 1 + x )^{ n - 1 } &amp; = \sum_{ k = 0 }^n kC_n^k x^{ k } \\
( nx ( 1 + x )^{ n - 1 } ) &#39; &amp; = ( \sum_{ k = 0 }^n kC_n^k x^{ k
} ) &#39; \\
n ( ( 1 + x )^{ n - 1 } + ( n - 1 ) x ( 1 + x )^{ n - 2 } ) &amp; =
\sum_{ k = 0 }^n k^2 C_n^k x^{ k - 1 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>取<span class="math inline">\(x = 1\)</span>,则原式<span class="math inline">\(= n ( n + 1 ) 2^{ n - 2 }\)</span>.</p>
<h4><span id="转化为二维平面">转化为二维平面</span></h4>
<h5><span id="example1">Example1</span></h5>
<p>多次询问给定<span class="math inline">\(k , r\)</span>,<span class="math inline">\(\sum k \leq 2 n , r &lt; 2 n - k\)</span>,求<span class="math inline">\(\sum_{ i = 0 }^{ r } \frac{ 1 }{ 2^i } \binom{ i
}{ n - k }\)</span>,.</p>
<p>我们把模型抽象成:在二维平面上,从<span class="math inline">\(( 0 , 0
)\)</span>随机游走到<span class="math inline">\(( n - k + 1 , r - n + k
)\)</span>正下方(包含这个点)的概率,容易发现此时向右走了<span class="math inline">\(n - k\)</span>步,总共走了<span class="math inline">\(\leq
r\)</span>步,然后再向右走一步保证第一次走到了<span class="math inline">\(( n - k + 1 , r - n + k )\)</span>下方.</p>
<p>因为是概率,所以当我们已经确定这个事会发生的时候可以多走几步,不难发现这里的概率等价于走到<span class="math inline">\(x + y = r + 1\)</span>这条直线时横坐标<span class="math inline">\(\geq n - k +
1\)</span>的概率.枚举一下总共向上走了几步,就得到<span class="math inline">\(\frac{ 1 }{ 2^{ r } } \sum_{ j = 0 }^{ r - n + k }
\binom{ r + 1 }{ j }\)</span>,注意这里是<span class="math inline">\(\frac{ 1 }{ 2^r
}\)</span>,因为从一开始钦定了一步,因此映射过来需要多乘个<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>,反映射就要乘个<span class="math inline">\(2\)</span>.但是这个式子还是做不了,因为<span class="math inline">\(r\)</span>并不满足<span class="math inline">\(\sum
r \leq 2 n\)</span>.我们需要另辟蹊径.</p>
<p>做一下补集转化转化成走到上方的概率,这个概率就等价于<span class="math inline">\(1 - \frac{ 1 }{ 2^{ r } } \sum_{ i = 0 }^{ n - k }
\binom{ r + 1 }{ i }\)</span>.我们考虑暴力预处理出<span class="math inline">\(f_r = \sum_{ i = 0 }^{ n } \binom{ r }{ i
}\)</span>,每次删掉一个后缀的组合数就行.现在的问题在于<span class="math inline">\(f\)</span>怎么做.</p>
<p>直接拆组合数,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_r &amp; = \sum_{ i = 0 }^n \binom{ r }{ i } \\
&amp; = \sum_{ i = 0 }^n \binom{ r - 1 }{ i - 1 } + \sum_{ i = 0 }^n
\binom{ r - 1 }{ i } \\
&amp; = 2 \sum_{ i = 0 }^n \binom{ r - 1 }{ i } - \binom{ r - 1 }{ n }
\\
&amp; = 2 f_{ r - 1 } - \binom{ r - 1 }{ n }
\end{aligned}
\]</span></p>
<h3><span id="lucas定理">Lucas定理</span></h3>
<p>若<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(C_n^m \mod p = C_{ n \mod p }^{ m \mod p } \times
C_{ \lfloor \frac{ n }{ p } \rfloor }^{ \lfloor \frac{ m }{ p } \rfloor
} \mod p \\\)</span>.</p>
<p>或者说,将<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>在<span class="math inline">\(p\)</span>进制下分解,再逐位求组合数并相乘.</p>
<p>证明:</p>
<p>首先,若<span class="math inline">\(i \ne 0\)</span>且<span class="math inline">\(i \ne p\)</span>,<span class="math inline">\(C_{ p
}^i \equiv \frac{ p }{ i } C_{ p - 1 }^{ i - 1 } \equiv 0 ( \mod p )
\\\)</span>.</p>
<p>而根据二项式定理,<span class="math inline">\(( 1 + x )^p \equiv
\sum_{ i = 0 }^p C_{ p }^i x^i = 1 + x^p ( \mod p ) \\\)</span>.</p>
<p>令<span class="math inline">\(n = k_1 p + b_1\)</span>,<span class="math inline">\(m = k_2 p + b_2\)</span>,则<span class="math inline">\(( 1 + x )^n = ( 1 + x )^{ k_1 p } ( 1 + x )^{ b_1
} \\\)</span>.</p>
<p>而<span class="math inline">\(( 1 + x )^{ k_1 p } \equiv ( 1 + x^p
)^{ k_1 } ( \mod p ) \\\)</span>,有<span class="math inline">\(( 1 + x
)^n \equiv ( 1 + x^p )^{ k_1 } ( 1 + x )^{ b_1 } \\\)</span>.</p>
<p>根据二项式定理,<span class="math inline">\(C_n^m \bmod
p\)</span>即<span class="math inline">\(x^m\)</span>项的系数.</p>
<p>我们可以得出,<span class="math inline">\(C_n^m x^m \equiv C_{ k_1 }^{
k_2 } x^{ k_2 p } C_{ b 1 }^{ b_2 } x^{ b_2 } \pmod{ p }
\\\)</span>,那么有<span class="math inline">\(C_a^b \equiv C_{ k_1 }^{
k_2 } C_{ b_1 }^{ b_2 } \pmod{ p } \\\)</span>.</p>
<p>另外,Lucas定理有一个很重要的推论是:</p>
<p><span class="math display">\[
\binom{ n }{ m } \equiv [ m \subseteq n ] \pmod{ 2 }
\]</span></p>
<h5><span id="example1cf1770fkoxia-andsequence">Example1([CF1770F]Koxia and
Sequence)</span></h5>
<p>首先观察样例并思考,可以发现当<span class="math inline">\(n\)</span>为偶数时,显然翻转整个序列就可以一一对应(除非翻转后与本身相同,但这种情况下异或值也是<span class="math inline">\(0\)</span>),所以异或值为<span class="math inline">\(0\)</span>.不然,我们可以翻转<span class="math inline">\(a [ 2 . . . n ]\)</span>,得出答案应该是所有<span class="math inline">\(a_1\)</span>的异或和.</p>
<p>问题在于接下来怎么做,我们考虑把按位或的那个东西容斥掉.现在问题转化为:对于所有<span class="math inline">\(y &#39; \subseteq y\)</span>,求出满足<span class="math inline">\(a_i \subseteq y &#39; , \sum a_i =
x\)</span>时,<span class="math inline">\(a_1\)</span>异或和.接下来怎么做呢?我们考虑拆位,若<span class="math inline">\(2^k \subseteq y &#39;\)</span>,假设<span class="math inline">\(a_1\)</span>的第<span class="math inline">\(k\)</span>位是<span class="math inline">\(1\)</span>,然后讨论此时它对答案是否会产生贡献.</p>
<p>我们不难发现,第<span class="math inline">\(k\)</span>位贡献是:</p>
<p><span class="math display">\[
[ 2^k \subseteq y &#39; ] \bigoplus_{ \sum a = x } [ 2^k \subseteq a_1 ]
\prod_{ i = 1 }^n [ a_i \subseteq y &#39; ]
\]</span></p>
<p>这个东西看上去没办法做,但我们突然想到个事:Lucas定理的推论:<span class="math inline">\([ x \subseteq y ] \equiv \binom{ y }{ x } \pmod{ 2
}\)</span>.</p>
<p>所以原式化简为:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ \sum a = x } \binom{ a_1 }{ 2^k }
\prod_{ i = 1 }^n \binom{ y &#39; }{ a_i } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{
a_1 - 2^k } \sum_{ \sum a = x - a_1 } \prod_{ i = 2 }^n \binom{ y &#39;
}{ a_i } \pmod{ 2 } \\

\end{aligned}\]</span>
<p>$$</p>
<p>然后呢?不难发现后面那一串是范德蒙德卷积的形式,就可以写成:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \binom{ y &#39; }{ 2^k } \sum_{ a_1 } \binom{ y &#39; - 2^k }{ a_1
- 2^k } \binom{ ( n - 1 ) y &#39; }{ x - a_1 } \pmod{ 2 } \\
= &amp; \binom{ y &#39; }{ 2^k } \binom{ ny &#39; - 2^k }{ x - 2^k }
\pmod{ 2 } \\
= &amp; [ 2^k \subseteq y &#39; ] [ ( x - 2^k ) \subseteq ( ny &#39; -
2^k ) ]
\end{aligned}
\]</span></p>
<h3><span id="扩展lucas定理">扩展Lucas定理</span></h3>
<p>令<span class="math inline">\(p = \prod p_i^{ e_i
}\)</span>,那我们只要对于每个<span class="math inline">\(i\)</span>求出<span class="math inline">\(C_n^m
\mod p_i^{ e_i }\)</span>,然后使用中国剩余定理合并即可.</p>
<p>那现在问题转化为要求<span class="math inline">\(C_n^m \mod
p^k\)</span>,其中<span class="math inline">\(p \in \mathrm{ prime
}\)</span>.</p>
<p>原式<span class="math inline">\(= \frac{ n ! }{ m ! ( n - m ) ! }
\mod p^k = \frac{ \frac{ n ! }{ p^x } }{ \frac{ m ! }{ p^y } \frac{ ( n
- m ) ! }{ p^z } } p^{ x - y - z } \mod p^k \\\)</span>.</p>
<p>现在问题转化为求<span class="math inline">\(\frac{ n ! }{ p^x } \mod
p^k 以 及 p^x \\\)</span>.</p>
<p>注意到:</p>
<p><span class="math display">\[
\begin{aligned}
n ! &amp; = \prod_{ i = 1 } i \\
&amp; = ( \prod_{ i = wp , w \in \mathbb{ Z } } i ) ( \prod_{ i \ne wp ,
w \in \mathbb{ Z } } i ) \\
&amp; = p^{ \lfloor n p \rfloor } ( \lfloor n p \rfloor ! ) ( \prod_{ i
\ne wp , w \in \mathbb{ Z } } i ) \\
&amp; \equiv p^{ \lfloor \frac{ n }{ p } \rfloor } ( \lfloor \frac{ n }{
p } \rfloor ! ) ( \prod_{ i = 1 , i \ne wp , w \in \mathbb{ Z } }^{ p^k
} i )^{ \lfloor \frac{ n }{ p^k } \rfloor } ( \prod^{ n \ \bmod{ p^k }
}_{ i = p^k \lfloor \frac{ n }{ p^k } \rfloor , i \ne wp , w \in
\mathbb{ Z } } i ) ( \mod p^k )
\end{aligned}
\]</span></p>
<p>递归求解即可.</p>
<p>ps:</p>
<p>这样摆式子可能非常难以理解,我们考虑将<span class="math inline">\([ 1
, n ]\)</span>的所有数全部排成一个宽为<span class="math inline">\(p^k\)</span>的矩阵.</p>
<p>那右边第一项就是把那些<span class="math inline">\(p\)</span>的倍数的列拿出来,第二项是那些填满的行,第三项是最后没填满的一行.</p>
<h2><span id="斯特林数">斯特林数</span></h2>
<h3><span id="第一类斯特林数">第一类斯特林数</span></h3>
<p><span class="math inline">\(n \brack k \\\)</span>:长度为<span class="math inline">\(n\)</span>的排列划分成<span class="math inline">\(k\)</span>个轮换的方案数.</p>
<p>考虑现在已经将<span class="math inline">\(n -
1\)</span>个数分成了若干轮换,现在新加入第<span class="math inline">\(n\)</span>个数.这个数要么和其他的数一起组成轮换,要么自己形成自环.</p>
<p>而由于它可以插入前面轮换的任意位置,显然<span class="math inline">\(\left [ \begin{array}{ c } n \\ k\end{array}
\right ] = ( n - 1 ) \left [ \begin{array}{ c } n - 1 \\ k\end{array}
\right ] + \left [ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right ]
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left [ \begin{array}{ c }
0 \\ k\end{array} \right ] = [ k = 0 ] \\\)</span>.</p>
<p>由于所有的排列都由若干置换组成,因此我们有:<span class="math inline">\(\sum_{ k = 0 }^n \left [ \begin{array}{ c } n \\
k\end{array} \right ] = n !\)</span>.</p>
<h3><span id="第二类斯特林数">第二类斯特林数</span></h3>
<p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
k\end{array} \right \}\)</span>:将<span class="math inline">\(n\)</span>个本质不同的物品划分成k个非空集合的方案数.</p>
<p>考虑现在已经放好<span class="math inline">\(n -
1\)</span>个物品,正要放入第<span class="math inline">\(n\)</span>个物品.那么这个物品要么单独放在一起,要么和其他物品放在一起.显然<span class="math inline">\(\left \{ \begin{array}{ c } n \\ k\end{array}
\right \} = k \left \{ \begin{array}{ c } n - 1 \\ k\end{array} \right
\} + \left \{ \begin{array}{ c } n - 1 \\ k - 1\end{array} \right \}
\\\)</span>.</p>
<p>特别地,我们定义<span class="math inline">\(\left \{ \begin{array}{ c
} 0 \\ k\end{array} \right \} = [ k = 0 ] \\\)</span>.</p>
<h3><span id="斯特林数的扩展">斯特林数的扩展</span></h3>
<p>如果我们让斯特林数的定义式扩展到整数域,我们可以发现一个性质:<span class="math inline">\({ n \brack m } ={ - m \brace - n }
\\\)</span>.</p>
<h3><span id="基本斯特林恒等式">基本斯特林恒等式</span></h3>
<ol type="1">
<li><span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{
\begin{array}{ c } n \\ k\end{array} \right \} x^{ \underline{ k } } =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
( - 1 )^{ n - k } x^{ \overline{ k } } \\\)</span>.</li>
</ol>
<p>证明:先考虑前半段,不妨使用数学归纳.若<span class="math inline">\(x^{
n - 1 } = \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}{ c } n - 1 \\
k\end{array} \right \} x^{ \underline{ k } } \\\)</span>,我们要证</p>
<p>\</p>
$$
<span class="math display">\[\begin{aligned}
x \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k } } &amp; = \sum_{ k = 0 }^{ n }
\left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑<span class="math inline">\(( x - k ) x^{ \underline{ k } } = x^{
\underline{ k + 1 } }\)</span>,所以<span class="math inline">\(x \cdot
x^{ \underline{ k } } = x^{ \underline{ k + 1 } } + kx^{ \underline{ k }
} \\\)</span>.那么左边即:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \sum_{ k = 0 }^{ n - 1 } \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} x^{ \underline{ k + 1 } } + \sum_{ k = 0 }^{ n - 1
} \left \{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 1 }^{ n } \left \{ \begin{array}
{ c } n - 1 \\
k - 1
\end{array} \right \} x^{ \underline{ k } } + \sum_{ k = 1 }^{ n } \left
\{ \begin{array}
{ c } n - 1 \\
k
\end{array} \right \} kx^{ \underline{ k } } \\
= &amp; \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} x^{ \underline{ k } } \\
\\

\end{aligned}\]</span>
<p>$$</p>
<p>至于后半段,由于<span class="math inline">\(x^{ \underline{ n } } = (
- 1 )^n ( - x )^{ \overline{ n } } \\\)</span>,所以<span class="math inline">\(x^n = \sum_{ k = 0 }^n \left \{ \begin{array}{ c }
n \\ k\end{array} \right \} ( - 1 )^k ( - x )^{ \overline{ k } }
\\\)</span>.</p>
<p>不妨用<span class="math inline">\(x\)</span>来代替<span class="math inline">\(- x\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
( - x )^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^k ( x )^{ \overline{ k } } \\
x^n &amp; = \sum_{ k = 0 }^n \left \{ \begin{array}
{ c } n \\
k
\end{array} \right \} ( - 1 )^{ n - k } x^{ \overline{ k } }
\end{aligned}
\]</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(x^{ \overline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] x^k
\\\)</span>.</p></li>
<li><p><span class="math inline">\(x^{ \underline{ n } } = \sum_{ k = 0
}^n \left [ \begin{array}{ c } n \\ k\end{array} \right ] ( - 1 )^{ n -
k } x^k \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,由于<span class="math inline">\(( x + n - 1 ) x^k = x^{ k
+ 1 } + ( n - 1 ) x^k
\\\)</span>,所以类似于(1)前半段的推导即可得到,后者同样可以使用下降幂和上升幂的转化来得到.</p>
<ol start="4" type="1">
<li>反转公式:<span class="math inline">\(\sum_{ k = 0 }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} ( - 1 )^{ n - k } = \sum_{ k = 0 }^n \left
\{ \begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{
c } k \\ m\end{array} \right ] ( - 1 )^{ n - k } = [ m = n ]
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑先证明后半部分,将(3)带入(1),得到<span class="math inline">\(x^n =
\sum_{ k = 0 }^n \left \{ \begin{array}{ c } n \\ k\end{array} \right \}
x^{ \underline{ k } } = \sum_{ k = 0 }^n \sum_{ m = 0 }^k \left \{
\begin{array}{ c } n \\ k\end{array} \right \} \left [ \begin{array}{ c
} k \\ m\end{array} \right ] ( - 1 )^{ n - k } x^m \\\)</span>.</p>
<p>由于这对任意<span class="math inline">\(x\)</span>都成立,因此右边除了<span class="math inline">\(x^n\)</span>以外的项系数均为<span class="math inline">\(0\)</span>,而<span class="math inline">\(x^n\)</span>的系数为<span class="math inline">\(1\)</span>.前半部分是同理的.这个公式是斯特林反演的基础.</p>
<ol start="5" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\
m + 1\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c }
n \\ k\end{array} \right ) \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m
+ 1\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left [ \begin{array}{ c } k \\ m\end{array}
\right ] \\\)</span>.</p></li>
</ol>
<p>证明:对于前者,考虑组合意义,将<span class="math inline">\(n +
1\)</span>个分为<span class="math inline">\(m +
1\)</span>组,也就是先找一部分分成<span class="math inline">\(m\)</span>组,再把剩下的分到一组.对于后者,也可以同样考虑组合意义.</p>
<h3><span id="补充斯特林恒等式">补充斯特林恒等式</span></h3>
<ol start="7" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = m }^n \left ( \begin{array}{ c } n
\\ k\end{array} \right ) \left \{ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right \} ( - 1 )^{ n - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\
m\end{array} \right ] = \sum_{ k = m }^n \left ( \begin{array}{ c } n \\
k\end{array} \right ) \left [ \begin{array}{ c } k + 1 \\ m +
1\end{array} \right ] ( - 1 )^{ n - k } \\\)</span>.</p></li>
</ol>
<p>证明:由(5)(6),根据二项式反演可知.</p>
<ol start="9" type="1">
<li><span class="math inline">\(m ! \left \{ \begin{array}{ c } n \\
m\end{array} \right \} = \sum_{ k = 0 }^m C_m^k k^n ( - 1 )^{ m - k }
\\\)</span>.</li>
</ol>
<p>证明:首先有<span class="math inline">\(m^n = \sum_{ k = 0 }^m m^{
\underline{ k } } \left \{ \begin{array}{ c } m \\ k\end{array} \right
\} = \sum_{ k = 0 }^m k ! C_m^k \left \{ \begin{array}{ c } m \\
k\end{array} \right \} \\\)</span>,对这个式子进行二项式反演即可.</p>
<ol start="10" type="1">
<li><span class="math inline">\(\left \{ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right \} = \sum_{ k = 0 }^n \left \{ \begin{array}{ c } k
\\ m\end{array} \right \} ( m + 1 )^{ n - k } \\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑组合意义,相当于先把前<span class="math inline">\(k\)</span>个分为<span class="math inline">\(m\)</span>组,把第<span class="math inline">\(k +
1\)</span>个数放到第<span class="math inline">\(m +
1\)</span>组.然后剩下<span class="math inline">\(( n + 1 ) - ( k + 1 ) =
n -
k\)</span>个随便放.相当于我们按照每组所放的数的最小值区分每组.由于这么做,第<span class="math inline">\(m + 1\)</span>组(最小值最大的那组)在<span class="math inline">\(k\)</span>不同的时候最小值是不同的,因此一定不重不漏.</p>
<ol start="11" type="1">
<li><span class="math inline">\(\left [ \begin{array}{ c } n + 1 \\ m +
1\end{array} \right ] = \sum_{ k = 0 }^n \left [ \begin{array}{ c } k \\
m\end{array} \right ] C_{ n }^k ( n - k ) ! = n ! \sum_{ k = 0 }^n
\frac{ \left [ \begin{array}{ c } k \\ m\end{array} \right ] }{ k ! }
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>先考虑前半部分,首先如果<span class="math inline">\(n &gt;
0\)</span>,我们有<span class="math inline">\(\left [ \begin{array}{ c }
n \\ 1\end{array} \right ] = ( n - 1 ) !
\\\)</span>.这个式子很显然,我们现在有一个长度为<span class="math inline">\(n - 1\)</span>的环,想要往里插入第<span class="math inline">\(n\)</span>个数有<span class="math inline">\(n -
1\)</span>种选择,所以我们有:<span class="math inline">\(\left [
\begin{array}{ c } n \\ 1\end{array} \right ] = \left [ \begin{array}{ c
} n - 1 \\ 1\end{array} \right ] ( n - 1 )
\\\)</span>,数学归纳一下即可.</p>
<p>那么前半部分的组合意义就是:考虑将<span class="math inline">\(n +
1\)</span>个数划分成<span class="math inline">\(m +
1\)</span>个环,我们先将其中<span class="math inline">\(k\)</span>个数划分成<span class="math inline">\(m\)</span>个环,剩下<span class="math inline">\(n +
1 -
k\)</span>个数划分成另一个环.但是这样算显然会算重,所以我们只需要勒令第<span class="math inline">\(n +
1\)</span>个数在最后一个环里即可.该证明就显然了.</p>
<p>而由于<span class="math inline">\(C_n^k ( n - k ) ! = C_n^{ n - k } (
n - k ) ! = n^{ \underline{ n - k } } = \frac{ n ! }{ k ! }
\\\)</span>.因此后半部分也得证.</p>
<ol start="12" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n + m + 1
\\ m\end{array} \right \} = \sum_{ k = 0 }^m k \left \{ \begin{array}{ c
} n + k \\ k\end{array} \right \} \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n + m + 1
\\ m\end{array} \right ] \sum_{ k = 0 }^m ( n + k ) \left [
\begin{array}{ c } n + k \\ k\end{array} \right ] \\\)</span>.</p></li>
</ol>
<p>证明:</p>
<p>先考虑前者,我们将<span class="math inline">\(n +
k\)</span>个位置分到<span class="math inline">\(k\)</span>个集合之后.还剩下<span class="math inline">\(( n + m + 1 ) - ( n + k ) = ( m - k + 1
)\)</span>个数,剩下<span class="math inline">\(( m - k
)\)</span>个集合.</p>
<p>拿出来<span class="math inline">\(( n + k + 1
)\)</span>这个数,剩下的数刚好够每个集合放一个.最后枚举一下把<span class="math inline">\(( n + k + 1
)\)</span>放在哪里即可.由于每个划分一定存在一段(可能是<span class="math inline">\(0\)</span>)单独自己集合的后缀.所以这个递推成立.后者也可以同样证明.</p>
<ol start="14" type="1">
<li><span class="math inline">\(C_n^m ( n - 1 )^{ \underline{ n - m } }
= \sum_{ k = m }^n \left [ \begin{array}{ c } n \\ k\end{array} \right ]
\left \{ \begin{array}{ c } k \\ m\end{array} \right \}
\\\)</span>.</li>
</ol>
<p>证明:</p>
<p>考虑<span class="math inline">\(( n - 1 )^{ \underline{ n - m } } =
\frac{ ( n - 1 ) ! }{ ( m - 1 ) ! } \\\)</span>,不妨设<span class="math inline">\(f ( n , m ) = \sum_{ k = m }^n \left [
\begin{array}{ c } n \\ k\end{array} \right ] \left \{ \begin{array}{ c
} k \\ m\end{array} \right \} \\\)</span>,相当于将<span class="math inline">\(n\)</span>个数分成非空<span class="math inline">\(m\)</span>组,然后组内的数要形成若干轮换的方案数.那么知道<span class="math inline">\(f ( n , m ) = f ( n - 1 , m - 1 ) + ( n - 1 + m )
f ( n - 1 , m ) \\\)</span>.</p>
<p>设<span class="math inline">\(g ( n , m ) = C_n^m \frac{ ( n - 1 ) !
}{ ( m - 1 ) ! } = \frac{ n ! ( n - 1 ) ! }{ m ! ( n - m ) ! ( m - 1 ) !
} \\\)</span>,那么知道:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n - 1 , m - 1 ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ ( m - 1 )
! ( n - m ) ! ( m - 2 ) ! } \\
g ( n - 1 , m ) &amp; = \frac{ ( n - 1 ) ! ( n - 2 ) ! }{ m ! ( n - 1 -
m ) ! ( m - 2 ) ! } \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然<span class="math inline">\(g ( n , m ) = g ( n - 1 , m - 1 ) + (
n - 1 + m ) g ( n - 1 , m ) \\\)</span>,数学归纳即可.</p>
<ol start="15" type="1">
<li><p><span class="math inline">\(C_n^m = \frac{ n ! }{ m ! ( n - m ) !
} = \sum_{ k = m }^n \left \{ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right \} \left [ \begin{array}{ c } k \\ m\end{array}
\right ] ( - 1 )^{ m - k } \\\)</span>.</p></li>
<li><p><span class="math inline">\(n^{ \underline{ n - m } } = \frac{ n
! }{ m ! } = \sum_{ k = m }^n \left [ \begin{array}{ c } n + 1 \\ k +
1\end{array} \right ] \left \{ \begin{array}{ c } k \\ m\end{array}
\right \} ( - 1 )^{ m - k } ， 其 中 m \leq n \\\)</span>.</p></li>
</ol>
<p>证明:考虑(5)(6),对其做一遍斯特林反演即可.</p>
<ol start="17" type="1">
<li><p><span class="math inline">\(\left \{ \begin{array}{ c } n \\ l +
m\end{array} \right \} C_{ l + m }^l = \sum_{ k = l }^n \left \{
\begin{array}{ c } k \\ l\end{array} \right \} \left \{ \begin{array}{ c
} n - k \\ m\end{array} \right \} C_n^k \\\)</span>.</p></li>
<li><p><span class="math inline">\(\left [ \begin{array}{ c } n \\ l +
m\end{array} \right ] C_{ l + m }^l = \sum_{ k = l }^n \left [
\begin{array}{ c } k \\ l\end{array} \right ] \left [ \begin{array}{ c }
n - k \\ m\end{array} \right ] C_n^k \\\)</span>.</p></li>
</ol>
<p>证明:先考虑前者,左边即先将<span class="math inline">\(n\)</span>个数分为<span class="math inline">\(l +
m\)</span>个集合,然后再挑出<span class="math inline">\(l\)</span>个集合.那不妨枚举这<span class="math inline">\(l\)</span>个集合中是哪些数,然后再进行分配.后者同理.</p>
<h2><span id="欧拉数">欧拉数</span></h2>
<p>记<span class="math inline">\(\left \langle \begin{array}\\ n \\
k\end{array} \right \rangle\)</span>表示<span class="math inline">\(\{ 1
, 2 , . . . , n \}\)</span>的排列<span class="math inline">\(a\)</span>中满足这条性质的排列个数:存在且只存在<span class="math inline">\(k\)</span>个升高,换句话说,存在且只存在<span class="math inline">\(k\)</span>个<span class="math inline">\(i\)</span>,满足<span class="math inline">\(1 \leq
i &lt; n\)</span>,<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>.不难发现<span class="math inline">\(\left \langle
\begin{array}\\ n \\ k\end{array} \right \rangle = \left \langle
\begin{array}\\ n \\ n - k - 1\end{array} \right \rangle\)</span>.</p>
<p>考虑在一个<span class="math inline">\(\{ 1 , 2 , . . . , n - 1
\}\)</span>的排列中插入<span class="math inline">\(n\)</span>,设插入的位置是原本<span class="math inline">\(a_i\)</span>的后面,那么要么原本<span class="math inline">\(a_i &lt; a_{ i + 1
}\)</span>,要么反之.前者不会改变排列的升高的数量,后者则会增加<span class="math inline">\(1\)</span>.另外还有一种情况是插入到了序列最前面.于是我们自然得到:<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = ( k + 1 ) \left \langle \begin{array}\\ n - 1 \\
k\end{array} \right \rangle + ( n - k ) \left \langle \begin{array}\\ n
- 1 \\ k - 1\end{array} \right \rangle\)</span>.</p>
<p>特别地,我们令<span class="math inline">\(\left \langle
\begin{array}\\ 0 \\ k\end{array} \right \rangle = [ k = 0
]\)</span>,若<span class="math inline">\(k &lt; 0\)</span>,则<span class="math inline">\(\left \langle \begin{array}\\ n \\ k\end{array}
\right \rangle = 0\)</span>.</p>
<h3><span id="欧拉数与二项式系数">欧拉数与二项式系数</span></h3>
<p>我们有Worpitzky恒等式:</p>
<p><span class="math display">\[
x^n = \sum_{ k \geq 0 } \binom{ x + k }{ n } \left \langle \begin{array}
\\
n \\
k
\end{array} \right \rangle , n \in \mathbb{ N }
\]</span></p>
<p>还有另一个恒等式:</p>
<p><span class="math display">\[
\left \langle \begin{array}
\\
n \\
m
\end{array} \right \rangle = \sum_{ k = 0 }^m \binom{ n + 1 }{ k } ( m +
1 - k )^n ( - 1 )^k
\]</span></p>
<p>剩下的不会了.</p>
<h2><span id="伯努利数">伯努利数</span></h2>
<p>定义<span class="math inline">\(B_j\)</span>为第<span class="math inline">\(j\)</span>个伯努利数,且满足<span class="math inline">\(\sum_{ j = 0 }^m \binom{ m + 1 }{ j } B_j = [ m =
0 ] , m \geq 0 \\\)</span>.</p>
<p>定义<span class="math inline">\(S_m ( n ) = \sum_{ i = 0 }^{ n - 1 }
i^m\)</span>.</p>
<p>伯努利数满足公式:<span class="math inline">\(S_m ( n ) = \cfrac{ 1 }{
m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1 - k }
\\\)</span>.</p>
<p>证明如下:</p>
<p>对<span class="math inline">\(S_{ m + 1 } ( n
)\)</span>使用扰动法,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
S_{ m + 1 } ( n ) + n^{ m + 1 } &amp; = \sum_{ k = 0 }^{ n - 1 } ( k + 1
)^{ m + 1 } \\
&amp; = \sum_{ k = 0 }^{ n - 1 } \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1
}{ j } k^j \\
&amp; = \sum_{ j = 0 }^{ m + 1 } \binom{ m + 1 }{ j } S_j ( n ) \\
&amp; = \sum_{ j = 0 }^{ m } \binom{ m + 1 }{ j } S_j ( n ) + S_{ m + 1
} ( n ) \\
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } S_j ( n ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来使用数学归纳,假设<span class="math inline">\(0 \leq j &lt;
m\)</span>时该公式成立,并假设有<span class="math inline">\(S_m ( n ) =
\cfrac{ 1 }{ m + 1 } \sum_{ k = 0 }^m \binom{ m + 1 }{ k } B_k n^{ m + 1
- k } + \Delta \\\)</span>,我们只需要证明<span class="math inline">\(\Delta = 0\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
n^{ m + 1 } &amp; = \sum_{ j = 0 }^m \binom{ m + 1 }{ j } \cfrac{ 1 }{ j
+ 1 } \sum_{ k = 0 }^j \binom{ j + 1 }{ k } B_k n^{ j + 1 - k } + ( m +
1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k } \binom{ m +
1 }{ j } \cfrac{ 1 }{ j + 1 } B_k n^{ j + 1 - k } + ( m + 1 ) \Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ j - k } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq j \leq m } \binom{ j + 1 }{ k + 1 } \binom{
m + 1 }{ j } \cfrac{ 1 }{ j + 1 } B_{ j - k } n^{ k + 1 } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \sum_{ j
= k }^m B_{ j - k } \binom{ m + 1 }{ j } \binom{ j }{ k } + ( m + 1 )
\Delta \\
&amp; = \sum_{ 0 \leq k \leq m } \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{
m + 1 }{ k } \sum_{ j = k }^m B_{ j - k } \binom{ m + 1 - k }{ j - k } +
( m + 1 ) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } \sum_{ j = 0 }^{ m - k } B_{ j } \binom{ m + 1 - k }{ j } + ( m + 1
) \Delta \\
&amp; = \sum_{ k = 0 }^m \cfrac{ n^{ k + 1 } }{ k + 1 } \binom{ m + 1 }{
k } [ m - k = 0 ] + ( m + 1 ) \Delta \\
&amp; = n^{ m + 1 } + ( m + 1 ) \Delta
\end{aligned}
\]</span></p>
<p>显然<span class="math inline">\(\Delta = 0\)</span>,上式成立.</p>
<h2><span id="斐波那契数">斐波那契数</span></h2>
<p>定义斐波那契数<span class="math inline">\(F_n = \begin{cases}0 &amp;
n = 0 \\ 1 &amp; n = 1 \\ F_{ n - 1 } + F_{ n - 2 } &amp; n &gt;
1\end{cases}\)</span>.</p>
<h3><span id="斐波那契数的扩展定义">斐波那契数的扩展定义</span></h3>
<p>首先根据数学归纳,不难证明卡西尼恒等式:</p>
<p><span class="math display">\[
F_{ n + 1 } F_{ n - 1 } - F_n^2 = ( - 1 )^n , n &gt; 0
\]</span></p>
<p>事实上,如果我们将斐波那契数的递推式改写作:<span class="math inline">\(F_n = F_{ n + 2 } - F_{ n + 1
}\)</span>,我们可以在<span class="math inline">\(n \in \mathbb{ Z
}\)</span>的时候定义斐波那契数,同样也是满足上面的恒等式的,而且我们可以发现:</p>
<p><span class="math display">\[
F_{ - n } = ( - 1 )^{ n - 1 } F_n , n \in \mathbb{ Z }
\]</span></p>
<h3><span id="斐波那契数与数论">斐波那契数与数论</span></h3>
<p>如果我们考虑不断使用斐波那契递推式展开,不难发现:</p>
<p><span class="math display">\[
\begin{aligned}
F_{ n + k } &amp; = F_k F_{ n + 1 } + F_{ k - 1 } F_n \\
F_{ n + m + 1 } &amp; = F_{ n + 1 } F_{ m + 1 } + F_n F_m
\end{aligned}
\]</span></p>
<p>另外,如果我们在上面这个式子中取<span class="math inline">\(k = wn , w
\in \mathbb{ N }\)</span>并使用归纳法,我们又可以得到一个性质:<span class="math inline">\(F_{ kn }\)</span>是<span class="math inline">\(F_n\)</span>的倍数,<span class="math inline">\(k
\in \mathbb{ Z }\)</span>.</p>
<p>再观察这个式子,使用归纳法可以证明<span class="math inline">\(\gcd (
F_{ n } , F_{ n - 1 } ) = 1\)</span>,进一步有:<span class="math inline">\(\gcd ( F_{ n + m } , F_m ) = \gcd ( F_n , F_m
)\)</span>.</p>
<p>如果我们推广这个结论,就可以得到一个重要的性质:</p>
<p><span class="math display">\[
\gcd ( F_m , F_n ) = F_{ \gcd ( n , m ) }
\]</span></p>
<p>如果我们再一次推广这个结论,可以得到马蒂亚舍维奇引理:</p>
<p><span class="math display">\[
F_n^2 | F_m \Leftrightarrow nF_n | m , n &gt; 2
\]</span></p>
<p>这个引理的证明如下:</p>
<p>由于<span class="math inline">\(F_{ n + 1 } \equiv F_{ n - 1 } \pmod{
F_n }\)</span>.于是我们有:<span class="math inline">\(F_{ 2 n } = F_n
F_{ n + 1 } + F_{ n - 1 } F_n\)</span>,也就是<span class="math inline">\(F_{ 2 n } \equiv 2 F_n F_{ n + 1 } \pmod{ F_n^2
}\)</span>.</p>
<p>另外我们有:<span class="math inline">\(F_{ 2 n + 1 } \equiv F_{ n + 1
}^2 \pmod{ F_n^2 }\)</span>.</p>
<p>同理,使用归纳法可以证明:<span class="math inline">\(F_{ kn } \equiv
kF_n F_{ n + 1 }^{ k - 1 } \pmod{ F_n^2 } , F_{ kn + 1 } \equiv F_{ n +
1 }^k \pmod{ F_n^2 }\)</span>.</p>
<p>而<span class="math inline">\(F_{ n + 1 } \bot F_n\)</span>,于是<span class="math inline">\(F_{ kn } \equiv 0 \pmod{ F_n^2 } \Leftrightarrow k
\equiv 0 \pmod{ F_n } , n &gt; 2\)</span>.</p>
<h3><span id="斐波那契数系">斐波那契数系</span></h3>
<p>我们如果定义<span class="math inline">\(j \gg k \Leftrightarrow j
\geq k + 2\)</span>,那么有齐肯多夫定理:</p>
<p>每个正整数都有唯一的表示方式满足:<span class="math inline">\(n =
\sum_{ i = 1 }^r F_{ k_i } , \forall 1 \leq i &lt; r , k_i \gg k_{ i + 1
} \gg 0\)</span>.</p>
<p>首先证明存在性:我们考虑数学归纳,对于一个数n,如果<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k = n\)</span>,则显然成立,不然,应<span class="math inline">\(\exists k\)</span>满足<span class="math inline">\(F_k &lt; n &lt; F_{ k + 1 }\)</span>,而<span class="math inline">\(n - F_k\)</span>的表示已经存在了.另外,由于<span class="math inline">\(n - F_k &lt; F_{ k + 1 } - F_k = F_{ k - 1
}\)</span>,因此必定不可能出现选了<span class="math inline">\(F_k\)</span>又选了<span class="math inline">\(F_{
k - 1 }\)</span>的情况,存在性得证.</p>
<p>至于唯一性,如果我们不选择<span class="math inline">\(F_k\)</span>而是选择<span class="math inline">\(F_{ k - 1
}\)</span>,那么显然接下来无论怎么选,它们的加和都不可能大于等于<span class="math inline">\(F_k\)</span>,因此一定是唯一的.</p>
<p>这样的话,我们可以将一个自然数<span class="math inline">\(n\)</span>以斐波那契数的形式表示出来.</p>
<h3><span id="斐波那契数的封闭形式">斐波那契数的封闭形式</span></h3>
<p>使用生成函数,令<span class="math inline">\(F ( z ) = \sum_{ k \geq 0
} F_k z^k\)</span>.那么不难发现<span class="math inline">\(F ( z ) - zF
( z ) - z^2 F ( z ) = z\)</span>,也就是<span class="math inline">\(F ( z
) = \cfrac{ z }{ 1 - z - z^2 }\)</span>.</p>
<p>考虑这个形式一定可以分解为<span class="math inline">\(F ( z ) =
\cfrac{ a }{ 1 - \alpha z } + \cfrac{ b }{ 1 - \beta z
}\)</span>的形式,而这两种形式对应的生成函数都很显然.</p>
<p>进行因式分解,如果令<span class="math inline">\(\phi = \cfrac{ 1 +
\sqrt{ 5 } }{ 2 } , \hat \phi = \cfrac{ 1 - \sqrt{ 5 } }{ 2
}\)</span>,那么可以得到<span class="math inline">\(F_n = \cfrac{ 1 }{
\sqrt{ 5 } } ( \phi^n - \hat \phi^n )\)</span>.</p>
<p>另外,由于<span class="math inline">\(\hat
\phi^n\)</span>的影响很小,于是又有<span class="math inline">\(F_n =
\lfloor \cfrac{ \phi^n }{ \sqrt{ 5 } } + 0 . 5 \rfloor\)</span>.</p>
<h3><span id="连项式">连项式</span></h3>
<p>连项式多项式<span class="math inline">\(K_n ( x_1 , x_2 , . . . , x_n
)\)</span>定义为:<span class="math inline">\(K_n ( x_1 , x_2 , . . . ,
x_n ) = \begin{cases}1 &amp; n = 0 \\ x_1 &amp; n = 1 \\ x_n K_{ n - 1 }
( x_1 , x_2 , . . . x_{ n - 1 } ) + K_{ n - 2 } ( x_1 , x_2 , . . . ,
x_{ n - 2 } ) &amp; n \geq 2\end{cases}\)</span>.</p>
<p>通过定义不难发现:<span class="math inline">\(K_n ( 1 , 1 , . . . , 1
) = F_{ n + 1 }\)</span>.</p>
<p>继续观察式子,会发现它递归的过程相当于枚举是否消掉相邻的一对数<span class="math inline">\(( x_{ n - 1 } , x_n
)\)</span>.我们考虑用这样一种形式的字符串来表示最后某一项的情况:‘.’为还没有消除掉的项,长度为<span class="math inline">\(1\)</span>;’-‘为已经消除了的两项,长度为<span class="math inline">\(2\)</span>.那么<span class="math inline">\(K_n (
x_1 , x_2 , . . . , x_n )\)</span>就可以表示为一个长度为<span class="math inline">\(n\)</span>的字符串,其中若有<span class="math inline">\(k\)</span>个’-‘,有<span class="math inline">\(n -
2 k\)</span>个’.’,则有<span class="math inline">\(\binom{ n - k }{ k
}\)</span>种不同的排列方式.</p>
<p>于是我们有:</p>
$$
<span class="math display">\[\begin{aligned}
K_n ( z , z , . . . , z ) &amp; = \sum_{ k = 0 }^n \binom{ n - k }{ k }
z^{ n - 2 k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>另外,这也导出:<span class="math inline">\(F_{ n + 1 } = \sum_{ k = 0
}^n \binom{ n - k }{ k } \\\)</span>.</p>
<p>考虑上面的构造过程,不难发现<span class="math inline">\(K_n ( x_1 ,
x_2 , . . . , x_n ) = K_n ( x_n , x_{ n - 1 } , . . . , x_1
)\)</span>.</p>
<p>于是递归式可以写成:<span class="math inline">\(K_n ( x_1 , x_2 , . .
. , x_n ) = x_1 K_{ n - 1 } ( x_2 , x_3 , . . . x_{ n } ) + K_{ n - 2 }
( x_3 , x_4 , . . . , x_{ n } )\)</span>.</p>
<p>进一步地,不断展开后得到:</p>
<p><span class="math display">\[
\begin{aligned}
K_{ m + n } ( x_1 , . . . , x_m , x_{ m + 1 } , . . . , x_{ n + m } )
&amp; = \\
K_m ( x_1 , . . . , x_m ) K_n ( x_{ m + 1 } , . . . , x_{ n + m } ) +
K_{ m - 1 } ( x_1 , . . . , x_{ m - 1 } ) K_{ n - 1 } ( x_{ m + 2 } , .
. . , x_{ n + m } )
\end{aligned}
\]</span></p>
<p>另外,根据连项式的定义,不难导出<span class="math inline">\(K_n ( x_1 ,
. . . , x_n + y ) = K_n ( x_1 , . . . , x_n ) + K_{ n - 1 } ( x_1 , . .
. , x_{ n - 1 } ) y\)</span>.</p>
<p>由这个公式可以推出:<span class="math inline">\(\cfrac{ K_{ n + 1 } (
a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) } = \cfrac{ K_n ( a_0 ,
. . . , a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }{ K_{ n - 1 } ( a_1 , . . .
, a_{ n - 1 } + \cfrac{ 1 }{ a_n } ) }\)</span>.</p>
<p>不断做这个迭代,于是我们可以得到连项式与连分数之间的关系:</p>
<p><span class="math display">\[
\cfrac{ K_{ n + 1 } ( a_0 , . . . , a_n ) }{ K_n ( a_1 , . . . , a_n ) }
= a_0 + \cfrac{ 1 }{ a_1 + \cfrac{ 1 }{ a_2 + \cfrac{ 1 }{ a_3 + . . . }
} }
\]</span></p>
<p>另外,这个与数论中的Stern-Brocot树有很大关系,暂略.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" class="post-title-link" itemprop="url">简单乐理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E4%B9%90%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="前言">前言</span></h3>
<p>这个博客是北京大学课程《音乐与数学》的相关笔记.然而我懒得画五线谱以及插入钢琴图片,所以这里我们只空谈理论.</p>
<p>本人在大学前并未学过相关乐理,所以下面的个人理解当然可能会出错.</p>
<h3><span id="泛音列">泛音列</span></h3>
<h4><span id="拍音理论">拍音理论</span></h4>
<p>假设两个正弦单音的频率分别是<span class="math inline">\(\omega ,
\omega + \delta\)</span>,那么它们叠加后是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sin ( 2 \pi ( \omega + \delta ) t ) + \sin ( 2 \pi \omega t ) \\
= &amp; 2 \sin \left ( 2 \pi ( \omega + \frac{ \delta }{ 2 } ) t \right
) \cos ( \pi \delta t )
\end{aligned}
\]</span></p>
<p>注意到这个声音受到<span class="math inline">\(\cos ( \pi \delta t
)\)</span>的控制.因此会以<span class="math inline">\(\frac{ \delta }{ 2
}\)</span>的频率振动,由于<span class="math inline">\(\delta\)</span>应该远小于<span class="math inline">\(\omega\)</span>,这里就会产生<span class="math inline">\(\delta = | \omega_1 - \omega_2
|\)</span>个拍音.</p>
<h4><span id="mersenne定律">Mersenne定律</span></h4>
<p>考虑弦乐的情况,将一根弦理想化后,可以只关注它的三个参数:</p>
<ol type="1">
<li><p>弦长<span class="math inline">\(L\)</span>.</p></li>
<li><p>张力<span class="math inline">\(T\)</span>.</p></li>
<li><p>线密度<span class="math inline">\(\rho\)</span>.</p></li>
</ol>
<p>对于弦的振动解微分方程,这里我不是很想解了啊!所以我们直接放结论,对于弦上一个点<span class="math inline">\(u ( x , t )\)</span>,首先是一维振动方程:</p>
<p><span class="math display">\[
\frac{ \partial^2 u }{ \partial x^2 } = \frac{ \rho }{ T } \frac{
\partial^2 u }{ \partial t^2 }
\]</span></p>
<p>最终得到的会是一个无穷级数,这个无穷级数的每一项都形如:</p>
<p><span class="math display">\[
u_n ( x , t ) = c_n \sin ( \omega_n t + \theta_n ) \sin ( \frac{ n \pi
}{ L } x )
\]</span></p>
<p>其中第<span class="math inline">\(n\)</span>项的频率满足:</p>
<p><span class="math display">\[
f_n = \frac{ n }{ 2 L } \sqrt{ \frac{ T }{ \rho } }
\]</span></p>
<p>其中我们将<span class="math inline">\(f_1\)</span>称为<strong>基频</strong>,相应的声音称为<strong>基音</strong>,而将剩下的频率对应的声音统称为泛音,其中<span class="math inline">\(f_n , n \geq 2\)</span>对应的是第<span class="math inline">\(n - 1\)</span>泛音.</p>
<p>特别地,如果我们干脆记<span class="math inline">\(f =
f_1\)</span>,上述结果告诉我们弦的振动产生的一列频率是:</p>
<p><span class="math display">\[
f , 2 f , 3 f , \cdots
\]</span></p>
<p>这个序列通常被称为<strong>泛音列</strong>.</p>
<p>特别地,上述的频率其实是固定了点来讨论的,实际上的泛音要更为复杂,会在一根弦上的不同位置处产生不同的加权.实际上对于不同的<span class="math inline">\(n\)</span>,它们的泛音列长这个样子:<img src="https://y.gtimg.cn/music/photo_new/T062M000004QlDkO0nCeWY.jpg?max_age=0"></p>
<p>其中标注的点(波节)在振动中均是固定不变的.</p>
<p>这其实是某些弦乐演奏中一些按弦技巧的基础.例如这里,如果我用手轻触中间点,我就可以消灭掉所有的<span class="math inline">\(f_{ 2 k + 1 }\)</span>,泛音列中只剩下<span class="math inline">\(2 f , 4 f ,
\cdots\)</span>.我们后面会再提这个事,这意味着我弹出的音高了八度.那如果我按<span class="math inline">\(\frac{ 1 }{ 3
}\)</span>处呢?那泛音列中就会只剩下<span class="math inline">\(3 f , 6 f
, 9 f , \cdots\)</span>,也就是先高一个纯八度,再高一个纯五度.</p>
<p>还有拨弦,如果我在中间拨弦会发生什么呢?由于我的拨动使得整个弦应该以中间为对称形成一个偶函数,中间的点一定在波动,因此泛音列中剩下的就会是<span class="math inline">\(f , 3 f , 5 f , \cdots\)</span>.</p>
<h4><span id="管乐器">管乐器</span></h4>
<p>管乐器中振动的变为空气柱,不过吧空气柱这个东西振动的时候会略微超出管口,因此会有管口矫正这个事存在.</p>
<p>再就是,管乐器其实分为两种:开管(两面开口)和闭管(单面开口).而且不像琴弦的两端是固定的.一个自然的想法是,根据上面我们放的那张图,开口的那个位置一定要振动,而闭口的那个位置一定被卡住不动.这意味着开管和闭管的泛音列天然不同.具体来说:</p>
<p>开管的泛音列:</p>
<p><span class="math display">\[
f , 2 f , 3 f , 4 f , \cdots
\]</span></p>
<p>闭管的泛音列:</p>
<p><span class="math display">\[
f , 3 f , 5 f , 7 f
\]</span></p>
<p>另外,相同长度的管,开管的基音比闭管高了一个八度.</p>
<p>管乐器有一种演奏方式是超吹.简单来说,当你用力吹的时候,直觉上随着你用力越大,你吹出来的音的频率应该是连续的.但实际上听感更接近于离散的.这是因为从一开始整个泛音列就都是存在的,只是当气流加快的时候,后面的音在某种程度上被”加强”了,所以对于开管来说,你会先听到一个高八度的音,再听到一个高五度的音.</p>
<h4><span id="泛音列重合理论">泛音列重合理论</span></h4>
<p>既然如此,我们可以见到,当两个音的基频的比较为简单的时候,它们产生的泛音列重合程度就会较高.例如:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
2 f , 4 f , 6 f , 8 f , \cdots
\end{gathered}
\]</span></p>
<p>或是:</p>
<p><span class="math display">\[
\begin{gathered}
f , 2 f , 3 f , 4 f , \cdots \\
\frac{ 3 }{ 2 } f , 3 f , \frac{ 9 }{ 2 } f , 6 f , \cdots
\end{gathered}
\]</span></p>
<p>这从相当的程度解释了为什么理想的音程全都是简单整数比.</p>
<h3><span id="律制">律制</span></h3>
<p>要讲律制,首先要知道从经验上来讲,人耳对于音乐的听觉其实并非线性.换言之,当你听两个音的时候,你关注的可不是它们之间的频率差值,而可能更关注它们之间的频率比值.类似地,其实人听声压的时候靠的也是比值,例如<strong>分贝</strong>的定义是<span class="math inline">\(L_p = 20 \log_{ 10 } ( \frac{ p }{ p_0 }
)\)</span>,其中<span class="math inline">\(p_0 = 20 \mu Pa\)</span>.</p>
<h4><span id="音程">音程</span></h4>
<p>我们称两个音级之间的距离为<strong>音程</strong>,其中高的音称为<strong>冠音</strong>,而低的音被称为<strong>根音</strong>,一个音程应该由两个参数决定:<strong>度数</strong>和<strong>半音数</strong>,简单来说,度数是跨越的音名数量,而半音数是跨越的半音数量.表格长这样:</p>
<div class="line-block">度数 | 半音数 | 名称 |</div>
<div class="line-block">—- | —— | —— |</div>
<div class="line-block">一 | 0 | 纯一度 |</div>
<div class="line-block">二 | 1 | 小二度 |</div>
<div class="line-block">二 | 2 | 大二度 |</div>
<div class="line-block">三 | 3 | 小三度 |</div>
<div class="line-block">三 | 4 | 大三度 |</div>
<div class="line-block">四 | 5 | 纯四度 |</div>
<div class="line-block">四 | 6 | 增四度 |</div>
<div class="line-block">五 | 6 | 减五度 |</div>
<div class="line-block">五 | 7 | 纯五度 |</div>
<div class="line-block">六 | 8 | 小六度 |</div>
<div class="line-block">六 | 9 | 大六度 |</div>
<div class="line-block">七 | 10 | 小七度 |</div>
<div class="line-block">七 | 11 | 大七度 |</div>
<div class="line-block">八 | 12 | 纯八度 |</div>
<p>从这套理论出发,毕达哥拉斯说我们找一下最简整数比:注意到:</p>
<div class="line-block">音程 | 频率比 |</div>
<div class="line-block">—— | —— |</div>
<div class="line-block">纯八度 | <span class="math inline">\(2 :
1\)</span> |</div>
<div class="line-block">纯五度 | <span class="math inline">\(3 :
2\)</span> |</div>
<div class="line-block">纯四度 | <span class="math inline">\(4 :
3\)</span> |</div>
<div class="line-block">大三度 | <span class="math inline">\(5 :
4\)</span> |</div>
<div class="line-block">小三度 | <span class="math inline">\(6 :
5\)</span> |</div>
<p>看上去太漂亮了对吧!但是就是这个规定出了大锅.</p>
<h4><span id="五度相生律">五度相生律</span></h4>
<p>中国的三分损益法和毕达哥拉斯的五度相生法其实是类似的东西,我们这里只考虑五度相生律.</p>
<p>毕达哥拉斯学派说,我们这么干,规定<span class="math inline">\(C\)</span>的频率(当时其实不存在频率的概念,但我们这里就为了方便这么说了)为<span class="math inline">\(1\)</span>,然后每次向上升一个纯五度,如果超出去了呢,那就降一个八度降回来.回忆到纯五度是七个半音,这相当于求<span class="math inline">\(\{ 7 k \} \pmod{ 12
}\)</span>这个数列对吧,简单数论知识告诉我们它必然能遍历<span class="math inline">\(12\)</span>种情况,具体而言:</p>
$$
<span class="math display">\[\begin{aligned}
C \to &amp; &amp; G \to &amp; &amp; D \to &amp; &amp; A \to &amp; &amp;
E \to &amp; &amp; B \to \\
1 \to &amp; &amp; \frac{ 3 }{ 2 } \to &amp; &amp; \frac{ 3^2 }{ 2^3 }
\to &amp; &amp; \frac{ 3^3 }{ 2^4 } \to &amp; &amp; \frac{ 3^4 }{ 2^6 }
\to &amp; &amp; \frac{ 3^5 }{ 2^7 } \to \\
\\
\\
\# F \to &amp; &amp; \# C \to &amp; &amp; \# G \to &amp; &amp; \# D \to
&amp; &amp; \# A \to &amp; &amp; \# E \\
\frac{ 3^6 }{ 2^9 } \to &amp; &amp; \frac{ 3^7 }{ 2^{ 11 } } \to &amp;
&amp; \frac{ 3^8 }{ 2^{ 12 } } \to &amp; &amp; \frac{ 3^9 }{ 2^{ 14 } }
\to &amp; &amp; \frac{ 3^{ 10 } }{ 2^{ 15 } } \to &amp; &amp; \frac{ 3^{
11 } }{ 2^{ 17 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>我们是拿纯八度和纯五度生成的所有的音,因此纯五度肯定是准的,那么与之对应的纯四度肯定是准的.但是看三度音程就会发现问题,例如大三度<span class="math inline">\(CE\)</span>的比是<span class="math inline">\(\frac{ 81 }{ 64 } &gt; \frac{ 80 }{ 64 } = \frac{
5 }{ 4 }\)</span>.</p>
<p>更难过的是就算我们按照纯八度和纯五度生成的,这个纯八度也有点难绷.具体而言这里的<span class="math inline">\(\# E \ne F\)</span>,你对着这个<span class="math inline">\(\# E\)</span>往上再升一个音得到的理应是<span class="math inline">\(C &#39; = \frac{ 3^{ 12 } }{ 2^{ 18 } } &gt;
2\)</span>,具体来说<span class="math inline">\(\frac{ 3^{ 12 } }{ 2^{ 19
} } \approx 1 .
013643\)</span>,这就出事了,这个东西转一圈并没有转到理想的纯八度音阶上,这个问题在中国古代的三分损益上也体现了,那里的名字叫旋宫不归,这里的话则是将这个略大于<span class="math inline">\(1\)</span>的数叫做<strong>毕达哥拉斯音差</strong>.</p>
<p>仔细分析一下就会发现这个问题几乎是不可避免的,因为你上升<span class="math inline">\(12\)</span>个纯五度,再下降<span class="math inline">\(7\)</span>个纯八度理应回到原点,可是:</p>
<p><span class="math display">\[
( \frac{ 3 }{ 2 } )^{ 12 } \times ( \frac{ 1 }{ 2 } )^7 &gt; 1
\]</span></p>
<p>这下这下了.</p>
<h4><span id="纯律">纯律</span></h4>
<p>其实我们刚才就能见到真正完美符合简单整数比的律根本调不出来.但是能不能让一些常用的音程(比如纯八度,纯五度,纯四度,大三度)尽可能准呢.这就是纯律在干的事.</p>
<p>还是规定<span class="math inline">\(C\)</span>的频率为<span class="math inline">\(1\)</span>.接下来用正三和弦(一个大三度和一个小三度)<span class="math inline">\(I : C - E - G\)</span>,<span class="math inline">\(IV : F - A - C &#39;\)</span>,<span class="math inline">\(V : G - B - D &#39;\)</span>的比例是<span class="math inline">\(4 : 5 : 6\)</span>确定剩下的:</p>
<p><span class="math display">\[
\begin{aligned}
C &amp; &amp; D &amp; &amp; E &amp; &amp; F &amp; &amp; G &amp; &amp; A
&amp; &amp; B &amp; &amp; C &#39; &amp; &amp; D &#39; \\
1 &amp; &amp; \frac{ 9 }{ 8 } &amp; &amp; \frac{ 5 }{ 4 } &amp; &amp;
\frac{ 4 }{ 3 } &amp; &amp; \frac{ 3 }{ 2 } &amp; &amp; \frac{ 5 }{ 3 }
&amp; &amp; \frac{ 15 }{ 8 } &amp; &amp; 2 &amp; &amp; \frac{ 9 }{ 4 }
\end{aligned}
\]</span></p>
<p>所以现在大三度和小三度都准了.但问题又来了:</p>
<ol type="1">
<li><p>五度音程<span class="math inline">\(D -
A\)</span>不协和,比例为<span class="math inline">\(\frac{ 80 }{ 54 }
&lt; \frac{ 81 }{ 54 } = \frac{ 3 }{ 2
}\)</span>.这直接导致了转调会出错.</p></li>
<li><p>有两种不同的大二度:音程<span class="math inline">\(C - D , F - G
, A - B\)</span>的比例是<span class="math inline">\(\frac{ 9 }{ 8
}\)</span>而音程<span class="math inline">\(D - E , G -
A\)</span>的比例为<span class="math inline">\(\frac{ 10 }{ 9
}\)</span>.</p></li>
<li><p><strong>谐调音差</strong>:从<span class="math inline">\(C\)</span>出发升高四个纯五度,降低两个八度和一个大三度后,得到的是:<span class="math inline">\(( \frac{ 3 }{ 2 } )^4 \times ( \frac{ 1 }{ 2 } )^2
\times \frac{ 4 }{ 5 } = \frac{ 81 }{ 80 } = 1 . 0125 &gt;
1\)</span>.</p></li>
</ol>
<h4><span id="十二平均律">十二平均律</span></h4>
<p>既然我们一开始就说了律是根据比值来定的,为什么不直接简单一点,干脆用<span class="math inline">\(\sqrt[12]{ 2
}\)</span>来平均律制呢?于是将近五百年前就有了朱载堉这位手开十二次根号的神人.这也是所有律法中几乎最简单的一种了,以至于我到这里发现没啥可写的了.</p>
<p>但它的问题也是最一眼能看出来的,那就是除了纯八度,全都不准.</p>
<p>先在这里定义<strong>音分</strong>的概念,设两个声音的频率分别是<span class="math inline">\(f_1 , f_2\)</span>,则它们的音分数定义为<span class="math inline">\(1200 \log_2 ( \frac{ f_2 }{ f_1 }
)\)</span>,容易见到十二平均律拿到的一个半音恰好是<span class="math inline">\(100\)</span>音分.</p>
<p>用音分可以迅速确定一下,发现十二平均律这玩意准的离谱,虽然哪里都差一点,但哪里差的都不多.</p>
<h3><span id="调式">调式</span></h3>
<h4><span id="大小调">大小调</span></h4>
<h5><span id="自然大调">自然大调</span></h5>
<p>就是我们最常用的<span class="math inline">\(CDEFGABC
&#39;\)</span>,用大二度和小二度组织调式.具体而言,以一个大二度分开了两组四声音阶(均为大大小),按顺序分别为:</p>
<ol type="1">
<li><p>主音</p></li>
<li><p>上主音</p></li>
<li><p>中音</p></li>
<li><p>下属音</p></li>
<li><p>属音</p></li>
<li><p>下中音</p></li>
<li><p>导音</p></li>
</ol>
<p>用五度相生,下属音<span class="math inline">\(\rightarrow\)</span>主音<span class="math inline">\(\rightarrow\)</span>属音.</p>
<h5><span id="自然小调">自然小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小大大)</p>
<p>以<span class="math inline">\(ABCDEFG\)</span>用的调子,然而这里的问题是<span class="math inline">\(G\)</span>作为导音却和<span class="math inline">\(A &#39;\)</span>差了个全音,导得不好.</p>
<h5><span id="和声小调">和声小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和小增小)</p>
<p>将自然小调的导音升高一个半音.用<span class="math inline">\(A , B , C
, D , E , F , (^\# G )\)</span>.</p>
<p>但是这样出了个增二度.</p>
<h5><span id="旋律小调">旋律小调</span></h5>
<p>以一个大二度分开了两组四声音阶(分别为大小大和大大小)</p>
<p>把下中音也升上去,这样差的就小,用<span class="math inline">\(A , B , C
, D , E , (^\# F ) , (^\# G )\)</span>.</p>
<p>可以见到小调改音的主要目的是为了调导音的作用,这种作用只有在上行音阶的时候才是需要人为更改的,因此下行音阶不改音,与自然小调的下行音阶保持一致.</p>
<h4><span id="升降号调">升降号调</span></h4>
<p>以五度相生:</p>
<p><span class="math display">\[
C \to G \to D \to A \to E \to B \to (^\# F ) \to (^\# C )
\]</span></p>
<p>依次考虑它们为主调的自然大调音阶.</p>
<p>大调音阶的前后是对称的全全半+全+全全半结构,跳一个五度刚好能从前半部分跳到后半部分,因此从<span class="math inline">\(C\)</span>开始每次往后跳一次都要在一个音阶上增一个升号.从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(G\)</span>大调的时候就是将<span class="math inline">\(C\)</span>的下属音(也就是<span class="math inline">\(F\)</span>)升音.</p>
<p>对称地,反方向的五度相生:</p>
<p><span class="math display">\[
C \to F \to (^b B ) \to (^b E ) \to (^b A ) \to (^b D ) \to (^b G ) \to
(^b C )
\]</span></p>
<p>那这个应该降什么呢?比如从<span class="math inline">\(C\)</span>大调提升到<span class="math inline">\(F\)</span>大调的时候就是将<span class="math inline">\(F\)</span>的下属音<span class="math inline">\(B\)</span>降一个音对吧.</p>
<p>所以最后的结果就是:</p>
<p><img src="https://img2022.cnblogs.com/blog/662544/202204/662544-20220411164109167-1657776014.png"></p>
<p>一个自然大调将主音向前挪小三度就得到了一个自然小调,它们称为一对<strong>关系大小调</strong>.</p>
<p>具有相同主音的大小调被称为<strong>平行大小调</strong>.其实也就是名字精确到大小写是一样的.</p>
<p>一个大调的下属音大调和属音大调以及对应的关系小调称为其<strong>近关系调</strong>.</p>
<h3><span id="和弦">和弦</span></h3>
<h4><span id="三和弦">三和弦</span></h4>
<p>按照三度音程叠起来的三个音所构成的和弦被称为<strong>三和弦</strong>.其中最下面的音被称为<strong>根音</strong>,最上面的音被称为<strong>冠音</strong>或者<strong>五音</strong>,中间的被称为<strong>三音</strong>.</p>
<p>由于三度音程分大小,所以就有了四种不同的三和弦.</p>
<ol type="1">
<li><p>大三和弦:下面一个大三度,上面一个小三度,刚好形成<span class="math inline">\(4 : 5 : 6\)</span>的频率关系.</p></li>
<li><p>小三和弦:下面一个小三度,上面一个大三度.</p></li>
<li><p>减三和弦:两个小三度.</p></li>
<li><p>增三和弦:两个大三度.</p></li>
</ol>
<h4><span id="七和弦">七和弦</span></h4>
<p>按照三度音程叠四个音构成的和弦被称为<strong>七和弦</strong>.除去其中由三个大三度构成的(这样使得最上方的七音和最底下的根音形成了八度)以外,其余七种七和弦依照三和弦名称+七度音阶名称的原则命名,如下:</p>
<ol type="1">
<li><p>减减七和弦(减七和弦):小小小.</p></li>
<li><p>减小七和弦(半减七和弦):小小大.</p></li>
<li><p>小小七和弦(小七和弦):小大小.</p></li>
<li><p>小大七和弦:小大大.</p></li>
<li><p>大小七和弦(属七和弦):大小小.</p></li>
<li><p>大大七和弦(大七和弦):大小大.</p></li>
<li><p>增大七和弦:大大小.</p></li>
</ol>
<p>很遗憾的是七和弦全部包含至少一个不协和音程,所以它们全都是不协和和弦.</p>
<h4><span id="和弦转位">和弦转位</span></h4>
<p>以根音为低音的和弦为<strong>原位和弦</strong>,以三五七音为低音的则称为<strong>转位和弦</strong>.</p>
<p>对于三和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>四六和弦</strong>.</p></li>
</ol>
<p>对于七和弦来说:</p>
<ol type="1">
<li><p>以三音作为低音的称为<strong>第一转位</strong>,也称作<strong>五六和弦</strong>.</p></li>
<li><p>以五音作为低音的称为<strong>第二转位</strong>,也称作<strong>三四和弦</strong>.</p></li>
<li><p>以七音作为低音的称为<strong>第三转位</strong>,也称作<strong>二和弦</strong>.</p></li>
</ol>
<h4><span id="和弦的调性">和弦的调性</span></h4>
<p>在调式的主音,下属音,属音上的和弦分别被称为<strong>主和弦(I)</strong>,<strong>下属和弦(IV)</strong>,<strong>属和弦(V)</strong>,它们被统称为<strong>正和弦</strong>,在C大调中体现为<span class="math inline">\(C - E - G\)</span>,<span class="math inline">\(F -
A - C &#39;\)</span>,<span class="math inline">\(G - B - D
&#39;\)</span>.其中主和弦一般比较稳定,属和弦则比较飘渺,下属和弦往往则起到过度作用.</p>
<p>一定范围内的和弦连接被称为<strong>和声进行</strong>,下面是三种基本形式:</p>
<ol type="1">
<li><p>正格进行:<span class="math inline">\(I \to V \to
I\)</span>.</p></li>
<li><p>变格进行:<span class="math inline">\(I \to IV \to
I\)</span>.</p></li>
<li><p>复式进行:<span class="math inline">\(I \to IV \to V \to
I\)</span>.</p></li>
</ol>
<p>对于大调来说,其不同的三和弦之间有更加复杂的关系.经验给出以下图表:</p>
<p><span class="math display">\[
\xymatrix{ &amp; &amp; &amp; &amp; I \\
&amp; &amp; IV \ar[r] \ar[d] \ar[dr] \ar[rru] &amp; vii \degree \ar[ru]
&amp; \\
iii \ar[r] &amp; vi \ar[r] \ar[ru] &amp; ii \ar[r] \ar[ru] &amp; V
\ar[ruu] &amp; }
\]</span></p>
<p>其中<span class="math inline">\(I\)</span>较为特殊,可以走向全部的和弦,这里略去不画.</p>
<h4><span id="新黎曼理论">新黎曼理论</span></h4>
<p>引入以下三种对三和弦的变换(均会使得大和弦变小和弦,小和弦变大和弦):</p>
<ol type="1">
<li><p>平行变换<span class="math inline">\(P\)</span>:保持纯五度音阶不变,将三音切换.</p></li>
<li><p>关系变换<span class="math inline">\(R\)</span>:保持大三度音阶不变,补上剩下的一个(等价于大小调转换).</p></li>
<li><p>导音变换<span class="math inline">\(L\)</span>:保持小三度音阶不变,补上剩下的一个.</p></li>
</ol>
<p>容易见到<span class="math inline">\(R \circ ( L \circ R )^3 =
P\)</span>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">随机算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-26 10:17:13" itemprop="dateModified" datetime="2025-09-26T10:17:13+08:00">2025-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="随机化算法">随机化算法</span></h2>
<h3><span id="基本分析">基本分析</span></h3>
<h4><span id="union-bound">Union Bound</span></h4>
<p>即:<span class="math inline">\(Pr [ \bigcup_i X_i ] \leq \sum Pr [
X_i ]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h4><span id="markov-不等式">Markov 不等式</span></h4>
<p>若<span class="math inline">\(X \geq 0\)</span>,则<span class="math inline">\(Pr [ X \geq t \mathbb{ E } [ X ] ] \leq \frac{ 1
}{ t }\)</span>.</p>
<h6><span id="examplemax-cut算法">Example(Max-Cut算法)</span></h6>
<p>一个无向无权图,将点集划分成两个部分,使得跨越这两部分的边尽可能多.</p>
<p>直接随机划分,容易见到每条边有<span class="math inline">\(\frac{ 1 }{
2 }\)</span>的概率是割边,因此期望自然是<span class="math inline">\(\frac{ 1 }{ 2 } | E | \geq \frac{ 1 }{ 2 } |
\text{ max - cut } |\)</span>.</p>
<p>由此立即见到,<span class="math inline">\(Pr [ | ans | \leq ( \frac{ 1
}{ 2 } - \epsilon ) | E | ] = Pr [ | E | - | ans | \geq ( \frac{ 1 }{ 2
} + \epsilon ) | E | ] \leq \frac{ 1 }{ 1 + 2 \epsilon }\)</span>.</p>
<p>由于每次独立操作,因此如果有<span class="math inline">\(P\)</span>的概率失败,那么运行<span class="math inline">\(T\)</span>次后至少成功一次的概率应当为<span class="math inline">\(1 - P^T\)</span>.从而<span class="math inline">\(T
= O ( \log_P{ \delta } ) = O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{ \ln (
1 +{ 2 \epsilon } ) } ) \approx O ( \cfrac{ \ln \frac{ 1 }{ \delta } }{
\epsilon } )\)</span>即可拿到<span class="math inline">\(\delta\)</span>失败概率.</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>设<span class="math inline">\(X_1 , \cdots , X_n \in [ 0 , 1
]\)</span>是独立,同期望(期望为<span class="math inline">\(\mu \geq
t\)</span>)的随机变量,令<span class="math inline">\(X = \frac{ \sum_k
X_k }{ n }\)</span>,对于任何失败概率<span class="math inline">\(\delta
\in ( 0 , 1 )\)</span>,应当有:</p>
<p><span class="math display">\[
Pr \left [ | X - \mu | \geq \sqrt{ \cfrac{ \log ( 1 / \delta ) }{ nt } }
\mu \right ] \leq \delta
\]</span></p>
<h6><span id="examplemedian-trick">Example(Median Trick)</span></h6>
<p>现在有一个黑盒能够以<span class="math inline">\(p &gt; \frac{ 1 }{ 2
}\)</span>的概率正确回答Yes或者No,问重复<span class="math inline">\(T\)</span>选多少次能拿到<span class="math inline">\(1 - \delta\)</span>的成功概率.</p>
<p>考虑重复<span class="math inline">\(T\)</span>次后应当有期望<span class="math inline">\(pT\)</span>个正确答案,因此直接取中位数.称此算法为Median
Trick.</p>
<p>Chernoff Bound 告诉我们<span class="math inline">\(T = O ( \log
\frac{ 1 }{ \delta } )\)</span>足够.</p>
<h4><span id="hoeffding-不等式">Hoeffding 不等式</span></h4>
<p>设独立随机变量<span class="math inline">\(x_1 , \cdots , x_m \in [ s
, t ]\)</span>,令<span class="math inline">\(X = \sum_i
x_i\)</span>,则:</p>
<p><span class="math display">\[
Pr [ X - E [ X ] \geq z ] \leq 2 \exp \left ( - \cfrac{ 2 z^2 }{ m ( t -
s )^2 } \right )
\]</span></p>
<h3><span id="编程中的随机性">编程中的随机性</span></h3>
<p>一般采用伪随机,也即是给定初值<span class="math inline">\(X_0\)</span>,通过某个确定性的函数来生成<span class="math inline">\(X_{ n + 1 } = f ( X_n )\)</span>这样的.</p>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li><p>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</p></li>
<li><p>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</p></li>
<li><p>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</p></li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1 - ( 1 - p )^k\)</span>,时间复杂度为<span class="math inline">\(O ( kf ( n ) )\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举一些元素.</p></li>
<li><p>设这个算法的复杂度为<span class="math inline">\(O ( f ( n ) g ( n
) )\)</span>,其中<span class="math inline">\(f ( n
)\)</span>为枚举部分的复杂度,<span class="math inline">\(g ( n
)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g ( n )\)</span>不会很大.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找元素来降低复杂度.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度.</p></li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要用到一个或多个传入的元素.</p></li>
<li><p>这个元素的值不应该依赖于输入数据.</p></li>
<li><p>我们可以通过check这个元素来得到与答案有关的信息.</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机这个元素.</p></li>
<li><p>计算随机化情况下的正确率以及复杂度</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n \leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O ( n^3 )\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil \frac{ n }{ 7 }
\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{ 1 }{ 7
}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{ 1 }{ 49 }\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1 - ( \frac{ 48 }{ 49 } )^{ 1000
}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{ n }{ 2
}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n \leq
10^6\)</span>,<span class="math inline">\(a_i \leq 10^{ 12
}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O ( n \sqrt{ a } )\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt{ a
}\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([ l , r ]\)</span>,问<span class="math inline">\(a
[ l , r
]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\(( n , m \leq 500000 , 1 \leq a_i \leq n
)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k = 2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O ( n^2 d )\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A = \begin{bmatrix}\vec{ a_1 } , \vec{ a_2 } , . .
. , \vec{ a_n }\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B =
AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{ i , j }\)</span>在<span class="math inline">\(\mod 2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B =
C\)</span>,那么对于任意一个<span class="math inline">\(X_{ m \times n
}\)</span>都应该满足<span class="math inline">\(XB = XC\)</span>,取<span class="math inline">\(m =
1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB \ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O ( nd )\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O ( n
)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D = B -
C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{ i , j } \ne 0\)</span>.我们令<span class="math inline">\(E = X \times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j = \sum_{ k } X_k D_{ k , j
}\)</span>,不难解得:<span class="math inline">\(E_i = - \frac{ 1 }{ D_{
i , j } } \sum_{ k \ne i } X_k D_{ k , j }\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O ( nd )\)</span>.</p>
<p><span class="math inline">\(k = 3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{
j } B_{ i , j }^2 X_j = \sum_{ j } B_{ i , j } X_j B_{ h , i
}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li><p>这个算法需要枚举全排列.</p></li>
<li><p>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</p></li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li><p>随机化寻找排列来降低复杂度.</p></li>
<li><p>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</p></li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T ( n )\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
T ( 0 ) &amp; = 0 \\
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } )
\end{aligned}
\]</span></p>
<p>做放缩(可能有些地方需要<span class="math inline">\(+
1\)</span>或者<span class="math inline">\(-
1\)</span>或者加取整,但是问题不大,反正是期望):</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; = n + \frac{ 1 }{ n } \sum_{ i = 0 }^{ n - 1 } ( T_i + T_{
n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ n - 1 } ( T_i
+ T_{ n - i - 1 } ) \\
&amp; = n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{ \frac{ 3 n }{
4 } } ( T ( i ) + T ( n - i - 1 ) ) + \frac{ 2 }{ n } \sum_{ i = \frac{
3 n }{ 4 } }^{ n } ( T ( i ) + T ( n - i - 1 ) )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(T ( n ) \geq n\)</span>,所以对于<span class="math inline">\(\frac{ n }{ 2 } \leq i \leq
j\)</span>,我们显然有:<span class="math inline">\(T ( i ) + T ( n - i )
\leq T ( j ) + T ( n - j )\)</span>.</p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 2 }{ n } \sum_{ i = \frac{ n }{ 2 } }^{
\frac{ 3 n }{ 4 } } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n }{ 4 } ) )
+ \frac{ 2 }{ n } \sum_{ i = \frac{ 3 n }{ 4 } }^{ n } ( T ( n - 1 ) + T
( 0 ) ) \\
&amp; \leq n + \frac{ 1 }{ 2 } ( T ( \frac{ 3 n }{ 4 } ) + T ( \frac{ n
}{ 4 } ) + T ( n - 1 ) )
\end{aligned}
\]</span></p>
<p>我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T ( n ) \leq cn \log
n\)</span>,考虑使用数学归纳法,则:</p>
<p><span class="math display">\[
\begin{aligned}
T ( n ) &amp; \leq n + \frac{ 1 }{ 2 } ( \frac{ 3 cn }{ 4 } \log (
\frac{ 3 n }{ 4 } ) + \frac{ cn }{ 4 } \log ( \frac{ n }{ 4 } ) + c ( n
- 1 ) \log ( n - 1 ) ) \\
&amp; \leq n + c ( \frac{ 3 n }{ 8 } \log n - \frac{ 3 n }{ 8 } \log
\frac{ 4 }{ 3 } + \frac{ n }{ 8 } \log n - \frac{ n }{ 4 } + \frac{ n }{
2 } \log n ) \\
&amp; = cn \log n + n ( 1 - \frac{ 3 c }{ 8 } \log ( \frac{ 4 }{ 3 } ) -
\frac{ c }{ 4 } )
\end{aligned}
\]</span></p>
<p>于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O ( f ( n ) )\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则:</p>
<p><span class="math display">\[
\begin{aligned}
k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^{ i - 1 } i \\
( 1 - p ) k &amp; = \sum_{ i = 1 }^{ \infty } p ( 1 - p )^i i \\
pk &amp; = \sum_{ i = 2 }^{ \infty } p ( 1 - p )^{ i - 1 } = p \sum_{ i
= 0 }^{ \infty } ( 1 - p )^i \\
k &amp; = \frac{ 1 }{ p }
\end{aligned}
\]</span></p>
<p>则期望复杂度为<span class="math inline">\(O ( \frac{ f ( n ) }{ p }
)\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([ x_1 , x_2 )\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1 \times 2 \leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{ 1 }{ 2 }\)</span>),而此时的<span class="math inline">\([ x_1 , x_2
)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1 , 2 , 4 , . .
.\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式:</p>
<p><span class="math display">\[
P = \begin{cases}
1 &amp; E_{ t + 1 } &gt; E_t \\
e^{ \frac{ E_{ t + 1 } - E_t }{ T } } &amp; E_{ t + 1 } \leq E_t
\end{cases}
\]</span></p>
<p>具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k
\in ( 0 , 1 )\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T = kT\)</span>,直到其小于终止温度.</p>
<h3><span id="数据随机下的性质">数据随机下的性质</span></h3>
<h4><span id="树">树</span></h4>
<ol type="1">
<li><p>随机树树高为<span class="math inline">\(\sqrt{ n
}\)</span>.</p></li>
<li><p>点的度数期望为<span class="math inline">\(\log
n\)</span>.</p></li>
</ol>
<h4><span id="数">数</span></h4>
<ol type="1">
<li>数字的期望因数个数为<span class="math inline">\(\log
V\)</span>.</li>
</ol>
<h4><span id="序列">序列</span></h4>
<ol type="1">
<li>随机序列的LIS长度期望为<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">概率与期望</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-26 09:23:52" itemprop="dateModified" datetime="2025-12-26T09:23:52+08:00">2025-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间<span class="math inline">\(\Omega\)</span>:在一个给定问题中可能发生的所有情况.</p>
<p>事件:<span class="math inline">\(\Omega\)</span>的一个子集.</p>
<p>基本事件<span class="math inline">\(\omega\)</span>:<span class="math inline">\(\Omega\)</span>中的单个元素,也可以看作集合大小为<span class="math inline">\(1\)</span>的事件.</p>
<p>概率:若<span class="math inline">\(\omega \in
\Omega\)</span>,我们称它发生的概率为<span class="math inline">\(\Pr (
\omega )\)</span>,有<span class="math inline">\(\Pr ( \omega ) \geq
0\)</span>且<span class="math inline">\(\sum_{ \omega \in \Omega } \Pr (
\omega ) = 1\)</span>.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>定义在同一个概率空间<span class="math inline">\(\Omega\)</span>上,对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,我们称<span class="math inline">\(\Pr (
X = x \land Y = y )\)</span>为它们的联合分布.</p>
<p>独立:如果对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,<span class="math inline">\(\Pr ( X = x
\land Y = y ) = \Pr ( X = x ) \times \Pr ( Y = y )\)</span>,我们称<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是独立的.</p>
<p>期望(均值)<span class="math inline">\(E
X\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的期望<span class="math inline">\(EX =
\sum_{ x \in X ( \Omega ) } x \times \Pr ( X = x ) = \sum_{ w \in \Omega
} X ( \omega ) \Pr ( \omega )\)</span>.</p>
<p>中位数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的中位数为满足<span class="math inline">\(\Pr ( X \leq x ) \geq 0 . 5 \land \Pr ( X \geq x )
\geq 0 . 5\)</span>的<span class="math inline">\(x \in X ( \Omega
)\)</span>所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的众数为满足<span class="math inline">\(\Pr ( X = x ) \geq \Pr ( X = x &#39; ) , \forall x
&#39; \in X ( \Omega )\)</span>的<span class="math inline">\(x \in X (
\Omega )\)</span>所组成的集合.</p>
<p>方差<span class="math inline">\(VX\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的方差<span class="math inline">\(VX = E
( ( X - EX )^2 )\)</span>.</p>
<p>标准差<span class="math inline">\(\sigma\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的标准差<span class="math inline">\(\sigma = \sqrt{ VX }\)</span>.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果<span class="math inline">\(X ,
Y\)</span>是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><p><span class="math inline">\(E ( X + Y ) = EX +
EY\)</span>.</p></li>
<li><p><span class="math inline">\(E ( \alpha X ) = \alpha
EX\)</span>.</p></li>
<li><p>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>互相独立,那么<span class="math inline">\(E ( XY ) = ( EX ) ( EY )\)</span>.</p></li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<p>此外(3)的逆命题不成立.考虑取<span class="math inline">\(X\)</span>分别以<span class="math inline">\(\frac{1}{2}\)</span>的概率选取<span class="math inline">\(-1\)</span>和<span class="math inline">\(1\)</span>,取<span class="math inline">\(Y=X^2\)</span>,则<span class="math inline">\(E(X)=E(XY)=0\)</span>.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X - EX )^2 ) &amp; = E ( X^2 - 2 X ( EX ) + ( EX )^2 ) \\
&amp; = E ( X^2 ) - 2 ( EX ) ( EX ) + ( EX )^2 \\
&amp; = E ( X^2 ) - ( EX )^2
\end{aligned}
\]</span></p>
<p>也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为独立的随机变量时,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( ( X + Y )^2 ) - ( EX + EY )^2 \\
&amp; = E ( ( X + Y )^2 ) - ( EX )^2 - 2 ( EX ) ( EY ) - ( EY )^2
\end{aligned}
\]</span></p>
<p>而又有:</p>
<p><span class="math display">\[
\begin{aligned}
E ( ( X + Y )^2 ) &amp; = E ( X^2 + 2 XY + Y^2 ) \\
&amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 )
\end{aligned}
\]</span></p>
<p>则:</p>
<p><span class="math display">\[
\begin{aligned}
V ( X + Y ) &amp; = E ( X^2 ) + 2 ( EX ) ( EY ) + E ( Y^2 ) - ( EX )^2 -
2 ( EX ) ( EY ) - ( EY )^2 \\
&amp; = VX + VY
\end{aligned}
\]</span></p>
<p>即:独立随机变量之和的方差等于它们的方差之和.此外显然也有<span class="math inline">\(\mathrm{Var}(X-Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)\)</span>.</p>
<p>事实上,容易见到可以定义协方差<span class="math inline">\(\mathrm{Cov}(X,Y)=E(XY)-E(X)E(Y)\)</span>.容易见到以下性质:</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{Cov}(X,X)=\mathrm{Var}(X)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(X_1+X_2,Y)=\mathrm{Cov}(X_1,Y)+\mathrm{Cov}(X_2,Y)\)</span>.</li>
<li>若<span class="math inline">\(X,Y\)</span>相互独立,则<span class="math inline">\(\mathrm{Cov}(X,Y)=0\)</span>.然而逆命题不成立.</li>
<li><span class="math inline">\(\mathrm{Var}(\sum_{i}X_i)=\sum_{i}\sum_j\mathrm{Cov}(X_i,X_j)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Var}(X+Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)+2\mathrm{Cov}(X,Y)\)</span>.</li>
</ol>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了<span class="math inline">\(n\)</span>个值<span class="math inline">\(X_1 , X_2 , . . . ,
X_n\)</span>,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p><span class="math inline">\(\hat EX = \cfrac{ \sum_{ i = 1 }^n X_i }{
n }\)</span>.</p>
<p><span class="math inline">\(\hat VX = \cfrac{ \sum_{ i = 1 }^n X_i^2
}{ n - 1 } - \cfrac{ ( \sum_{ i = 1 }^n X_i )^2 }{ n ( n - 1 )
}\)</span>.</p>
<p>这里的<span class="math inline">\(\hat
VX\)</span>似乎与定义不是那么相符.但是它拥有更好的性质:<span class="math inline">\(E ( \hat VX ) = VX\)</span>.</p>
<p>证明如下:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \hat VX ) &amp; = \cfrac{ 1 }{ n - 1 } E ( \sum_{ i = 1 }^n X_i^2 -
\cfrac{ 1 }{ n } \sum_{ j = 1 }^n \sum_{ k = 1 }^n X_j X_k ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X_i^2 ) - \cfrac{ 1
}{ n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n E ( X_i X_j ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( \sum_{ i = 1 }^n E ( X^2 ) - \cfrac{ 1 }{
n } \sum_{ i = 1 }^n \sum_{ j = 1 }^n ( ( EX )^2 [ j \ne k ] + E ( X^2 )
[ j = k ] ) ) \\
&amp; = \cfrac{ 1 }{ n - 1 } ( nE ( X^2 ) - \cfrac{ 1 }{ n } ( nE ( X^2
) + n ( n - 1 ) ( EX )^2 ) ) \\
&amp; = E ( X^2 ) - ( EX )^2 \\
&amp; = VX
\end{aligned}
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为<span class="math inline">\(P ( A | B
) = \frac{ P ( AB ) }{ P ( B ) } \\\)</span>.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有<span class="math inline">\(\{ B_i
\}\)</span>是样本空间的一个划分,即<span class="math inline">\(\forall i
, j\)</span>,有<span class="math inline">\(B_i \cap B_j =
\emptyset\)</span>,并且有<span class="math inline">\(\bigcup_{ i = 1 }^n
B_i = \Omega\)</span>.则有<span class="math inline">\(P ( B_i | A ) =
\frac{ P ( AB_i ) }{ P ( A ) } = \frac{ P ( AB_i ) }{ P ( A ) \sum P (
B_j ) } = \frac{ P ( A B_i ) }{ \sum_{ j = 1 }^n P ( A B_j ) } = \frac{
P ( A | B_i ) P ( B_i ) }{ \sum_{ j = 1 }^n P ( A | B_j ) P ( B_j ) }
\\\)</span>.</p>
<p>简化形式:<span class="math inline">\(P ( B | A ) = \frac{ P ( A | B )
P ( B ) }{ P ( A ) } \\\)</span>.</p>
<p>另外,我们考虑设<span class="math inline">\(O ( B ) = \cfrac{ P ( B )
}{ P ( \lnot B ) }\)</span>,称<span class="math inline">\(\cfrac{ P ( B
| E ) }{ P ( \lnot B | E ) }\)</span>为贝叶斯算子,则同理可得:</p>
<p><span class="math display">\[
O ( B | E ) = O ( B ) \cfrac{ P ( B | E ) }{ P ( \lnot B | E ) }
\]</span></p>
<p>这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果<span class="math inline">\(X\)</span>是定义在概率空间<span class="math inline">\(\Omega\)</span>上的随机变量,那么它的概率生成函数为<span class="math inline">\(G_X ( z ) = \sum_{ k \geq 0 } \Pr ( X = k ) z^k =
E ( z^X )\)</span>.</p>
<p>不难发现<span class="math inline">\(G_X ( z
)\)</span>需要满足的条件:所有系数都非负并且<span class="math inline">\(G_X ( 1 ) = 1\)</span>.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = G_X &#39; ( 1 ) \\
E ( X^2 ) &amp; = G &#39; &#39;_X ( 1 ) + G_X &#39; ( 1 ) \\
VX &amp; = G_X &#39; &#39; ( 1 ) + G_X &#39; ( 1 ) - ( G_X &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G ) &amp; = G &#39; ( 1 ) \\
Var ( G ) &amp; = G &#39; &#39; ( 1 ) + G &#39; ( 1 ) - ( G &#39; ( 1 )
)^2
\end{aligned}
\]</span></p>
<p>不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:</p>
<p><span class="math display">\[
G ( 1 + t ) = \sum_{ i \geq 0 } \cfrac{ G^{ ( i ) } ( 1 ) }{ i ! } t^i
\]</span></p>
<p>另外,我们不难发现:<span class="math inline">\(G_{ X + Y } ( z ) = G_X
( z ) G_Y ( z )\)</span>.</p>
<p>根据前面的推导,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_{ X + Y } ) &amp; = Mean ( G_X ) + Mean ( G_Y ) \\
Var ( G_{ X + Y } ) &amp; = Var ( G_X ) + Var ( G_Y )
\end{aligned}
\]</span></p>
<p>换句话说,若<span class="math inline">\(G_X ( 1 ) = 1 , G_Y ( 1 ) =
1\)</span>,那么这个式子与直接对<span class="math inline">\(G_{ X + Y
}\)</span>使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则:</p>
<p><span class="math display">\[
\begin{aligned}
Mean ( G_X ) &amp; = Mean ( G_{ X + Y } ) - Mean ( G_Y ) \\
Var ( G_X ) &amp; = Var ( G_{ X + Y } ) - Var ( G_Y )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为<span class="math inline">\(p\)</span>,反面向上的概率为<span class="math inline">\(q\)</span>,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设<span class="math inline">\(N\)</span>为所有不包含THTTH的硬币序列的生成函数,<span class="math inline">\(S\)</span>为所有只有结尾为THTTH的硬币序列的生成函数,令<span class="math inline">\(H = pz , T = qz\)</span>,<span class="math inline">\(1\)</span>为空集,我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N \times ( H + T ) &amp; = N + S \\
N \times THTTH &amp; = S + S \times TTH
\end{aligned}
\]</span></p>
<p>解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设<span class="math inline">\(A\)</span>是我们要找到的字符串,<span class="math inline">\(m\)</span>是它的长度,令<span class="math inline">\(A^{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的前<span class="math inline">\(k\)</span>个字符所组成的字符串,<span class="math inline">\(A_{ ( k ) }\)</span>表示<span class="math inline">\(A\)</span>字符串的后<span class="math inline">\(k\)</span>个字符所组成的字符串.这样的形式与<span class="math inline">\(k\)</span>阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S \\
N \times A &amp; = S ( \sum_{ k = 0 }^{ m - 1 } A^{ ( k ) } [ A^{ ( m -
k ) } = A_{ ( m - k ) } ] )
\end{aligned}
\]</span></p>
<p>如果我们设<span class="math inline">\(\tilde{ A
}\)</span>为将字符串<span class="math inline">\(A\)</span>中的H替换成<span class="math inline">\(\cfrac{ 1 }{ p } z\)</span>,T替换成<span class="math inline">\(\cfrac{ 1 }{ q }
z\)</span>之后的值,那么显然有:</p>
<p><span class="math display">\[
\begin{aligned}
N \times A &amp; = A \times S \times ( \sum_{ k = 1 }^{ m } \tilde{ A
}_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
N &amp; = S \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ (
k ) } = A_{ ( k ) } ] ) \\
\cfrac{ S - 1 }{ H + T - 1 } &amp; = S \times ( \sum_{ k = 1 }^{ m }
\tilde{ A }_{ ( k ) } [ A^{ ( k ) } = A_{ ( k ) } ] ) \\
S \times ( 1 + ( 1 - H - T ) \times ( \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } &amp; = A_{ ( k ) } ] ) ) = 1
\end{aligned}
\]</span></p>
<p>这显然是一个卷积的形式.</p>
<p>令<span class="math inline">\(w = \sum_{ k = 1 }^{ m } \tilde{ A }_{
( k ) } [ A^{ ( k ) } = A_{ ( k ) } ]\)</span>.</p>
<p>令<span class="math inline">\(H ( z ) = 1\)</span>,<span class="math inline">\(F ( z ) = ( 1 + ( 1 - z ) \times w
)\)</span>,<span class="math inline">\(G ( z ) = S\)</span>.</p>
<p>那么我们显然可以直接求<span class="math inline">\(G ( z
)\)</span>的期望和方差,事实上:</p>
<p><span class="math display">\[
\begin{aligned}
EX &amp; = \sum_{ k = 1 }^{ m } \tilde{ A }_{ ( k ) } [ A^{ ( k ) } =
A_{ ( k ) } ] \\
VX &amp; = ( EX )^2 - \sum_{ k = 1 }^m ( 2 k - 1 ) \tilde{ A }_{ ( k ) }
[ A^{ ( k ) } = A_{ ( k ) } ]
\end{aligned}
\]</span></p>
<p>如果硬币是均匀的(<span class="math inline">\(p = q = \cfrac{ 1 }{ 2
}\)</span>)我们引入另一个符号:我们设<span class="math inline">\(A : A =
\sum_{ k = 1 }^m 2^{ k } [ A^{ ( k ) } = A_{ ( k ) }
]\)</span>.那么显然期望需要的抛硬币次数就是<span class="math inline">\((
A : A )\)</span>.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设<span class="math inline">\(S_A\)</span>为所有以HHT结尾的硬币序列的生成函数,设<span class="math inline">\(S_B\)</span>为所有以HTT结尾的硬币序列的生成函数.<span class="math inline">\(N\)</span>为其它的硬币序列的生成函数,令<span class="math inline">\(H = T = 0 . 5 z\)</span>.</p>
<p>我们显然有:</p>
<p><span class="math display">\[
\begin{aligned}
1 + N ( H + T ) &amp; = N + S_A + S_B \\
N \times HHT &amp; = S_A \\
N \times HTT &amp; = S_A \times T + S_B
\end{aligned}
\]</span></p>
<p>解方程并带入<span class="math inline">\(z =
1\)</span>,可以有得知以HHT结尾的概率为<span class="math inline">\(\cfrac{ 2 }{ 3 }\)</span>.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,那么可以求出:</p>
<p><span class="math display">\[
\cfrac{ S_A }{ S_B } = \cfrac{ B : B - B : A }{ A : A - A : B }
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{ k , i }\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F , G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><p><span class="math inline">\(1 + xG ( x ) = \sum_k F_k ( x ) + G (
x )\)</span>.</p></li>
<li><p><span class="math inline">\(( \frac{ 1 }{ 2 } x )^L G ( x ) =
\sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 } ( \frac{ 1 }{ 2 } x
)^i [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i ) } ]\)</span>.</p></li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x =
1\)</span>,发现<span class="math inline">\(\sum_{ k } F_k ( 1 ) =
1\)</span>.</p>
<p>把(2)化简一下,有:</p>
<p><span class="math display">\[
\begin{aligned}
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 0 }^{ L - 1 }
( \frac{ 1 }{ 2 } x )^{ i - L } [ A_k^{ ( L - i ) } ={ A_j }_{ ( L - i )
} ] \\
x^L G ( x ) &amp; = \sum_{ j = 1 }^n F_j ( x ) \sum_{ i = 1 }^{ L } (
\frac{ 1 }{ 2 } x )^{ - i } [ A_k^{ ( i ) } ={ A_j }_{ ( i ) } ]
\end{aligned}
\]</span></p>
<p>带入<span class="math inline">\(x = 1\)</span>,有:</p>
<p><span class="math display">\[
G ( 1 ) = \sum_{ j = 1 }^n F_j ( 1 ) \sum_{ i = 1 }^{ L } 2^i [ A_k^{ (
i ) } ={ A_j }_{ ( i ) } ]
\]</span></p>
<p>不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n + 1\)</span>个等式,可以算出<span class="math inline">\(G ( 1 ) , F_{ 1 \cdots n } ( 1 )\)</span>这<span class="math inline">\(n + 1\)</span>个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为<span class="math inline">\(n +
1\)</span>的概率空间,其中<span class="math inline">\(\Pr ( \omega_k ) =
\binom{ n }{ k } p^k q^{ n - k }
\\\)</span>,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令<span class="math inline">\(H ( z ) = q +
pz\)</span>,不难发现二项式分布的生成函数为<span class="math inline">\(H
( z )^n\)</span>.</p>
<p>不难发现,满足二项式分布的随机变量的均值是<span class="math inline">\(np\)</span>,方差是<span class="math inline">\(npq\)</span>.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:<span class="math inline">\(G ( z )^n = ( \cfrac{ p }{ 1 - qz } )^n = \sum_{ k
} \binom{ n + k - 1 }{ k } p^n q^k z^k\)</span>.</p>
<p>我们考虑如何求<span class="math inline">\(G ( z
)\)</span>的方差和均值,不妨设<span class="math inline">\(F ( z ) =
\cfrac{ 1 - qz }{ p } = \cfrac{ 1 }{ p } - \cfrac{ q }{ p }
z\)</span>,则<span class="math inline">\(G ( z )^n = F ( z )^{ - n
}\)</span>.</p>
<p>不难发现<span class="math inline">\(F ( z
)\)</span>满足二项式分布.也就是说,以<span class="math inline">\(( n , p
, q )\)</span>为参数的负二项式分布也就是以<span class="math inline">\((
- n , - \cfrac{ q }{ p } , \cfrac{ 1 }{ p }
)\)</span>为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为<span class="math inline">\(1\)</span>的<span class="math inline">\(n\)</span>个点的树,问所有点对<span class="math inline">\(( i , j ) ( 1 \leq i , j \leq n
)\)</span>中,从<span class="math inline">\(i\)</span>走到<span class="math inline">\(j\)</span>的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设<span class="math inline">\(f_u\)</span>表示<span class="math inline">\(u\)</span>随机走到它父亲的期望,<span class="math inline">\(g_v\)</span>表示<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的期望.</p>
<p>对于<span class="math inline">\(f_u\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ \sum_{ u \rightarrow v } ( f_v + f_u ) }{ \deg_u } +
1 \\
f_u &amp; = \deg_u + \sum_{ u \rightarrow v } f_v
\end{aligned}
\]</span></p>
<p>对于<span class="math inline">\(g_v\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
g_v &amp; = \cfrac{ g_u + g_v + \sum_{ u \rightarrow w , w \ne v } ( g_v
+ f_w ) }{ \deg_u } + 1 \\
g_v &amp; = g_u + \sum_{ u \rightarrow w , w \ne v } f_w + \deg_u
\end{aligned}
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵<span class="math inline">\(n\)</span>个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从<span class="math inline">\(1\)</span>号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案<span class="math inline">\(+ 1\)</span>.当走到度数为<span class="math inline">\(1\)</span>的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设<span class="math inline">\(f_u\)</span>表示以<span class="math inline">\(u\)</span>为起点的路径的期望长度,不难注意到<span class="math inline">\(f_{ leaf } = 1\)</span>且<span class="math inline">\(f_u = 1 + \cfrac{ 1 }{ \deg_u } \sum_{ u
\rightarrow v \lor v \rightarrow u }
f_v\)</span>.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得<span class="math inline">\(f_u = k_u f_{ fa } +
b_u\)</span>,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出<span class="math inline">\(g_v\)</span>表示从<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的概率,再令<span class="math inline">\(f_u\)</span>表示从<span class="math inline">\(u\)</span>走到父亲的概率,类似Example1,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
f_u &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + \sum_{ u \rightarrow v } f_v f_u
) \\
g_v &amp; = \cfrac{ 1 }{ \deg_u } ( 1 + g_v g_u + \sum_{ u \rightarrow w
, w \ne v } f_w g_v )
\end{aligned}
\]</span></p>
<p>最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为<span class="math inline">\(\frac{ 1 }{ \binom{ n }{ 2 } }\)</span>.</p>
<p>把所有人权值从大到小排序,设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>个人的时候的期望,不难发现:<span class="math inline">\(f_{ i } = \frac{ 1 }{ \binom{ i }{ 2 } } v_i + ( 1
- \frac{ 1 }{ \binom{ i }{ 2 } } ) f_{ i - 1 }\)</span>.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设<span class="math inline">\(f_{ i , j }\)</span>表示过了<span class="math inline">\(i\)</span>关,花费为<span class="math inline">\(j\)</span>的期望,不难发现所有的<span class="math inline">\(f\)</span>都需要与<span class="math inline">\(f_{
0 , 0 }\)</span>取<span class="math inline">\(\min\)</span>,这咋办?</p>
<p>我们考虑二分这个<span class="math inline">\(f_{ 0 , 0
}\)</span>,做的时候直接取<span class="math inline">\(\min\)</span>,这样最后还会求出一个<span class="math inline">\(f_{ 0 , 0
}\)</span>,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的<span class="math inline">\(f_{ 0 , 0
}\)</span>越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取<span class="math inline">\(\min\)</span>的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张<span class="math inline">\(n \times
m\)</span>的图(假设<span class="math inline">\(n \geq
m\)</span>),其中格点<span class="math inline">\(( a , b
)\)</span>表示现在还剩<span class="math inline">\(a\)</span>个Yes,<span class="math inline">\(b\)</span>个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0
)\)</span>的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线<span class="math inline">\(y =
x\)</span>翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从<span class="math inline">\(( n , m )\)</span>走到<span class="math inline">\(( 0 , 0 )\)</span>一定会经过<span class="math inline">\(n\)</span>条有向边,所以期望贡献一定要加上一个<span class="math inline">\(n\)</span>.而如果我走到了直线<span class="math inline">\(y = x\)</span>上,那接下来的贡献是<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="一些不等式">一些不等式</span></h2>
<h3><span id="union-bound">Union Bound</span></h3>
<p>即:<span class="math inline">\(\mathbb{P} [ \bigcup_i X_i ] \leq \sum
\mathbb P [ X_i ]\)</span>,取等当且仅当所有<span class="math inline">\(X_i\)</span>互斥.</p>
<h3><span id="markov-不等式">Markov 不等式</span></h3>
<p>若<span class="math inline">\(X \geq 0\)</span>,则<span class="math inline">\(\mathbb{P} [ X \geq t \mathbb{ E } [ X ] ] \leq
\frac{ 1 }{ t }\)</span>.</p>
<p>显然,多的太多的话就会超过<span class="math inline">\(E\)</span>.</p>
<h3><span id="chebyshev-不等式">Chebyshev 不等式</span></h3>
<p>当<span class="math inline">\(\sigma(X)&gt;0\)</span>时,有 <span class="math display">\[
\mathbb{P}(|X-\mathbb{E}(X)|\geq c\sdot \sigma(X))\leq \frac{1}{c^2}
\]</span> 证明的话直接考虑设<span class="math inline">\(Y=(X-\mathbb
E(X))^2\)</span>,用Markov不等式得到: <span class="math display">\[
\begin{aligned}
\mathbb{P}(Y\geq c^2\mathbb E(Y))&amp;\leq \frac{1}{c^2}\\
\mathbb{P}((X-\mathbb E(X))^2\geq c^2\sigma^2(X))&amp;\leq
\frac{1}{c^2}\\
\mathbb{P}|(X-\mathbb E(X)|\geq c\sigma(X))&amp;\leq \frac{1}{c^2}\\
\end{aligned}
\]</span></p>
<h2><span id="一些离散分布">一些离散分布</span></h2>
<h3><span id="泊松分布">泊松分布</span></h3>
<p>取二项分布的极限情况.设此时<span class="math inline">\(n=\lambda
m\)</span>,每个东西有<span class="math inline">\(\frac{1}{m}\)</span>的概率选入,则对于一个固定的常数<span class="math inline">\(k\)</span>,当<span class="math inline">\(m\to
\infty\)</span>的时候,<span class="math inline">\(P(X=k)=\frac{1}{k!}\lambda^k
e^{-\lambda}\)</span>,记作<span class="math inline">\(X\sim
\pi(\lambda)\)</span>.</p>
<p>欸,虽然我们这里只考虑了<span class="math inline">\(k\)</span>某种程度上远小于<span class="math inline">\(m\)</span>的存在,但好在大的部分也不会有什么太大影响,因此:
<span class="math display">\[
\sum_k P(X=k)=1
\]</span> 原因是<span class="math inline">\(e^{\lambda}=\sum_k
\frac{\lambda^k}{k!}\)</span>.</p>
<p>此时来看<span class="math inline">\(\mathbb
E(X)\)</span>,留神到无非是上面那个东西转移了一下子,因此<span class="math inline">\(\mathbb{E}(X)=\lambda\)</span>.</p>
<p>来看<span class="math inline">\(\mathbb{E}(X^2)\)</span>,自然有:
<span class="math display">\[
\begin{aligned}
&amp;\sum_k \frac{1}{k!}\lambda^k e^{-\lambda}k^2\\
=&amp;\sum_k \frac{1}{k!}\lambda^k e^{-\lambda}k(k-1)+\sum_k
\frac{1}{k!}\lambda^k e^{-\lambda}k\\
=&amp;\lambda^2+\lambda
\end{aligned}
\]</span> 所以<span class="math inline">\(\sigma^2(X)=\mathbb{E}(X^2)-(\mathbb
E(X))^2=\lambda\)</span>.</p>
<h3><span id="几何分布">几何分布</span></h3>
<p>伯努利试验中首次发生结果<span class="math inline">\(A\)</span>的次数,记作<span class="math inline">\(X\sim \text{G}(p)\)</span>.</p>
<p>显然<span class="math inline">\(P(X=k)=p(1-p)^{k-1}\)</span>,此外<span class="math inline">\(P(X&gt;n)=(1-p)^n\)</span>.</p>
<p>设<span class="math inline">\(f(p)=\sum_{k\geq
1}(1-p)^{k-1}\)</span>,则<span class="math inline">\(f(p)=\frac{1}{p}\)</span>,<span class="math inline">\(E(X)=-pf&#39;(p)=\frac{1}{p}\)</span>,<span class="math inline">\(\sigma^2(X)=\frac{1-p}{p^2}\)</span>.</p>
<p>很重要的一个性质是无记忆性.即<span class="math inline">\(P(X&gt;m+n|X&gt;m)=P(X&gt;n)\)</span>.</p>
<h3><span id="负二项分布">负二项分布</span></h3>
<p>伯努利实验中结果<span class="math inline">\(A\)</span>发生<span class="math inline">\(r\)</span>次的重复次数.则<span class="math inline">\(P(X=k)=\binom{k-1}{r-1}p^r(1-p)^{k-r}\)</span>,记作<span class="math inline">\(X\sim \text{NB}(r,p)\)</span>.显然<span class="math inline">\(\text{NB}(1,p)\sim
\text{G}(p)\)</span>.必然有<span class="math inline">\(E(X)=\frac{r}{p}\)</span>.</p>
<p>首先要验证: <span class="math display">\[
\begin{aligned}
\sum_{k\geq r}P(X=k)&amp;=\sum_{k\geq r}\binom{k-1}{r-1}p^r(1-p)^{k-r}\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{r-1}p^r(1-p)^l\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{l}p^r(1-p)^l
\end{aligned}
\]</span> 而: <span class="math display">\[
\begin{aligned}
p^{-r}&amp;=(1-(1-p))^{-r}\\
&amp;=\sum_{l\geq 0}\binom{-r}{l}(-1)^l(1-p)^{l}\\
&amp;=\sum_{l\geq 0}\binom{l+r-1}{l}(1-p)^l
\end{aligned}
\]</span></p>
<h2><span id="连续随机变量">连续随机变量</span></h2>
<p>给定随机变量<span class="math inline">\(X\)</span>和实数<span class="math inline">\(x\)</span>,定义<span class="math inline">\(F(x)=P(X\leq x)\)</span>为随机变量<span class="math inline">\(X\)</span>的<strong>分布函数</strong>.</p>
<p>分布函数有如下性质:</p>
<ol type="1">
<li><strong>有界性</strong>:<span class="math inline">\(0\leq F(x)\leq
1\)</span>,而且<span class="math inline">\(\lim_{x\to
-\infty}F(x)=0,\lim_{x\to +\infty}F(x)=1\)</span>.</li>
<li><strong>单调性</strong>:<span class="math inline">\(F(x)\)</span>单调不减.</li>
<li><strong>右连续</strong>:<span class="math inline">\(F(x_0+0)=F(x_0)\)</span>.</li>
</ol>
<p>如果存在一个<span class="math inline">\(f(x)\)</span>,使得<span class="math inline">\(F(x)=\int_{-\infty}^x
f(x)\mathrm{d}x\)</span>,则称<span class="math inline">\(X\)</span>是<strong>连续随机变量</strong>,而<span class="math inline">\(f(x)\)</span>是其概率密度函数.它还应当满足以下性质:</p>
<ol type="1">
<li><strong>非负性</strong>:<span class="math inline">\(f(x)\geq
0\)</span>.</li>
<li><strong>正则性</strong>:<span class="math inline">\(\int_{-\infty}^{+\infty}f(t)\mathrm{d}t=1\)</span>.</li>
</ol>
<p>对于连续随机变量.此时<span class="math inline">\(F\)</span>还满足左连续<span class="math inline">\(F(x_0-0)=F(x_0)\)</span>.</p>
<p>由此还可以得出连续随机变量在任何一点处取值必然为零,因为<span class="math inline">\(P(a\leq X\leq a)=P(a&lt;X&lt;a)=0\)</span>.</p>
<p>由此可以定义期望:当<span class="math inline">\(\int_{-\infty}^{+\infty}f(x)|x|\mathrm{d}x&lt;\infty\)</span>,则定义<span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)\mathrm{d}x\)</span>.注意这里要求的是绝对可积而不是可积.</p>
<p>现在我们来搞定:<span class="math inline">\(P(X\leq
E(X))&gt;0\)</span>.</p>
<p>策略是反证:如果<span class="math inline">\(P(X\leq
E(X))=0\)</span>.此时任取一个<span class="math inline">\(\epsilon&gt;0\)</span>使得<span class="math inline">\(P(X\leq E(X)+\epsilon)\leq
\frac{1}{2}\)</span>.</p>
<p>此时<span class="math inline">\(E(X)\geq P(X\geq
E(X)+\epsilon)(E(X)+\epsilon)+P(X&lt;
E(X)+\epsilon)E(X)&gt;E(X)\)</span>,这就矛盾了.</p>
<p>接下来来做Markov不等式,对于非负随机变量<span class="math inline">\(X\)</span>,若<span class="math inline">\(E(X)&gt;
0,a&gt;0\)</span>,则<span class="math inline">\(P(X\geq aE(X))\leq
\frac{1}{a}\)</span>.原因是: <span class="math display">\[
\begin{aligned}
E(X)&amp;=\int_{-\infty}^{+\infty}f(x)x\mathrm{d}x\\
&amp;\geq \int_{aE(X)}^{+\infty}f(x)x\mathrm{d}x\\
&amp;\geq \int_{aE(X)}^{+\infty}f(x)aE(X)\mathrm{d}x\\
&amp;=aE(X)\int_{aE(X)}^{+\infty}f(x)\mathrm{d}x\\
&amp;=aE(X)P(X\geq aE(X))
\end{aligned}
\]</span> 此时还可以定义<span class="math inline">\(\mathrm{Var}(X)=E((X-E(X))^2)=E(X^2)-E^2(X)\)</span>.</p>
<p>Chebyshev不等式的证明只依赖于Markov不等式,因此在这里也能用.</p>
<h3><span id="高斯分布">高斯分布</span></h3>
<p>概率密度函数<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span>.</p>
<p>除了上述已经提到的性质,它还满足:</p>
<ol type="1">
<li>对称性:<span class="math inline">\(f(x)=f(-x)\)</span>.</li>
<li><span class="math inline">\(f(x)_{\max}=f(0)\)</span>.</li>
<li><span class="math inline">\(\lim_{x\to -\infty}f(x)=\lim_{x\to
+\infty}f(x)=0\)</span>.</li>
<li><span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}f(x)x\mathrm{d}x=0\)</span>.</li>
<li><span class="math inline">\(E(X^2)=\int_{-\infty}^{+\infty}f(x)x^2\mathrm{d}x=1\)</span>.</li>
<li><span class="math inline">\(\mathrm{Var}(X)=1\)</span>.</li>
</ol>
<p>其中(5)的证明见: <span class="math display">\[
\begin{aligned}
\int_{-\infty}^{+\infty}f(x)x^2\mathrm{d}x&amp;=\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}x^2\mathrm{d}x\\
&amp;=\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}(-x)\mathrm{d}e^{-\frac{x^2}{2}}\\
&amp;=\frac{1}{\sqrt{2\pi}}(-x)e^{-\frac{x^2}{2}}|_{-\infty}^{+\infty}+\int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\mathrm{d}x\\
&amp;=1
\end{aligned}
\]</span> 还可以对此进行推广,考虑<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</span>,记<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.只需取<span class="math inline">\(y=\frac{x-\mu}{\sigma}\)</span>,就可以转换回标准正态分布,并且此时<span class="math inline">\(F_Y(y)=F_X(\sigma y+\mu)\)</span>.</p>
<h3><span id="指数分布">指数分布</span></h3>
<p>对于<span class="math inline">\(\lambda&gt;0\)</span>,定义概率密度函数<span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;x\geq
0\\0&amp;x&lt;0\end{cases}\)</span>,记作<span class="math inline">\(X\sim
\mathrm{EXP}(\lambda)\)</span>.其分布函数<span class="math inline">\(F(X)=\begin{cases}1-e^{-\lambda
x}&amp;X&gt;0\\0&amp;X\leq 0\end{cases}\)</span>.</p>
<p>它同样也有无记忆性.考虑<span class="math inline">\(P(X&gt;t)=e^{-\lambda t}\)</span>,从而<span class="math inline">\(P(X&gt;s+t|X&gt;s)=P(X&gt;t)\)</span>.</p>
<h3><span id="伽马分布">伽马分布</span></h3>
<p>对于<span class="math inline">\(\alpha&gt;0\)</span>,定义伽马函数<span class="math inline">\(\Gamma(\alpha)=\int_0^{+\infty}x^{\alpha-1}e^{-x}\mathrm{d}x\)</span>.我们见过很多次这个东西了,请看:</p>
<ol type="1">
<li><span class="math inline">\(\Gamma(1)=1\)</span>.</li>
<li><span class="math inline">\(\Gamma(\frac{1}{2})=\sqrt{\pi}\)</span>.</li>
<li><span class="math inline">\(\Gamma(\alpha+1)=\alpha\Gamma(\alpha)\)</span>.</li>
<li><span class="math inline">\(\Gamma(n+1)=n!\)</span>.</li>
<li><span class="math inline">\(\Gamma(n+\frac{1}{2})=\frac{(2n)!}{4^nn!}\sqrt
\pi\)</span>.</li>
</ol>
<p>对于<span class="math inline">\(\lambda,\alpha&gt;0\)</span>,定义概率密度函数<span class="math inline">\(f(x)=\begin{cases}\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda
x}&amp;x\geq 0\\0&amp;x&lt;0\end{cases}\)</span>,称此时<span class="math inline">\(x\)</span>符合伽马分布,记作<span class="math inline">\(X\sim \Gamma(\alpha,\lambda)\)</span>.</p>
<p>先把正则性验证了吧,令<span class="math inline">\(y=\lambda
x\)</span>,则<span class="math inline">\(f(x)=\frac{\lambda}{\Gamma(\alpha)}y^{\alpha-1}e^{-y}\)</span>,则<span class="math inline">\(f(x)\mathrm{d}x=\frac{1}{\Gamma(\alpha)}y^{\alpha-1}e^{-y}\mathrm{d}y\)</span>,于是搞定了.</p>
<p>然后是其期望: <span class="math display">\[
\begin{aligned}
E(X)&amp;=\int_{0}^{+\infty}xf(x)\mathrm{d}x\\&amp;=\int_0^{+\infty}\frac{1}{\Gamma(\alpha)}y^{\alpha}e^{-y}\frac{\mathrm{d}y}{\lambda}\\
&amp;=\frac{\Gamma(\alpha+1)}{\Gamma(\alpha)\lambda}\\
&amp;=\frac{\alpha}{\lambda}
\end{aligned}
\]</span> 类似地,<span class="math inline">\(\int_0^{+\infty}x^2f(x)\mathrm{d}x=\frac{\Gamma(\alpha+2)}{\Gamma(\alpha)\lambda^2}\)</span>,从而算出<span class="math inline">\(\mathrm{Var}(X)=\frac{\alpha}{\lambda^2}\)</span>.显然当<span class="math inline">\(X\sim \Gamma(\alpha,\lambda)\)</span>时，<span class="math inline">\(Y=kX\sim
\Gamma(\alpha,\frac{\lambda}{k})\)</span>.</p>
<p>当<span class="math inline">\(\alpha=1\)</span>的时候,我们得到了指数分布<span class="math inline">\(\Gamma(1,\lambda)\sim
\mathrm{Exp}(\lambda)\)</span>.</p>
<p>另一个特例是,<span class="math inline">\(\alpha=\frac{n}{2},\lambda=\frac{1}{2}\)</span>.此时我们称其为自由度为<span class="math inline">\(n\)</span>的卡方<span class="math inline">\(\chi^2\)</span>分布.记作<span class="math inline">\(\chi^2(n)\)</span>,其数学期望为<span class="math inline">\(n\)</span>,方差为<span class="math inline">\(2n\)</span>.当<span class="math inline">\(n=1\)</span>的时候,<span class="math inline">\(f(x)=\sqrt \frac{1}{2\pi
x}e^{-\frac{x}{2}}\)</span>.</p>
<h2><span id="多维离散随机变量">多维离散随机变量</span></h2>
<h3><span id="重期望公式">重期望公式</span></h3>
<p>考虑把<span class="math inline">\(E(X|Y)\)</span>视作一个<span class="math inline">\(g(Y)\)</span>,则<span class="math inline">\(E(E(X|Y))=E(X)\)</span>.原因是<span class="math inline">\(E(E(X|Y))=\sum_j P(Y=y_j)E(X|Y=y_j)\)</span>.</p>
<h2><span id="多维连续随机变量">多维连续随机变量</span></h2>
<p>设<span class="math inline">\(F(x,y)=P(X\leq x\land Y\leq
y)\)</span>.应该有:</p>
<p><strong>联合分布函数</strong>有如下性质:</p>
<ol type="1">
<li><strong>有界性</strong>:<span class="math inline">\(0\leq F(x,y)\leq
1\)</span>,而且<span class="math inline">\(\lim_{x\to
-\infty}F(x,y)=\lim_{y\to -\infty}F(x,y)=0,\lim_{x,y\to
+\infty}F(x,y)=1\)</span>.</li>
<li><strong>单调性</strong>:当<span class="math inline">\(x_1\leq
x_2\)</span>时,<span class="math inline">\(F(x_1,y)\leq
F(x_2,y)\)</span>;当<span class="math inline">\(y_1\leq
y_2\)</span>时,<span class="math inline">\(F(x,y_1)\leq
F(x,y_2)\)</span>.</li>
<li><strong>右连续</strong>:<span class="math inline">\(F(x_0+0,y)=F(x_0,y)\)</span>,<span class="math inline">\(F(x,y_0+0)=F(x,y_0)\)</span>.</li>
<li><strong>非负性</strong>:<span class="math inline">\(P(a&lt;X\leq
b,c&lt;Y\leq d)=F(b,d)-F(a,d)-F(b,c)+F(a,c)\geq 0\)</span>.</li>
</ol>
<p>当<span class="math inline">\(F\)</span>连续时,如果能找到函数<span class="math inline">\(f\geq 0\)</span>满足<span class="math inline">\(F(x,y)=\int_{-\infty}^x\int_{-\infty}^y
f(u,v)\mathrm{d}v\mathrm{d}u\)</span>,称<span class="math inline">\(f\)</span>为<strong>联合密度函数</strong>.</p>
接下来来看条件分布函数和条件密度函数,当概率密度函数的确连续时,定义: $$
<span class="math display">\[\begin{aligned}
P(X\leq x|Y=y)&amp;=\lim_{\Delta\to +0}P(X\leq x|y\leq Y\leq y+\Delta)\\
&amp;=\lim_{\Delta\to
+0}\cfrac{\int_{-\infty}^x\int_{y}^{y+\Delta}f(u,v)\mathrm{d}v\mathrm{d}u}{\int_{y}^{y+\Delta}f_Y(v)\mathrm{d}v}\\
&amp;=\lim_{\Delta\to
+0}\cfrac{\int_{-\infty}^x(\frac{1}{\Delta}\int_{y}^{y+\Delta}f(u,v)\mathrm{d}v)\mathrm{d}u}{\frac{1}{\Delta}\int_{y}^{y+\Delta}f_Y(v)\mathrm{d}v}\\
&amp;=\cfrac{\int_{-\infty}^xf(u,y)\mathrm{d}u}{f_Y(y)}\\
&amp;=\int_{-\infty}^x\cfrac{f(u,y)}{f_Y(y)}\mathrm{d}u\\

\end{aligned}\]</span>
<p>$$ 其中<span class="math inline">\(f_Y(y)=\int_{-\infty}^{+\infty}f(u,y)\mathrm{d}u\)</span>.</p>
<p>当<span class="math inline">\(\forall x,y\)</span>都有<span class="math inline">\(f(x,y)=f_X(x)f_Y(y)\)</span>,则称<span class="math inline">\(X,Y\)</span>相互独立.</p>
<p>容易检验<span class="math inline">\(E(X+Y)=E(X)+E(Y)\)</span>,而且当<span class="math inline">\(X,Y\)</span>相互独立的时候,<span class="math inline">\(E(XY)=E(X)E(Y)\)</span>,于是自然也有<span class="math inline">\(\mathrm{Var}(X\pm
Y)=\mathrm{Var}(X)+\mathrm{Var}(Y)\)</span>.</p>
<h3><span id="二维正态分布">二维正态分布</span></h3>
<p>即: <span class="math display">\[
f(x,y)=\frac{\exp(-\frac{1}{2(1-\rho^2)}\left(\frac{(x-\mu_1)^2}{\sigma_1^2}+\frac{(y-\mu_2)^2}{\sigma_2^2}-\frac{2\rho(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}\right))}{2\pi
\sigma_1\sigma_2\sqrt{1-\rho^2}}
\]</span> 现在来验证正则性,取<span class="math inline">\(u=\frac{\frac{x-\mu_1}{\sigma_1}-\rho
\frac{y-\mu_2}{\sigma_2}}{\sqrt{1-\rho^2}},v=\frac{y-\mu_2}{\sigma_2}\)</span>.而<span class="math inline">\(\left|\frac{\partial(u,v)}{\partial(x,y)}\right|=\sigma_1\sigma_2\sqrt{1-\rho^2}\)</span>​.于是:
<span class="math display">\[
\begin{aligned}
&amp;\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}x\mathrm{d}y\\
=&amp;\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)\mathrm{d}u\mathrm{d}v\\
=&amp;1
\end{aligned}
\]</span> 此外请看: <span class="math display">\[
\begin{aligned}
f_X(x)&amp;=\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}y\\
&amp;=\sigma_2\sqrt{1-\rho^2}\int_{-\infty}^{+\infty}f(x,y)\mathrm{d}u\\
&amp;=\frac{1}{\sigma_1\sqrt{2\pi}}\exp\left(-\frac{(x-\mu_1)^2}{2\sigma_1^2}\right)
\end{aligned}
\]</span> 于是当<span class="math inline">\(X,Y\sim
N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)\)</span>,则<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2),Y\sim
N(\mu_2,\sigma_2^2)\)</span>.</p>
<p>此外: <span class="math display">\[
\begin{aligned}
f(x|y)&amp;=\frac{f(x,y)}{f_Y(y)}\\
&amp;=\frac{1}{\sigma_1\sqrt{2\pi}\sqrt{1-\rho^2}}\exp\left(-\frac{1}{2(1-\rho^2)}\left(\frac{x-\mu_1}{\sigma_1}-\rho\frac{y-\mu_2}{\sigma_2}\right)^2\right)
\end{aligned}
\]</span> 也就是说,当<span class="math inline">\(Y=y\)</span>时,<span class="math inline">\(X\sim
N(\mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2),\sigma_1^2(1-\rho^2))\)</span>,容易见到相互独立当且仅当<span class="math inline">\(\rho=0\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(n\times n\)</span>的矩阵<span class="math inline">\(A\)</span>中每个元素独立服从<span class="math inline">\(N(0,1)\)</span>.求<span class="math inline">\(E(\det
A),E(\mathrm{trace}(A)),E(\mathrm{trace}(A^2))\)</span>.</p>
<p>考虑<span class="math inline">\(\det
A=\sum_{\sigma}\mathrm{sgn}(\sigma)\prod
A_{i,\sigma(i)}\)</span>.直接套期望就知道<span class="math inline">\(E(\det A)=0\)</span>.</p>
<p>显然<span class="math inline">\(E(\mathrm{trace}(A))=0\)</span>.</p>
<p>而<span class="math inline">\(E(\mathrm{trace}(A^2))\)</span>中,每一个<span class="math inline">\((A^2)_{i,i}=\sum_{j}E(a_{i,j}a_{j,i})=1\)</span>,于是<span class="math inline">\(E(\mathrm{trace}(A^2))=n\)</span>.</p>
<h3><span id="重期望公式">重期望公式</span></h3>
<p>定义<span class="math inline">\(E(X|Y=y)=\int_{-\infty}^{+\infty}f(x|y)x\mathrm{d}x\)</span>.则<span class="math inline">\(E(E(X|Y))=E(X)\)</span>.</p>
<h3><span id="协方差">协方差</span></h3>
<p>和离散时的基本全部一样.其实早该看出来协方差就是一种双线性形式.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明二维正态分布的<span class="math inline">\(\mathrm{Cov}(X,Y)=\sigma_1\sigma_2\rho\)</span>.</p>
<p>容易见到: <span class="math display">\[
\begin{aligned}
\mathrm{Cov}(X,Y)&amp;=\int\int
f(x,y)(x-\mu_1)(y-\mu_2)\mathrm{d}x\mathrm{d}y\\
&amp;=\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)\sigma_1\sigma_2v(u\sqrt{1-\rho^2}+\rho
v)\mathrm{d}u\mathrm{d}v
\end{aligned}
\]</span> 然而: <span class="math display">\[
\begin{aligned}
\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)uv\mathrm{d}u\mathrm{d}v&amp;=0\\
\int\int\frac{1}{2\pi}\exp\left(-\frac{1}{2}(u^2+v^2)\right)v^2\mathrm{d}u\mathrm{d}v&amp;=1\\
\end{aligned}
\]</span> 带入得到结果.</p>
<h4><span id="相关系数">相关系数</span></h4>
<p>可以定义相关系数<span class="math inline">\(\mathrm{Corr}(X,Y)=\frac{\mathrm{Cov}(X,Y)}{\sigma(X)\sigma(Y)}\)</span>.一个很好玩的事是两个变量的任意线性变换<span class="math inline">\(X&#39;=aX+b\)</span>后,仍有: <span class="math display">\[
\begin{aligned}
\mathrm{Corr}(X&#39;,Y)=\frac{a\mathrm{Cov}(X,Y)}{|a|\sigma(X)\sigma(Y)}=\mathrm{sgn}(a)\frac{\mathrm{Cov}(X,Y)}{\sigma(X)\sigma(Y)}
\end{aligned}
\]</span> 一个显然结论是当标准化后即<span class="math inline">\(\tilde
X=\frac{X-E(X)}{\sigma(X)}\)</span>后相关系数不变.</p>
<p>此外,我们可以证明以下性质:</p>
<ol type="1">
<li><span class="math inline">\(|\mathrm{Corr}(X,Y)|\leq
1\)</span>.</li>
<li>如果<span class="math inline">\(|\mathrm{Corr}(X,Y)|=1\)</span>等价于<span class="math inline">\(Y,X\)</span>存在关系<span class="math inline">\(a\ne 0\)</span>使得<span class="math inline">\(P(Y=aX+b)=1\)</span>.</li>
</ol>
<p>(1)(2)其实就是柯西不等式对吧,因为<span class="math inline">\(\mathrm{Cov}\)</span>其实是某种内积,所以当然有<span class="math inline">\(\frac{\mathrm{Cov}(X,Y)}{\sqrt{\mathrm{Cov}(X,X)\mathrm{Cov}(Y,Y)}}\in
[-1,1]\)</span>.</p>
<h4><span id="协方差矩阵">协方差矩阵</span></h4>
<p>设随机变量<span class="math inline">\(X=(X_1,\cdots,X_n)\)</span>,定义<span class="math inline">\(E(X)=(E(X_1),\cdots,E(X_n))\)</span>为其<strong>数学期望向量</strong>,而<span class="math inline">\(\mathrm{Cov}(X)=E((X-E(X))(X-E(X))^t)\)</span>为<span class="math inline">\(X\)</span>的协方差矩阵.也就是<span class="math inline">\(\mathrm{Cov}(X)_{i,j}=\mathrm{Cov}(X_i,X_j)\)</span>.容易见到其半正定,原因是<span class="math inline">\(\alpha^t\mathrm{Cov}(X)\alpha=E((\alpha^t(X-E(X)))^2)\)</span>.</p>
<p>事实上应该总有<span class="math inline">\(\mathrm{Cov}(AX)=A\mathrm{Cov}(X)A^t\)</span>,原因是:
<span class="math display">\[
\mathrm{Cov}(AX)=E((AX-E[AX])(AX-E[AX])^t)
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>求二维正态分布的协方差矩阵.</p>
<p>显然为: <span class="math display">\[
B=\begin{bmatrix}
\sigma_1^2&amp;\rho\sigma_1\sigma_2\\
\rho\sigma_1\sigma_2&amp;\sigma_2^2
\end{bmatrix}
\]</span> 此外<span class="math inline">\(\det(B)=(1-\rho^2)\sigma_1^2\sigma_2^2\)</span>.其逆矩阵<span class="math inline">\(B^{-1}=\frac{1}{1-\rho^2}\begin{bmatrix}\frac{1}{\sigma_1^2}&amp;-\frac{\rho}{\sigma_1\sigma_2}\\-\frac{\rho}{\sigma_1\sigma_2}&amp;\frac{1}{\sigma_2^2}\end{bmatrix}\)</span>.</p>
<p>此时见到: <span class="math display">\[
\begin{aligned}
f(x_1,x_2)&amp;=\frac{\exp(-\frac{1}{2(1-\rho^2)}\left(\frac{(x_1-\mu_1)^2}{\sigma_1^2}+\frac{(x_2-\mu_2)^2}{\sigma_2^2}-\frac{2\rho(x_1-\mu_1)(x_2-\mu_2)}{\sigma_1\sigma_2}\right))}{2\pi
\sigma_1\sigma_2\sqrt{1-\rho^2}}\\
&amp;=\frac{1}{2\pi\sqrt {\det B}}\exp\left(-\frac{1}{2}(\vec x-\vec
\mu)^TB^{-1}(\vec x-\vec \mu)\right)
\end{aligned}
\]</span> 从而容易推广到任意多维,只需定义: <span class="math display">\[
\begin{aligned}
f(\vec x)
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
B}}\exp\left(-\frac{1}{2}(\vec x-\vec \mu)^TB^{-1}(\vec x-\vec
\mu)\right)
\end{aligned}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>求证:当<span class="math inline">\(\vec X\sim N(\vec
\mu,B)\)</span>,则<span class="math inline">\(\vec Y=A\vec X+\vec b\sim
N(A\vec \mu+\vec b,ABA^t)\)</span>,其中<span class="math inline">\(A\)</span>必须行满秩.</p>
<p>当<span class="math inline">\(A\)</span>是方阵的时候,直接可逆,于是:
<span class="math display">\[
\begin{aligned}
f_Y(y)&amp;=f_X(A^{-1}(y-b))|\frac{\partial x}{\partial y}|\\
&amp;=f_X(A^{-1}(y-b))|\frac{\partial y}{\partial x}|^{-1}\\
&amp;=f_X(A^{-1}(y-b))|\frac{1}{\det A}|\\
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
ABA^{t}}}\exp\left(-\frac{1}{2}(A^{-1}(\vec y-\vec b)-\vec
\mu)^TB^{-1}(A^{-1}(\vec y-\vec b)-\vec \mu)\right)\\
&amp;=\frac{1}{(2\pi)^{\frac{n}{2}}\sqrt {\det
ABA^{t}}}\exp\left(-\frac{1}{2}(\vec y-A\vec \mu-\vec
b)^T(ABA^{T})^{-1}(A^{-1}(\vec y-A\vec \mu-\vec b)\right)
\end{aligned}
\]</span>
此外,一般的多为高斯分布可以看作独立同分布标准正态分布线性变换后的结果,原因是当<span class="math inline">\(X\sim N(0,I),Y\sim N(\vec
\mu,B)\)</span>,当然有<span class="math inline">\(Y=B^{\frac{1}{2}}X+\vec \mu\)</span>.</p>
<p>特别地,把一个有一定信息关系的东西<span class="math inline">\(Y\)</span>变成<span class="math inline">\(X\)</span>也只需要<span class="math inline">\(X=B^{-\frac{1}{2}}(X-\vec \mu
)\)</span>,这个过程一般叫<strong>白化</strong>.因为信息被缩简单了.</p>
<p>然而,考虑如果<span class="math inline">\(X\sim
N(0,I)\)</span>,如果<span class="math inline">\(Y=AX\)</span>,此时<span class="math inline">\(Y\)</span>的结果似乎只和<span class="math inline">\(AA^t\)</span>有关,而与<span class="math inline">\(A\)</span>竟然无关.特别地,如果<span class="math inline">\(A\)</span>是一个正交矩阵,则<span class="math inline">\(Y\)</span>干脆和<span class="math inline">\(X\)</span>服从同样的分布.</p>
<p>这揭示了正态分布其实更关注于<strong>模长</strong>,换言之,当<span class="math inline">\(\vec \mu=0,B=I\)</span>的时候,<span class="math inline">\(f(\vec y)\)</span>其实是只和<span class="math inline">\(\vec
y\)</span>的模长相关的.此时如果看它的等密度轮廓线其实是一圈又一圈的圆.而拉伸之后就成了某种一圈又一圈的椭圆(因为要拉伸呀).</p>
<h3><span id="卷积">卷积</span></h3>
<p>若<span class="math inline">\(X,Y\)</span>相互独立,考虑<span class="math inline">\(Z=X+Y\)</span>,则<span class="math inline">\(f_Z(z)=\int_{-\infty}^{+\infty}f_X(z-y)f_Y(y)\mathrm{d}y\)</span>.</p>
<h2><span id="熵">熵</span></h2>
<p>离散情况下将熵定义为<span class="math inline">\(H[X]=E(\log
\frac{1}{P(X)})=\sum_{i}P_i\log \frac{1}{P_i}\)</span>.如果设<span class="math inline">\(|X|=|\{x|P(x)&gt;0\}|\)</span>,则容易见到<span class="math inline">\(0\leq H[X]\leq \log|X|\)</span>.</p>
<p>接下来我们想定义条件熵,直观的理解是”去掉<span class="math inline">\(X\)</span>的信息后<span class="math inline">\(Y\)</span>还剩多少信息”: <span class="math display">\[
\begin{aligned}
H[Y|X]&amp;=\sum_xH[Y|X=x]P[X=x]\\
&amp;=\sum_x\sum_yP(Y=y|X=x)P[X=x]\lg\frac{1}{P(Y=y|X=x)}\\
&amp;=\sum_{x,y}P(Y=y,X=x)\lg\frac{1}{P(Y=y|X=x)}\\
&amp;=E(\lg\frac{1}{P(Y|X)})
\end{aligned}
\]</span></p>
<p>首先检验<span class="math inline">\(f(x)=x\ln
x\)</span>是下凸函数,原因是<span class="math inline">\(f&#39;(x)=1+\ln
x\)</span>而<span class="math inline">\(f&#39;&#39;(x)=\frac{1}{x}&gt;0\)</span>.于是琴生不等式给出<span class="math inline">\(f(\frac{a+b}{2})\leq
\frac{f(a)+f(b)}{2}\)</span>,或说<span class="math inline">\(E(f(X))\geq
f(E(X))\)</span>.</p>
<p>另外一个很重要的工具是对数求和不等式,对于任何非负实数<span class="math inline">\(a_1,\cdots,a_n\)</span>和正数<span class="math inline">\(b_1,\cdots,b_n\)</span>,记<span class="math inline">\(a=\sum_i a_i,b=\sum_i b_i\)</span>,则: <span class="math display">\[
\sum_i a_i\log\frac{a_i}{b_i}\geq a\log \frac{a}{b}
\]</span> 一个重要的性质是证明其是上凸函数,对于任意分布<span class="math inline">\(P,Q\)</span>和<span class="math inline">\(\lambda\in (0,1)\)</span>,都有: <span class="math display">\[
H[\lambda P+(1-\lambda)Q]\geq \lambda H[P]+(1-\lambda)H[Q]
\]</span> 原因是考虑: <span class="math display">\[
f(\lambda p_i+(1-\lambda)q_i)\leq \lambda f(p_i)+(1-\lambda)f(q_i)
\]</span> 可以见到以下性质:</p>
<ol type="1">
<li><span class="math inline">\(H[X,Y]=H[X]+H[Y|X]\)</span>.</li>
<li><span class="math inline">\(H[X|Y]\leq H[X]\)</span>.</li>
<li>作为(2)的推论,互信息<span class="math inline">\(I(X,Y)=H[X]+H[Y]-H[X,Y]=H[X]-H[X|Y]\geq
0\)</span>.</li>
<li>对于一个确定性函数<span class="math inline">\(g\)</span>,<span class="math inline">\(H[X]\geq H[g(X)]\)</span>.</li>
<li><span class="math inline">\(I(X;YZ)=I(X;Z)+I(X;Y|Z)\)</span>.</li>
<li><span class="math inline">\(I(X;Y\mid Z)\leq
I(X;Y)+H(Z)\)</span>.</li>
<li>当<span class="math inline">\(X,Y,Z\)</span>满足Markov规则,或者说<span class="math inline">\(P_{X,Y,Z}=P_XP_{Y|X}P_{Z|Y}\)</span>,或说<span class="math inline">\(P_{Z|Y}=P_{Z|XY}\)</span>,则<span class="math inline">\(I(X;Y)=I(X;Z)+I(X;Y|Z)\)</span>.这自然推出<span class="math inline">\(I(X;Y)\geq
I(X;Z)\)</span>,也即这个过程中信息不会增多.</li>
</ol>
<p>(1)是上述的一个显然推论.</p>
<p>(2)的话考虑: <span class="math display">\[
\begin{aligned}
&amp;H[X]-H[X|Y]\\
=&amp;\sum_x\left(P(X=x)\lg \frac{1}{P(X=x)}-\sum_y P(X=x,Y=y)\lg
\frac{1}{P(X=x|Y=y)}\right)\\
=&amp;\sum_x\left(\sum_y P(X=x,Y=y)\lg
\frac{P(X=x|Y=y)}{P(X=x)}\right)\\
=&amp;\sum_x\sum_y P(X=x,Y=y)\lg \frac{P(X=x,Y=y)}{P(X=x)P(Y=y)}\\
\end{aligned}
\]</span> 不妨令<span class="math inline">\(a_i=P(X=x,Y=y),b_i=P(X=x)P(Y=y)\)</span>.容易见到<span class="math inline">\(a=\sum_i a_i=1,b=\sum_i
b_i=1\)</span>.于是上式变为: <span class="math display">\[
\begin{aligned}
&amp;H[X]-H[X|Y]\\
=&amp;\sum_i a_i\lg \frac{a_i}{b_i}\\
=&amp;-\sum_i a_i\lg \frac{b_i}{a_i}\\
\geq &amp;-\sum_i a_i (\frac{b_i}{a_i}-1)\\
=&amp;-\sum_i (b_i-a_i)\\
=&amp;0
\end{aligned}
\]</span> 对于(4),轻易地: <span class="math display">\[
\begin{aligned}
H[X,g(X)]&amp;=H[g(X)]+H[X|g(X)]\\
H[X]&amp;=H[g(X)]+H[X|g(X)]
\end{aligned}
\]</span> 然而后者非负,于是显然.特别地,当<span class="math inline">\(g\)</span>是一个单射的时候,<span class="math inline">\(H[X]=H[g(X)]\)</span>.</p>
<p>对于(5),留神到<span class="math inline">\(H[X]=I(X;Z)+H[X|Z]\)</span>,考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=H[X]-H[X|YZ]\\
&amp;=I(X;Z)+H[X|Z]-H[X|YZ]
\end{aligned}
\]</span> 然而<span class="math inline">\(I(X;Y\mid Z)=H[X|
Z]-H[(X|Y)|Z]=H[X|Z]-H[X|YZ]\)</span>.</p>
<p>对于(6),考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=I(X;Z)+I(X;Y\mid Z)\\
&amp;=I(X;Y)+I(X;Z\mid Y)\\
I(X;Y\mid Z)&amp;=I(X;Y)+I(X;Z\mid Y)-I(X;Z)\\
\end{aligned}
\]</span> 然而<span class="math inline">\(I(X;Z\mid
Y)=H[Z|Y]-H[X|YZ]\leq H[Z]\)</span>,而<span class="math inline">\(I(X;Z)\geq 0\)</span>,于是显然.</p>
<p>对于(7),考虑: <span class="math display">\[
\begin{aligned}
I(X;YZ)&amp;=I(X;Y)+I(X;Z\mid Y)\\
I(X;YZ)&amp;=I(X;Z)+I(X;Y\mid Z)\\
\end{aligned}
\]</span> 此外: <span class="math display">\[
\begin{aligned}
I(X;Y)+I(X;Z\mid Y)&amp;=H[X]-H[X|Y]+H[Z|Y]-H[Z|YX]\\
&amp;=H[X]-H[X|Y]+H[Z|Y]-H[Z|Y]\\
&amp;=I(X;Y)
\end{aligned}
\]</span> 于是<span class="math inline">\(I(X;Z\mid
Y)=0\)</span>,这就证毕.</p>
<h3><span id="kl散度">KL散度</span></h3>
<p>定义<span class="math inline">\(D(P||Q)=\sum_x P(x)\lg
\frac{P(x)}{Q(x)}\)</span>.其中如果<span class="math inline">\(P(x)\ne
0\)</span>而<span class="math inline">\(Q(x)=0\)</span>的情况出现,我们就说此时其为<span class="math inline">\(+\infty\)</span>.我们想要证明:<span class="math inline">\(D(P||Q)\geq 0\)</span>.考虑: <span class="math display">\[
\begin{aligned}
D(P||Q)&amp;=E_{x\sim Q}(\frac{P(X)}{Q(X)}\lg \frac{P(X)}{Q(X)})\\
&amp;\geq f\left(E_{x\sim Q}(\frac{P(X)}{Q(X)})\right)\\
&amp;=f(1)\\
&amp;=0
\end{aligned}
\]</span> 从而这的确是某种衡量偏离程度的算子.</p>
此外还应当定义条件KL散度.考察: $$
<span class="math display">\[\begin{aligned}
D(P_{X,Z}||Q_{X,Z})&amp;=\sum_{(x,z)} P_{X,Z}(x,z)\log
\frac{P_{X,Z}(x,z)}{Q_{X,Z}(x,z)}\\
&amp;=\sum_{(x,z)} P_{Z|X}(z|x)P_{X}(x)\log
\frac{P_{Z|X}(z|x)P_{X}(x)}{Q_{Z|X}(z|x)Q_{X}(x)}\\

&amp;=D(P_X||Q_X)+\sum_{(x,z)} P_{Z|X}(z|x)P_{X}(x)\log
\frac{P_{Z|X}(z|x)}{Q_{Z|X}(z|x)}\\
\end{aligned}\]</span>
<p>$$ 将后面的部分定义为<span class="math inline">\(D(P_{Y|X}||Q_{Y|X}\mid
P_X)\)</span>.顺便应该有<span class="math inline">\(D(P_{X,Z}||Q_{X,Z})\geq D(P_X||Q_X)\)</span>.</p>
<p>此外还应当证明KL散度凸性.对于概率分布对<span class="math inline">\((P_1,Q_1),(P_2,Q_2)\)</span>,以及任意<span class="math inline">\(\theta\in [0,1]\)</span>,令<span class="math inline">\(P=\theta P_1+(1-\theta)P_2,Q=\theta
Q_1+(1-\theta)Q_2\)</span>.下面我们证明下凸: <span class="math display">\[
D(P||Q)\leq \theta D(P_1||Q_1)+(1-\theta)D(P_2||Q_2)
\]</span></p>
<p>此外,有趣的性质是证明<span class="math inline">\(I(X;Y)=D(P_{XY}||P_XP_Y)\)</span>,不过这个只需简单转化即可.</p>
<p>另外,对任意<span class="math inline">\(P_X,Q_X\)</span>和kernel<span class="math inline">\(P_{Y|X}\)</span>,令<span class="math inline">\(P_Y=P_X\circ P_{Y|X}\)</span>,<span class="math inline">\(Q_Y=Q_X\circ P_{Y|X}\)</span>.
散度的data-processing不等式给出:<span class="math inline">\(D(P_X||Q_X)\geq D(P_Y||Q_Y)\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证<span class="math inline">\(d(p||q)=D(\mathrm{Bern}(p)||\mathrm{Bern}(q))\geq
(2\log e)(p-q)^2\)</span>.</p>
<p>具体来说,<span class="math inline">\(d(p||q)=p\log
\frac{p}{q}+(1-p)\log \frac{1-p}{1-q }\)</span>.</p>
<h3><span id="编码">编码</span></h3>
<h4><span id="一般无损编码">一般无损编码</span></h4>
<p>考虑一个编码-解码过程,要求编码器Encode是一个到<span class="math inline">\(\{0,1\}^*\)</span>的单射,从而存在其的一个左逆Decode满足$((x))=x
$.</p>
<p>对于编码,我们非常在意的是它的长度.考虑设<span class="math inline">\(L(X)=\text{len}(\text{Encode}(X))\)</span>,我们下面将会估计<span class="math inline">\(E(L(X))\)</span>的大小.</p>
<p>首先证明其下界,我们断言: <span class="math display">\[
H(X)-H(L)\leq E[L(X)]
\]</span> 由于<span class="math inline">\(H(X)-H(L)=H(X|L)\)</span>,因此其实只需要证明<span class="math inline">\(H(X|L)\leq
E[L]\)</span>.由于该编码无损,不妨设<span class="math inline">\(n(l)\)</span>为满足<span class="math inline">\(L(x)=l\)</span>的数量,容易见到<span class="math inline">\(n(l)\leq 2^l\)</span>,立刻有<span class="math inline">\(H(X|L=l)=\log_2 n(l)\leq l\)</span>.于是: <span class="math display">\[
H(X|L)=\sum_l P(L=l)H(X|L=l)\leq \sum_{l}P(L=l)l=E[L]
\]</span> 此外我们还想要估计<span class="math inline">\(H(L)\)</span>具体有多大,事实上: <span class="math display">\[
H(L)\leq \log_2(e(1+E[L]))
\]</span> 下面来看一种比较优秀的编码方式.不妨假设<span class="math inline">\(P(x_1)\geq P(x_2)\geq
\cdots\)</span>,于是自然有<span class="math inline">\(P(x_i)\geq
\frac{1}{i}\)</span>.取码长<span class="math inline">\(L(x_i)=\lfloor
\log_2i\rfloor\)</span>.其实就是按照出现的频率用小码,则: <span class="math display">\[
\begin{aligned}
E[L(X)]&amp;=\sum_i P(x_i)\lfloor \log_2 i\rfloor\\
&amp;\leq \sum_i P(x_i)\log_2 i\\
&amp;\leq \sum_i P(x_i)\log_2 \frac{1}{P(x_i)}\\
&amp;=H(X)
\end{aligned}
\]</span></p>
<h4><span id="前缀码">前缀码</span></h4>
<p>一个更合适的例子是前缀码,对于一个<span class="math inline">\(L(X)\)</span>函数,我们声称存在前缀码<span class="math inline">\(f\)</span>使得<span class="math inline">\(|f(x_i)|=L(x_i)\)</span>,当且仅当<span class="math inline">\(\sum_{x\in A}2^{-L(x)}\leq
1\)</span>,原因是在二叉树上表示一下.</p>
<p>众所周知Huffman编码是最优编码,现在我们来看它为什么优秀,我们说其满足<span class="math inline">\(H(X)\leq E[L(X)]\leq
H(X)+1\)</span>,下面我们来证明这个结论.</p>
<p>先证上界,由于Huffman编码是最优编码,我们只要选取任意一个编码,使得它的界<span class="math inline">\(\leq
H(X)+1\)</span>即可.根据上面的引理,我们直接将<span class="math inline">\(x\)</span>映射到一个长度为<span class="math inline">\(\lceil \log
\frac{1}{P(x)}\rceil\)</span>的前缀编码.此时: <span class="math display">\[
\begin{aligned}
E(L(X))&amp;=\sum_{x}P(x)\lceil \log \frac{1}{P(x)}\rceil\\
&amp;\leq \sum_{x}P(x)\left(\log \frac{1}{P(x)}+1\right)\\
&amp;=H(X)+1
\end{aligned}
\]</span> 再来看下界.来证明任意前缀编码都会被这个下界控制住.</p>
<p>对于一个前缀编码,实际上是把<span class="math inline">\(X\)</span>映射到了另一个<span class="math inline">\(Y\)</span>处.由于这是一个单射,所以有<span class="math inline">\(H(X)=H(Y)\)</span>.然而: <span class="math display">\[
\begin{aligned}
H(Y)&amp;=\sum_{t}H(Y_t|Y_{1}\cdots Y_{t-1})\\
\end{aligned}
\]</span> 来看一个特定的<span class="math inline">\(H(Y_t|Y_1\cdots
Y_{t-1}=y_1\cdots y_{t-1})\)</span>,如果此时<span class="math inline">\(y_1\cdots y_{t-1}\)</span>已经能解码了,那<span class="math inline">\(Y_t\)</span>就一定是空白,因此此时熵为<span class="math inline">\(0\)</span>;反之,则<span class="math inline">\(Y_t\)</span>要么是<span class="math inline">\(0\)</span>要么是<span class="math inline">\(1\)</span>,伯努利分布的最大值只有<span class="math inline">\(\log_2
2=1\)</span>.因此我们可以发现,对于一个特定的<span class="math inline">\(x\)</span>和对应的<span class="math inline">\(y_1\cdots y_k\)</span>,一定有<span class="math inline">\(H(Y_t|Y_1\cdots Y_{t-1}=y_1\cdots y_{t-1})\leq
Pr[L(x)\geq t]\)</span>.</p>
<p>所以实际上<span class="math inline">\(H(Y)\leq \sum_t Pr[L(X)\geq
t]=E(L)\)</span>.</p>
<h4><span id="几乎无损压缩">几乎无损压缩</span></h4>
<p>对于独立同分布<span class="math inline">\(X^n\)</span>,如果满足:
<span class="math display">\[
Pr[\text{Decode}(\text{Encode}(X^n))=X^n]\geq 1-\epsilon,\epsilon\to 0
\]</span> 则称其为几乎无损压缩.不妨记录<span class="math inline">\(\vec
X\sim X^n\)</span>.</p>
<p>现在我们来看做到几乎无损压缩需要怎么办.我们将说明几乎就一定需要<span class="math inline">\(nH(X)\)</span>左右的信息长度才足够.事实上:</p>
<ol type="1">
<li><span class="math inline">\(\forall
\delta&gt;0\)</span>,存在编码方案使得<span class="math inline">\(L\leq
n(H(X)+\delta)\)</span>,并且错误概率趋近于<span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(\forall \delta&gt;0\)</span>,如果<span class="math inline">\(L&lt;n(H(X)-\delta)\)</span>,则无论怎么编码,错误概率趋近于<span class="math inline">\(1\)</span>.</li>
</ol>
<p>先来证明(1),考虑直接取<span class="math inline">\(L=n(H(X)+\delta)\)</span>,并且编码出现概率最大的前<span class="math inline">\(2^L\)</span>个元素,剩下的扔掉.不妨可以发现我们只会扔掉所有<span class="math inline">\(P(\vec X)\leq
2^{-n(H(X)+\delta)}\)</span>的,原因是比这个阈值大的不可能超过<span class="math inline">\(2^L\)</span>个.然而留意到<span class="math inline">\(P(\vec X=(x_1,\cdots,x_n))=\prod_i
P(X=x_i)\)</span>: <span class="math display">\[
\begin{aligned}
Pr[P(\vec X)\leq 2^{-n(H(X)+\delta)}]&amp;=Pr[-\log_2P(\vec X)\geq
n(H(X)+\delta)]\\
&amp;=Pr[-\sum_i\log_2P(X_i)\geq n(H(X)+\delta)]\\
\end{aligned}
\]</span> 可是<span class="math inline">\(\sum_i -\log_2
P(X_i)\)</span>的期望恰好为<span class="math inline">\(H(X)\)</span>,因此根据Chernoff-Hoeffding
Bound,这个错误概率<span class="math inline">\(\leq
e^{-O(n\delta^2)}\)</span>.</p>
<p>那么反过来的界怎么证明呢?此时最多可编码<span class="math inline">\(2^{n(H(X)-\delta)}\)</span>个元素.仍然用Chernoff
Bound就可以搞定了.</p>
<h4><span id="通用压缩">通用压缩</span></h4>
<p>我们上面的所有讨论都基于已知分布的情况.如果我们不知道分布,又能做到多好的编码呢?</p>
<p>当编码的时候不知道分布,但解码的时候知道分布的时候,事实上可以做到:<span class="math inline">\(\varlimsup_{n\to \infty}\frac{1}{n}E[L_n(X^n)]\leq
H(X)+\epsilon\)</span>,其中<span class="math inline">\(\epsilon\)</span>可以任意小.</p>
<p>这个怎么做呢?考虑一个暴力方法,我先随便将信息映射到<span class="math inline">\(\{0,1\}^L\)</span>.此时的Encode并非单射.解码的时候直接最大似然估计找最好的那个解码.</p>
<p>假设<span class="math inline">\(x_i\to c_i\)</span>,并且<span class="math inline">\(P(x_1)\geq P(x_2)\geq
\cdots\)</span>,取一个阈值<span class="math inline">\(M=2^{n(H(X)+\delta)}\)</span>,以及<span class="math inline">\(L=n(H(X)+2\delta)\)</span>现在来看失败概率也就是:
<span class="math display">\[
\begin{aligned}
&amp;\sum_{i} P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]\\
=&amp;\sum_{i=1}^M P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]+\sum_{i\geq
M} P(x_i)Pr[c_i\in \{c_1,\cdots,c_{i-1}\}]\\
\leq &amp;\sum_{i=1}^M P(x_i)\frac{M}{2^L}+2^{-O(n\delta^2)}\\
\leq &amp;2^{-O(n\delta)}+2^{-O(n\delta^2)}\\
\end{aligned}
\]</span> 这个错误概率就很小了.</p>
<h3><span id="信道编码">信道编码</span></h3>
<p>定义<strong>信道</strong>为某种会”污染”信息的东西,或者干脆写称条件概率分布<span class="math inline">\(P_{Y|X}\)</span>.此外定义<strong>信道容量</strong><span class="math inline">\(C=\max_{P_X}I(X;Y)\)</span>,其中<span class="math inline">\((X,Y)\sim P_XP_{Y|X}\)</span>.</p>
<p>现在我们考虑一个一般的信道编码,取<span class="math inline">\(W\to
\vec X\in \mathcal{X}^L\to \vec Y\in \mathcal{Y}^L\to \hat
W\)</span>.</p>
<p>现在我们来证明以下性质:</p>
<ol type="1">
<li><span class="math inline">\(I(\vec X;\vec Y)\leq L\sdot
C\)</span></li>
<li>data-processing不等式:<span class="math inline">\(I(W;\hat W)\leq
I(\vec X;\vec Y)\)</span></li>
</ol>
<p>对于(1),由于<span class="math inline">\(Y_i\)</span>独立地依赖于<span class="math inline">\(X_i\)</span>,考虑: <span class="math display">\[
\begin{aligned}
I(\vec X;\vec Y)&amp;=\sum_i I(\vec X;Y_i\mid Y_1\cdots Y_{i-1})\\
&amp;=\sum_i I(X_i;Y_i)\\
&amp;\leq L\sdot C
\end{aligned}
\]</span> 至于(2),实际上是互信息的data-processing不等式.</p>
<p>接下来我们要搞定传送速率的问题.不妨设<span class="math inline">\(n=H(W)\)</span>,现在我们将要证明: <span class="math display">\[
n\leq\frac{LC+H(\epsilon)}{1-\epsilon}
\]</span> 其中<span class="math inline">\(\epsilon\)</span>是可接受的最大错误概率,定义为<span class="math inline">\(\epsilon=\max_w Pr[\hat W\ne W|W=w]\)</span>.</p>
<p>怎么证明呢?考虑取一个指示变量<span class="math inline">\(Z\)</span>,当<span class="math inline">\(\hat W\ne
W\)</span>的时候<span class="math inline">\(Z=1\)</span>,否则<span class="math inline">\(Z=0\)</span>.不妨直接让<span class="math inline">\(Z\)</span>多错一点,到达<span class="math inline">\(Pr[Z=1|W=w]\equiv
\epsilon\)</span>以方便我们下面的分析.这样的话<span class="math inline">\(Z\)</span>和<span class="math inline">\(W\)</span>就独立了.此时立刻见到: <span class="math display">\[
(1-\epsilon)I(W;\hat W\mid Z=0)\leq I(W;\hat W\mid Z)\leq I(W;\hat
W)+H(Z)
\]</span> 而<span class="math inline">\(I(W;\hat W\mid
Z=0)=I(W;W)=H(W)=n\)</span>.</p>
<h2><span id="极限的情况">极限的情况</span></h2>
<h3><span id="尾不等式">尾不等式</span></h3>
<p>留神到如果事件在<span class="math inline">\(n\)</span>次中发生了<span class="math inline">\(n_a\)</span>次,其实是不能说<span class="math inline">\(\lim_{n\to
\infty}\frac{n_a}{n}=P\)</span>的.因为后面总是会有微小的扰动.但似乎总能刻画这些微小扰动的代价.</p>
<p>设<span class="math inline">\(f_n(A)=\frac{n_a}{n}\)</span>.如果我们能求出<span class="math inline">\(P(|f_n-p|\geq \epsilon)=P(|n_a-E(n_a)|\geq
n\epsilon)\)</span>的上界,看上去就会非常优秀.进一步地:</p>
<ol type="1">
<li>尾不等式:给出<span class="math inline">\(P(X\geq
k)\)</span>的上界.</li>
<li>集中不等式:给出<span class="math inline">\(P(|X-E(X)|\geq
k)\)</span>的上界.</li>
</ol>
<h6><span id="example1">Example1</span></h6>
<p>对二项分布用Chebyshev不等式,轻易有: <span class="math display">\[
P(|n_A-E(n_A)|\geq n\epsilon)\leq \frac{p(1-p)}{n\epsilon^2}
\]</span> 这个估计有点菜,右侧是<span class="math inline">\(O(\frac{1}{n})\)</span>的,这个趋近也太慢了.</p>
<p>考虑一下它为什么菜,问题在于Chebyshev不等式只用到了”两两独立”这件事,但是实际上二项分布更强一点,它其实是”互相独立”的.</p>
<h4><span id="矩">矩</span></h4>
<p>定义<span class="math inline">\(E(X^k)\)</span>为<span class="math inline">\(X\)</span>的<strong><span class="math inline">\(k\)</span>阶原点矩</strong>,而将<span class="math inline">\(E((X-E(X))^k)\)</span>称为<span class="math inline">\(X\)</span>的<strong><span class="math inline">\(k\)</span>阶中心距</strong>.则期望是其一阶原点矩而方差是二阶中心矩.</p>
<p>对于随机变量<span class="math inline">\(X\)</span>,定义<span class="math inline">\(M_X(t)=E(e^{tX})\)</span>为<span class="math inline">\(X\)</span>的<strong>矩生成函数</strong>.考虑:
<span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=\sum_{k=0}^ne^{kt}P(X=k)\\
&amp;=\sum_{k=0}^nP(X=k)\left(\sum_{j=0}^{+\infty}\frac{(kt)^j}{j!}\right)\\
&amp;=\sum_{j=0}^{\infty}\frac{t^j}{j!}\sum_{k=0}^nP(X=k)k^j\\
&amp;=\sum_{j=0}^\infty \frac{t^j}{j!}E(X^j)
\end{aligned}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>对<span class="math inline">\(X\sim B(n,p)\)</span>,求<span class="math inline">\(E((X-E(X))^4)\)</span>.</p>
<p>考虑其矩生成函数: <span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=\sum_{k=0}^ne^{kt}P(X=k)\\
&amp;=\sum_{k=0}^ne^{kt}\binom{n}{k}p^k(1-p)^{n-k}\\
&amp;=\sum_{k=0}^n\binom{n}{k}(pe^{t})^k(1-p)^{n-k}\\
&amp;=(pe^t+(1-p))^n\\
&amp;=(1+p(e^t-1))^n
\end{aligned}
\]</span> 令<span class="math inline">\(Y=X-E(X)\)</span>,则<span class="math inline">\(E(e^{Yt})=E(e^{Xt})e^{-tpn}\)</span>,现在我们可以对其求四次导数得到:
<span class="math display">\[
E((X-E(X))^4)=np(1-p)^4+n(1-p)p^4+3n(n-1)p^2(1-p^2)
\]</span> 那这个有什么用呢?考虑对其用Markov不等式: <span class="math display">\[
P((X-E(X))^4\geq (n\epsilon)^4)\leq
\frac{O(n^2)}{(n\epsilon)^4}=O(\frac{1}{n^2\epsilon^4})
\]</span> 这的确给出了一个更好的估计.</p>
<p>但是再做六阶矩好像也很痛苦,而且这只能给出一个多项式估计,但看着这个逼近速度就不太可能是多项式估计,那怎么办呢?</p>
<h4><span id="chernoff-bound">Chernoff Bound</span></h4>
<p>考虑直接对<span class="math inline">\(e^{tX}\)</span>用Markov不等式:</p>
<ol type="1">
<li>当<span class="math inline">\(t&gt;0\)</span>的时候,有<span class="math inline">\(P(X\geq k)\leq M_X(t)e^{-tk}\)</span>.</li>
<li>当<span class="math inline">\(t&lt;0\)</span>的时候,有<span class="math inline">\(P(X\leq k)\leq M_X(t)e^{-tk}\)</span>.</li>
</ol>
<p>左侧没有<span class="math inline">\(t\)</span>而右侧有,那看上去只要找到能使右侧取到最小值的<span class="math inline">\(t\)</span>就万事大吉了.</p>
<h6><span id="example1">Example1</span></h6>
<p>当<span class="math inline">\(X\sim
\pi(\lambda)\)</span>的时候,求<span class="math inline">\(P(X\geq
x)\)</span>的上界.其中<span class="math inline">\(x&gt;\lambda\)</span>.</p>
<p>先求此时的矩生成函数: <span class="math display">\[
\begin{aligned}
E(e^{Xt})&amp;=e^{-\lambda}\sum_{k\geq 0}\frac{\lambda^k}{k!}e^{kt}\\
&amp;=e^{-\lambda}\sum_{k\geq 0}\frac{(\lambda e^t)^k}{k!}\\
&amp;=e^{\lambda (e^t-1)}
\end{aligned}
\]</span> 当<span class="math inline">\(t&gt;0\)</span>的时候,我们想要优化<span class="math inline">\(e^{\lambda(e^t-1)-tx}\)</span>的最小值,直接对<span class="math inline">\(t\)</span>求导,发现当<span class="math inline">\(t=\ln\frac{x}{\lambda}\)</span>时最小.</p>
<p>此时: <span class="math display">\[
P(X\geq x)\leq \frac{e^{-\lambda}(e\lambda)^x}{x^x}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>当<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>,求<span class="math inline">\(P(X-E(X)\geq k\sigma)\)</span>的上界.</p>
<p>还是求矩生成函数,考虑: <span class="math display">\[
E(e^{tX})=\int_{-\infty}^{+\infty}\frac{1}{\sqrt
{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}+tx}=e^{\mu
t+\frac{\sigma^2t^2}{2}}
\]</span> 从而: <span class="math display">\[
P(X\geq k\sigma+\mu)\leq e^{\mu
t+\frac{\sigma^2t^2}{2}}e^{-t(\mu+k\sigma)}=e^{\frac{\sigma^2t^2}{2}-k\sigma
t}
\]</span> 当<span class="math inline">\(t=\frac{k}{\sigma}\)</span>的时候取最小值,从而最后的界是<span class="math inline">\(e^{-\frac{k^2}{2}}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>当<span class="math inline">\(X\sim B(n,p)\)</span>,求<span class="math inline">\(P(X-E(X)\geq n\epsilon)\)</span>的上界.</p>
<p>考虑<span class="math inline">\(M_X(t)=(1-p+pe^t)^n\)</span>.</p>
<p>然后需要一个Lemma,我们说<span class="math inline">\((1-p)e^{-tp}+pe^{t(1-p)}\leq
e^{\frac{t^2}{8}}\)</span>,这个会在后面的Hoeffding引理证明.</p>
<p>直接带入,右侧为: <span class="math display">\[
\begin{aligned}
M_X(t)e^{-t(E(X)+n\epsilon)}&amp;=e^{-tn\epsilon}\left((1-p)e^{-tp}+pe^{t(1-p)}\right)^n\\
&amp;\leq e^{-tn\epsilon+\frac{nt^2}{8}}
\end{aligned}
\]</span> 取<span class="math inline">\(t=4\epsilon\)</span>得到<span class="math inline">\(e^{-2n\epsilon^2}\)</span>的上界.</p>
<p>此外取<span class="math inline">\(t=-4\epsilon\)</span>得到<span class="math inline">\(P(X-E(X)\leq -n\epsilon)\)</span>的上界为<span class="math inline">\(e^{-2n\epsilon^2}\)</span>.</p>
<p>于是我们有<span class="math inline">\(P(|X-E(X)|\geq n\epsilon)\leq
2e^{-2n\epsilon^2}\)</span>.</p>
<h4><span id="hoeffding引理">Hoeffding引理</span></h4>
<p>若实数随机变量<span class="math inline">\(a\leq X\leq
b\)</span>,则<span class="math inline">\(M_{X-E(X)}(t)=E(e^{t(X-E(X))})\leq
e^{\frac{t^2(b-a)^2}{8}}\)</span>.</p>
<h6><span id="example1chernoff-hoeffding不等式">Example1(Chernoff-Hoeffding不等式)</span></h6>
<p>若<span class="math inline">\(X=\sum_{i=1}^n X_i\)</span>,其中<span class="math inline">\(X_i\)</span>相互独立且<span class="math inline">\(a\leq X_i\leq b\)</span>.则(<span class="math inline">\(k&gt; 0\)</span>):</p>
<ol type="1">
<li><span class="math inline">\(P(X\geq E(X)+k)\leq
e^{-\frac{2k^2}{n(b-a)^2}}\)</span>.</li>
<li><span class="math inline">\(P(X\leq E(X)-k)\leq
e^{-\frac{2k^2}{n(b-a)^2}}\)</span>.</li>
</ol>
<p>怎么证明呢,考虑<span class="math inline">\(P(X\geq E(X)+k)\leq
M_{X-E(X)}(t)e^{-tk}\)</span>.</p>
<p>然而: <span class="math display">\[
\begin{aligned}
M_{X-E(X)}(t)&amp;=E(e^{t(X-E(X))})\\
&amp;=E(\prod_i e^{t(X_i-E(X_i))})\\
&amp;=\prod_i E(e^{t(X_i-E(X_i))})\\
&amp;=\prod_i M_{X_i-E(X_i)}(t)\\
&amp;\leq e^{n\frac{t^2(b-a)^2}{8}}
\end{aligned}
\]</span> 接下来对后面那个东西最优化,可以发现<span class="math inline">\(t=\frac{4k}{n(b-a)^2}\)</span>的时候足够优秀,这就证明了上面的不等式.</p>
<h4><span id="sanov-bound">Sanov Bound</span></h4>
<p>回忆到斯特林公式<span class="math inline">\(n!\sim \sqrt{2\pi
n}(\frac{n}{e})^n\)</span>.</p>
<p>先来看一个在二项分布上的版本,不妨设<span class="math inline">\(X_1,\cdots,X_n\sim
\mathrm{Bern}(p)\)</span>,而<span class="math inline">\(q&gt;p\)</span>,我们断言: <span class="math display">\[
\frac{1}{n+1}\exp(-nd(q||p))\leq Pr[\sum_i^n X_i\geq qn]\leq
(n(1-q)+1)\exp(-nd(q||p))
\]</span> 为此留神到<span class="math inline">\(Pr[\sum_i^n X_i\geq
qn]=\sum_{t=qn}^n\binom{n}{t}p^t(1-p)^{n-t}\)</span>,容易证明当<span class="math inline">\(q&gt;p\)</span>的时候,<span class="math inline">\(\binom{n}{t}p^t(1-p)^{n-t}\)</span>单调下降.</p>
<p>此时来看<span class="math inline">\(\binom{n}{qn}\)</span>的取值:
<span class="math display">\[
\begin{aligned}
1&amp;\geq \binom{n}{qn}q^{qn}(1-q)^{n-qn}\\
\binom{n}{qn}&amp;\leq \frac{1}{q^{qn}(1-q)^{n-qn}}\\
&amp;=\left((\frac{1}{q})^q(\frac{1}{1-q})^{1-q}\right)^n\\
&amp;=\left(\exp(q\ln  \frac{1}{q}+(1-q)\ln \frac{1}{1-q})\right)^n\\
&amp;=\exp(nh(q))
\end{aligned}
\]</span> 此外,我们知道<span class="math inline">\(\binom{n}{t}q^{t}(1-q)^{n-t}\)</span>在<span class="math inline">\(t=qn\)</span>处取最大值,从而$
q<sup>{qn}(1-q)</sup>{n-qn}<span class="math inline">\(,于是给出\)</span>(nh(q))(nh(q))$.</p>
<p>此时观察: <span class="math display">\[
\begin{aligned}
\exp(nh(q))p^{qn}(1-p)^{n-qn}&amp;=\exp(nh(q))\exp(n(q\ln p+(1-q)\ln
(1-p)))\\
&amp;=\exp(n(q\ln \frac{p}{q}+(1-q)\ln \frac{1-p}{1-q}))\\
&amp;=\exp(-nd(q||p))
\end{aligned}
\]</span> 从而给出了上面的答案.</p>
<p>现在来看一个一般的版本.对于一个可能的空间<span class="math inline">\(\Omega=\{v_1,\cdots
v_L\}\)</span>,现在有一个分布<span class="math inline">\(P:\Omega\to
[0,1]\)</span>,记录<span class="math inline">\(p_i=P(v_i)\)</span>.</p>
<p>现在从<span class="math inline">\(P\)</span>中独立取样<span class="math inline">\(x_1,\cdots,x_n\)</span>.考虑对于一个特定的可重集合<span class="math inline">\(S\)</span>,求<span class="math inline">\(Pr[\{x_1,\cdots
,x_n\}=S]\)</span>.回忆到可重集的定义为<span class="math inline">\(S:\Omega\to\mathbb{N}\)</span>,不妨干脆记录<span class="math inline">\(s_i=S(v_i)\)</span>.容易发现<span class="math inline">\(Pr[\{x_1,\cdots
,x_n\}=S]=\binom{n}{s_1,\cdots,s_L}p_1^{s_1}\cdots
p_L^{s_L}\)</span>.</p>
<p>现在考虑一个新的分布<span class="math inline">\(Q:\Omega\to
[0,1]\)</span>,其中<span class="math inline">\(q_i=\frac{s_i}{n}\)</span>,此时如果采样<span class="math inline">\(y_1,\cdots,y_n\sim Q\)</span>的时候,先来看看<span class="math inline">\(Pr[\{y_1,\cdots,y_n\}=S]\)</span>.</p>
<p>容易见到<span class="math inline">\(|\Omega\to \mathbb N|\leq
\frac{1}{(n+1)^{L-1}}\)</span>,从而见到以下简单估计(需要证明当前的情况的概率是所有情况中最大的):
<span class="math display">\[
\begin{gathered}
\frac{1}{(n+1)^{L-1}}\leq Pr[\{y_1,\cdots,y_n\}=S]\leq 1\\
\frac{1}{(n+1)^{L-1}}\leq \binom{n}{s_1,\cdots,s_L}\leq
\left((\frac{1}{q_1})^{q_1}\cdots (\frac{1}{q_L})^{q_L}\right)^n\\
\frac{\exp(nH(Q))}{(n+1)^{L-1}}\leq \binom{n}{s_1,\cdots,s_L}\leq
\exp(nH(Q))\\
\end{gathered}
\]</span> 这给出了<span class="math inline">\(\binom{n}{s_1,\cdots,s_L}\)</span>的一个上下界.然而天然有:
<span class="math display">\[
p_1^{s_1}\cdots p_L^{s_L}=\exp(n\sum_i q_i\log
p_i)=\exp(-nD(Q||P)-nH(Q))
\]</span> 从而: <span class="math display">\[
\frac{\exp(-nD(Q||P))}{(n+1)^{L-1}}\leq Pr[\{x_1,\cdots ,x_n\}=S] \leq
\exp(-nD(Q||P))\\
\]</span></p>
<p>如果这里把<span class="math inline">\(\{x_1,\cdots
,x_n\}=S\)</span>弱化到<span class="math inline">\(\{x_1,\cdots
,x_n\}\in A\)</span>,则右边当然要补一个<span class="math inline">\(|A|\)</span>,当然显然<span class="math inline">\(|A|\leq (n+1)^{L-1}\)</span></p>
<h3><span id="大数定律">大数定律</span></h3>
<p>对于随机变量<span class="math inline">\(\{X_i\}\)</span>,对于任意<span class="math inline">\(\epsilon&gt;0\)</span>,如果: <span class="math display">\[
\lim_{n\to \infty} P(|\frac{1}{n}\sum_i^n X_i-\frac{1}{n}\sum_i^n
E(X_i)|&lt;\epsilon)=1
\]</span> 则称它们满足大数定律.</p>
<p>一般而言,对于一列随机变量<span class="math inline">\(\{Y_i\}\)</span>和一个随机变量<span class="math inline">\(Y\)</span>,如果<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\lim_{n\to
\infty}P(|Y_n-Y|&lt;\epsilon)=1\)</span>,则称其<strong>依概率收敛</strong>.</p>
<h4><span id="markov大数定律">Markov大数定律</span></h4>
<p>若<span class="math inline">\(\mathrm{Var}(\sum X_i)\sim
o(n^2)\)</span>,则<span class="math inline">\(\{X_n\}\)</span>符合大数定律.</p>
<p>策略是考虑<span class="math inline">\(\mathrm{Var}(\frac{\sum
X_i}{n})=\frac{1}{n^2}\mathrm{Var}(\sum
X_i)\)</span>.用Chebyshev不等式碾一下就好了.</p>
<h4><span id="khinchin大数定律弱大数定律">Khinchin大数定律(弱大数定律)</span></h4>
<p>设<span class="math inline">\(\{X_i\}\)</span>独立同分布,且数学期望<span class="math inline">\(\mu=E(X_i)\)</span>存在,则<span class="math inline">\(\{X_i\}\)</span>满足大数定律.</p>
<h3><span id="特征函数">特征函数</span></h3>
<p>对于随机变量<span class="math inline">\(X\)</span>,设<span class="math inline">\(\phi_X(t)=E(e^{itX})\)</span>为其特征函数.容易见到<span class="math inline">\(\phi_X(-it)=E(e^{tX})\)</span>.一些常见的特征函数:</p>
<ol type="1">
<li><span class="math inline">\(X\sim
\pi(\lambda),M_X(t)=e^{\lambda(e^t-1)},\phi_X(t)=e^{\lambda(e^{it}-1)}\)</span>.</li>
<li><span class="math inline">\(X\sim N(\mu,\sigma^2),M_X(t)=e^{\mu
t+\frac{\sigma^2t^2}{2}},\phi_X(t)=e^{i\mu
t-\frac{\sigma^2t^2}{2}}\)</span>.</li>
<li><span class="math inline">\(X\sim
B(n,p),M_X(t)=(1-p+pe^t)^n,\phi_X(t)=(1-p+pe^{it})^n\)</span>.</li>
<li><span class="math inline">\(X\)</span>服从柯西分布,<span class="math inline">\(f(x)=\frac{1}{\pi(x^2+1)}\)</span>,则<span class="math inline">\(\phi_X(t)=e^{-|t|}\)</span>.</li>
</ol>
<p>随机变量的分布函数由其特征函数唯一确定.此外,依分布收敛等价于特征函数逐点收敛.</p>
<p>依照上面的结论,就可以拿到<span class="math inline">\(X_n\sim
\pi(n)\)</span>推出<span class="math inline">\(\frac{X_n-n}{\sqrt n}\to
N(0,1)\)</span>,原因正是上面的依分布收敛的性质.</p>
<h3><span id="中心极限定理">中心极限定理</span></h3>
<p>先来看Lindeberg-Levy版本:</p>
<p>设<span class="math inline">\(\{X_n\}\)</span>独立同分布,而且<span class="math inline">\(E(X_n)=\mu,\mathrm{Var}(X_n)=\sigma^2\)</span>,设<span class="math inline">\(Y_n=\sum_i^n X_i\)</span>,而<span class="math inline">\(\tilde{Y}_n=\frac{Y_n-E(Y_n)}{\sigma(Y_n)}=\frac{\sum_i^n
(X_i-\mu)}{\sqrt n\sigma}\)</span>.</p>
<p>我们断言<span class="math inline">\(\tilde
Y_n\)</span>一定依分布收敛于<span class="math inline">\(Z\)</span>,其中<span class="math inline">\(Z\sim
N(0,1)\)</span>.</p>
<p>为什么呢?用泰勒展开考虑<span class="math inline">\(\Re
\phi_{X_n-\mu}(t)=1-\frac{\sigma^2}{2}t^2+o(t^2)\)</span>.此时<span class="math inline">\(\Re \phi_{\tilde
Y_n}(t)=(1-\frac{t^2}{2n}+o(\frac{t^2}{n}))^n\to
e^{-\frac{t^2}{2}}\)</span>.</p>
<p>现在来看一个强的版本:</p>
<p>Berry-Esseen定理:在上述版本的基础上,如果<span class="math inline">\(E(|X_n-\mu|^3)\)</span>有限,则收敛速度有: <span class="math display">\[
|P(\tilde Y_n\leq x)-P(Z\leq x)|\leq
O(1)\frac{E(|X_n-\mu|^3)}{\sigma^3\sqrt{n}}
\]</span></p>
<h2><span id="概率方法">概率方法</span></h2>
<h6><span id="example1">Example1</span></h6>
<p>求证拉姆齐数<span class="math inline">\(R(k,k)&gt;2^{\frac{k-1}{2}}\)</span>.</p>
<p>考虑一个随机图,任何两个点之间以<span class="math inline">\(\frac{1}{2}\)</span>概率连边,现在取点集的一个大小为<span class="math inline">\(k\)</span>的子集,它是一个完全图或者或独立集的概率都是<span class="math inline">\(2^{-\frac{k(k-1)}{2}}\)</span>,立刻见到这个图所有的期望大小为<span class="math inline">\(k\)</span>的完全图或独立集的期望为<span class="math inline">\(\binom{n}{k}2^{1-\frac{k(k-1)}{2}}\)</span>,如果这个东西<span class="math inline">\(&lt;1\)</span>,就证明总有一个图二者皆不存在.于是取<span class="math inline">\(n=2^{\frac{k-1}{2}}\)</span>,则: <span class="math display">\[
\begin{aligned}
\binom{n}{k}2^{1-\frac{k(k-1)}{2}}&amp;&lt;
\frac{n^k}{k!}2^{1-\frac{k(k-1)}{2}}\\
&amp;=\frac{2}{k!}
\end{aligned}
\]</span></p>
<h6><span id="example2">Example2</span></h6>
<p>考虑一个大小为<span class="math inline">\(n\)</span>的集合<span class="math inline">\(X\)</span>的若干大小为<span class="math inline">\(k\)</span>的子集所组成的集合<span class="math inline">\(\Omega\)</span>,并且要求<span class="math inline">\(\forall S,T\in \Omega,S\cap T\ne
\emptyset\)</span>.求证:<span class="math inline">\(|\Omega|\leq
\binom{n-1}{k-1}\)</span>.</p>
<p>这个上界显然是容易达到的,只需要让所有子集都包含同一个元素即可.</p>
<p>现在考虑随机一个置换<span class="math inline">\(\sigma\)</span>,选定<span class="math inline">\(A_i=[i,k+i-1]\)</span>,考虑<span class="math inline">\(Pr[\sigma(S)=A_i]=\frac{1}{\binom{n}{k}}\)</span>于是<span class="math inline">\(Pr[\sigma(S)\in
\{A_0,\cdots,A_{n-1}\}]=\frac{n}{\binom{n}{k}}\)</span>.从而<span class="math inline">\(E(\sum_{S\in \Omega}[\sigma(S)\in
\{A_0,\cdots,A_{n-1}\}])=\frac{n}{\binom{n}{k}}|\Omega|\)</span>.然而这个数必定小于等于<span class="math inline">\(k\)</span>,因为置换不会改变相交性,而如果要从<span class="math inline">\(\{A_0,\cdots,A_{n-1}\}\)</span>中选出若干个两两相交的,最多只能选出<span class="math inline">\(k\)</span>个.</p>
<h6><span id="example3">Example3</span></h6>
<p>取若干个集合<span class="math inline">\(A_1,\cdots,A_n\)</span>,<span class="math inline">\(B_1,\cdots,B_n\)</span>,要求<span class="math inline">\(|A_i|=k,|B_j|=l\)</span>,此外要求<span class="math inline">\(A_i\cap B_i=\emptyset\)</span>,而且当<span class="math inline">\(i\ne j\)</span>时,要求<span class="math inline">\(A_i\cap B_j\ne\emptyset\)</span>.求证<span class="math inline">\(n\leq \binom{k+l}{k}\)</span>.</p>
<p>考虑取<span class="math inline">\(X=\bigcup_i(A_i\cup
B_i)\)</span>,考虑在<span class="math inline">\(X\)</span>上随机一个序关系,并设事件<span class="math inline">\(E_i\)</span>为:<span class="math inline">\(A_i\)</span>中的所有元素都$$<span class="math inline">\(B_i\)</span>中的所有元素.但这个事不能发生两次,因为如果<span class="math inline">\(E_i\)</span>和<span class="math inline">\(E_j\)</span>都成立,如果<span class="math inline">\(A_i\cap B_j\ne \emptyset\)</span>,则<span class="math inline">\(A_j\cap
B_i=\emptyset\)</span>,这就完蛋了.所以<span class="math inline">\(Pr[E_i]\leq \frac{1}{n}\)</span>.然而<span class="math inline">\(Pr[E_i]=\frac{1}{\binom{l+k}{k}}\)</span>,这就搞定了.</p>
<h6><span id="example4">Example4</span></h6>
<p>求证<span class="math inline">\(\forall k\geq 2\)</span>和<span class="math inline">\(\forall n\)</span>,总存在矩阵<span class="math inline">\(M\in \{0,1\}^{n\times n}\)</span>,使得:</p>
<ol type="1">
<li><span class="math inline">\(M\)</span>中<span class="math inline">\(1\)</span>的数量约为<span class="math inline">\(\Omega(n^{2-\frac{2}{k+1}})\)</span>.</li>
<li>不存在<span class="math inline">\(k\times k\)</span>的全<span class="math inline">\(1\)</span>子矩阵.</li>
</ol>
<p>考虑每一位置按照<span class="math inline">\(B(1,p)\)</span>随机,则全<span class="math inline">\(1\)</span>的<span class="math inline">\(k\times
k\)</span>的子矩阵的期望个数为<span class="math inline">\(p^{k^2}\binom{n}{k}^2\)</span>.对于这些问题,我们强行删它们中的一个<span class="math inline">\(1\)</span>,在做完这些操作后,剩下的<span class="math inline">\(1\)</span>的个数的期望就会<span class="math inline">\(\geq
pn^2-p^{k^2}\binom{n}{k}^2\)</span>,最终选定<span class="math inline">\(p=(\frac{n^2}{k^2n^{2k}})^{\frac{1}{k^2-1}}\)</span>.</p>
<h6><span id="example5">Example5</span></h6>
<p>求证:对于<span class="math inline">\(\forall
k,l\)</span>,存在一个图,它的环的长度均<span class="math inline">\(\geq
l\)</span>,但它的最小染色数<span class="math inline">\(\geq
k\)</span>.</p>
<p>考虑一个两个点之间以<span class="math inline">\(p\)</span>概率连边的随即图,存在一个长度为<span class="math inline">\(i\)</span>的环的概率为<span class="math inline">\(\frac{n^{\underline{i}}}{i}p^i\leq
n^ip^i\)</span>.</p>
<p>考虑每个染色都是一个独立集,因此必定有<span class="math inline">\(\chi(G)\alpha(G)\geq n\)</span>,其中<span class="math inline">\(\chi(G)\)</span>是染色数,<span class="math inline">\(\alpha(G)\)</span>是最大独立集大小.从而只需要让<span class="math inline">\(\alpha(G)\)</span>足够小就行.</p>
<p>现在考虑<span class="math inline">\(Pr[\alpha(G)\geq a]\geq
\binom{n}{a}(1-p)^{\frac{a(a-1)}{2}}\)</span>.然后倒腾倒腾吧,取<span class="math inline">\(p=n^{\frac{1}{2l}-1}\)</span>,懒得算了.</p>
<h6><span id="example6">Example6</span></h6>
<p>考虑一个有限集合<span class="math inline">\(B\subseteq
\mathbb{Z}\setminus\{0\}\)</span>,求证存在一个<span class="math inline">\(A\subseteq B\)</span>,使得<span class="math inline">\(|A|\geq \frac{|B|}{3}\)</span>,并且满足<span class="math inline">\(\forall a_1,a_2\in A,a_1+a_2\notin A\)</span>.</p>
<p>假如我们在一个环上做这件事,比如<span class="math inline">\(\mathbb{Z}_p\)</span>.当<span class="math inline">\(B=\mathbb{Z}_p\setminus\{0\}\)</span>,其中<span class="math inline">\(p=3k+2\)</span>的时候,此时可以选取<span class="math inline">\([k+1,2k+1]\)</span>中的元素,容易见到这占据了<span class="math inline">\(\geq
\frac{|B|}{3}\)</span>.而如果不然,我们可以随机一个<span class="math inline">\(r\)</span>,使得<span class="math inline">\(B\to
\mathbb{Z}_p\setminus\{0\},b\mapsto br\)</span>.此时落在<span class="math inline">\([k+1,2k+1]\)</span>的期望就已经<span class="math inline">\(\geq \frac{|B|}{3}\)</span>.<span class="math inline">\(p\)</span>取足够大能包住<span class="math inline">\(B\)</span>即可.</p>
<h6><span id="example7">Example7</span></h6>
<p>求证:存在一个竞赛图,其中的哈密顿路的数量<span class="math inline">\(\geq \frac{n!}{2^{n-1}}\)</span>.</p>
<p>这个好像非常平凡,随机图上随机一个排列然后它是哈密顿路的概率就是<span class="math inline">\(2^{n-1}\)</span>.</p>
<h6><span id="example8">Example8</span></h6>
<p>我们称竞赛图的<span class="math inline">\(S_k\)</span>性质是,任何<span class="math inline">\(k\)</span>个点组成的子集,都存在一个点赢过了这<span class="math inline">\(k\)</span>个点.问是否总存在一个竞赛图满足<span class="math inline">\(S_k\)</span>性质.</p>
<p>随机一个竞赛图,考虑其任何一个大小为<span class="math inline">\(k\)</span>的子集.对于外面一个点<span class="math inline">\(u\)</span>胜过了这<span class="math inline">\(k\)</span>个点的概率是<span class="math inline">\(2^{-k}\)</span>.外面一个点都没赢的概率是<span class="math inline">\((1-2^{-k})^{n-k}\)</span>.于是用Union
Bound,存在一个问题的概率<span class="math inline">\(\leq
\binom{n}{k}(1-2^{-k})^{n-k}\)</span>.显然<span class="math inline">\(n\to \infty\)</span>的时候这玩意趋近于<span class="math inline">\(0\)</span>,所以肯定能找到满足条件的.</p>
<h6><span id="example9">Example9</span></h6>
<p>考虑一系列向量<span class="math inline">\(\vec v_1,\cdots \vec v_n\in
\{-1,1\}^l\)</span>,求证:</p>
<ol type="1">
<li><span class="math inline">\(\exists a_1,\cdots,a_n\in
\{-1,1\}\)</span>,使得<span class="math inline">\(\Vert\sum a_i\vec
l_i\Vert^2\geq nl\)</span>.</li>
<li><span class="math inline">\(\exists a_1,\cdots,a_n\in
\{-1,1\}\)</span>,使得<span class="math inline">\(\Vert\sum a_i\vec
l_i\Vert^2\leq nl\)</span>.</li>
</ol>
<p>只要证明这玩意期望就是<span class="math inline">\(nl\)</span>即可,随机<span class="math inline">\(\{a_i\}\)</span>,容易见到<span class="math inline">\(E(a_i)=0,E(a_i^2)=1,E(a_ia_j)=E(a_i)E(a_j)=0\)</span>.带进去算一下.</p>
<h6><span id="example10">Example10</span></h6>
<p>求证:随机一个<span class="math inline">\(x\in[1,n]\)</span>,使得<span class="math inline">\(P(|v(x)-\ln\ln n|&gt;\lambda \sqrt{\ln\ln n})\leq
\lambda^{-2}\)</span>.</p>
<p>拆贡献用Chebyshev不等式硬估,懒得抄过程了.</p>
<h6><span id="example11">Example11</span></h6>
<p>考虑一个随机图<span class="math inline">\(G(n,m)\)</span>,也就是从<span class="math inline">\(\frac{n(n-1)}{2}\)</span>中随机<span class="math inline">\(m\)</span>条边留下.这上面可能有若干随着<span class="math inline">\(m\)</span>单调的性质,比如连通性之类的.我们下面证明:对于一个单调性质<span class="math inline">\(P\)</span>,存在一个函数<span class="math inline">\(m^*(n)\)</span>,使得:</p>
<ol type="1">
<li>当<span class="math inline">\(m(n)=\omega(m^*(n))\)</span>时,总有<span class="math inline">\(\lim_{n\to \infty}Pr_{G\sim G(n,m(n))}(G\in
P)=1\)</span>.</li>
<li>当<span class="math inline">\(m(n)=o(m^*(n))\)</span>时,总有<span class="math inline">\(\lim_{n\to \infty}Pr_{G\sim G(n,m(n))}(G\in
P)=0\)</span>.</li>
</ol>
<p>下面简单记<span class="math inline">\(Pr_{G\sim G(n,m)}(G\in
P)=Pr_{n,m}\)</span>.</p>
<p>现在考虑<span class="math inline">\(Pr_{n,mk}\)</span>,显然我们可以随机<span class="math inline">\(k\)</span>次,然后再把它们拼起来(虽然有重边,但是单调性质可以不管这个),从而<span class="math inline">\(1-Pr_{n,mk}\leq (1-Pr_{n,m})^k\)</span>.</p>
<p>直接选取<span class="math inline">\(m^*(n)\)</span>为使得<span class="math inline">\(Pr_{n,m^*(n)}\geq
\frac{1}{2}\)</span>的最小的解.则立刻就可以控制住.</p>
<p>不过,部分的单调性质有更强的性质,即<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,当<span class="math inline">\(m(n)\geq(1+\epsilon)m^*(n)\)</span>的时候就可以控制住,当<span class="math inline">\(m(n)\leq
(1-\epsilon)m^*(n)\)</span>也可以控制住.甚至更强地,对于有的性质,这个<span class="math inline">\(\epsilon\)</span>还可以换成<span class="math inline">\(\epsilon(n)=o(1)\)</span>.</p>
<h6><span id="example12">Example12</span></h6>
<p>现在来看连通性的性质,假设以<span class="math inline">\(\frac{\log
n-\alpha(n)}{n}\)</span>的概率随机每条边,那么一个点成为孤点的概率就是<span class="math inline">\((1-\frac{\log n-\alpha(n)}{n})^{n-1}\approx
\frac{1}{n}e^{\alpha(n)}\)</span>.从而孤立点个数(设为<span class="math inline">\(W\)</span>)的期望就是<span class="math inline">\(e^{\alpha(n)}\)</span>.</p>
<p>接下来算<span class="math inline">\(\mathrm{Var}(W)\)</span>,拆开硬算算,得到<span class="math inline">\(\mathrm{Var}(W)=e^{\alpha(n)}+O(1)\)</span>.</p>
<p>然而<span class="math inline">\(W\)</span>非负,从而: <span class="math display">\[
\begin{aligned}
Pr[W=0]&amp;\leq Pr[|W-E|\geq E]\\
&amp;\leq \frac{\mathrm{Var}(W)}{E^2(W)}\\
&amp;\approx \frac{e^{\alpha(n)}+O(1)}{e^{2\alpha(n)}}
\end{aligned}
\]</span> 于是只要<span class="math inline">\(\alpha(n)\to\infty\)</span>就完蛋了,这个图甚至会出现孤点.</p>
<p>现在假设以<span class="math inline">\(\frac{\log
n+\alpha(n)}{n}\)</span>的概率随机每条边,和上面一样,由于期望足够小,用Markov不等式,我们可以证明此时孤立点消失了.</p>
<p>然后需要把剩下的部分处理一下,存在一个大小为<span class="math inline">\(k\in
[2,\frac{n}{2}]\)</span>的块与外界不连通的概率是<span class="math inline">\(\binom{n}{k}(1-p)^{k(n-k)}\)</span>,考虑<span class="math inline">\(1-p\leq e^{-p}\)</span>和<span class="math inline">\(\binom{n}{k}\leq
(\frac{ne}{k})^k\)</span>,于是这个概率被<span class="math inline">\((\frac{ne}{k}e^{-p(n-k)})^k\)</span>限制住了.</p>
<p>当<span class="math inline">\(k\in [2,\epsilon n]\)</span>的时候<span class="math inline">\(n-k=O(n)\)</span>,从而这个概率立刻被限制住.反之当<span class="math inline">\(k\in [\epsilon n,\frac{n}{2}]\)</span>的时候<span class="math inline">\(k(n-k)=O(n^2)\)</span>,但是组合数被压到了<span class="math inline">\((\frac{e}{\epsilon})^{O(n)}\)</span>,这就足够跑赢了.</p>
<h2><span id="统计">统计</span></h2>
<h3><span id="点估计">点估计</span></h3>
<p>将只依赖于样本,不依赖于任何位置参数的函数称作<strong>统计量</strong>.例如:</p>
<ol type="1">
<li>样本均值<span class="math inline">\(\bar X=\frac{1}{n}\sum_{i=1}^n
X_i\)</span>.</li>
<li>样本方差<span class="math inline">\(S^2=\frac{1}{n-1}\sum_{i=1}^n(X_i-\bar
X)^2\)</span>.</li>
<li>样本<span class="math inline">\(k\)</span>阶矩<span class="math inline">\(A_k=\frac{1}{n}\sum_{i=1}^n X_i^k\)</span>.</li>
<li>样本<span class="math inline">\(k\)</span>阶中心矩<span class="math inline">\(B_k=\frac{1}{n}\sum_{i=1}^n(X_i-\bar
X)^k\)</span>.</li>
</ol>
<p>对于<span class="math inline">\(\theta\)</span>的估计量<span class="math inline">\(\hat
\theta\)</span>,定义<strong>偏差</strong><span class="math inline">\(\mathrm{Bias}(\hat \theta)=E(\hat
\theta)-\theta\)</span>.如果其等于<span class="math inline">\(0\)</span>,则称其是<strong>无偏</strong>的.如果<span class="math inline">\(\lim_{n\to \infty}\mathrm{Bias}(\hat
\theta)=\theta\)</span>,则称<span class="math inline">\(\hat\theta\)</span>是<strong>渐进无偏</strong>的.</p>
<p>此外定义<span class="math inline">\(\mathrm{MSE}(\hat
\theta)=E\left((\hat\theta-\theta)^2\right)\)</span>.容易见到: <span class="math display">\[
\begin{aligned}
\mathrm{MSE}(\hat\theta)&amp;=E\left((\hat\theta-\theta)^2\right)\\
&amp;=E\left((\hat\theta-E(\hat\theta)+E(\hat\theta)-\theta)^2\right)\\
&amp;=E\left((\hat\theta-E(\hat\theta))^2\right)+\left(E(\hat\theta)-\theta\right)^2\\
&amp;=\mathrm{Var}(\hat \theta)+\left(\mathrm{Bias}(\hat\theta)\right)^2
\end{aligned}
\]</span> 因此对于无偏估计的<span class="math inline">\(\mathrm{MSE}(\hat\theta)=\mathrm{Var}(\hat\theta)\)</span>.</p>
<p>此外,如果估计量依概率收敛,或言<span class="math inline">\(\forall
\epsilon&gt;0\)</span>,<span class="math inline">\(\lim_{n\to
\infty}P\left(|\hat\theta_n-\theta|\geq
\epsilon\right)=0\)</span>,则称<span class="math inline">\(\hat\theta_n\)</span>是<strong>一致估计量</strong>.</p>
<p>我们有性质:如果<span class="math inline">\(\lim_{n\to
\infty}\mathrm{MSE}(\hat\theta_n)\to 0\)</span>,则<span class="math inline">\(\hat\theta_n\)</span>为一致估计量.原因是: <span class="math display">\[
\begin{aligned}
&amp;P\left(|\hat\theta_n-\theta|\geq \epsilon\right)\\
=&amp;P\left((\hat\theta_n-\theta)^2\geq \epsilon^2\right)\\
\leq &amp;\frac{\mathrm{MSE}(\hat\theta_n)}{\epsilon^2}
\end{aligned}
\]</span></p>
<h6><span id="example1">Example1</span></h6>
<p>假设<span class="math inline">\(E(X)\)</span>和<span class="math inline">\(\mathrm{Var}(X)\)</span>均存在,独立随机的样本序列<span class="math inline">\(X_1,\cdots,X_n\)</span>,现在考虑<span class="math inline">\(\hat\theta_A=\bar X\)</span>,<span class="math inline">\(\hat \theta_B=X_1\)</span>.</p>
<p>显然它们都是<span class="math inline">\(E(X)\)</span>的无偏估计.然而<span class="math inline">\(\mathrm{MSE}(\hat\theta_A)=\frac{\mathrm{Var}(X)}{n}\)</span>,而<span class="math inline">\(\mathrm{MSE}(\hat\theta_B)=\mathrm{Var}(X)\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>假设已知<span class="math inline">\(X\sim
U(0,\theta)\)</span>.考虑<span class="math inline">\(\hat\theta_A=2\bar
X\)</span>和<span class="math inline">\(\hat\theta_B=\max_k\{X_k\}\)</span>.</p>
<p>容易见到<span class="math inline">\(\hat\theta_A\)</span>无偏.现在来看<span class="math inline">\(\hat\theta_B\)</span>,自然地: <span class="math display">\[
\begin{aligned}
F_{\hat\theta_B}(x)&amp;=(F_X(x))^n\\&amp;=(\frac{x}{\theta})^n\\
E(\hat\theta_B)&amp;=\int_0^{+\infty}(1-F_{\hat\theta_B}(x))\mathrm{d}x\\
&amp;=\int_0^\theta(1-(\frac{x}{\theta})^n)\mathrm{d}x\\
&amp;=\frac{n}{n+1}\theta
\end{aligned}
\]</span> 但至少<span class="math inline">\(\hat\theta_C=\frac{n+1}{n}\hat\theta_B\)</span>无偏.</p>
<p>现在来看,容易见到<span class="math inline">\(\mathrm{MSE}(\hat\theta)=\frac{\theta^2}{3n}\)</span>.留神到:
<span class="math display">\[
\begin{aligned}
E(\hat\theta_B^2)&amp;=\int_0^{\theta^2}\left(1-\frac{x^{\frac{n}{2}}}{\theta^n}\right)\mathrm{d}x\\
&amp;=\theta^2-\frac{2}{n+2}\theta^2\\
&amp;=\frac{n}{n+2}\theta^2
\end{aligned}
\]</span> 于是<span class="math inline">\(\mathrm{Var}(\hat\theta_C^2)=(\frac{n+1}{n})^2\mathrm{Var}(\hat\theta_B^2)=\frac{\theta^2}{n(n+2)}\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>考虑<span class="math inline">\(B_2\)</span>对<span class="math inline">\(\mathrm{Var}(X)\)</span>的估计,显然有<span class="math inline">\(B_2=\frac{1}{n}\sum_k X_k^2-(\bar
X)^2\)</span>.也就是说<span class="math inline">\(E(B_2)=E(X^2)-E(\bar
X^2)\)</span>.看上去欣欣向荣,然而: <span class="math display">\[
\begin{aligned}
E(\bar X^2)&amp;=E((\bar X-E(\bar X)+E(\bar X))^2)\\
&amp;=E((\bar X-E(\bar X))^2)+(E(\bar X))^2\\
&amp;=(E(\bar X))^2+\frac{\mathrm{Var}(X)}{n}
\end{aligned}
\]</span> 这就出事了.</p>
<h6><span id="example4正态分布">Example4(正态分布)</span></h6>
<p>考虑估计一个正态分布<span class="math inline">\(X\sim
N(\mu,\sigma^2)\)</span>.取<span class="math inline">\(\bar
X\)</span>和<span class="math inline">\(S^2\)</span>作为其期望和方差的估计量.现在我们将展示一个非常厉害的结论,那就是<span class="math inline">\(\bar X\)</span>和<span class="math inline">\(S^2\)</span>实际上是独立的.</p>
<p>考虑一个正交矩阵<span class="math inline">\(U\)</span>,其第一行每个元素限定为<span class="math inline">\(\frac{1}{\sqrt
n}\)</span>,其余行任取.由于其正交性,这必然意味着其余行所有元素之和为<span class="math inline">\(0\)</span>.现在来取<span class="math inline">\(\vec Y=U\vec X\)</span>.从前的结论告知我们<span class="math inline">\(\vec Y\)</span>服从<span class="math inline">\(n\)</span>维高斯分布.而且:</p>
<ol type="1">
<li><span class="math inline">\(E(\vec Y)=(\sqrt
n\mu,0,\cdots,0)\)</span>.</li>
<li><span class="math inline">\(\mathrm{Cov}(\vec
Y)=\sigma^2I\)</span>.</li>
<li><span class="math inline">\(\sum_k Y_k^2=\sum_k X_k^2\)</span>.</li>
</ol>
<p>其中(1)是由于除第一行外,每一行的所有元素和为<span class="math inline">\(0\)</span>.(2)是因为原本的<span class="math inline">\(\vec
X\)</span>的各个分量独立.(3)是因为正交变换保模长.</p>
<p>此时必定有<span class="math inline">\(\bar X=\frac{Y_1}{\sqrt
n}\)</span>,事实上还有: <span class="math display">\[
\begin{aligned}
(n-1)S^2&amp;=\sum_{i=1}^n(X_i-\bar X)^2\\
&amp;=(\sum_k X_k^2)-n\bar X^2\\
&amp;=\sum_{k=1}^nY_k^2-Y_1^2\\
&amp;=\sum_{k=2}^nY_k^2
\end{aligned}
\]</span> 于是二者独立.还能得知<span class="math inline">\(\bar X\sim
N(\mu,\frac{\sigma^2}{n})\)</span>,以及<span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)\)</span>.</p>
<h4><span id="矩法">矩法</span></h4>
<p>显然<span class="math inline">\(k\)</span>阶矩的估计总是无偏的.因此一个想法是将我们想要估计的量写成矩的函数,再分别估计矩(注意,这样做在该函数并非一次的时候当然未必无偏).</p>
<h4><span id="最大似然估计">最大似然估计</span></h4>
<p>尝试选择参数<span class="math inline">\(\theta\)</span>,使得<span class="math inline">\(L(\theta)=P(X_1=x_1,\cdots,X_n=x_n|\theta)\)</span>最大.</p>
<p>如果样本干脆是均匀随机的,那就只需要最大化对数似然函数<span class="math inline">\(\ln L(\theta)=\sum_{i=1}^n \ln
P(X_i=x_i|\theta)\)</span>.</p>
<p>这样做当然不可能是无偏的.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑一个均匀分布<span class="math inline">\(U(0,\theta)\)</span>,对其进行最大似然估计的结果是<span class="math inline">\(\hat\theta=\max\{x_1,\cdots,x_n\}\)</span>.</p>
<h6><span id="example2">Example2</span></h6>
<p>考虑一个分类函数<span class="math inline">\(f:X\to
Y\)</span>.现在我们已经有其采样的一些结果<span class="math inline">\((x_i,y_i)\)</span>,想要去估计一个函数<span class="math inline">\(f_\theta\)</span>.根据上面说的,我们需要最小化<span class="math inline">\(\sum_{i=1}^n-\ln f_\theta(y_i|x_i)\)</span>.</p>
<p>现在考虑一个标签分布<span class="math inline">\(g(y|x_i)=[y=y_i]\)</span>.我们来看交叉熵: <span class="math display">\[
\begin{aligned}
H(g,f_\theta)&amp;=-\sum_{y}g(y|x_i)\ln f_\theta(y|x_i)\\
&amp;=-\ln f_\theta(y_i|x_i)
\end{aligned}
\]</span></p>
<h3><span id="区间估计">区间估计</span></h3>
<p>我们想要更进一步,对于一个想要估计量<span class="math inline">\(\theta\)</span>,以及两个统计量<span class="math inline">\(\hat\theta_L\)</span>和<span class="math inline">\(\hat\theta_R\)</span>,如果必有<span class="math inline">\(P(\hat\theta_L\leq \theta\leq \hat\theta_U)\geq
1-\alpha\)</span>,则称<span class="math inline">\([\hat\theta_L,\hat\theta_R]\)</span>为<span class="math inline">\(\theta\)</span>的<strong>置信水平</strong>为<span class="math inline">\(1-\alpha\)</span>的<strong>置信区间</strong>.类似还可以定义<strong>单侧置信下限</strong>和<strong>单侧置信上限</strong>.</p>
<h6><span id="example1">Example1</span></h6>
<p>对于一个<span class="math inline">\(X\sim
N(\mu,\sigma^2)\)</span>,假设<span class="math inline">\(\sigma^2\)</span>已知,设计一个对<span class="math inline">\(\mu\)</span>的置信水平为<span class="math inline">\(1-\alpha\)</span>的估计.</p>
<p>考虑<span class="math inline">\(\bar X\sim
N(\mu,\frac{\sigma^2}{n})\)</span>.此时必定有<span class="math inline">\(\frac{\bar X-\mu}{\frac{\sigma}{\sqrt{n}}}\sim
N(0,1)\)</span>.只需要取一组<span class="math inline">\(c,d\)</span>,使得<span class="math inline">\(P(c\leq \frac{\bar
X-\mu}{\frac{\sigma}{\sqrt{n}}}\leq d)=1-\alpha\)</span>即可.</p>
<p>现在取<span class="math inline">\(\Phi(x)=\int_{-\infty}^x\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}\mathrm{d}t\)</span>为其分布函数,取<span class="math inline">\(c=\Phi^{-1}(\frac{\alpha}{2}),d=\Phi^{-1}(1-\frac{\alpha}{2})\)</span>.留神到<span class="math inline">\(c+d=0\)</span>.化简就有: <span class="math display">\[
P(\bar X-\frac{\Phi^{-1}(1-\frac{\alpha}{2})\sigma}{\sqrt n}\leq \mu\leq
\bar X+\frac{\Phi^{-1}(1-\frac{\alpha}{2})\sigma}{\sqrt n})=1-\alpha
\]</span> 不过这个估计因为要算<span class="math inline">\(\Phi^{-1}\)</span>,可能意义不是特别大.回忆到Chernoff
Bound给出: <span class="math display">\[
P(X-E(X)\geq k\sigma)\leq e^{-\frac{k^2}{2}}
\]</span> 于是立刻有<span class="math inline">\(P(|\bar X-\mu|\geq
\frac{k\sigma}{\sqrt n})\leq 2e^{-\frac{k^2}{2}}\)</span>.</p>
<p>从而: <span class="math display">\[
P(\bar X-\frac{\sigma\sqrt{2\ln(\frac{2}{\alpha})}}{\sqrt n}\leq \mu\leq
\bar X+\frac{\sigma\sqrt{2\ln(\frac{2}{\alpha})}}{\sqrt n})\geq 1-\alpha
\]</span>
现在我们来干另一件事,众所周知,中心极限定理说大部分估计最后都会趋于一个正态分布.那么在此时,能否估计出<span class="math inline">\(P(\mu=\bar X)=O(\frac{1}{\sqrt n})\)</span>呢?</p>
<p>考虑取<span class="math inline">\(\alpha=1-O(\frac{1}{\sqrt
n})\)</span>,就可以发现这个时候的<span class="math inline">\(\mu\)</span>已经落在<span class="math inline">\(\bar X\pm O(1)\)</span>的区间内了.</p>
<h6><span id="example2">Example2</span></h6>
<p>考虑对<span class="math inline">\(X\sim B(1,p)\)</span>.设计<span class="math inline">\(p\)</span>的置信水平<span class="math inline">\(1-\alpha\)</span>的置信区间.</p>
<p>直接考虑Chernoff Bound,给出<span class="math inline">\(P(|\bar
X-p|&gt;\epsilon)\leq 2e^{-2n\epsilon^2}\)</span>.取<span class="math inline">\(\epsilon=\sqrt{\frac{\ln\frac{2}{\alpha}}{2n}}\)</span>,于是:
<span class="math display">\[
P(\bar X-\sqrt{\frac{\ln(\frac{2}{\alpha})}{2n}}\leq p\leq \bar
X+\sqrt{\frac{\ln(\frac{2}{\alpha})}{2n}})\geq 1-\alpha
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">数论相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-15 21:35:01" itemprop="dateModified" datetime="2025-08-15T21:35:01+08:00">2025-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="数据结构理论">数据结构理论</span></h2>
<h3><span id="维度">维度</span></h3>
<h4><span id="b维正交范围">B维正交范围</span></h4>
<p>对于一个<span class="math inline">\(B\)</span>维的点<span class="math inline">\(x\)</span>,满足<span class="math inline">\(\forall
1 \leq i \leq B , l_i \leq x_i \leq
r_i\)</span>,称所有这样的点组成的集合为一个<span class="math inline">\(B\)</span>维正交范围.</p>
<p>一维正交范围就是区间,二维正交范围是矩形,三维正交范围是立方体.</p>
<p>另外,如果<span class="math inline">\(l ,
r\)</span>有若干个是自动满足的(所有点都满足),那么我们称它为无用限制,如果一个<span class="math inline">\(B\)</span>维正交范围有<span class="math inline">\(k\)</span>个有用限制,称它为<span class="math inline">\(k - side\)</span>的.</p>
<p>例如,找到区间<span class="math inline">\([ l , r ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(3 - side\)</span>的.找到区间<span class="math inline">\([ 1 , l ]\)</span>中<span class="math inline">\(&lt; x\)</span>的元素,这个矩形是<span class="math inline">\(2 -
side\)</span>的.有些矩形虽然是高side的,但可能因为某些维度满足可减性,因此可能等价于一个低side的问题.</p>
<p>(lxl:我建议大家遇到题都要把能差分的东西差分到不能差分为止)</p>
<h3><span id="矩阵乘法归约">矩阵乘法归约</span></h3>
<h4><span id="矩阵乘法">矩阵乘法</span></h4>
<p>做<span class="math inline">\(n \times
n\)</span>的矩阵乘法目前得到的最优秀复杂度也是<span class="math inline">\(O ( n^{ 2 . 373 } )\)</span>.</p>
<p>另外可以归约:<span class="math inline">\(01\)</span>矩阵和整数矩阵在去除<span class="math inline">\(\log n\)</span>后的复杂度相同.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1链颜色数问题">Example1(链颜色数问题)</span></h5>
<p>考虑构造一棵树:他有<span class="math inline">\(\sqrt{ n
}\)</span>个叉,每个叉上有<span class="math inline">\(\sqrt{ n
}\)</span>个点.我们将这些叉编号为<span class="math inline">\([ 1 ,
\sqrt{ n } ]\)</span>.然后我们考虑询问两个叉所组成的链的答案,设<span class="math inline">\(f_{ i , j }\)</span>表示数字<span class="math inline">\(j\)</span>是否在<span class="math inline">\(i\)</span>的叉上出现过,不难发现它们合并的时候要对<span class="math inline">\(f\)</span>做或运算,<span class="math inline">\(01\)</span>矩阵乘法相当于且运算,显然这两个运算等价,证毕.</p>
<h5><span id="example2区间逆序对">Example2(区间逆序对)</span></h5>
<p>考虑对序列和值域同时分块,考虑序列中第<span class="math inline">\(L\)</span>到第<span class="math inline">\(R\)</span>个块的答案,设为<span class="math inline">\(f ( L , R )\)</span>,这两块间的答案设为<span class="math inline">\(g ( L , R )\)</span>,显然<span class="math inline">\(f ( L , R ) = f ( L + 1 , R ) + f ( L , R - 1 ) -
f ( L + 1 , R - 1 ) + g ( L , R )\)</span>,而由于对值域分块,<span class="math inline">\(g ( L , R ) = \sum a \times
b\)</span>的形式.根据这个形式构造即可.当然这个只是简化了好多,你会发现这个东西只能处理矩阵某一行递增的情况.lxl:真正的归约是很复杂的.</p>
<h5><span id="example3">Example3</span></h5>
<p>平面上有若干点,两个操作:每次将横坐标小于等于<span class="math inline">\(A\)</span>的点加上<span class="math inline">\(v\)</span>,或者查询纵坐标小于等于<span class="math inline">\(B\)</span>的点的点权和.</p>
<p>这玩意显然能加上扫描线归约区间逆序对.</p>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="分块">分块</span></h3>
<h5><span id="example1luogup8527ynoi2003-樋口円香">Example1(luoguP8527
[Ynoi2003] 樋口円香)</span></h5>
<p>首先将<span class="math inline">\(a\)</span>分块,这样对于一次修改就分成了整块和散块.散块暴力做,整块的话显然是一个位移的形式,可以直接卷积,比较简单.</p>
<p>不过我们先考虑个事:这么顺溜就出来了,为啥会需要分块啊?</p>
<p>首先看到题面的位移的形式,自然想到卷积.但问题在于有个区间,所以需要把区间处理掉.注意到每个区间是需要记录一下不同的<span class="math inline">\(L\)</span>的,这使得这个问题只能使用分块解决.</p>
<p>最后还没完,这题要平衡复杂度.</p>
<p>设块长为<span class="math inline">\(B\)</span>,暴力处理散块的复杂度是<span class="math inline">\(O ( Bm )\)</span>,处理整块的复杂度是<span class="math inline">\(O ( \frac{ n }{ B } ( m + n \log n )
)\)</span>.取<span class="math inline">\(B^2 = \frac{ n }{ m } ( m + n
\log n ) = 500\)</span>最优.</p>
<p>但事实上FFT肯定是很慢的,所以我开到了<span class="math inline">\(B =
2048\)</span>.</p>
<p>即使这样,笔者还是被卡常了(哭).</p>
<h5><span id="example2luoguynoi2079riapq">Example2(luogu[Ynoi2079]
riapq)</span></h5>
<p>首先对于这种区间内部贡献,而且每个点由前面点的贡献,先看有没有可差分性(区间逆序对也是一个套路).</p>
<p>注意到是有的,这样我们就把问题转化为了<span class="math inline">\([ 1
, l - 1 ]\)</span>对<span class="math inline">\([ l , r
]\)</span>的贡献.</p>
<p>先序列分块.然后<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块对<span class="math inline">\([ l , r
]\)</span>的贡献是简单的:我们对每个整块开一个区间加单点查的树状数组,每次将<span class="math inline">\([ 1 , l - 1
]\)</span>中的整块的树状数组进行一个<span class="math inline">\([ l , r
]\)</span>的区间加,查询的时候查一下每个整块对当前单点的贡献,这里需要对整块内部提前处理一下小于等于某个数的数量,自然可以做到<span class="math inline">\(O ( Bq \log n )\)</span>的时间复杂度和<span class="math inline">\(O ( Bn )\)</span>的空间复杂度.</p>
<p>问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块咋办.首先<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的散块的贡献是好处理的,因为总共就<span class="math inline">\(O ( \frac{ n }{ B }
)\)</span>个数字,直接全部存下来排序做归并就可以统计,时间复杂度<span class="math inline">\(O ( Bq \log n )\)</span>.</p>
<p>现在的问题在于<span class="math inline">\([ 1 , l - 1
]\)</span>中的散块对<span class="math inline">\([ l , r
]\)</span>中的整块如何贡献.能不能把<span class="math inline">\([ l , r
]\)</span>的信息统计在<span class="math inline">\([ 1 , l - 1
]\)</span>的散块中呢?似乎不太行.因为散块的总数太多了.所以我们考虑把散块的信息记录在整块里.但是好像不太好记,因为你查询一个整块内的点的时候是需要判断记录的这些信息是否比它要小的,只有比它小的才能贡献.自然想到值域分块.不过还有一个问题,就是散块一共有<span class="math inline">\(\frac{ n }{ B }\)</span>个,整块一共有<span class="math inline">\(B\)</span>个,是不能一一对应着贡献的,这咋办呢?</p>
<p>其实挺好办的,因为散块要对一个区间有贡献,所以拿树状数组+差分统计一下就行.</p>
<p>最终复杂度为<span class="math inline">\(O ( n \sqrt{ n } \log n
)\)</span>,需要进行一个极致卡常.</p>
<p>如果你写完代码测一下会发现,跑的最慢的是散块对散块的贡献,你把sort改成基数排序就行.事实上实测了一下基数排序还不如直接换成树状数组.</p>
<p>但即使这样,笔者现在也没过这个题(哭).</p>
<h5><span id="example3cts2022普罗霍洛夫卡">Example3([CTS2022]
普罗霍洛夫卡)</span></h5>
<p>比较复杂的分块题.</p>
<p>放弃了,太难了.</p>
<h5><span id="example4walking-plan-hdu6331">Example4(Walking Plan HDU
6331)</span></h5>
<p>类似BSGS一样分块处理即可,最后需要枚举中继点,询问部分复杂度<span class="math inline">\(O ( nq )\)</span>.</p>
<h5><span id="example5p5063-ynoi2014置身天上之森">Example5(P5063 [Ynoi2014]
置身天上之森)</span></h5>
<p>考虑如果<span class="math inline">\(n =
2^k\)</span>,很好做,因为每一层的点大小是相等的.我们对每一层分开处理,显然区间加操作也就等价于每一层的节点区间加上若干倍的<span class="math inline">\(a\)</span>(开头结尾可能有两个需要特殊判断),用分块求区间rank的技巧就行.</p>
<p>但是<span class="math inline">\(n\)</span>不一定是<span class="math inline">\(2^k\)</span>,也简单,每一层最多有两种不一样大小的点,这是经典结论.</p>
<h5><span id="example6第二分块ynoi2018五彩斑斓的世界">Example6(第二分块:[Ynoi2018]五彩斑斓的世界)</span></h5>
<p>大概是对于每个块处理出它的值域范围:一开始是<span class="math inline">\([ 1 , n
]\)</span>,然后每次操作都会将整个块分为两部分:<span class="math inline">\([ 1 , x )\)</span>和<span class="math inline">\([
x , maxn ]\)</span>,讨论一下<span class="math inline">\(maxn\)</span>和<span class="math inline">\(2
x\)</span>的大小,就可以用<span class="math inline">\(\min ( x , maxn - x
)\)</span>的复杂度使得<span class="math inline">\(maxn\)</span>变成<span class="math inline">\(maxn - x\)</span>,复杂度均摊掉了.</p>
<h3><span id="二次离线">二次离线</span></h3>
<h5><span id="example1luogup5047ynoi2019-模拟赛-yuno-loves-sqrt-technology-ii">Example1(luoguP5047
[Ynoi2019 模拟赛] Yuno loves sqrt technology II)</span></h5>
<p>简单来说就是区间逆序对数.</p>
<p>首先想到莫队,然后配一个树状数组就可以做到<span class="math inline">\(O ( n \sqrt{ n } \log n )\)</span>.</p>
<p>那我们怎么改这个东西呢?</p>
<p>我们注意到:我们莫队在实现的无非是俩事:一个是移动左端点的时候判断左端点对右边的贡献,一个是移动右端点的时候,由于这俩是对称的,我们只讨论左端点不动移动右端点.</p>
<p>考虑这个过程的答案实际上是可差分的,因为<span class="math inline">\([
l , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献实际上就是<span class="math inline">\([ 1 , r ]\)</span>对<span class="math inline">\(r\)</span>的贡献减去<span class="math inline">\([
1 , l - 1 ]\)</span>对<span class="math inline">\(r\)</span>的贡献,前者可以直接算,而后者呢?</p>
<p>我们考虑对后者再进行一次离线操作,我们把这<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次贡献查询全都记下来,然后扫描线处理一下.注意到我们只需要插入<span class="math inline">\(O ( n )\)</span>次但是需要查询<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次,所以需要使用一下值域分块平衡一下复杂度.</p>
<p>做到这里其实要做完了,但还没完,这里空间复杂度达到了<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>,有点大.咋办呢?我们发现右端点移动的时候左端点不动,并且右端点移动的是一个区间,所以我们把所有不动的左端点上记录一下右端点移动的区间即可,由于不动的左端点只有可能是查询区间的左端点,所以这里空间复杂度降到<span class="math inline">\(O ( n )\)</span>.</p>
<p>注意到我们求出的是两个查询的答案的差分,最后还需要做一下前缀和求答案.</p>
<h3><span id="二维分块">二维分块</span></h3>
<p>我们现在有一个需要维护的<span class="math inline">\(n \times
n\)</span>的平面,我们现在对其进行分块:</p>
<ol type="1">
<li><p>将平面分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{
\frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(A\)</span>块,以<span class="math inline">\(A\)</span>块为单位做二维前缀和.</p></li>
<li><p>每个<span class="math inline">\(A\)</span>块内部分成<span class="math inline">\(n^{ \frac{ 1 }{ 2 } }\)</span>个<span class="math inline">\(n^{ \frac{ 1 }{ 2 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>的<span class="math inline">\(B\)</span>块,在<span class="math inline">\(A\)</span>块内部以<span class="math inline">\(B\)</span>块为单位做二维前缀和.</p></li>
<li><p>将整个平面横着分别分成一个个<span class="math inline">\(n \times
n^{ \frac{ 3 }{ 4 } }\)</span>的<span class="math inline">\(C\)</span>块.(竖着也要分成一个个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times
n\)</span>的块,是类似的,略去)</p></li>
<li><p>每个<span class="math inline">\(C\)</span>块内部分成<span class="math inline">\(\sqrt{ n }\)</span>个<span class="math inline">\(n^{ \frac{ 3 }{ 4 } } \times n^{ \frac{ 1 }{ 2 }
}\)</span>个<span class="math inline">\(D\)</span>块,在<span class="math inline">\(C\)</span>块内部以<span class="math inline">\(D\)</span>块为单位做二位前缀和.</p></li>
</ol>
<p>注意到修改一个点的时候,需要更新三次二位前缀和,每次复杂度<span class="math inline">\(O ( \sqrt{ n }
)\)</span>.同时注意到空间复杂度是<span class="math inline">\(O ( n
)\)</span>的.</p>
<p>查询显然是分四种情况讨论:<span class="math inline">\(A , B ,
D\)</span>块都可以快速求得答案,接下来只需要做一下散块就行.</p>
<p>那散块怎么做呢?我们考虑一个特殊情况:修改点的纵坐标以及横坐标两两不同,或至少一个坐标只对应<span class="math inline">\(O ( 1 )\)</span>个点.</p>
<p>如果查询的时候,也仍然是满足查询的一个<span class="math inline">\(l\)</span>对应<span class="math inline">\(O ( 1
)\)</span>个<span class="math inline">\(r\)</span>,我们就可以枚举一个点被哪些查询查到了散块,显然只有可能有<span class="math inline">\(O ( \sqrt{ n }
)\)</span>个查询,记录一下即可.这样就做到了<span class="math inline">\(O
( \sqrt{ n } )\)</span>单点改,<span class="math inline">\(O ( 1
)\)</span>查询.</p>
<p>如果我们一开始不做二维前缀和,就可以实现<span class="math inline">\(O
( 1 )\)</span>单点改,那这种情况下如何实现<span class="math inline">\(O (
\sqrt{ n } )\)</span>求和呢?首先还是可以<span class="math inline">\(O (
\sqrt{ n } )\)</span>求出整块的和.</p>
<p>横着和竖着的散块相同,只讨论横着的.由于横着的散块高度<span class="math inline">\(&lt; n^{ \frac{ 1 }{ 2 }
}\)</span>,我们就可以在每次查询的时候用<span class="math inline">\(\sqrt{ n
}\)</span>的复杂度枚举一遍横纵坐标在这个区间的点然后暴力判断即可,也可以<span class="math inline">\(O ( \sqrt{ n } )\)</span>求散块.</p>
<h5><span id="example1luogup7448-ynoi2007rdiq">Example1(luoguP7448 [Ynoi2007]
rdiq)</span></h5>
<p>首先注意到这个问题严格难于区间逆序对,想到二次离线莫队.</p>
<p>开始做二次离线,发现问题在于我们需要求出右端点移动的时候,找到新增了多少个本质不同的逆序对.设上一个和<span class="math inline">\(a_r\)</span>颜色相同的点是<span class="math inline">\(r
&#39;\)</span>,则显然新增的逆序对只可能出现在<span class="math inline">\([ r &#39; , r ]\)</span>中.</p>
<p>由于我们现在在保证左端点不动,于是我们考虑对于每种颜色,找到其在这个左端点后第一次出现的位置,并且只在这个位置贡献答案.这里其实已经可以扫描线了,套一下二次离线,把点扔到二位坐标系上.</p>
<p>现在问题在于,我们需要从<span class="math inline">\(n \rightarrow
1\)</span>扫左端点,总共做<span class="math inline">\(O ( n
)\)</span>次单点修改,做<span class="math inline">\(O ( n \sqrt{ n }
)\)</span>次矩阵查询.</p>
<p>现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; +
1 , a_r )\)</span>,右上角是<span class="math inline">\(( r , \infty
)\)</span>的矩阵.</p>
<p>这个东西其实已经可以做高维前缀和了.为了使答案更显然,我们令<span class="math inline">\(rev ( x ) = n - x +
1\)</span>.然后将所有点的纵坐标<span class="math inline">\(rev\)</span>掉,现在我们要查询的也就是左下角为<span class="math inline">\(( r &#39; + 1 , 1 )\)</span>,右上角是<span class="math inline">\(( r , rev ( a_r )
)\)</span>的矩阵,这玩意可以拆前缀和拆成形如左下角是<span class="math inline">\(( 1 , 1 )\)</span>,右上角是<span class="math inline">\(( i , rev ( a_i )
)\)</span>的矩阵.也就是说我们的<span class="math inline">\(O ( n \sqrt{
n } )\)</span>次矩阵查询本质上只有<span class="math inline">\(O ( n
)\)</span>种.</p>
<p>拆到这里发现其实到这一步<span class="math inline">\(a_r\)</span>和<span class="math inline">\(a_{ r
&#39;
}\)</span>是否相等已经不重要了,可以用一下基数排序让他俩有一定的差异.</p>
<p>然后上二维分块.</p>
<h5><span id="example2luogup8530ynoi2003-博丽灵梦">Example2(luoguP8530
[Ynoi2003] 博丽灵梦)</span></h5>
<p>首先自然的想法是拿莫队扫掉<span class="math inline">\([ l_1 , r_1
]\)</span>这一维.</p>
<p>这样我们的问题转化为:每次插入/删除一个点,求一个类似区间颜色数的东西.</p>
<p>那么这个东西咋做呢?</p>
<p>首先我们考虑插入/删除的本质,把第二维<span class="math inline">\([ l_2
, r_2
]\)</span>扔到二维平面上,那本质也就是需要寻找前驱后继,然后对一个矩形做加法,查询的时候单点查询,可以配个树套树解决这个问题.</p>
<p>有没有什么好办法?先考虑对矩形做加法然后单点查询这个操作看上去很蛋疼.我们考虑把它转化为单点加法矩形查询.这个做法比较显然:如果没有相同的只贡献一次的限制,我们就可以直接对于每个点<span class="math inline">\(( a , a )\)</span>上加上一个相应的<span class="math inline">\(b\)</span>,然后每次查询矩阵即可.但是有了限制怎么办呢?我们考虑在每两个相邻的点<span class="math inline">\(A ( x_1 , x_1 )\)</span>和<span class="math inline">\(B ( x_2 , x_2 )\)</span>之间的<span class="math inline">\(( x_1 , x_2 )\)</span>上加上一个<span class="math inline">\(- b\)</span>,不难发现这样就满足了条件.</p>
<p>分析一下我们现在需要做的东西:</p>
<ol type="1">
<li><p>莫队时查询一个点的前驱后继,这个操作就需要<span class="math inline">\(O ( 1 )\)</span>完成.</p></li>
<li><p><span class="math inline">\(n \sqrt{ n
}\)</span>次单点修改,这个操作需要<span class="math inline">\(O ( 1
)\)</span>完成.</p></li>
<li><p><span class="math inline">\(n\)</span>次矩阵求和,这个操作需要在小于<span class="math inline">\(O ( \sqrt{ n } )\)</span>的时间完成.</p></li>
</ol>
<p>对于第一个问题,我们可能会想到用链表来解决.但问题在于链表难以支持插入操作.不过问题不大,我们有回滚莫队.这样就可以实现只删除不插入,解决了问题.</p>
<p>而后半部分是一个经典的二维分块.</p>
<p>简单来说,我们首先需要猜出时间复杂度为<span class="math inline">\(O (
n \sqrt{ n }
)\)</span>,然后用到莫队,然后用二维平面表示这个问题,发现直接做不太能做,想到一步转化,转化后的问题的一半可以直接套二维分快.最后想到前半部分可以用回滚莫队+链表解决.</p>
<h3><span id="trie树">trie树</span></h3>
<h5><span id="example12019zrtg十连测day1set">Example1([2019zrtg十连测day1]set)</span></h5>
<p>首先反应是扔到trie上然后异或就是打个tag,但是<span class="math inline">\(+
1\)</span>很难处理,因为它形如在trie上找到所有长度连续为<span class="math inline">\(1\)</span>到叶子的链并且全部翻转,不过打一下tag应该也能做.</p>
<p>更简单的做法是,我们考虑从小到大插入数字.这样异或几乎没有影响,但是<span class="math inline">\(+ 1\)</span>的话就相当于反转一条从根开始均为<span class="math inline">\(1\)</span>的链,这个东西更为好做.</p>
<h3><span id="线段树">线段树</span></h3>
<h4><span id="普通线段树">普通线段树</span></h4>
<h5><span id="example1luogup6780ynoi2009-pmrllcsrms">Example1(luoguP6780
[Ynoi2009] pmrllcsrms)</span></h5>
<p>感觉这题比较厉害.</p>
<p>先扔做法:对<span class="math inline">\(c\)</span>分块,这样答案就是块内和块间的最大值.对于每个块都可以用线段树维护最大值,然后最后再求<span class="math inline">\(\max\)</span>.而对于块间如何做呢?</p>
<p>我们设<span class="math inline">\(suf_i\)</span>为前一个块的后<span class="math inline">\(i\)</span>个数之和,<span class="math inline">\(pre_i\)</span>为后一个块的前<span class="math inline">\(i\)</span>个数之和.注意到我们要求的就是<span class="math inline">\(\max \{ suf_i + pre_j | i + j \leq c
\}\)</span>.这个咋做呢?</p>
<p>你注意到这个<span class="math inline">\(i + j \leq
c\)</span>的限制非常的奇怪,我们如果想处理两个东西,自然想让这两个东西联系越紧密越好,但是这个联系就特别奇怪.但没关系,我们注意到如果用<span class="math inline">\(j \rightarrow c - j +
1\)</span>的话,这个限制就转化为了<span class="math inline">\(i + c - j +
1 \leq c\)</span>,也就是<span class="math inline">\(i &lt;
j\)</span>,这个限制就可以放到线段树上维护了.</p>
<p>仔细思考这个过程:线段树只可以维护有大于小于的限制的两个数,而不能维护和区间长度有关的条件.但如果一个限制和区间长度有关,可能可以通过翻转之类的操作取消掉区间长度.</p>
<p>这个问题解决了,我们再回到一开始:为啥要对<span class="math inline">\(c\)</span>分块?</p>
<p>一方面,题目中的<span class="math inline">\(c\)</span>是给定的.另一方面,我们注意到我们需要维护一个和<span class="math inline">\(c\)</span>有关的东西,而如果没有<span class="math inline">\(c\)</span>,或者说<span class="math inline">\(c =
n\)</span>的时候,这个东西是好维护的:一般的区间最大子段和其实暗含了<span class="math inline">\(c = n\)</span>的条件.考虑到这一点,对<span class="math inline">\(c\)</span>分块就合情合理了.换句话说,分块其实有两种用途:一种是平衡暴力的复杂度:它可以让一些和块长有关的暴力复杂度降低.另一种用途是保证某个东西的合法性.</p>
<p>一个需要注意的事是,由于我们最后查询的是一个区间,所以对于块间的处理是需要处理区间的.不过我选择将<span class="math inline">\(a [ l - 1 ]\)</span>和<span class="math inline">\(a [ r + 1 ]\)</span>都加上一个极大值.</p>
<p>但是啊,但是.我们发现我们一开始是需要把块间做线段树的那个<span class="math inline">\(maxn\)</span>设成<span class="math inline">\(-
\infty\)</span>的.如果这两个东西设成等大的<span class="math inline">\(-
\infty\)</span>,就会出现错误,为啥呢?</p>
<p>因为一开始这样会使得运算过程中有可能出现比<span class="math inline">\(- \infty\)</span>还要小的数字,最底层的<span class="math inline">\(maxn\)</span>有可能覆盖掉上面的.</p>
<h4><span id="线段树分治">线段树分治</span></h4>
<p>大概就是用到了线段树结构进行操作,通常用来处理存在区间的问题.</p>
<p>之所以说它是线段树分治而不是一般的分治,是因为有的时候我们还可以利用线段树的结构.</p>
<h5><span id="example12022qbxt国庆day1dottlebot">Example1([2022qbxt国庆Day1]dottlebot)</span></h5>
<p>注意到每个点其实只需要找到<span class="math inline">\([ i - r_i , i -
1 ]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两段的最大值,设为<span class="math inline">\(x\)</span>,则最后的答案就是<span class="math inline">\(\max \{ a_i + x \}\)</span>.</p>
<p>思考这个过程,我们将<span class="math inline">\([ i - r_i , i - 1
]\)</span>和<span class="math inline">\([ i + 1 , i + r_i
]\)</span>这两条线段以<span class="math inline">\(a_i\)</span>的权值放到线段树上.具体地,我们在线段树的每个节点都开一个堆存储覆盖了这个节点区间的线段的权值.然后利用线段树求出每个区间的<span class="math inline">\(a_i\)</span>的最大值,在节点处和堆中元素一起更新答案即可.</p>
<h4><span id="线段树上二分">线段树上二分</span></h4>
<h5><span id="example12022qbxt国庆day3analysis">Example1([2022qbxt国庆Day3]analysis)</span></h5>
<p>考虑全局的和是<span class="math inline">\(sum\)</span>,则我们要在这些数中找到一个分界点,使得左边的和大于等于<span class="math inline">\(sum\)</span>,然后再考虑能不能将右边移动一个过去.</p>
<p>先把数据离散化,那么这就是一个值域线段树上二分的过程.</p>
<p>另外值得一提的是,考虑树状数组的形态也即线段树删去所有的右儿子,因此树状数组上也是可以二分的.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(a_i , b_i\)</span>,选定至多<span class="math inline">\(k\)</span>个位置使这里的值为<span class="math inline">\(a_i - b_i\)</span>,其它位置的值是<span class="math inline">\(a_i\)</span>,最小化最大子段和.</p>
<p>考虑先二分再贪心:二分一个值,然后看如果需要使得答案小于等于这个值,最少需要用多少次操作.这个咋做呢?一个想法是,我先从左到右去扫一遍,然后每次如果当前最大后缀和大于二分的<span class="math inline">\(mid\)</span>,我们就需要找一个位置使得把这个位置改掉后,最大后缀和最小.</p>
<p>首先来看这个为什么是正确的.考虑后面的最大后缀和是会继承前面的最大后缀和的,因此让当前局面最小一定更优秀,并且每个位置选中的代价是相等的,那自然要选择贡献最高的那个.</p>
<p>显然,如果选择一个改掉的话,我们需要求出<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - b_k + \max_{ i = 1 }^k \{ sum_i \} )
\}\)</span>.注意改掉一个位置后要把它的<span class="math inline">\(b\)</span>变成<span class="math inline">\(0\)</span>.</p>
<p>那么什么样的<span class="math inline">\(b\)</span>有可能是我们要选中的呢?显然可能被选中的<span class="math inline">\(b\)</span>一定是一个单调下降的序列中的某个,因为同等大小,选后面一定更优秀.上面那个式子我们是难以快速维护的,但如果我把它改成:<span class="math inline">\(\min_{ k = 1 }^r \{ \max ( \max_{ i = k + 1 }^n \{
sum_{ i } \} , - \max_{ i = k }^n \{ b_i \} + \max_{ i = 1 }^k \{ sum_i
\} )
\}\)</span>,你会发现前者是一个单调不升的序列,后者是一个单调不降的序列,现在我们想要让它们的<span class="math inline">\(\max\)</span>尽量小,这玩意显然可以做线段树二分.</p>
<p>上面那个东西也就是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - sufmax ( b
)_k + premax ( sum )_k \} \\
= &amp; \min_{ k = 1 }^r \{ \max ( sufmax ( sum )_{ k + 1 } , - \max (
sufmax ( b )_{ k + 1 } , b_k ) + premax ( sum )_k \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样就可以在交界点更新答案.</p>
<p>另外,我们实际上更新答案会用到实际上找到的最小的<span class="math inline">\(k\)</span>后面最大的<span class="math inline">\(b\)</span>,这是为啥呢?首先这样的确是更优秀的解,而且我们发现,我们的确有可能找到更靠前的位置,如果往前的挪动不影响<span class="math inline">\(sufmax ( b
)\)</span>的话.那有没有可能跳出了这一段,来到了更靠后的地方呢?这显然也不会,因为我们只找到最后面第一个处于当前分段函数的<span class="math inline">\(b\)</span>,这个<span class="math inline">\(b\)</span>必然存在.如果它所在的sufmax和premax不一样,那么会是一个更优秀的解,压根不可能找到前面.</p>
<h4><span id="线段树合并">线段树合并</span></h4>
<h4><span id="线段树维护矩阵乘法">线段树维护矩阵乘法</span></h4>
<h4><span id="吉司机线段树">吉司机线段树</span></h4>
<h4><span id="李超线段树">李超线段树</span></h4>
<h3><span id="珂朵莉树">珂朵莉树</span></h3>
<h5><span id="example1luogup8512ynoi-easy-round-2021-test_152">Example1(luoguP8512
[Ynoi Easy Round 2021] TEST_152)</span></h5>
<p>首先有经典套路:赋值操作有用的只有最后一次.</p>
<p>所以考虑扫描线,扫右端点的时候直接用珂朵莉树做.这样就剩下左端点的问题,因为有珂朵莉树,所以再开以时间为下标的数据结构就能处理.</p>
<h3><span id="猫树">猫树</span></h3>
<h3><span id="kd-tree">KD-Tree</span></h3>
<p>处理<span class="math inline">\(K\)</span>维正交范围(给定<span class="math inline">\(n\)</span>个有意义的点)在线修改查询的数据结构,是一棵二叉树.单次复杂度<span class="math inline">\(O ( n^{ 1 - \frac{ 1 }{ k } } + \log n
)\)</span>.(单调修改复杂度只是<span class="math inline">\(O ( \log n
)\)</span>)</p>
<p>离线情况下通常可以用cdq分治代替.</p>
<p>如果要支持动态插点,可以使用复杂度不正确的替罪羊树重构+kdtree.</p>
<h4><span id="1d-tree">1D-Tree</span></h4>
<p>也就是线段树.</p>
<h4><span id="2d-tree">2D-Tree</span></h4>
<p>建树的时候,对于每一维轮流考虑,每次考虑将这一维上的坐标的中位数的点(基准点)找到,左右分治下去(下一层要考虑另一维)处理.查询和修改都是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KD_tree</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> siz;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="type">int</span> l,r,u,d;</span><br><span class="line">&#125;tr[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cur[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> clen;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;p[qwq&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpx</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpy</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">tr[cnt].l=tr[cnt].r=tr[cnt].x;</span><br><span class="line">tr[cnt].d=tr[cnt].u=tr[cnt].y;</span><br><span class="line">tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">0</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">0</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">0</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">0</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">0</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">0</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].son[<span class="number">1</span>])&#123;</span><br><span class="line">tr[cnt].l=std::<span class="built_in">min</span>(tr[cnt].l,tr[tr[cnt].son[<span class="number">1</span>]].l);</span><br><span class="line">tr[cnt].r=std::<span class="built_in">max</span>(tr[cnt].r,tr[tr[cnt].son[<span class="number">1</span>]].r);</span><br><span class="line">tr[cnt].d=std::<span class="built_in">min</span>(tr[cnt].d,tr[tr[cnt].son[<span class="number">1</span>]].d);</span><br><span class="line">tr[cnt].u=std::<span class="built_in">max</span>(tr[cnt].u,tr[tr[cnt].son[<span class="number">1</span>]].u);</span><br><span class="line">tr[cnt].siz+=tr[tr[cnt].son[<span class="number">1</span>]].siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispp</span><span class="params">(<span class="type">int</span> pa,<span class="type">int</span> pb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].x-tr[pb].x)+<span class="number">1ll</span>*<span class="built_in">mabs</span>(tr[pa].y-tr[pb].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dispm</span><span class="params">(<span class="type">int</span> po,<span class="type">int</span> mat)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!mat)<span class="keyword">return</span> <span class="number">320051113</span>;</span><br><span class="line">ll d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&lt;tr[mat].l)d+=tr[mat].l-tr[po].x;</span><br><span class="line"><span class="keyword">if</span>(tr[po].x&gt;tr[mat].r)d+=tr[po].x-tr[mat].r;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&lt;tr[mat].d)d+=tr[mat].d-tr[po].y;</span><br><span class="line"><span class="keyword">if</span>(tr[po].y&gt;tr[mat].u)d+=tr[po].y-tr[mat].u;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get_var</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> avx=<span class="number">0</span>,avy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">avx+=p[i].x;avy+=p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">avx/=(r-l+<span class="number">1</span>);avy/=(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> varx=<span class="number">0</span>,vary=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">varx+=<span class="number">1ll</span>*(avx-p[i].x)*(avx-p[i].x);</span><br><span class="line">vary+=<span class="number">1ll</span>*(avy-p[i].y)*(avy-p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> varx&lt;vary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=cur[mid];</span><br><span class="line">tr[cnt].f=<span class="built_in">get_var</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(tr[cnt].f)std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpy);</span><br><span class="line"><span class="keyword">else</span> std::<span class="built_in">nth_element</span>(p+l,p+mid,p+r+<span class="number">1</span>,cmpx);</span><br><span class="line">tr[cnt].x=p[mid].x;tr[cnt].y=p[mid].y;tr[cnt].siz=<span class="number">1</span>;</span><br><span class="line">tr[cnt].son[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>);</span><br><span class="line">tr[cnt].son[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(cnt);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="笛卡尔树">笛卡尔树</span></h3>
<h5><span id="example1cfgym101613factor-freetree">Example1([CFgym101613]Factor-free
tree)</span></h5>
<p>首先有一个自然的想法是随便找一个和整个区间都互质的数,然后把序列分成左右两端向下递归.对于一棵构造出来的二叉树,它的复杂度就是<span class="math inline">\(\sum dep_u\)</span>,是可以被卡成<span class="math inline">\(O ( n^2 )\)</span>的.</p>
<p>但我们考虑类似dsu on
tree的做法,我们每次找到一个点,它将一个区间劈成了两部分,我们把小的那部分的贡献删去,然后做大的那部分.在递归过程中把大的那部分的贡献逐渐消磨掉.最后再做小的那部分,这样就类似于启发式合并的过程,复杂度就正确了.</p>
<h5><span id="example223省选第一轮集训day5c">Example2(23省选第一轮集训day5C)</span></h5>
<p>注意到最小值的条件是容易满足的.</p>
<p>考虑枚举以每个点为最大值转移的区间,假设为<span class="math inline">\([ l , r ]\)</span>,这样会有:<span class="math inline">\([ l - 1 , i - 1 ] \rightarrow [ i , r
]\)</span>.注意到我们可以选择其中较短的区间来更新零一个区间或被另一个区间更新.</p>
<h3><span id="单调队列">单调队列</span></h3>
<h5><span id="exampleloj3151">Example(loj3151)</span></h5>
<p>首先自然地,我们设<span class="math inline">\(f_{ i , j
}\)</span>表示前<span class="math inline">\(i\)</span>个测试点已经分成了<span class="math inline">\(j\)</span>段的方案数,然后做转移,复杂度<span class="math inline">\(O ( T^2 S )\)</span>.</p>
<p>接下来咋优化咧?<del>决策单调性!</del></p>
<p>嘶这题好像不满足决策单调性(这个故事也告诉我们不要看到<span class="math inline">\(k\)</span>最短路就想决策单调性).</p>
<p>冷静一下,首先如果我把<span class="math inline">\([ l , r
]\)</span>分到一段里,那这一段的答案和啥有关?显然只和有多少个人在这段区间中没挂分有关.对于一个右端点<span class="math inline">\(r\)</span>,我们不妨枚举有多少个人会在它所在的子任务挂分.显然,在左端点在一个区间内的时候,这个子任务会有一定的人挂分.而且随着现在右端点的移动,这个区间的左右端点都是单调不降的.那我们对于每种人数做单调队列维护即可.</p>
<h3><span id="树套树">树套树</span></h3>
<p>解决矩阵修改+单点查询或单点修改+矩阵查询问题.</p>
<h5><span id="example1">Example1</span></h5>
<p>维护一个序列支持把<span class="math inline">\(x\)</span>位置的值改为<span class="math inline">\(y\)</span>或查询一个区间中小于<span class="math inline">\(y\)</span>的数个数.</p>
<p>用树状数组维护平衡树,每次在树状数组上对应的节点修改即可.</p>
<h5><span id="example2luogu4054jsoi2009计数问题">Example2(Luogu4054
[JSOI2009]计数问题)</span></h5>
<p>乍一看是动态三维问题.</p>
<p>相等维度是特殊的,我们开<span class="math inline">\(100\)</span>个二维数据结构处理值不同的情况,这样就是二维.</p>
<h2><span id="数据结构常见套路">数据结构常见套路</span></h2>
<h3><span id="分开考虑">分开考虑</span></h3>
<h5><span id="example1p6105-ynoi2010y-fast-trie">Example1(P6105 [Ynoi2010]
y-fast trie)</span></h5>
<p>考虑只有两种可能:</p>
<ol type="1">
<li><p><span class="math inline">\(x + y &lt; C\)</span>,取<span class="math inline">\(x + y\)</span>作为答案.</p></li>
<li><p><span class="math inline">\(x + y \geq C\)</span>,取<span class="math inline">\(x + y - C\)</span>作为答案.</p></li>
</ol>
<p>后者只需要取出最大的两个数即可,至于前者,考虑将所有数字分成两个集合,一个集合只在<span class="math inline">\([ 0 , \lceil \frac{ C }{ 2 } \rceil
)\)</span>中,一个集合包含剩下的数字.对于第一个集合,我们只需要取出其中最大的两个数字就行.接下来的问题是怎么处理跨越两个集合的答案.考虑将每个点对应的答案配对,显然每个点能影响到的点是一段区间,删除时暴力修改.</p>
<p>另外,<span class="math inline">\(x + y &lt; C\)</span>也就是<span class="math inline">\(x &lt; C -
y\)</span>,我们把第二个集合中的元素全部变成<span class="math inline">\(C
- y\)</span>后插入,只需最小化<span class="math inline">\(C - x -
y\)</span>,这个只需要维护最大的<span class="math inline">\(x\)</span>和最小的<span class="math inline">\(C -
y\)</span>就行.</p>
<h3><span id="合并信息">合并信息</span></h3>
<p>lxl:这种问题主要需要解决三件事:标记对标记可合并,标记对值可合并,值与值可合并.</p>
<h5><span id="example1hnoi2011括号修复-jsoi2011括号序列">Example1([HNOI2011]括号修复
/ [JSOI2011]括号序列)</span></h5>
<p>注意到只要知道区间的最小前缀和以及区间的和,这个题就做完了.我们只需要维护这两件事.区间的和显然是好维护的,难以维护的是最小前缀和,我们来分开看每个操作:</p>
<p>替换:简单的.翻转:不太好做,尝试维护一下最小后缀和.反转:需要维护最大前缀和,进一步需要维护最大后缀和.</p>
<p>这样就可以更新答案了.</p>
<h5><span id="example2p4198-楼房重建">Example2(P4198 楼房重建)</span></h5>
<p>左右维护单调栈合并,但这样复杂度肯定不对.</p>
<p>怎么办呢?我们可以用<span class="math inline">\(O ( \log n
)\)</span>的单次pushup操作,也就是维护一下每个节点所代表的区间的答案和最大值,不断递归右子树(或左子树)判断.</p>
<h5><span id="example3cf1017g">Example3(CF1017G)</span></h5>
<p>设<span class="math inline">\(w_i\)</span>为从上往下延伸到<span class="math inline">\(i\)</span>这个点后,还能多往下延伸多少,一开始<span class="math inline">\(w\)</span>都是<span class="math inline">\(-
1\)</span>,每次操作会让<span class="math inline">\(w + =
1\)</span>.树链剖分维护子段最大非空后缀和.</p>
<h3><span id="去除冗余信息">去除冗余信息</span></h3>
<h5><span id="example1luogup6617">Example1(luoguP6617)</span></h5>
<p>自然的想法是考虑找到每个点前面第一个和它之和为<span class="math inline">\(w\)</span>的数字,但这样就炸了,因为每修改一个点可能要影响<span class="math inline">\(O ( n )\)</span>个点的答案.</p>
<p>我们注意到一个事实:我们也可以找到每个点后面第一个和它之和为<span class="math inline">\(w\)</span>的数字,而显然只有两个数互相匹配才可行.如果<span class="math inline">\(i &lt; j &lt; k , ( i , j ) , ( i , k
)\)</span>分别配对,那么显然<span class="math inline">\(( i , k
)\)</span>没有用.这样每个点只有<span class="math inline">\(O ( 1
)\)</span>个匹配了.</p>
<h3><span id="set维护颜色">set维护颜色</span></h3>
<h5><span id="example1luogup5278算术天才9与等差数列">Example1(luoguP5278
算术天才⑨与等差数列)</span></h5>
<p>首先考虑<span class="math inline">\(k =
1\)</span>怎么做,显然找一下区间最大值和区间最小值,然后就只需要判断区间内有没有重复元素,经典套路:set维护颜色,这样可以处理出每个点上一个和它相同颜色的点,拿线段树维护它的最大值.</p>
<p><span class="math inline">\(k \ne
1\)</span>怎么办呢?考虑这只是相当于要判断一下这个区间内的数字是否在<span class="math inline">\(\bmod
k\)</span>意义下全部相等,维护差分数组的区间<span class="math inline">\(\gcd\)</span>就行.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3>
<h5><span id="example1cf702f-t-shirts">Example1(CF702F T-Shirts)</span></h5>
<p>看到这个感觉很奇怪,想想好像也没有什么快速tag算法.</p>
<p>我们考虑对人建平衡树,然后按照顺序买衣服,每次找到所有能买这件衣服的人,显然是平衡树的某棵子树.但是,这棵子树在买完衣服后可能就不满足顺序了,那怎么办呢?能不能暴力重构一波?</p>
<p>事实上是可以的,对于一件价格为<span class="math inline">\(q\)</span>的衣服,<span class="math inline">\([ 0 ,
q )\)</span>的人肯定买不了,<span class="math inline">\([ q , 2 q - 1
]\)</span>的人买完后,手上的钱至少减半,我们暴力处理,至于<span class="math inline">\([ 2 q , + \infty
)\)</span>,显然买完后不会对其形态有什么影响,打个tag.</p>
<h5><span id="example2uoj228">Example2(uoj228)</span></h5>
<p>一个自然的想法是暴力开根号,它会迅速缩短两个数之间的差.但可能也不能缩到<span class="math inline">\(0\)</span>,那怎么办呢?当我们发现这个区间的最大值和最小值开根号后的差不变了,我们就把开根操作改成区间减法就行了.</p>
<p>loj6029是等价做法.</p>
<h5><span id="example3luogu-4690ynoi2016镜中的昆虫">Example3(Luogu 4690
[Ynoi2016]镜中的昆虫)</span></h5>
<p>维护每个点的颜色相同的前驱,单点修改的话就是简单树套树.</p>
<p>然后区间推平可以用颜色块均摊(同一个颜色块内只需要改开头元素,剩下的都是<span class="math inline">\(pre [ i ] = i - 1\)</span>).</p>
<h3><span id="根号分治">根号分治</span></h3>
<h5><span id="example1luogup7722-ynoi2007tmpq">Example1(luoguP7722 [Ynoi2007]
tmpq)</span></h5>
<p>这个题告诉我们一个故事:有的时候,有的条件可能真的没用.</p>
<p>直接把题目改成:每次修改<span class="math inline">\(a , b ,
c\)</span>中的某个数,求.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个数字<span class="math inline">\(x\)</span>,每次随机在<span class="math inline">\([ 1 , x ]\)</span>中一个数<span class="math inline">\(y\)</span>并令<span class="math inline">\(x
\leftarrow x \bmod y\)</span>,初始值为<span class="math inline">\(n\)</span>,求期望几次能变成<span class="math inline">\(0\)</span>.</p>
<p>注意到如果<span class="math inline">\(y\)</span>很小就直接做,<span class="math inline">\(y\)</span>很大的话<span class="math inline">\(\lfloor \frac{ x }{ y }
\rfloor\)</span>很小,暴力做数论分块.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一棵树,每次修改树上某个点的权值,或询问某个点周围的点的权值和.</p>
<p>度数大的点在修改的时候改,度数小的在询问的时候做.</p>
<h5><span id="example4">Example4</span></h5>
<p>给定序列,每次询问给出两个数字<span class="math inline">\(x ,
y\)</span>,求最小的<span class="math inline">\(| i - j
|\)</span>满足<span class="math inline">\(a_i = x , a_j =
y\)</span>.</p>
<p>对于出现次数大的,处理出它和所有数字的答案.</p>
<p>如果<span class="math inline">\(x ,
y\)</span>出现次数都少,就在做的时候直接归并.</p>
<h5><span id="example5shoi2006-homework">Example5(SHOI2006 Homework)</span></h5>
<p>首先对于<span class="math inline">\(Y\)</span>很小的情况直接预处理就行,每次插入的时候更新答案.</p>
<p>对于<span class="math inline">\(Y\)</span>很大的情况,<span class="math inline">\(\frac{ n }{ Y
}\)</span>一定很小,我们不断查询大于等于<span class="math inline">\(kY\)</span>的最小元素即可,这个可以值域分块来根号平衡做到<span class="math inline">\(O ( 1 )\)</span>查询,<span class="math inline">\(O
( \sqrt{ n }
)\)</span>单点修改.具体地,我们对每个块处理出大于等于这个块的最小的<span class="math inline">\(X\)</span>,以及块内每个点后面最小的<span class="math inline">\(X\)</span>(必须在块内),然后定位到<span class="math inline">\(kY\)</span>的块.</p>
<h5><span id="example6">Example6</span></h5>
<p>给定<span class="math inline">\(n , m\)</span>,以及序列<span class="math inline">\(a\)</span>和长度为<span class="math inline">\(n\)</span>的排列<span class="math inline">\(y\)</span>,你需要回答<span class="math inline">\(m\)</span>个询问.对每个询问,给定<span class="math inline">\(l , r\)</span>,查询:</p>
<p><span class="math display">\[
\sum_{ i = 1 }^n \sum_{ j = i + 1 }^n [ a_i = a_j ] \prod_{ k = i }^j [
l \leq y_k \leq r ]
\]</span></p>
<p>注意到<span class="math inline">\(y_i =
i\)</span>的时候,这题等价于小Z的袜子.因此这题不会低于根号复杂度.轮流猜算法,猜到根号分治.</p>
<p>首先有一个性质:对于一对点<span class="math inline">\(( x , y ) , a_x
= a_y , \nexists x &lt; z &lt; y , a_z = a_x\)</span>,对于<span class="math inline">\(( x , y
)\)</span>这个区间内部的点,它们其实是可以缩起来的!(比赛的时候没想到呜呜)具体来说,我们只需要保留它们中最大的那个和最小的那个就行.</p>
<p>接下来,对于出现次数大于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,它们最多只有<span class="math inline">\(\sqrt{ n
}\)</span>个,考虑莫队复杂度<span class="math inline">\(O ( n \sqrt{ m }
+ m )\)</span>,因此我们可以对每个分别做莫队,总复杂度<span class="math inline">\(O ( n \sqrt{ m } + m \sqrt{ n }
)\)</span>,注意用基数排序,甚至不能用桶排.</p>
<p>对于出现次数小于<span class="math inline">\(\sqrt{ n
}\)</span>的数字,这些数字一共最多有<span class="math inline">\(n\)</span>个,每个点暴力配对就有<span class="math inline">\(O ( n \sqrt{ n } )\)</span>个点对,然后<span class="math inline">\(O ( m
)\)</span>次询问,用根号平衡做扫描线,这里复杂度<span class="math inline">\(O ( n \sqrt{ n } + m \sqrt{ n } )\)</span>.</p>
<h3><span id="重链分治">重链分治</span></h3>
<h5><span id="example1luogu5314ynoi2011odt">Example1(Luogu5314
[Ynoi2011]ODT)</span></h5>
<p>其实不是根号分治,但是差不多,扔这里了.</p>
<p>给一棵树,边权为<span class="math inline">\(1\)</span>,支持把一条链上所有点加上<span class="math inline">\(k\)</span>,或者查询距离一个点<span class="math inline">\(&lt; = 1\)</span>的所有点的点权<span class="math inline">\(kth\)</span>.<span class="math inline">\(n \leq 2
\times 10^5\)</span>.</p>
<p>每个点周围的点一共有三种可能:父亲,重儿子,轻儿子,特判重儿子和父亲,然后处理出所有轻儿子的情况,这个怎么做都能做(大不了把所有轻儿子全扔平衡树里),然后重链剖分的时候只会改<span class="math inline">\(O ( \log n )\)</span>个轻儿子.</p>
<h3><span id="扫描线">扫描线</span></h3>
<h4><span id="一维扫描线">一维扫描线</span></h4>
<p>最经典的应用是对于一个<span class="math inline">\(B\)</span>维的静态问题,我们可能可以用扫描线扫掉一维,让它变成一个<span class="math inline">\(B -
1\)</span>维的动态问题.不过扫描线处理的时候可能需要是低<span class="math inline">\(side\)</span>的问题,具体情况具体分析.</p>
<p>主席树通常就是解决强制在线不能处理扫描线的问题.</p>
<p>另外,通常认为时间也是一维,也就是即使是动态问题也一般是等价于对时间跑了扫描线.</p>
<h4><span id="二维扫描线">二维扫描线</span></h4>
<p>也就是莫队.</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1cf1609finteresting-sections">Example1(CF1609F
Interesting Sections)</span></h5>
<p>首先枚举每个数的<span class="math inline">\(popcount\)</span>,相当于每次将一些点标记为关键点,然后查询有多少个区间满足区间最大值和最小值都是关键点.</p>
<p>可以求出每个点<span class="math inline">\(x\)</span>作为最大值的影响区间<span class="math inline">\([ l , r ]\)</span>,也就是如果一个区间左端点在<span class="math inline">\([ l , x ]\)</span>,右端点在<span class="math inline">\([ x , r
]\)</span>即可满足条件.我们考虑放入一个左下角坐标为<span class="math inline">\(( l , x )\)</span>,右上角坐标为<span class="math inline">\(( x , r
)\)</span>的矩阵.最小值也是同理的,最后也就是求所有最大值矩阵和所有最小值矩阵的交.注意到如果两个点相同,我们规定一下在前面的更小,那么最大值矩阵两两不交,最小值矩阵也两两不交,就是一个最简单的扫描线问题了.</p>
<h5><span id="example2cf833e">Example2(CF833E)</span></h5>
<p>离散化,设<span class="math inline">\(S = \{ l \} \cup \{ r
\}\)</span>,考虑用<span class="math inline">\(len_i\)</span>表示<span class="math inline">\(i\)</span>节点及以前最多能有多少阳光.我们考虑用<span class="math inline">\(len_{ i - 1 }\)</span>更新<span class="math inline">\(len_i\)</span>,如果<span class="math inline">\([ i
- 1 , i ]\)</span>没被覆盖,显然直接加上这段的长度.如果<span class="math inline">\([ i - 1 , i
]\)</span>被覆盖大于两次,那显然直接继承<span class="math inline">\(len_{
i - 1 }\)</span>.</p>
<p>先考虑<span class="math inline">\([ i - 1 , i
]\)</span>被两朵云覆盖了怎么办,我们考虑用<span class="math inline">\(h_{
j , k }\)</span>表示当前被且只被<span class="math inline">\(j\)</span>和<span class="math inline">\(k\)</span>共同覆盖的区间长度,不难发现<span class="math inline">\(h_{ j , k
}\)</span>有值的地方很少,用map.然后还要加上它们各自的贡献,用<span class="math inline">\(g_j\)</span>表示当前被且只被<span class="math inline">\(j\)</span>覆盖的区间长度,这样就可以计算答案.而这两个辅助数组也可以在判断<span class="math inline">\([ i - 1 , i
]\)</span>是被一朵云还是被两朵云覆盖的时候更新掉.</p>
<p>如果<span class="math inline">\([ i - 1 , i
]\)</span>被一朵云覆盖了怎么办呢?我们考虑把这朵云杀了,但我们还可能杀掉前面的某一朵云,假设为<span class="math inline">\(k\)</span>,那么就有两种情况:要么这两朵云有交,要么无交.</p>
<p>先考虑无交的情况,这个时候答案显然是<span class="math inline">\(g_j +
g_k\)</span>,用线段树处理出当前代价和小于等于<span class="math inline">\(C\)</span>的<span class="math inline">\(k\)</span>的<span class="math inline">\(g_k\)</span>的最大值就行.</p>
<p>再考虑有交的情况,答案应该为<span class="math inline">\(g_j + g_k +
h_{ j , k }\)</span>,我们在每次遇到<span class="math inline">\(( j , k
)\)</span>的时候都在对方那里打个tag就好,也就是对于每个<span class="math inline">\(j\)</span>,处理出和它有交的云中<span class="math inline">\(g_j + g_k + h_{ j , k
}\)</span>的最大值.虽然这些值都会变,但是只会变大,因此可以处理.</p>
<p>那么怎么判断两朵云有交呢?我们不用判断两朵云是否有交,因为前者一定没有后者优秀.不过需要判断两朵云不能是同一朵,这个存一下次大值就可以解决.</p>
<p>这样就转移完了这个题,挺厉害的.</p>
<h5><span id="example3loj3489">Example3(loj3489)</span></h5>
<p>时间也是一维,扫序列维护时间,线段树二分就可以解决.</p>
<p>具体地,我们需要对每个询问找到这个询问前最近的队列为空的时刻,然后这个时刻后面的答案就可以直接拿前缀max二分,问题在于怎么求这个时刻.</p>
<p>这个时刻也是好求的,它一定是前缀的最小值(这个点一定清空了,这个点后面的数比它小,因此这个点变成<span class="math inline">\(0\)</span>后那些数一定没清空).</p>
<h5><span id="example4luogup7709wdsr-27八云蓝自动机-ii">Example4(luoguP7709
「Wdsr-2.7」八云蓝自动机 Ⅱ)</span></h5>
<p>如果初始序列全为<span class="math inline">\(0\)</span>:</p>
<p>倒着扫操作序列,维护当前还没有得到答案的询问,每次找到一个操作一定将整个区间的询问全部得知了答案.</p>
<p>不然不会做.</p>
<h5><span id="example5luogu3863">Example5(luogu3863)</span></h5>
<p>仍然是个数据结构维护时间维,扫描线扫序列维的东西.</p>
<h5><span id="example6qoj6304">Example6(qoj6304)</span></h5>
<p>考虑横纵坐标是对称的,因此我们只需要考虑两横一竖的情况和三条横的情况.</p>
<p>先做三条横,枚举中间的那个横的位置,剩了一段前缀和一段后缀需要覆盖,这个可以前后缀预处理.</p>
<p>然后是两横一竖,扫竖线,问题转化为动态加入删除区间,求当前用两个点覆盖所有区间的方案数,不妨设这两个点是<span class="math inline">\(L &lt; R\)</span>,自然有<span class="math inline">\(L \leq \min \{ r_i \} , R \geq \max \{ l_i
\}\)</span>,那么当我们确定<span class="math inline">\(L\)</span>后,我们有<span class="math inline">\(R
\in [ \max \{ l_i \} , f ( L ) ]\)</span>.接下来我们考虑如何计算<span class="math inline">\(f ( L )\)</span>.</p>
<p>注意到<span class="math inline">\(L &lt; l_i \Rightarrow R \leq
r_i\)</span>,我们考虑将<span class="math inline">\(l_i\)</span>这个点的权值设成<span class="math inline">\(r_i\)</span>,那么我们要做的就是一个后缀最小值求和,用楼房重建.</p>
<h3><span id="莫队">莫队</span></h3>
<h4><span id="回滚莫队">回滚莫队</span></h4>
<h4><span id="带修莫队">带修莫队</span></h4>
<p>也就是维护三维的扫描线,根据KDT不难发现复杂度是<span class="math inline">\(O ( nm^{ \frac{ 2 }{ 3 } } )\)</span>,<span class="math inline">\(B = n^{ \frac{ 2 }{ 3 } }\)</span>,排序原则是<span class="math inline">\(( ls , rs , t
)\)</span>,复杂度算一算就知道是对的.</p>
<h4><span id="树上莫队">树上莫队</span></h4>
<h4><span id="二次离线莫队">二次离线莫队</span></h4>
<p>这个直接拿区间逆序对当例子记笔记好了.</p>
<p>如果我们用正常的莫队做区间逆序对,我们会得到带个<span class="math inline">\(\log
n\)</span>的复杂度:也就是每次扩展一个数,计算它对答案的贡献,这个是必须带<span class="math inline">\(\log
n\)</span>的,而且查询次数等价于移动次数,我们甚至不能用根号平衡.</p>
<p>那么怎么解决这个问题呢?我们现在无非是有<span class="math inline">\(n
\sqrt{ n }\)</span>次询问,每次询问<span class="math inline">\(f ( l , r
, r + 1 )\)</span>表示区间<span class="math inline">\([ l , r
]\)</span>对<span class="math inline">\(r +
1\)</span>的逆序对贡献.考虑差分成<span class="math inline">\(f ( 1 , r ,
r + 1 ) - f ( 1 , l - 1 , r + 1
)\)</span>,前者显然可以迅速求出.而后者的右端点需要移动<span class="math inline">\(n\)</span>次,需要查询总共<span class="math inline">\(n \sqrt{ n }\)</span>次,zhe’ge</p>
<h4><span id="example">Example</span></h4>
<h5><span id="example1ynoi2016这是我自己的发明">Example1([Ynoi2016]这是我自己的发明)</span></h5>
<p>dfn将子树转序列,注意到换根无非是把一个序列拆成了两个序列,这是好做的.不过这玩意都<span class="math inline">\(4 - side\)</span>了,但是有可减性,减成<span class="math inline">\(2 - side\)</span>就能莫队了.</p>
<h5><span id="example2hnoi2016大数">Example2([HNOI2016]大数)</span></h5>
<p>区间子区间问题对于莫队是有一个套路的:即转化为二元组计数问题.</p>
<p>具体怎么做呢?首先这个题我们特判掉<span class="math inline">\(p =
2\)</span>和<span class="math inline">\(p =
5\)</span>的情况,这个只需要判断个位数就可以.然后我们考虑求每个点后缀代表的数字<span class="math inline">\(\bmod p\)</span>的值,设为<span class="math inline">\(suf_i\)</span>,假设存在两个点<span class="math inline">\(l , r\)</span>满足<span class="math inline">\(p |
( suf_l - suf_{ r + 1 } )\)</span>,那么<span class="math inline">\([ l ,
r ]\)</span>就是合法的,这是自然的,也就等价于<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>,相当于要对满足<span class="math inline">\(suf_l = suf_{ r + 1 }\)</span>的二元组<span class="math inline">\(( l , r )\)</span>计数,这个是可以用莫队维护的.</p>
<h5><span id="example3luogup3604美好的每一天">Example3(luoguP3604
美好的每一天)</span></h5>
<p>类似上面那个题,用哈希(其实就是将26个字母表示成26个二的幂次)然后异或起来,和上面的题就完全一样了,做二元组计数.</p>
<h3><span id="区间子区间问题">区间子区间问题</span></h3>
<p>求有多少个子区间满足条件.</p>
<p>上二维平面,子区间所代表的<span class="math inline">\(( l , r
)\)</span>的点一定是在一条角平分线上的一个等腰直角三角形.</p>
<h5><span id="example1cf997e">Example1(CF997E)</span></h5>
<p>考虑转化为二维平面,<span class="math inline">\(a_{ l , r } = maxn -
minn - ( r - l )\)</span>,显然只需要找到为<span class="math inline">\(0\)</span>的操作就行,这四个数可以转化为四个矩形加法,做扫描线.</p>
<p>另外这里的矩阵加法有<span class="math inline">\(3 -
side\)</span>的,但是可差分成<span class="math inline">\(2 -
side\)</span>.</p>
<h3><span id="时间倒流">时间倒流</span></h3>
<h5><span id="example12022qbxt国庆day6sgtbeats">Example1([2022qbxt国庆Day6]sgtbeats)</span></h5>
<p>首先考虑:如果一个点被清空了多次,那么只有最后一次有意义.</p>
<p>删除操作很难做,考虑变成插入,然后就可以拿数据结构维护操作序列的后缀max,存一下每个点最后被清空的时间,然后处理即可.</p>
<h5><span id="example2wc2006水管局长">Example2([WC2006]水管局长)</span></h5>
<p>时间倒流,删边变加边,LCT做一下.</p>
<h3><span id="数据结构维护分段函数">数据结构维护分段函数</span></h3>
<h5><span id="example1cf1540d-inverseinversions">Example1(CF1540D Inverse
Inversions)</span></h5>
<p>考虑对于一个数列怎么构造:假设只考虑前<span class="math inline">\(k\)</span>个数,它们的取值是<span class="math inline">\([ 1 , k ]\)</span>,现在加入第<span class="math inline">\(k +
1\)</span>个数,由于我们知道它是前缀第几小,所以我们可以直接将它设成这个值,然后将前面所有大于等于这个值的点全都<span class="math inline">\(+ 1\)</span>,不难发现这一定是唯一构造.</p>
<p>那么我们现在要知道<span class="math inline">\(p_i\)</span>是多少,根据上面的构造过程,首先将<span class="math inline">\(p_i =
a_i\)</span>,然后不断向后遍历,每遇到一个<span class="math inline">\(a_j\)</span>,如果<span class="math inline">\(a_j
\leq p_i\)</span>,则把<span class="math inline">\(p_i + =
1\)</span>.</p>
<p>我们将数列分块,设块长为<span class="math inline">\(B\)</span>,那一个值经过一个块的时候最多加块长个<span class="math inline">\(1\)</span>.也就是经过整块的时候是一个<span class="math inline">\(B\)</span>段的分段函数.</p>
<p>考虑暴力求出这个分段函数,每次询问的时候直接二分,修改的时候考虑每个块维护一个线段树,线段树的区间表示这个区间对应的分段函数.这样单点修改复杂度是<span class="math inline">\(\sum{ \cfrac{ B }{ 2^i } } = B\)</span>的,</p>
<p>于是最后复杂度为<span class="math inline">\(O ( T ( B + \cfrac{ n }{
B } \log n ) )\)</span>,取<span class="math inline">\(B = \sqrt{ n \log
n }\)</span>即可.</p>
<h3><span id="根号平衡">根号平衡</span></h3>
<p>根号平衡主要用到下面四个东西:</p>
<ol type="1">
<li><p><span class="math inline">\(O ( 1 )\)</span>单点加,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>区间和:维护块内的和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>单点加,<span class="math inline">\(O ( 1
)\)</span>区间和:维护块内和块间的前缀和即可.</p></li>
<li><p><span class="math inline">\(O ( \sqrt{ n } )\)</span>区间加,<span class="math inline">\(O ( 1 )\)</span>单点和:差分转化为<span class="math inline">\(( 2 )\)</span>.当然打标记也是可以的.</p></li>
<li><p><span class="math inline">\(O ( 1 )\)</span>区间加,<span class="math inline">\(O ( \sqrt{ n } )\)</span>单点和:差分转化为<span class="math inline">\(( 1 )\)</span>.当然打标记也是可以的.</p></li>
</ol>
<p>还有一些拓展的东西:</p>
<ol start="5" type="1">
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( 1
)\)</span>插入,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块就可以.</p></li>
<li><p>维护值域<span class="math inline">\(O ( n
)\)</span>的集合,支持<span class="math inline">\(O ( \sqrt{ n }
)\)</span>插入,<span class="math inline">\(O ( 1 )\)</span>查询第<span class="math inline">\(k\)</span>小:值域分块,然后暴力改变每个点所属的块就行.</p></li>
</ol>
<h4><span id="example">Example</span></h4>
<h5><span id="example1区间众数">Example1(区间众数)</span></h5>
<p>首先分块,处理出<span class="math inline">\(f_{ l , r
}\)</span>表示块<span class="math inline">\([ l , r
]\)</span>的答案.这样每次只需要加入散块中的每个数并判断答案即可,由于判断每个数在区间出现次数是<span class="math inline">\(\log n\)</span>的,因此复杂度<span class="math inline">\(O ( n \sqrt{ n \log n } )\)</span>.</p>
<p>但是可以优化,我们设<span class="math inline">\(mx\)</span>表示当前众数出现次数,注意到我们判断一个数字在区间中出现次数是否大于<span class="math inline">\(mx\)</span>可以<span class="math inline">\(O ( 1
)\)</span>判断(处理出这个数所有的出现位置),而如果遇到两个数需要对冲,显然<span class="math inline">\(mx\)</span>增加总次数也不会超过<span class="math inline">\(O ( \sqrt{ n } )\)</span>,因此做到<span class="math inline">\(O ( n \sqrt{ n } )\)</span>.</p>
<p>不删除莫队也能做.</p>
<p>当然,如果只要求区间众数的出现次数,可以直接莫队.</p>
<h5><span id="example2codechef-chef-andchuru">Example2(CodeChef Chef and
Churu)</span></h5>
<p>首先发现函数是不会被修改的,因此考虑对函数分块,对于那些散着的函数肯定可以用一个<span class="math inline">\(O ( 1 )\)</span>查询区间和,<span class="math inline">\(O ( \sqrt{ n }
)\)</span>单点修改的进行根号平衡.</p>
<p>而怎么快速处理整块呢?发现函数可差分,差分后就可以算出每一个位置对这个块内的总贡献,这样就可以更新了.</p>
<h5><span id="example3ahoi2013作业">Example3([Ahoi2013]作业)</span></h5>
<p>莫队,发现有<span class="math inline">\(m\)</span>次查询,<span class="math inline">\(n \sqrt{ m }\)</span>次移动,于是根号平衡.</p>
<h5><span id="example4bzoj4241历史研究">Example4(Bzoj4241历史研究)</span></h5>
<p><del>回滚莫队板子.</del></p>
<p>事实上考虑可能的答案只有<span class="math inline">\(O ( n
)\)</span>种,用值域分块就可以平衡复杂度.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
