<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="不过是白日梦里一瞬息">
<meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的备忘录">
<meta property="og:url" content="http://lwlaymh.github.io/page/5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="不过是白日梦里一瞬息">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LWLAymh的备忘录</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="post-title-link" itemprop="url">博弈论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="bash游戏">Bash游戏</span></h3><p>$A $和$B $,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq m \ $,求$A $是否能赢.</p>
<p>考虑直接令石子数量为状态,有$SG ( x ) = mex \{ SG ( y ) | \max \{ 0 , x - m \} \leq y \leq x - 1 \} \ $,注意到$SG ( x ) = 0 $当且仅当$x \equiv 0 ( \mod m + 1 ) $.</p>
<p>我们使用数学归纳证明:</p>
<p>当$0 \leq x \leq m $时,显然成立.</p>
<p>而对于$x $,如果$x \equiv 0 ( \mod m + 1 ) \ $,那么集合$S = \{ y \in \mathbb { Z  } | \max \{ 0 , x - m \} \leq y \leq x - 1 \} $中一定$\nexists y $满足$y \equiv 0 ( \mod m + 1 ) \ $.</p>
<p>也就是$\nexists y $满足$SG ( y ) = 0 $,那么$SG ( n ) = 0 $.反之,一定存在.</p>
<h3><span id="nim游戏">Nim游戏</span></h3><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选一堆取走若干个石子,最后不能取的人输.求先手是否必胜.</p>
<p>注意到如果$x $均等于$0 $一定先手必败.考虑令$w = x _1 \oplus x _2 \oplus . . . \oplus x _n $($w $即为全游戏的$SG $值),那么先手必败当且仅当$w = 0 \ $.</p>
<p>证明:</p>
<p>只需证明当$w \ne 0 $时一定存在一种方法使得$w = 0 \ $.</p>
<p>考虑$w $的最高位为第$k $位,那么一定存在一个$x _i $的第$k $位为$1 $.将它改为$0 $,然后这个$x _i $的后面几位可以随意更改.</p>
<h4><span id="example1nimk游戏">Example1(Nimk游戏)</span></h4><p>$A $和$B $,有$n $堆石子,第$i $堆石子有$x _i $个石子.每次可以任选不超过$k $堆取走若干个石子,最后不能取的人输.</p>
<p>将$x _i $写成二进制,如果每一位的$1 $的个数均是$k + 1 $的倍数,那么先手一定必败.道理是差不多的.</p>
<h4><span id="example2multi-nim游戏">Example2(Multi-Nim游戏)</span></h4><p>Nim游戏,但是玩家每回合可以将任意一堆石子数量大于等于$2 $的石子堆分成任意两堆不为空的石子堆.没法操作的人输.</p>
<p>本质仍然是SG游戏,我们正常做就行.</p>
<p>$SG ( x ) = mex \{ \{ SG ( v ) | x \rightarrow v \} , \{ SG ( x - i ) \oplus SG ( i ) | 1 \leq i &lt; x \} \} \ $.</p>
<p>找一下规律可以发现:</p>
<script type="math/tex; mode=display">
\begin{aligned}
SG ( x ) & = \begin{cases}
x - 1 & x \equiv 0 ( \mod 4 ) \\
x & x \equiv 1 或 2 ( \mod 4 ) \\
x + 1 & x \equiv 3 ( \mod 4 ) \\

\end{cases} \\

\end{aligned}</script><p>不妨设当$x \leq 4 k $时结论成立.</p>
<p>当$x = 4 k + 1 $时,前半部分一定是取遍了$[ 1 , 4 k ] $.</p>
<p>但是一定不存在$a $和$b $满足$a + b = 4 k + 1 $并且$SG ( a ) \oplus SG ( b ) = 4 k + 1 $.讨论一下$a $和$b $在$\mod 4 $意义下的值就会发现不可能.</p>
<p>其他的是同理的.</p>
<h3><span id="sg游戏">SG游戏</span></h3><p>$n $个DAG,每个DAG只有一个起始点,起始点上有一枚棋子.$A $和$B $每次可以选一个图,将上面的棋子沿DAG移动一条边,不能移动的人输.</p>
<p>直接使用$SG ( u ) = mex \{ SG ( v ) | u \rightarrow v \} $.</p>
<p>那么先手必败当且仅当所有DAG初始节点的SG异或起来是$0 $.</p>
<p>首先如果$SG ( u ) = x $,那么$\forall 0 \leq y &lt; x $,$\exists v $使得$u \rightarrow v $且$SG ( v ) = y $.可以发现这就如同Nim游戏了.</p>
<p>但是与Nim游戏不同的是,可能$\exists y &gt; x $,但是仍然可以转移到.</p>
<p>但在这种情况下,我可以继续转移到一个$u ‘ $使得$SG ( u ‘ ) = x $,因此异或值不变.</p>
<h4><span id="example1anti-sg游戏">Example1(Anti-SG游戏)</span></h4><p>SG游戏,但是不能取的人赢.</p>
<p>SJ定理:</p>
<p>先手必胜当且仅当下面两个条件满足一个:</p>
<ol>
<li><p>游戏的SG函数不为$0 $且游戏中某个单一游戏的SG函数大于$1 $.</p>
</li>
<li><p>游戏的SG函数为$0 $且游戏中没有单一游戏的SG函数大于$1 $.</p>
</li>
</ol>
<p>如果没有单一游戏的SG函数大于$1 $,那么显然游戏的SG函数为$0 $就赢了,否则就输了.</p>
<p>而如果SG函数为$0 $且存在某个单一游戏的SG函数大于$1 $,一定是输的.</p>
<p>因为这个情况下,后手先按照正常$SG $游戏压着先手,最后一定会剩两堆一样大于$1 $的,无论你怎么选,对手都可以压着你.如果你把一堆全选了,此时对手就可以把另一堆剩下一个,这样就必输;如果你把这一堆选的只剩下一个,对手就可以把它那一堆全选了,这样就也是必输的.</p>
<h4><span id="example2every-sg">Example2(Every-SG)</span></h4><p>SG游戏,但是每次每个能移动的游戏都必须移动,不能移动任何游戏的人输.</p>
<p>对于每个子游戏,如果先手必胜,先手一定会尽可能多争取时间.</p>
<p>反之,先手一定会尽可能早结束游戏.</p>
<p>在$DAG $上dp的时候除了$SG $我们再加一维表示时间耗费,就可以dp了.</p>
<h4><span id="example25every-sg">Example2.5(Every-SG)</span></h4><p>n个游戏,每个游戏两堆石子,每次可以从大的那堆中取小的那堆石子大小的整数倍的石子.</p>
<p>直接套用Every-SG的做法就行.</p>
<h4><span id="example3nim-on-tree">Example3(Nim on tree)</span></h4><p>一棵有根树两个人,每次可以挑一棵真子树删掉,不能操作者输.</p>
<p>结论:$SG ( u ) = \bigoplus _{ u \rightarrow v  } ( SG ( v ) + 1 ) $.</p>
<p>考虑归纳假设.如果$u $只有$v $一个儿子.那么要么将$v $子树全删,要么删一部分,有:</p>
<script type="math/tex; mode=display">
SG ( u ) = mex ( x | x = 0 \lor 0 \leq x - 1 < SG ( v ) ) = SG ( v ) + 1</script><p>而如果有多个儿子,则每个儿子都相当于是一个SG子游戏,异或起来即可.</p>
<p>另一种理解方式:考虑只有一个儿子的情况,那么相当于这个儿子的所有状态都向终止节点连了一条边,终止节点的$SG $为$0 $,而显然$SG $图中的其它节点的$SG $均要$+ 1 $.</p>
<h4><span id="example4">Example4</span></h4><p>$n $个有根仙人掌,保证所有的环与树的结构只有一个公共点(环只有一条连到环外的边).</p>
<p>两个人分别操作删边,与根不连通的边都被删掉.</p>
<p>结论:奇环$SG = 1 $,偶环$SG = 0 $.</p>
<p>这么考虑:边数为$k $的链的$SG $为$k $.</p>
<p>而拆开奇环后,你得到的两条链奇偶性一定相同,因而不可能得到$1 $.偶环同理,不可能得到$0 $.</p>
<h4><span id="example5">Example5</span></h4><p>无向图,每次删掉一条边以及与根节点不连通的部分,无法操作者输.</p>
<p>考虑Example2.</p>
<p>Fusion定理:将偶环替换成一个新点,奇环替换成一个新点连出去一条边,做边双.对于一个边双,$SG $值只和他边的奇偶性有关.证明大概和上面一样.</p>
<h3><span id="斐波那契博弈">斐波那契博弈</span></h3><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次的两倍.</p>
<p>不能操作者输.</p>
<p>结论为:当且仅当$N $是斐波那契数时,先手必败.</p>
<p>考虑归纳证明:</p>
<p>先证明当$N $是斐波那契数时必败,不妨假设$N = N _0 + N _1 $,</p>
<p>考虑将$N $看成两堆,因为如果第一次取走了大于$N _1 $颗石子,由于$N _0 \leq N _1 \ $,则后手第二步可以全取走,必败.</p>
<p>并且一开始先手一定要在$N _0 $堆取石子,原因是如果取了大于$N _0 $颗石子,由于$N = N _0 + N _1 \leq 3 N _0 \ $.这样下一步后手就可以全取完.</p>
<p>那么现在先手应该开始取$N _0 $这一堆,如果在这一堆取的过程中,先手一直取得不超过$N _0 $剩下的数,那么根据归纳假设,后手一定可以取走$N _0 $堆的最后一个石子,此时局面变成了只剩$N _1 $颗石子.只要此时先手不能一次取走$N _1 $颗石子,先手就必败.而后手最后一步拿走石子最多会拿走$\frac { 2  } { 3  } N _0 $的石子,但是,$\frac { 4  } { 3  } N _0 &lt; N _1 $,因此一定不可能.</p>
<p>否则,仍然是先手取走了$N _0 $全部石子,又当了先手取$N _1 $的石子.仍然是必败的.</p>
<p>齐肯多夫定理:任意一个正整数都可以被表示成若干不连续的斐波那契数之和.</p>
<p>设$N = \sum _{ i = 1  } ^k f _{ p _i  } $,其中$p _1 &lt; p _2 &lt; p _3 &lt; . . . &lt; p _k \ $,先手取走$f _{ p _1  } \ $.由于$2 f _{ p _1  } &lt; f _{ p _2  } $,因此后手接下来无论如何不可能取得大于等于$f _{ p _2  } \ $,问题转化为一堆大小为$f _{ p _2  } $的石子,此时先手必败.因此原问题的先手必胜.</p>
<h3><span id="二分图博弈">二分图博弈</span></h3><p>给出一张二分图和起点$S $,$A $和$B $轮流操作,每次操作只能选与上一个被选的点相邻的点,且不能选已经选过的点.</p>
<p>考虑二分图的所有最大匹配,如果在所有的最大匹配的方案中都包含了起点$S $,那么先手必胜,否则先手必败.</p>
<p>证明:</p>
<p>如果所有匹配都包含$S $,那么$A $只需要每次走到一个和$S $匹配的点即可.$B $无论如何不可能走到一个不在最大匹配中的点,不然,我们将路径全部取反,就得到了一个最大匹配不变但不包含$S $的点,与假设不符.</p>
<p>而如果存在一个匹配不包含$S $,如果$A $仍然第一步走到一个和$S $匹配的点那么$B $一定能想办法走到一个不在当前$A $选择的最大匹配中的点而在一个不包含$S $的最大匹配中的点,于是$B $必胜.</p>
<h4><span id="example12022qbxt国庆day5c">Example1([2022qbxt国庆Day5]C)</span></h4><p>显然,一个人敢抢金条当且仅当没有人敢抢他的金条.假设$dp _{ S , x  } = 0 / 1 $表示目前集合$S $中的所有人都已经离场了,而目前金条在$x $手中,金条会不会被抢.显然,如果$\exists y $满足$dp _{ S \cup \{ x \} , y  } = 0 $,也就是金条在$y $手里不会被抢,那$x $手中的金条必定会被抢.</p>
<p>将这个抢的过程看作二分图博弈中走到相邻的点的过程,于是这个问题等价于二分图博弈.也就是说,如果二分图博弈先手必胜,那么第一个拿到金条的人一定会被抢.</p>
<p>因此,我们需要找到所有与$S $匹配的可能出现在最大匹配中的边,对应编号最小的那个点,金条最后一定在他手里.(第一步这么走后,一定能构造出)</p>
<p>这个怎么构造呢,我们考虑先跑一遍dinic求最大匹配,然后做一遍tarjan缩点,然后如果$S $和$x $并未匹配,那么我们判断二者是否在一个强连通分量中,如果在,那他们可以被匹配.</p>
<p>至于判断$S $是否一定在其中,只需要先删去$S $,跑dinic,再在残联网络上加上$S $,判断是否有新的增广路.</p>
<h3><span id="树上博弈">树上博弈</span></h3><h4><span id="example1zr23省选10连-day1-clashmas">Example1(zr[23省选10连 day1] Clashmas)</span></h4><p>注意到删点对树形态的影响,考虑重心</p>
<ol>
<li>$n $为奇数,重心为后手点.</li>
</ol>
<p>注意到此时后手一定可以通过一些方式维持重心不变,因此后手必胜.</p>
<ol>
<li>$n $为奇数,重心为先手点.</li>
</ol>
<p>我们不妨设先手是A,后手是B.</p>
<p>考虑一个事实:对于这样一棵树,我们删着删着一定会出现一个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),根据(4)和(5)的讨论,此时胜负已分.而且不难注意到此时A变为了实际上的后手.</p>
<p>根据(5),如果B掌控了任意一个重心,那A就输了.因此A必定要使当前局面的两个中心均为A的点.考虑原重心的所有儿子,它们有的是A点,有的是B点.由于树的重心的性质,树的重心的移动一定是一点一点挪的,也就是说第一次出现上面的局面的时候,两个重心必有一个是原重心,另一个是原重心的儿子,接下来A和B就要对于另一个重心能取到哪个儿子做争夺.我们不妨设A的点的集合为$S _A $,B的点的集合为$S _B $.以原重心为根建树,设其所有儿子组成的集合为$S _C $,不难发现A能胜利(也就是让两个重心全都属于他)当且仅当$\sum _{ u \in S _A \cap S _C  } siz _u \geq \sum _{ u \in S _B \cap S _C  } siz _u $.</p>
<p>原因很简单:A和B必然每次都会去杀属于对方的子树中$siz $最大的那棵.由于A有着先手优势,因此只要满足上面的条件,A总能获胜.</p>
<ol>
<li>$n $为偶数,唯一重心,重心为后手点.</li>
</ol>
<p>类似(2)的讨论,最后一定有某个时刻使得此时$n $为偶数,有两个重心(比如最后只剩下两个点的时刻),此时A仍然是先手,根据(5),只要他掌控一个重心就可以获胜.</p>
<p>类似地,不难发现胜利条件等价于(2).</p>
<ol>
<li>$n $为偶数,两个重心,重心均为后手点.</li>
</ol>
<p>注意到此时整棵树分为两个大小相等的部分,因此后手一定可以维持这个场面不动,后手必胜.</p>
<ol>
<li>$n $为偶数,至少有一个重心是先手点.</li>
</ol>
<p>注意到此时先手一定存在一种方式开局,使得重心仍为这个先手点,这样就转化为第一种情况,先手必胜.</p>
<h3><span id="散题">散题</span></h3><h5><span id="problem1csp-s2020贪吃蛇">Problem1([CSP-S2020]贪吃蛇)</span></h5><p>首先注意到,如果一个蛇吃完后还不是最小的蛇,那它一定会吃.因为被吃的蛇是单调不降的,而吃蛇的蛇是单调不增的,因此下一个蛇如果要吃,那一定会比它还小,所以至少会先被吃掉,而那条蛇会被吃掉,它就一定不会选,所以无论如何这条蛇都不会被吃掉.</p>
<p>我们考虑如果吃完后变成了最小的蛇后会怎么样,我们设$f _i $为还剩$i $条蛇的时候能不能吃,那$f _i = 1 $的话,要么$i = 2 $,要么吃完后不是最小的,要么$f _{ i - 1  } = 0 $.</p>
<p>递归做就好了.另外这题需要复杂度$O ( n ) $,需要用几个队列/双端队列维护.</p>
<h5><span id="problem2agc023dgo-home">Problem2([AGC023D]Go Home)</span></h5><p>首先,最后一个人要么是最左边的,要么是最右边的.而显然这两边中人数较少的一个将会是最后一个到家的,那么这个人的目标就是帮助另一边的人尽可能快到家,于是会帮着它投票.以此类推不断递归下去.</p>
<h5><span id="problem3牛客38727e">Problem3(牛客38727E)</span></h5><p>首先考虑如果有人作为第$n - p + 1 $个人复读了,那接下来复读一定不会被惩罚,于是没复读的都会复读,这样这个人就必死.于是最多只会复读$n - p $个人.</p>
<p>继续思考,如果有人作为第$n - 2 p + 1 $个人复读了会怎么样,后面的人也都不会被惩罚了,于是也会继续复读.</p>
<p>以此类推,会发现最后只会有$n \mod p $个人复读,并且一定是前$n \mod p $在一轮内复读完.</p>
<h5><span id="problem4arc155d">Problem4(arc155D)</span></h5><p>考虑直接转移,但是有可能出现在原地转的情况,注意到这种情况我们只需要记录$f _{ i , j  } $表示当前的$G $是$i $,$G $的倍数还剩下$j $个,然后做转移,再进一步发现我们只关心$j $的奇偶性.于是记$f _{ i , 0 / 1  } $即可.</p>
<p>这题给我最大的启示是,我们不能假定让双方共同遵守一个”君子协定”,博弈论最重要的就是博弈,不能说我们最后再选倍数之类的,他的转移路线会变化的.</p>
<h5><span id="problem5">Problem5</span></h5><p>给一个“日”字型图,七条边,每条边有一堆石子.每次可以选任意多条不构成环的边,然后将这些边上的石子堆取走任意多个石子.求先手必胜策略,以及如果每条边的石子数量在$[ l _i , r _i ] $,那么有多少种先手必胜的情况.</p>
<p>考虑将这个图分成三部分,上面三条边,中间一条边,下面三条边.那么这三部分一定不能全选至少两部分,不然会构成环.反之一定构不成环.</p>
<p>先手必败当且仅当,这三部分内部的边上石子均相等,并且所有边异或值为$0 $.</p>
<p>否则,考虑将上部分和下部分三条边先全改成相等的,会修改较大的两条边.</p>
<p>接下来,我们剩了三条边,我们只能选择改其中一条,使得他们仨异或值为$0 $.</p>
<p>换句话说,我们现在有$x _1 , x _2 , x _3 $,我们要将其中一个$x _i $改为$y _i $,其他不变,使得他们仨异或值为$0 $.和Nim游戏类似,假设他们仨异或值的最高位为$k $.那么一定有一个$x _i $的第$k $位为$1 $,将它改为$0 $,后面就可以随意变换.</p>
<p>思路具体怎么想到的呢,可以发现整个图只有三个环,并且这三个环都可以由这几部分组成.接下来就可以每个部分的$[ l _i , r _i ] $求个交,用FWT做一遍异或卷积.数位dp也可以做.</p>
<h5><span id="problem6">Problem6</span></h5><p>Nim游戏,但是每堆石子有一个$K _i $.如果这堆石子剩$x _i $个每次最多取$\lfloor \frac { x _i  } { K _i  } \rfloor $个石子.求先手是否必胜.</p>
<p>结论是</p>
<p>SG(n-\lfloor\frac n k\rfloor,k)&amp;n\ne 0(\mod k)\\</p>
<p>\frac n k&amp;n=0(\mod k)\\</p>
<p>\end{cases}\\</p>
<p>考虑数学归纳就可以证明.</p>
<p>然后我们就只需要对于$k $是否大于$\sqrt { n  } $讨论一下,如果$k &lt; \sqrt { n  } $暴力,最多只会做$\sqrt { n  } $次.否则,意识到此时可以通过求一个区间$[ l , r ] $,满足$\forall x \in [ l , r ] , \lfloor \frac { x  } { k  } \rfloor $均相等,加速一下.这种区间最多只会有$\sqrt { n  } $个.</p>
<h5><span id="problem7">Problem7</span></h5><p>一个数$N $,两个人轮流令他减去一个数,第一次不能减完,每次减的不能超过上一次.不能操作者输.</p>
<p>先手必败当且仅当$N = 2 ^k $,不然,每次选lowbit即可.</p>
<h5><span id="problem8">Problem8</span></h5><p>A和B,有$n $颗石子,每次可以取$x $颗,其中$1 \leq x \leq \lceil \frac { n  } { 2  } \rceil \ $.</p>
<p>仍然令石子数量为状态,注意到$SG ( x ) = 0 $当且仅当$x + 1 = 2 ^k - 1 $,也即$x = 2 ^k - 2 \ $.首先,注意到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n - \lceil \frac { n  } { 2  } \rceil & = \lfloor \frac { n  } { 2  } \rfloor \\
SG ( n ) & = mex \{ SG ( y ) | \lfloor \frac { n  } { 2  } \rfloor & \leq y & \leq n - 1 \} \\

\end{aligned}</script><p>设$n = 2 ^k - w $,其中:</p>
<script type="math/tex; mode=display">
\begin{aligned}
- 2 ^{ k - 1  } + 2 & \leq w & \leq 2 \\
\lfloor \frac { 2 ^k - w  } { 2  } \rfloor & = 2 ^{ k - 1  } - \lfloor \frac { w  } { 2  } \rfloor \\

\end{aligned}</script><p>当$w = 2 $时,原式$= 2 ^{ k - 1  } - 1 &gt; 2 ^{ k - 1  } - 2 \ $.反之.$2 ^k - 2 \leq $原式.因此数学归纳即可证明.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">北大相关选拔数学真题汇总</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8C%97%E5%A4%A7%E7%9B%B8%E5%85%B3%E9%80%89%E6%8B%94%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="2024寒假学堂部分">2024寒假学堂(部分)</span></h3><h4><span id="problem4">Problem4</span></h4><p>设$G ( x ) = ( x ^2 + x - 1 ) ^{ 100  } = \sum _{ k = 0  } ^{ 200  } a _k x ^k $,求$2 a _0 - a _1 - a _2 + 2 a _3 - a _4 - a _5 + \cdots + 2 a _{ 198  } - a _{ 199  } - a _{ 200  } $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑求出$\sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.直接取三次单位根$\omega _3 = - \frac { 1  } { 2  } + \frac { \sqrt { 3  }  } { 2  } i $,自然有$1 + \omega _3 + \omega _3 ^2 = 0 $,所以$G ( 1 ) + G ( \omega _3 ) + G ( \omega _3 ^2 ) = 3 \sum _{ 0 \leq k \leq 66  } { a _{ 3 k  }  } $.</p>
<p>所以答案显然是$G ( \omega _3 ) + G ( \omega _3 ^2 ) = ( - 2 ) ^{ 100  } + ( - 2 ) ^{ 100  } = 2 ^{ 101  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>等差数列中,$a _1 &gt; 0 $,公差$d &lt; 0 , \frac { a _{ 31  }  } { a _{ 30  }  } &lt; - 1 $,求最大的正整数$n $,使得$S _n &gt; 0 $.</p>
<h5><span id="solution10">Solution10</span></h5><p>显然$S _{ 60  } = 30 ( a _{ 30  } + a _{ 31  } ) &lt; 0 , S _{ 59  } = 59 a _{ 30  } &gt; 0 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>全为整数的等差数列,$d = 4 $,求所有满足$S _n = 2024 $的$n $的和.</p>
<h5><span id="solution11">Solution11</span></h5><p>则$n ( 2 n - 2 + a _1 ) = 2024 = 2 ^3 \times 11 \times 23 $.显然只要$n | 2024 $即可.</p>
<p>所有$n $的和自然是$( 1 + 2 + 4 + 8 ) ( 1 + 11 ) ( 1 + 23 ) = 15 \times 12 \times 24 = 4320 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>整数数列$U _n $满足$U _0 = 1 $,且当$n \geq 1 $的时候$U _{ n + 1  } U _{ n - 1  } = kU _n $,其中$k $是一个正整数.问能让$U _{ N  } = N $的$k $的个数有多少个,其中$N = 2024 $.</p>
<h5><span id="solution14">Solution14</span></h5><p>则$U _{ n + 1  } = \frac { kU _n  } { U _{ n - 1  }  } , \frac { U _{ n + 1  }  } { U _n  } = k \frac { U _n  } { U _{ n - 1  }  } \frac { 1  } { U _n  } $.</p>
<p>观察上面的式子,不难想到换元后求前缀积,但其实注意到我们可以直接求前缀积,设$T _n = \prod _{ k = 1  } ^n U _k , W _n = U _n \prod _{ k = 1  } ^{ n - 2  } U _k $.</p>
<p>注意到$W _n = kW _{ n - 1  } , W _1 = U _1 , W _n = k ^{ n - 1  } U _1 $.又注意到$T _n = kU _{ n - 1  } W _{ n - 1  } = kW _{ n - 1  } \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = k ^{ n - 1  } U _1 \frac { T _{ n - 1  }  } { T _{ n - 2  }  } = ( k ^{ n - 1  } U _1 ) ( k ^{ n - 2  } U _1 ) \frac { 1  } { T _{ n - 3  }  } $,$T _{ n - 3  } = ( k ^{ n - 4  } U _1 ) ( k ^{ n - 5  } U _1 ) \frac { 1  } { T _{ n - 6  }  } $.所以$T _{ n  } = k ^6 T _{ n - 6  } $,所以$U $存在长度为$6 $的循环节.所以$U _{ N  } = \frac { T _N  } { T _{ N - 1  }  } = \frac { T _2  } { T _1  } = U _2 = kU _1 $.(其实直接暴力找循环节也是可以的)</p>
<p>所以$k $需要是$N $的因子.</p>
<p>哦,还不如直接找循环节,还要判断这是个整数序列.</p>
<p>设$w = U _1 $,则$U $的前六项是:$1 , w , kw , k ^2 , \frac { k ^2  } { w  } , \frac { k  } { w  } $.要求$kw = N , w | k $,所以$( 11 \times 23 ) | k $,$k \equiv 0 \pmod { 4  } $.所以$k = 4 \times 11 \times 23 $或$k = 8 \times 11 \times 23 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>求使方程$\lfloor \frac { 10 ^n  } { x  } \rfloor = N = 2024 $恰有两个整数解的正整数$n $的个数.</p>
<h5><span id="solution15">Solution15</span></h5><p>我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
N & \leq \frac { 10 ^n  } { x  } & < N + 1 \\
xN & \leq 10 ^n & < x ( N + 1 ) \\
\frac { 10 ^n  } { N + 1  } & < x & \leq \frac { 10 ^n  } { N  } \\
\lfloor \frac { 10 ^n  } { N + 1  } \rfloor & < x & \leq \lfloor \frac { 10 ^n  } { N  } \rfloor \\
\lfloor \frac { 10 ^n  } { N  } \rfloor - \lfloor \frac { 10 ^n  } { N + 1  } \rfloor & = 2 \\
\frac { 10 ^n  } { N ( N + 1 )  } - \frac { 10 ^n \bmod N  } { N  } + \frac { 10 ^n \bmod { ( N + 1 )  }  } { N + 1  } & = 2 
\end{aligned}</script><p>显然$\lfloor \frac { 10 ^n  } { N ( N + 1 )  } \rfloor = 1 , 2 , 3 $.而$N ( N + 1 ) = 4098600 $,所以只有$n = 7 $可能满足条件,带入检验可行.</p>
<h4><span id="problem18">Problem18</span></h4><p>用六种颜色给正方形六个面染色,旋转平移后相同算一种方案,要求每个面颜色都不同,求方案数.</p>
<h5><span id="solution18">Solution18</span></h5><p>钦定一个面,然后枚举对面,中间四个是一个环,方案数是$5 \times 3 ! = 30 $.</p>
<h4><span id="problem19">Problem19</span></h4><p>$f ( x ) = \lfloor 2 x \rfloor + \lfloor 4 x \rfloor + \lfloor 6 x \rfloor + \lfloor 8 x \rfloor , x \in \mathbb { R  } $,求其不超过$n = 2024 $的正整数取值有多少种.</p>
<h5><span id="solution19">Solution19</span></h5><p>显然$f ( x + 1 ) = f ( x ) + 20 $,因此我们先考虑$x \in [ 0 , 1 ) $的情况.</p>
<p>手动枚举一下知道此时$f ( x ) $有$12 $种不同的取值,前六种是$\{ 0 , 1 , 2 , 4 , 5 , 6 \} $,后六种对应了前六种$+ 10 $.而$2024 = 101 \times 20 + 4 $,所以共有$101 \times 12 - 1 + 4 = 1215 $种取值.</p>
<h4><span id="problem20">Problem20</span></h4><p>从$[ 1 , n ] , n = 2024 $中分别独立随机两个正整数(可以相同)$a , b $,则求$3 ^a + 7 ^b \equiv 8 \pmod { 10  } $的概率.</p>
<h5><span id="solution20">Solution20</span></h5><p>考虑$\varphi ( 10 ) = 4 $,所以原题答案等价于$n = 4 $的时候的答案.在这$16 $中可能性中满足条件的只有三种,概率为$\frac { 3  } { 16  } $.</p>
<h3><span id="2023强基部分">2023强基(部分)</span></h3><h4><span id="problem3">Problem3</span></h4><p>已知$a _1 = \frac { 5  } { 2  } , a _{ n + 1  } = a _n ^2 - 2 $,求$\lfloor a _n \rfloor \bmod 7 , n = 2023 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>这个一看就不是好解的,想都别想直接数学归纳,注意到$a _n = \frac { 4 ^{ 2 ^{ n - 1  }  } + 1  } { 2 ^{ 2 ^{ n - 1  }  }  } $,那么$\lfloor a _n \rfloor = 2 ^{ 2 ^{ n - 1  }  } $.</p>
<p>而$\varphi ( 7 ) = 6 , \varphi ( 6 ) = 2 $.由扩展欧拉定理,立刻有:$2 ^{ 2 ^{ 2022  }  } \equiv 2 ^{ 2 ^{ 2022  } \bmod 6  } \equiv 2 ^{ 2 ^{ 6  }  } \equiv 16 \equiv 2 \pmod { 7  } $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$50 $个队伍两两打比赛,胜一场积分$+ 1 $,负一场积分不变,无平局.</p>
<p>且任取$27 $支队伍,其中一定有一支队伍负于其它的$26 $支,也一定有一支队伍胜于其它的$26 $支.</p>
<p>问$50 $支队伍最少有多少种不同的积分.</p>
<h5><span id="solution4">Solution4</span></h5><p>答案是$50 $.</p>
<p>因为是竞赛图,缩点之后是一条链.</p>
<p>如果所有强连通分量的大小都$\leq 27 $的话,显然我们全选一个强连通分量就完蛋了.因此所有的强连通分量的大小都$&gt; 27 $,唯一的可能是所有点在一个强连通分量中,我们在其中取出一个长度为$k $的简单环,由鸽笼原理,剩下的$n - k $个点中至少有$\frac { n - k  } { 2  } $个点对着$k $个点只输或者只赢(如果有输有赢就无所谓了),这样的话只需要$k + \frac { n - k  } { 2  } \geq 27 $即可,此时$k \geq 4 $即可.由于这是竞赛图,显然存在长度为$4 $的简单环.</p>
<p>还有一种更简单的做法,考虑取一个积分最多的点,假设为$u $.我们任意取一个击败过它的点(如果有的话),假设为$v $,再取$25 $个被$u $击败的点(显然这些点存在),设这些点集为$S $.则$u , v , S $组成的集合中,有一个点可以击败其它所有点,根据假设,只能是$v $.由此,可以知道,只要是$u $能击败的点,$v $一定能击败,而且$v $能击败$u $,因此$\deg _v &gt; \deg _u $,与假设不符.因此一定不存在一个$v $可以击败$u $.删掉$u $后做数学归纳,可知原图一定是拓扑图.</p>
<h4><span id="problem8">Problem8</span></h4><p>一只蚂蚁第一天在$( 0 , 0 ) $,第$k + 1 $天向上下左右随机一个方向移动$\frac { 1  } { 4 ^k  } $单位,求第$n $天的可能位置数量,$n = 2023 $.</p>
<h5><span id="solution8">Solution8</span></h5><p>不妨设第$n $天不同位置数量为$S _n $,显然只要前面岔开了,后面永远无法走到一个点.所以$S _1 = 1 , S _{ n + 1  } = 4 S _n , S _{ 2023  } = 4 ^{ 2022  } $.</p>
<h4><span id="problem10">Problem10</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 10 $,求$U $中的满足元素两两互素的三元子集个数.</p>
<h5><span id="solution10">Solution10</span></h5><p>集合是无序的,这个很难搞,我们先从$U $中把$1 $去掉最后再加上.</p>
<p>先考虑可以重复放$1 $的情况:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^{ n  } \sum _{ k = 1  } ^{ n  } [ \gcd ( i , j ) & = 1 ] [ \gcd ( i , k ) & = 1 ] [ \gcd ( j , k ) & = 1 ] \\

\end{aligned}</script><p>这个推下去感觉就头大了,退一步考虑暴力算吧.</p>
<p>先考虑全是奇数的情况,只能从$1 , 3 , 5 , 7 , 9 $中选,答案应该是$1 + 2 \binom { 3  } { 2  } = 7 $.</p>
<p>接下来考虑选一个偶数,如果选$2 , 4 , 8 $是等价的,答案此时是$3 ( \binom { 5  } { 2  } - 1 ) = 27 $.如果选$6 $的话答案是$\binom { 3  } { 2  } = 3 $.如果选$10 $的话方案数是$\binom { 4  } { 2  } - 1 = 5 $,加起来方案数是$42 $.</p>
<h4><span id="problem11">Problem11</span></h4><p>集合$U = \{ 1 , 2 , \cdots , n \} , n = 366 $,则$U $的互不相交且各元素之和为$17 $的倍数的二元子集最多有多少个?</p>
<h5><span id="solution11">Solution11</span></h5><p>考虑$\lfloor \frac { 366  } { 17  } \rfloor = 21 , 366 \equiv 9 \pmod { 17  } $.答案显然是$21 \times 8 + 10 + 1 = 179 $个.</p>
<h4><span id="problem12">Problem12</span></h4><p>三个互不相同的数的$\gcd = 20 , \text { lcm  } = 20000 $,求选取这三个数的方案数(顺序不同算不同的方案).</p>
<h5><span id="solution12">Solution12</span></h5><p>显然等价于$\gcd = 1 , \text { lcm  } = 1000 = 2 ^3 \times 5 ^3 $.先只分析其中一个质因子,方案应该是$( 0 , 0 , 3 ) , ( 0 , 1 , 3 ) , ( 0 , 2 , 3 ) , ( 0 , 3 , 3 ) $,打乱一下顺序的话就共有$3 + 6 + 6 + 3 = 18 $种方案.如果可以重复,平方一下得到$324 $.</p>
<p>接下来去掉重复的情况,只有可能两个质因子都相同才会重复,拿上面的三元组算一下,此时方案数共有$2 \times 2 \times 3 = 12 $种,于是答案为$312 $.</p>
<h4><span id="problem14">Problem14</span></h4><p>求$\lfloor \frac { k ^2  } { n  } \rfloor , k \in [ 1 , n ] , n = 2023 $种有多少个不同的元素.</p>
<h5><span id="solution14">Solution14</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\lfloor \frac { k ^2  } { n  } \rfloor & = d \\
d & \leq \frac { k ^2  } { n  } & < d + 1 \\
nd & \leq k ^2 & < n ( d + 1 ) 
\end{aligned}</script><p>由于两个完全平方数的差是固定的,不妨猜测存在一个$k _0 $,$\leq k _0 $的$k $会扎堆,但是这些$d $全都能取到,$&gt; k _0 $的则不会有两个$k $得到相同的元素.所以前者统计不同的$d $,后者统计不同的$k $考虑$( k + 1 ) ^2 - k ^2 = 2 k + 1 $.分界线应该是$k _0 = 1011 $.</p>
<p>所以答案应该是$n - k _0 + \lfloor \frac { k _0 ^2  } { 2 k _0 + 1  } \rfloor + 1 = 1012 + 506 = 1518 $.</p>
<h4><span id="problem15">Problem15</span></h4><p>对四元组$( a , b , c , d ) $计数,满足$101 | ( a + b + c + d ) $且$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $.</p>
<h5><span id="solution15">Solution15</span></h5><p>这题真的厉害啊.</p>
<p>不妨设$S _k $为满足$( a + b + c + d ) \equiv k \pmod { 101  } $的满足$0 &lt; a &lt; b &lt; c &lt; d \leq 101 $的四元组数量.不难发现$\sum S _k = \binom { 101  } { 4  } $.</p>
<p>注意到$( a , b , c , d ) \mapsto ( a + 1 , b + 1 , c + 1 , d + 1 ) $,注意这里是$\pmod { 101  } $意义下的加法,这是一个双射,所以$S _{ k  } = S _{ k + 4  } $,下标同样也是$\pmod { 101  } $意义下进行的.又因为$\gcd ( 101 , 4 ) = 1 $,所以所有的$S _k $均相等.$S _0 = \frac { \binom { 101  } { 4  }  } { 101  } = 40425 $.</p>
<h4><span id="problem16">Problem16</span></h4><p>问方程$x \lfloor x \rfloor = 6 $的解的个数.</p>
<h5><span id="solution16">Solution16</span></h5><p>$6 = x \lfloor x \rfloor \geq \lfloor x \rfloor ^2 $,所以$\lfloor x \rfloor = \pm 1 , \pm 2 $.显然都不可以.所以个数为$0 $.</p>
<h4><span id="problem17">Problem17</span></h4><p>设$R ( n ) = \sum _{ k = 2  } ^{ 10  } ( n \bmod k ) $,求满足$R ( n ) = R ( n + 1 ) $的十进制下的两位数$n $的个数.</p>
<h5><span id="solution17">Solution17</span></h5><p>从$R ( n ) $到$R ( n + 1 ) $,应该是加了若干个$1 $,然后又丢了几个$k - 1 $这样的.那就一定需要丢掉的数字之和为$9 $.枚举一下,丢了的只有可能是以下情况:$( 9 ) , ( 7 + 2 ) , ( 6 + 3 ) , ( 5 + 4 ) , ( 4 + 3 + 2 ) $,分别对应了$n + 1 $应该是分别以下数的倍数$( 9 ) , ( 14 ) , ( 6 ) , ( 20 ) , ( 12 ) $,并且和分别要求不是另一些数的倍数,这就去掉了其中的若干个,最后剩下的是:$( 7 + 2 ) $,并且分别不能是以下数字的倍数$( 3 , 4 , 5 ) $.</p>
<p>取一下的话$n + 1 $可以是:$14 , 98 $,$n = 13 , 97 $,验证一下均合法,所以答案为$2 $.</p>
<h4><span id="problem18">Problem18</span></h4><p>已知$a &lt; b &lt; c &lt; d $,而$x , y , z , w $是$a , b , c , d $的一个排列,求$( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 $得到的不同数个数.</p>
<h5><span id="solution18">Solution18</span></h5><p>圆排列个数是$3 ! = 6 $个,只需要判掉相同的圆排列即可.</p>
<p>显然翻转后是相同的,所以最多有三个不同数,排列分别是$( x , y , z , w ) , ( x , z , w , y ) , ( x , w , y , z ) $.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x - y ) ^2 + ( y - z ) ^2 + ( z - w ) ^2 + ( w - x ) ^2 \\
& = 2 ( x ^2 + z ^2 + y ^2 + w ^2 ) - 2 ( xy + yz + zw + wx ) 
\end{aligned}</script><p>显然只要$xy + yz + zw + wx $不同,那么两个数就不同.不难判断上面三个数互不相同.</p>
<h4><span id="problem19">Problem19</span></h4><p>已知$0 &lt; x _1 &lt; x _2 &lt; \cdots &lt; x _9 $且$\sum _{ k = 1  } ^9 x _k = 220 $,在$\sum _{ k = 1  } ^5 x _k $最大的前提下,最小化$x _9 - x _1 $.</p>
<h5><span id="solution19">Solution19</span></h5><p>不妨枚举一下$x _5 $选啥,设$f ( S , m , k ) $表示选出$k $个互不相同的数,使得它们$\leq m $且总和为$S $,是否可行.不难发现$f ( S , m , k ) = [ \frac { k ( k + 1 )  } { 2  } \leq S \leq \frac { k ( 2 m - k + 1 )  } { 2  } ] $.</p>
<p>那我们要求的就是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\max _{ 5 \leq x _5  } \{ S | f ( 220 - 4 x _5 - S , + \infty , 4 ) & = 1 \land f ( S - x _5 , x _5 - 1 , 4 ) & = 1 \} \\
& = \max _{ 5 \leq x _5  } \{ S | 4 x _5 + S & \leq 210 \land 10 + x _5 & \leq S & \leq 5 x _5 - 10 \} \\
& = \max _{ 5 \leq x _5  } ( \min \{ 5 x _5 - 10 , 210 - 4 x _5 \} ) 
\end{aligned}</script><p>立刻得到$x _5 = 24 , 25 , S = 110 $,那么后面的选法就一定了,后面四个数一定是$26 , 27 , 28 , 29 $,只需要让$x _1 $最大即可</p>
<p>$x _5 = 24 $时,此时最优显然是$20 , 21 , 22 , 23 , 24 , 26 , 27 , 28 , 29 $,$x _9 - x _1 = 9 $.</p>
<h4><span id="problem20">Problem20</span></h4><p>有一个$n $边形,其中有$\binom { n  } { 2  } $条对角线,不存在三线交于一点的情况,问这些对角线将该$n $边形分成了多少个部分.$n = 10 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>平面图同样符合欧拉定理.</p>
<p>考虑内部一定多出来了$\binom { n  } { 4  } $个点(任意四个点有且只有一种交法),每交一个点就会多出$2 $条边,所以多出来了$2 \binom { n  } { 4  } + \frac { n ( n - 3 )  } { 2  } $条边.</p>
<p>考虑内部的若干个部分一定是$a _3 $个三角形,$a _4 $个四边形,…,$a _k $个$k $边形,总之我们发现:</p>
<script type="math/tex; mode=display">
\begin{cases}
\sum _{ j = 3  } ^k ( j - 2 ) \pi a _j = ( n - 2 ) \pi + 2 \pi \binom { n  } { 4  } \\
\sum _{ j = 3  } ^k ja _j = n + 4 \binom { n  } { 4  } + n ( n - 3 ) 
\end{cases}</script><p>两式得到:$\sum _{ j = 3  } ^k a _j = \frac { ( n - 1 ) ( n - 2 )  } { 2  } + \binom { n  } { 4  } $.</p>
<p>$n = 10 $的时候,答案为$246 $.</p>
<h3><span id="2024强基部分">2024强基(部分)</span></h3><h4><span id="problem1">Problem1</span></h4><p>求$\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \bmod 7 , n = 2024 $.</p>
<h5><span id="solution1">Solution1</span></h5><script type="math/tex; mode=display">
\begin{aligned}
\sum _{ i = 1  } ^n \lfloor \frac { 19 ^i  } { 20  } \rfloor \\
& = \sum _{ i = 1  } ^n \lfloor \frac { \sum _{ k = 0  } ^i 20 ^k ( - 1 ) ^{ i - k  } \binom { i  } { k  }  } { 20  } \rfloor \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \sum _{ i = 1  } ^{ n  } \frac { 19 ^i - ( - 1 ) ^i  } { 20  } \\
& = - \lfloor \frac { n  } { 2  } \rfloor + \frac { \frac { 19  } { 18  } ( 19 ^n - 1 ) - ( \frac { ( - 1 ) ^n - 1  } { 2  } )  } { 20  } 
\end{aligned}</script><p>带入$n = 2024 $并$\bmod 7 $,原式为:</p>
<script type="math/tex; mode=display">
\equiv - 4 + \frac { 5  } { 4  } ( 1 - 5 ^n ) \equiv - 4 + 3 ( 1 - 5 ^n )</script><p>注意到$2024 \bmod 6 = 2 $,原式$\equiv - 4 - 9 \equiv 1 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>求长度为$n $的排列个数,使得排列中$\nexists i \in [ 1 , n - 1 ] , a _i = a _{ i + 1  } - 1 $.$n = 8 $.</p>
<h5><span id="solution3">Solution3</span></h5><p>一眼容斥,也就是每个长度为$k $的连续段的容斥系数应该是$( - 1 ) ^{ k - 1  } $.那么设分成了$w $个段,总的容斥系数应该是$( - 1 ) ^{ n - w  } $,答案就是$f _{ n ‘  } = \sum _{ w = 1  } ^n ( - 1 ) ^{ n - w  } w ! \binom { n - 1  } { w - 1  } = \sum _{ w = 0  } ^{ n ‘  } ( - 1 ) ^{ n ‘ - w  } \binom { n ‘  } { w  } ( w + 1 ) ! = n ‘ ! \sum _{ w = 0  } ^{ n ‘  } \frac { ( - 1 ) ^w  } { w !  } ( n ‘ - w + 1 ) $,此时已经能算出答案是$16687 $.</p>
<p>注意到这个形式和错排非常像,类似错排去凑递推公式.设$g _n $为错排数量,显然有$f _{ n  } = nf _{ n - 1  } + g _{ n  } $,立刻算出答案是$16687 $.</p>
<h4><span id="problem4">Problem4</span></h4><p>已知数列$1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , \cdots $,求其第$n $项$\bmod 5 $的值,$n = 2024 $.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑第一个值为$k $的地方应该在哪里.显然$a _{ \frac { k ( k - 1 )  } { 2  } + 1  } = k $.注意到$a _{ 2081  } = 65 $,所以$a _n = 64 $,其$\bmod 5 = 4 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>求四元组$( a _1 , a _2 , a _3 , a _4 ) $的个数,满足$a _1 , a _2 , a _3 , a _4 \in \{ 1 , 2 , 3 \} $,且$10 &lt; a _1 a _2 a _3 a _4 &lt; 20 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>排个序按照字典序开搜,只有三种可能:$\{ 3 , 3 , 2 , 1 \} , \{ 3 , 2 , 2 , 1 \} , \{ 2 , 2 , 2 , 2 \} $,打乱顺序的话就有$25 $种可能.</p>
<h4><span id="problem8">Problem8</span></h4><p>求$\mathbb { R  } $上方程$x ^2 - 13 \lfloor x \rfloor + 11 = 0 $的解的个数.</p>
<h5><span id="solution8">Solution8</span></h5><p>首先注意到$\lfloor x \rfloor = \frac { x ^2 + 11  } { 13  } $,那么自然有方程组:</p>
<script type="math/tex; mode=display">
\begin{cases}
\frac { x ^2 + 11  } { 13  } \leq x \\
x < \frac { x ^2 + 11  } { 13  } + 1 
\end{cases}</script><p>只需要解这个方程组即可.但是这个方程组很难搞.</p>
<p>先考虑$x ^2 \equiv 2 \pmod { 13  } $这个性质,由勒让德判别符号,算出该方程在整数范围内无解.</p>
<p>没办法,只能设$x = \sqrt { 2 + 13 k  } $的形式,带入有不等式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
k - x + 1 & \leq 0 & < k - x + 2 \\
1 & \leq \sqrt { 2 + 13 k  } - k & < 2 \\
\begin{cases}
0 < k ^2 - 9 k + 2 \\
k ^2 - 11 k - 1 \leq 0 
\end{cases} 
\end{aligned}</script><p>冷静一下!注意到$0 \leq k \leq 13 $,又根据第一个不等式得知大部分$k $应该会很大,开始暴力枚举一下,合法的情况有:$k = 0 , 9 , 10 , 11 $,共有四个解.</p>
<h4><span id="problem9">Problem9</span></h4><p>在一个体积为$1 $的正方体内部找一个点,过这个点作平行于正方体的面的三个平面,这样整个正方体会被分为八个长方体,最小化这八个部分中,体积$\leq \frac { 1  } { 8  } $的长方体的个数.</p>
<h5><span id="solution9">Solution9</span></h5><p>原本想考虑先横着切一刀,分为一个大部分一个小部分,大部分均分即可,小部分选一个很大的部分,剩下三个部分体积$\leq \frac { 1  } { 8  } $.考虑设这个点是$( x , x , h ) $,那么必然有$\begin{cases}( 1 - h ) x ^2 &gt; \frac { 1  } { 8  } \ h ( 1 - x ) ^2 &gt; \frac { 1  } { 8  } \end{cases} $,化简,只要$8 &gt; \frac { 1  } { x ^2  } + \frac { 1  } { ( 1 - x ) ^2  } $即可,这个根据基本不等式不可能满足,寄了.</p>
<p>但是四个肯定是好构造的,我们直接取$( 0 . 5 , 0 . 5 , 0 . 1 ) $即可.那么是不是可以证明答案一定$&gt; 3 $呢?</p>
<p>考虑一个面上的四个长方体,其中较小的两个一定是相邻的.因此,最终体积$\leq \frac { 1  } { 8  } $的长方体肯定也是相连的.接下来证明三个的不行,只需要设这个点为$( x , y , h ) , x , y , h \leq \frac { 1  } { 2  } $,然后证明$8 &gt; \frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } , x , y \leq \frac { 1  } { 2  } $这个不等式无解即可.</p>
<p>由基本不等式,$\frac { 1  } { xy  } + \frac { 1  } { ( 1 - x ) ( 1 - y )  } \geq 2 \sqrt { \frac { 1  } { x ( 1 - x ) y ( 1 - y )  }  } \geq 2 \sqrt { 4 \times 4  } = 8 $,不符题意.</p>
<p>这样就是最少是四个.</p>
<h4><span id="problem11">Problem11</span></h4><p>设$S ( n ) $表示正整数$n $的十进制数码和,求满足$S ( n ) \equiv S ( n + 1 ) \equiv 0 \pmod { 5  } $的最小的$n $.</p>
<h5><span id="solution11">Solution11</span></h5><p>显然必须发生进位,不妨设$n = 10 ^k a + 10 ^k - 1 $,$a \ne 9 \pmod { 10  } $,$S ( n ) = S ( a ) + 9 k , S ( n + 1 ) = S ( a ) + 1 $,</p>
<p>此时显然有$9 k - 1 \equiv 0 \pmod { 5  } $,$k \equiv 4 \pmod { 5  } $.$n _{ \min  } = 49999 $.</p>
<h4><span id="problem12">Problem12</span></h4><p>求满足以下条件的最大的正整数$n $:十进制下每一位数字互不相同,且$\forall m , 10 ^m \leq n , \lfloor \frac { n  } { 10 ^m  } \rfloor | n $.</p>
<h5><span id="solution12">Solution12</span></h5><p>显然不可能是五位数及以上,而且如果是四位数的话最后一位必然是$0 $.</p>
<p>不妨设其为$\overline { ab  } $,其中$b = 10 c $,$a $是$b $的因子,不妨枚举一下$k = \frac { b  } { a  } $.注意到因为$a $中不能有$0 $,所以$k \in \{ 2 , 4 , 5 , 8 \} $.取$k = 2 $试出来$3570 $是合法的,而且显然$k \in \{ 4 , 5 , 8 \} $的时候不可能有更大的答案了.</p>
<h4><span id="problem20">Problem20</span></h4><p>$a _1 = \sqrt { 2  } , a _{ n + 1  } = \lfloor a _n \rfloor + \frac { 1  } { a _n - \lfloor a _n \rfloor  } $,求$\sum _{ k = 1  } ^{ n  } a _k , n = 2024 $.</p>
<h5><span id="solution20">Solution20</span></h5><p>这一看就是个环,设$a _n = b _n + c _n \sqrt { 2  } $.难点显然在下取整函数.</p>
<p>没想出太好的办法,选择使用数学归纳,注意到:</p>
<script type="math/tex; mode=display">
\begin{cases}
a _1 = 0 + \sqrt { 2  } \\
a _2 = 2 + \sqrt { 2  } \\
a _3 = 4 + \sqrt { 2  } \\
\cdots 
\end{cases}</script><p>容易猜测$b _n = 2 ( n - 1 ) , c _n = 1 $.也就是$a _n = 2 ( n - 1 ) + \sqrt { 2  } $,数学归纳一下即可.</p>
<p>那么$\sum _{ k = 1  } ^n a _k = n ( n - 1 ) + n \sqrt { 2  } $,带入$n = 2024 $即可.</p>
<h3><span id="2022图选">2022图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问能否将有限个单位正方形摆放在平面上使得:</p>
<ol>
<li><p>任意两个正方形至多有一个顶点重合</p>
</li>
<li><p>每个正方形的每个顶点都与其他某个正方形的顶点重合</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>这个题传到我这里题面已经丧失了,但反正理解起来就两种情况</p>
<ol>
<li><p>边不能相交.此时不可能.考虑扫描线,从上到下扫一条线,然后第一次扫到的最右边的那个顶点显然不可能和其它的某个正方形顶点重合.</p>
</li>
<li><p>边可以相交,放到正十二边形的边上.</p>
</li>
</ol>
<h4><span id="problem2">Problem2</span></h4><p>求$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor $.</p>
<h5><span id="solution2">Solution2</span></h5><p>考虑$( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^3 = 2 + \sqrt { 5  } $,$\lfloor ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ 12  } \rfloor = 161 + \lfloor 72 \sqrt { 5  } \rfloor = 321 $.</p>
<p>也可以考虑类似斐波那契数列,取$f _n = ( \frac { 1 + \sqrt { 5  }  } { 2  } ) ^{ n  } + ( \frac { 1 - \sqrt { 5  }  } { 2  } ) ^{ n  } $,其满足$f _n = f _{ n - 1  } + f _{ n - 2  } , f _0 = 2 , f _1 = 1 $,取$f _{ 12  } - 1 $就是答案$321 $.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于一个加法乘法环,要求你利用:</p>
<ol>
<li><p>乘法结合律、交换律、对加法的分配律、逆元.</p>
</li>
<li><p>加法结合律、逆元.</p>
</li>
</ol>
<p>来证明加法的交换律.</p>
<h5><span id="solution3">Solution3</span></h5><p>倒反天罡题.</p>
<p>注意到$( a + 1 ) ( b + 1 ) = ( b + 1 ) ( a + 1 ) $,所以$a + b = b + a $.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你$n $个数集$a _i $,其中$| a _i | = i + 1 $,要你选出$n $个两两不同的数字满足$x _i \in a _i $,求最少方案数.</p>
<h5><span id="solution4">Solution4</span></h5><p>考虑从小的往大了选,每次可能会删掉一个可选择的数字,所以是$2 ^n $.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice和Bob博弈.Alice先选一个数$m $,然后Bob选一个数$n ( n &gt; m ) $,并构造一个$n $个点的竞赛图.Alice如果能从中选出$m $个不同的点,满足不存在某个点$x $到这$m $个点都有出边,那么Alice赢,否则Bob赢.问是否有人存在必胜策略.</p>
<h5><span id="solution5">Solution5</span></h5><p>一开始以为Alice肯定赢,结果被gank了.</p>
<p>其实Bob一定赢.为啥呢?考虑一对点合法的概率,应该是$( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,因此期望为$E = \binom { n  } { m  } ( 1 - \frac { 1  } { 2 ^m  } ) ^{ n - 2  } $,只需$n $足够大的时候期望$&lt; 1 $,则说明一定存在$0 $,也就是Bob总有必胜策略.</p>
<p>注意到只需证明$\exists n $,$\binom { n  } { m  } &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $,而$\binom { n  } { m  } = \frac { n ^{ \underline { m  }  }  } { m !  } &lt; n ^m $.下面证明$\exists n , n ^m &lt; ( \frac { 2 ^m  } { 2 ^m - 1  } ) ^{ n - 2  } $.</p>
<p>两边取$\ln $,不妨假设$n \geq 3 $,有$m \ln n &lt; ( n - 2 ) \ln ( \frac { 2 ^m  } { 2 ^m - 1  } ) , \frac { m  } { \ln ( \frac { 2 ^m  } { 2 ^m - 1  } )  } &lt; \frac { n - 2  } { \ln n  } $,$\frac { n - 2  } { \ln n  } $显然在$n \geq 3 $的时候单增,所以一定存在这么一个$n $.</p>
<h3><span id="2023图选">2023图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>求单位正方形中能放下的最大的等边三角形的边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>首先肯定三角形有一个角卡在正方形的角上(不然可以平移过去),而且剩下两个角肯定卡在边上.</p>
<h4><span id="problem2">Problem2</span></h4><p>求正整数拆分成有序的$1 , 2 $序列的个数.</p>
<h5><span id="solution2">Solution2</span></h5><p>显然为斐波那契数.</p>
<h4><span id="problem3">Problem3</span></h4><p>定义$* $为集合$G $上的二元运算,已知:</p>
<ol>
<li><p>满足结合律$a ∗ b ∗ c = a ∗ ( b ∗ c ) $.</p>
</li>
<li><p>存在左单位元$e $,对任意$a $满足$e ∗ a = a $.</p>
</li>
<li><p>对任意$a $存在左逆元$b $,使$b ∗ a = e $.</p>
</li>
</ol>
<p>问:</p>
<ol>
<li><p>左单位元是否也为右单位元.</p>
</li>
<li><p>左逆元是否也为右逆元.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>看(2),考虑设$b $是$a $的左逆元,$c $是$b $的左逆元,则$cba = ce = a , ab = ceb = e $.</p>
<p>看(1),设$b $是$a $的逆元,$ea = aba = ae $,所以左单位元也是右单位元.</p>
<p>值得一提的是,这个题如果将条件(3)改为右逆元,则不一定构成群.</p>
<p>感性理解一下改前的题,如果存在左逆元的话,说明$ab $的时候$b $不能彻底损失信息,而观察$ab = eab $知道$a $也不能损失信息,于是应该是群.</p>
<p>但怎么构造反例呢?首先得造出来左单位元对吧.答案给了一种很聪明的构造方式:考虑运算$( a _1 , b _1 ) ( a _2 , b _2 ) $,想办法让其损失掉$( a _1 , b _1 ) $中的信息(这样使其不存在左逆元,但可以构造出左幺元).注意到$( a _1 , b _1 ) ( a _2 , b _2 ) = ( a _1 + a _2 , b _2 ) $即可,存在左幺元为$( 0 , 0 ) $,右逆元为$( - a , 0 ) $.</p>
<h4><span id="problem4">Problem4</span></h4><p>$f $的定义域和值域都是正整数并且$f ( xy ) = f ( x ) + f ( y ) - 1 $,求:</p>
<ol>
<li><p>是否存在这样的函数.</p>
</li>
<li><p>是否存在无数个这样的函数.</p>
</li>
<li><p>是否存在严格递增的函数.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>令$g ( x ) = f ( x ) - 1 $,则$g ( xy ) = g ( x ) + g ( y ) $.</p>
<p>对于(1),取$g ( x ) = 0 , f ( x ) = 1 $即可.</p>
<p>对于(2),考虑$g ( p ^k ) = kg ( p ) $,只需要让$g ( p ) $取不同的值即可.</p>
<p>对于(3),考虑$g ( 2 ^a ) = ag ( 2 ) $,$g ( 3 ^b ) = bg ( 3 ) $.</p>
<p>考虑构造$a , b $,使得$2 ^a &lt; 3 ^b $但是$ag ( 2 ) \geq bg ( 3 ) $.不妨取$a = \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil $,那么必定有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ^{ \lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil  } & < 3 ^b \\
\lceil \frac { bg ( 3 )  } { g ( 2 )  } \rceil & < b \log _2 3 \\
\frac { bg ( 3 )  } { g ( 2 )  } + \Delta & \leq b \log _2 3 \\

\end{aligned}</script><p>于是如果存在,必定需要$\frac { g ( p _1 )  } { g ( p _2 )  } \geq \log _{ p _2  } p _1 \land \frac { g ( p _2 )  } { g ( p _1 )  } \geq \log _{ p _1  } p _2 $,也就是$\frac { g ( p _2 )  } { g ( p _1 )  } = \log _{ p _1  } p _2 $.但是左边是有理数右边是无理数,不可能.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于任意$2 n - 1 $个正整数(可重复),问其中是否一定有$n $个数的和能被$n $整除,这题$n = 50 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑当$n $是合数的时候,设$n = pq $,则可以将其拆成$q - 1 $组每组$2 p $个数以及一组$2 p - 1 $个数,因此只需要这些都可以找到$p $个数使得其是$p $的倍数,组合起来就行了.</p>
<p>只需要解决$n $是质数的情况.</p>
<p>感觉场上的最优解应该是解决$n = 2 $和$n = 5 $的情况然后拼成$n = 50 $.</p>
<p>$n = 2 $的时候显然是对的.</p>
<p>这谁想得到啊?</p>
<p>考虑反证,如果不存在的话,显然$S = \sum _{  } ( x _{ p _1  } + x _{ p _2  } + \cdots + x _{ p _n  } ) ^{ p - 1  } \equiv \binom { 2 n - 1  } { n  } \equiv 1 \pmod { n  } $.</p>
<p>但是考虑左边那个多项式的每一项,形如$c \prod _{ i = 1  } ^k x _{ p _i  } ^{ e _i  } $.注意到$c $一定是$\binom { 2 n - 1 - k  } { n - k  } $的倍数,而后者$\bmod n $为$0 $.</p>
<p>这玩意到底咋想到的?</p>
<p>不过其实也合理,因为$1 $并不是对称的,而左边是个对称式子,某个$x $增大也无所谓,这意味着左边应该是为$0 $的,我们要做的就是去证明它是$0 $.</p>
<h3><span id="2024图选">2024图选</span></h3><h4><span id="problem1">Problem1</span></h4><p>问在双曲线$xy = 1 $上有一个三个点都在上面的等边三角形,求其边长.</p>
<h5><span id="solution1">Solution1</span></h5><p>不会做,取个特殊值知道答案应该是$[ 2 \sqrt { 6  } , + \infty ) $.</p>
<h4><span id="problem2">Problem2</span></h4><p>我们称”能表示为两个数的平方和”的数是好的,求证:</p>
<ol>
<li><p>如果$n , m $都是好的,那么$nm $是好的.</p>
</li>
<li><p>$2024 $不是好的.</p>
</li>
</ol>
<h5><span id="solution2">Solution2</span></h5><p>如果$n = a ^2 + b ^2 , m = c ^2 + d ^2 $,那么$nm = a ^2 c ^2 + a ^2 d ^2 + b ^2 c ^2 + b ^2 d ^2 = ( ac - bd ) ^2 + ( ad + bc ) ^2 $.</p>
<p>$2024 = 2 ^3 \times 11 \times 23 $,使用反证法,不妨设其可以被表示为$a ^2 + b ^2 $.</p>
<p>讨论一下:如果$a , b $均为奇数,那么$a ^2 + b ^2 \equiv 2 \pmod { 8  } $,不符题意.</p>
<p>于是$a , b $应该均为偶数,那么就有$a ‘ ^2 + b ‘ ^2 = 506 $.简单枚举一下就知道不存在.</p>
<p>当然这个题是个数竞结论,可以直接套用结论.</p>
<h4><span id="problem3">Problem3</span></h4><p>对于集合$G $,$e \in G $,定义域为$G $的函数$f $满足以下性质:</p>
<ol>
<li><p>$e \in G $,但$e $不在$f $的值域中.</p>
</li>
<li><p>$G $关于$f $封闭.</p>
</li>
<li><p>若$\exists A \subseteq G $,$e \in A $且$A $对$f $封闭,则$A = G $.</p>
</li>
</ol>
<p>在$G $上定义二元运算$\circ $,满足$ae = a , af ( b ) = f ( ab ) $.</p>
<p>求证:</p>
<ol>
<li><p>存在幺元.</p>
</li>
<li><p>运算满足交换律.</p>
</li>
<li><p>运算满足结合律.</p>
</li>
</ol>
<h5><span id="solution3">Solution3</span></h5><p>只需要证明运算满足交换律即可.</p>
<p>考虑性质(3),我们不妨先往$A $里面扔个$e $,此时$A $一定不满足条件.我们不断从$A $中选出一个元素$w $满足$f ( w ) \notin A $,并把$A : = A \cup \{ f ( w ) \} $.不断做这个过程显然最后会得到$G $,这意味着任何一个元素$a $可以写成$f ( f ( f \cdots f ( e ) ) ) $的形式.</p>
<p>不妨将$f $函数嵌套$k $次记作$f ^{ ( k )  } $,那么我们要证明的是$a = f ^{ ( A )  } ( e ) , b = f ^{ ( B )  } ( e ) $,$ab = ba $.</p>
<p>考虑$ab = f ^{ ( A )  } ( e ) f ^{ ( B )  } ( e ) = f ^{ ( B )  } ( f ^{ ( A )  } ( e ) e ) = f ^{ ( A + B )  } ( e ) $,因此证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>给出一个具体函数满足:</p>
<ol>
<li><p>$f ( x + y ) = f ( x ) + f ( y ) + xy $.</p>
</li>
<li><p>$f ( xy ) = f ( x ) f ( y ) + f ( x - 1 ) f ( y - 1 ) $.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>先注意到$f ( 0 ) = 0 , f ( 1 ) = 1 $.</p>
<p>以$x $为主元两边求导,立刻得到$f ‘ ( x + y ) = f ‘ ( x ) + y $,因此$f ‘ ( x ) $是斜率为$1 $的一次函数,立刻得到$f ( x ) = \frac { x ^2  } { 2  } + \frac { x  } { 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>对于$r = \sqrt { 2  } $,是否存在正整数$p $和整数$q $满足$| pr - q | &lt; \frac { 1  } { 2024  } $且$p &lt; 2024 $.</p>
<h5><span id="solution5">Solution5</span></h5><p>考虑取$0 , \sqrt { 2  } , 2 \sqrt { 2  } , 3 \sqrt { 2  } , \cdots 2023 \sqrt { 2  } $的小数部分,记作$a _0 , a _1 , \cdots a _{ 2023  } $.</p>
<p>由鸽笼原理,一定存在两个数$0 \leq x &lt; y \leq 2023 $满足$| a _x - a _y | &lt; \frac { 1  } { 2024  } $,于是证毕.</p>
<h3><span id="2019茶选">2019茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>在一个数轴上,你站在$0 $点,并按照如下算法寻找$x ( x &gt; 0 ) $点处的牛:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curpos = 0;</span><br><span class="line">curdir = LEFT;</span><br><span class="line">step = 1;</span><br><span class="line">while (没有找到牛) &#123;</span><br><span class="line">沿着 curdir 方向，走 step 单位距离，如果找到牛就停止;</span><br><span class="line">如果没有找到牛，回到原点并将 curdir 设为反方向，step = step * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大约至少需要多少步才能找到牛?</p>
<p>A. $3 x $  B. $5 x $  C. $7 x $  D. $9 x $  E. 以上答案都不对.</p>
<h5><span id="solution1">Solution1</span></h5><p>考虑找到牛的时候$step $为多少,应该为$2 ^{ 2 k  } $,其中$k $满足$2 ^{ 2 k  } \geq x &gt; 2 ^{ 2 ( k - 1 )  } $.此时走的步数应该是$ans = 2 \sum _{ i = 0  } ^{ 2 k - 1  } 2 ^i + x = 2 ^{ 2 k + 1  } - 1 + x $步.而$x \leq 2 ^{ 2 k  } &lt; 4 x $,所以$ans &lt; 9 x - 1 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定$10 $个实数变量$x _1 , \cdots , x _{ 10  } $,满足它们均$\geq 1 $且两两不同.你要寻找一组$\{ x \} $和一个实数$a $,使得存在尽可能多组$\langle b \rangle , b _i = \pm 1 $,满足$\sum _{ i = 1  } ^{ 10  } b _i x _i \in ( a , a + 2 ) $.</p>
<p>最多存在多少组$\langle b \rangle $?</p>
<p>A. $512 $  B. $252 $  C. $504 $  D. $684 $  E.以上答案都不对.</p>
<h5><span id="solution2">Solution2</span></h5><p>不妨猜测$x $全取$1 $最优,此时的答案是$\binom { 10  } { 5  } = 252 $.</p>
<p>能不能严格证明这个事情呢?我们不妨注意到一个事情:由于$x \geq 1 $,所以如果存在两组$\langle b \rangle $,使得$A $组中选择取$+ 1 $恰好是$B $组的子集,那么$S _A \leq S _B - 2 $,不可能同时满足条件.</p>
<p>如果我们能选出若干个互不相交的集合呢?那我们显然可以让$x $尽可能接近$1 $,这样就是满足条件的.所以问题变为对于一个大小为$10 $的集合,要在其中挑选出尽可能多的子集使得这些集合两两之间没有包含关系,有结论说这个东西取$\binom { 10  } { 5  } $最优,即Sperner定理.其实也就是Dilworth定理的特例.</p>
<h4><span id="problem3">Problem3</span></h4><p>给定无向图$G = ( V , E ) $,我们称一个图是好的,如果:</p>
<ol>
<li><p>每个点的度数均为$d $.</p>
</li>
<li><p>任何一个大小不超过$\frac { | V |  } { 2  } $的联通集合$S $,其邻居(不属于$S $但和$S $中的某个点存在直接相连的边)的大小$\geq \frac { 5  } { 4  } | S | $.</p>
</li>
</ol>
<p>求证:好的图中任意两个点$u , v $之间的最短路径长度$dis ( u , v ) = O ( \log | V | ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑以$u $为起点一点一点往外扩张,这样一直扩张到$\frac { | V |  } { 2  } + 1 $时,集合中每个点到$u $的距离不超过$O ( \log | V | ) $.</p>
<p>然后以$v $做同样的事,由于这两个集合大小之和大于$| V | $,说明一定有交,且存在一条路径长度为$O ( \log | V | ) $的路径,最短路径肯定比这个还短.</p>
<h4><span id="problem4">Problem4</span></h4><p>给你两个完全相同的鸡蛋和一个$n = 100 $层的高楼,你每次可以将鸡蛋从某一层楼掉下去.问你最少用多少次操作才能测出能让鸡蛋摔碎的最低楼层.</p>
<h5><span id="solution4">Solution4</span></h5><p>经典信息论题.考虑构造一棵左倾的决策树,从根到任何一个叶子节点最多向右走两步,并且有$101 $个叶子节点(因为还有可能从最高层掉下去不碎).</p>
<p>设$f _{ i , 1 / 2  } $表示一棵有$i $个叶子的树,最多向右走$1 / 2 $步,深度最低为多少.显然$f _{ i , 1  } = i - 1 $.</p>
<p>不妨设最后的最大深度为$k $,需要满足$1 + \sum _{ i = 1  } ^k i = 1 + \frac { k ( k + 1 )  } { 2  } \geq 101 , k ( k + 1 ) \geq 200 $,$k _{ \min  } = 14 $.</p>
<h4><span id="problem5">Problem5</span></h4><p>$n $个人要进行一场游戏.游戏设计者准备了$n $张卡片,正面分别写着$n $个人的名字,背面写了$[ 1 , n ] $共$n $个不同的数字.所有卡片都背面朝上放置在一个房间里.</p>
<p>当设计者准备完成后,$n $个人可以经过充分的讨论,并依次进入房间,一张一张地翻开$\lfloor \frac { n  } { 2  } \rfloor $张卡片,并找到写有自己名字的卡片.当一个人操作结束后,他无法与其他人交流直到游戏结束.</p>
<p>只有所有$n $个人全部找到了写有自己名字的卡片,他们才能获胜.请问:是否存在一种策略,使得无论设计者怎样安排名字和数字的对应,他们均拥有超过$0 . 1 $的胜率.</p>
<h5><span id="solution5">Solution5</span></h5><p>这题真理元素讲过.做法是每个人先翻开自己编号的位置的卡片,假设卡片上数字是$a $,如果$a $就是自己的编号就下班;反之接下来翻开$a $位置的卡片.为了防止设计者刻意安排,可以提前自己随机一个数字的映射.这样失败当且仅当场上存在一个长度大于$\frac { n  } { 2  } $的环.</p>
<p>考虑总方案数是$n ! $.不妨枚举这个环的长度为$K $,则存在一个长度$= K &gt; \frac { n  } { 2  } $的环的方案数是$\binom { n  } { K  } ( K - 1 ) ! ( n - K ) ! = \frac { n !  } { K  } $.所以此时的概率为$\frac { 1  } { K  } $.</p>
<p>那么失败的概率就是$H _n - H _{ \frac { n  } { 2  }  } \approx \ln 2 $.</p>
<h3><span id="2022茶选">2022茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>证明弱对偶定理,差不多就是:</p>
<p>提一个问题:最大化$z = 5 x _1 + 8 x _2 + 4 x _3 $,其中:</p>
<ol>
<li><p>$x _1 , x _2 , x _3 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } x _1 + 5 x _2 + 9 x _3 \leq 3 $</p>
</li>
<li><p>$4 x _1 + 7 x _2 + 3 x _3 \leq 6 $</p>
</li>
</ol>
<p>再提一个问题:最小化$v = 3 y _1 + 6 y _2 $,其中:</p>
<ol>
<li><p>$y _1 , y _2 \geq 0 $</p>
</li>
<li><p>$\frac { 1  } { 2  } y _1 + 4 y _2 \geq 5 $</p>
</li>
<li><p>$5 y _1 + 7 y _2 \geq 8 $</p>
</li>
<li><p>$9 y _1 + 3 y _2 \geq 4 $</p>
</li>
</ol>
<p>现在请你证明:$z \leq v $.</p>
<h5><span id="solution1">Solution1</span></h5><p>下面乘一下配一下上面的系数,自然得证.</p>
<p>写成矩阵形式,设$X = \begin{bmatrix}x _1 &amp; x _2 &amp; x _3 \end{bmatrix} , A = \begin{bmatrix}0 . 5 &amp; 4 \ 5 &amp; 7 \ 9 &amp; 3 \end{bmatrix} , Y = \begin{bmatrix}y _1 \ y _2 \end{bmatrix} $,不难发现$z \leq XAY \leq v $.</p>
<h4><span id="problem2">Problem2</span></h4><p>半径为$R $的球里放点,要求两两之间距离不能小于$1 $,证明至多放$( 2 R + 1 ) ^3 $个.</p>
<h5><span id="solution2">Solution2</span></h5><p>要求两两距离不能小于$1 $等价于往其中放半径为$0 . 5 $的球,这种球体积为$\frac { 4  } { 3  } \pi \frac { 1  } { 8  } $.然后原球要扩大一圈,所以原球体积变为$\frac { 4  } { 3  } \pi ( R + 0 . 5 ) ^3 $.除一下得到答案.</p>
<h4><span id="problem3">Problem3</span></h4><p>一个无限长的数轴上有一辆车,它的初始坐标是个未知的整数$n $.</p>
<p>它每秒以$v $的速度行驶,其中$v $是个未知的整数(可以为负).</p>
<p>现在你每秒能进行一次这样的询问:询问整数$x $,你会得知此时车的坐标是否是$x $(Yes or No).</p>
<p>请给出一个策略,使得在有限的时间里可以获得一次Yes回答.</p>
<h5><span id="solution3">Solution3</span></h5><p>第$t $秒的时候车应该在$n + vt $处.由于我们知道现在是第几秒,枚举$n , v $然后不断check即可.这个是经典的证明$\mathbb { Z  } ^2 $和$\mathbb { N  } $等势.按照$| n | + | v | $排序然后一个一个遍历.</p>
<h4><span id="problem4">Problem4</span></h4><p>对满足$\forall i , | i - p _i | \leq 1 $的排列计数.</p>
<h5><span id="solution4">Solution4</span></h5><p>简单题,设$f _n $为答案,考虑$p _n $取什么.</p>
<p>当$p _n = n $时,方案数为$f _{ n - 1  } $.</p>
<p>当$p _n = n - 1 $时,$p _{ n - 1  } = n $,方案数为$f _{ n - 2  } $.</p>
<p>于是,$f _1 = 1 , f _2 = 2 $,$f _n = f _{ n - 1  } + f _{ n - 2  } $.</p>
<h4><span id="problem5">Problem5</span></h4><p>你有一个$n \times n $的棋盘.初始所有格子都是白色的.</p>
<p>你可以选择$k $个格子染黑.此后,如果某个格子四联通的两个格子都是黑色,它自己也会变成黑色.</p>
<p>你要让所有格子最终都变黑.试证明:你一开始选择染黑的格子数$k $最小值是$n $.</p>
<h5><span id="solution5">Solution5</span></h5><p>数学归纳了半天,屁用没用.</p>
<p>注意到在扩张过程中,黑色格子的周长不会变大,所以至少是$\frac { 4 n  } { 4  } = n $个.</p>
<h4><span id="problem6">Problem6</span></h4><p>设$F = \{ S _1 , S _2 , S _3 , . . . , S _{ | F |  } \} $,定义一个集合$T $能被$F $ shattered为:$T $的任意一个子集(包括它自己和空集),都可以由$T \cap S _{ i _1  } \cap S _{ i _2  } . . . $表示.其中$S _{ i _j  } $是$F $中的集合(就是说每个子集都等于$T $和某些$F $内集合的交.)</p>
<p>定义一个$F $的”VC-Dimension”是,能被他shattered的集合$T $的大小的最大值.</p>
<p>$F $中的集合们只会包含某$n $种不同的元素.证明:</p>
<ol>
<li><p>任意一个$F $能shattered的$T $至少有$| F | $个.</p>
</li>
<li><p>对于一个VC-Dimension的大小为$k $的$F $,其$| F | \leq \sum _{ i = 0  } ^k \binom { n  } { i  } $.</p>
</li>
</ol>
<h5><span id="solution6">Solution6</span></h5><p>显然只要证明了(1),那么(2)是显然的.</p>
<p>那么怎么证明(1)呢?考虑数学归纳.先考虑拎出所有的$S $,满足$S , S \cup \{ x \} \in F $,然后将这些$S \cap \{ x \} $拎出来,假设有$t $个,左边删去$x $后再进行数学归纳得到$| F | - t $个集合(由于拎出了所有满足上述条件的集合,不可能删出重复的集合),右边也有$t $个集合,在这$t $个集合添上$x $这个元素即可.</p>
<p>$t = 0 $怎么办?我们自己造一组满足条件的就行了.每次加入一个集合:如果这个集合存在一个前面所有的集合都没有的元素,那么显然把这个元素拎出来就行了.又注意到如果一个元素全局都有的话,那么很废物对吧,我们把这个元素删掉继续做.此时不妨设新加入的集合为$S $(选取最大的那个集合为新加入的),我们在前面的集合中找到一个与$S $有交的集合$T $,根据上面的预处理,此集合显然存在.选出一个$x \in S \setminus T $,不妨设$S = S ‘ \cup \{ x \} $,令$T ‘ = S ‘ \cap T $,然后用$T ‘ $代替原本的$T $即可.</p>
<h3><span id="2023茶选">2023茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>令$p ( x ) $表示$x $的最大质因子,求所有$( x , y , z ) $使得:</p>
<ol>
<li><p>$x &lt; y &lt; z $且$x + z = 2 y $.</p>
</li>
<li><p>$p ( xyz ) \leq 3 $.</p>
</li>
</ol>
<h5><span id="solution1">Solution1</span></h5><p>不妨令$g = \gcd ( x , y , z ) $,令$x ‘ = \frac { x  } { g  } $,则只需要解:$x ‘ + z ‘ = 2 y ‘ $.</p>
<p>我们有$y - x = z - y $,则$\gcd ( y ‘ , x ‘ ) = \gcd ( y ‘ , y ‘ - x ‘ ) = \gcd ( y ‘ , z ‘ ) = 1 $,用这个能解决不少讨论.</p>
<p>此时有以下两种情况:</p>
<ol>
<li><p>$2 \nmid x ‘ , 2 \nmid z ‘ $.</p>
</li>
<li><p>$2 \mid x ‘ , 2 \mid z ‘ , 2 \nmid y ‘ $.</p>
</li>
</ol>
<p>先看(1),设$x ‘ = 3 ^a , z ‘ = 3 ^c , y ‘ = 2 ^b $.方程变为$3 ^a ( 1 + 3 ^{ c - a  } ) = 2 ^{ b + 1  } $,一定有$a = 0 $,只需解$1 + 3 ^{ c  } = 2 ^{ b + 1  } $.</p>
<p>当$b \leq 2 $的时候,经检验有$\begin{cases}c = 0 \ b = 0 \end{cases} $(舍)和$\begin{cases}c = 1 \ b = 1 \end{cases} $两组解.</p>
<p>当$b \geq 3 $的时候,注意到$3 ^{ c  } \equiv - 1 \pmod { 4  } $,所以$c $是偶数.又注意到$3 ^{ c  } \equiv - 1 \pmod { 8  } $,但是奇数的平方$\bmod 8 $应该是$1 $,不符.</p>
<p>再看(2),设$x ‘ = 2 ^d , z ‘ = 2 ^e , y ‘ = 3 ^b $.</p>
<p>当$e = 1 $时,显然不符.</p>
<p>当$d = 1 , e &gt; 1 $时,要解$2 ^{ e - 1  } + 1 = 3 ^{ b  } $.当$e = 2 $的时候有一组解$\begin{cases}e = 2 \ b = 1 \end{cases} $.当$e \geq 3 $的时候,有$3 ^b \equiv 1 \pmod { 4  } $,说明$b $是偶数.</p>
<p>那必然有$2 ^{ e - 1  } = 3 ^b - 1 = ( 3 ^{ \frac { b  } { 2  }  } + 1 ) ( 3 ^{ \frac { b  } { 2  }  } - 1 ) $.令$t = 3 ^{ \frac { b  } { 2  }  } - 1 $,则$2 ^{ e - 1  } = t ( t + 2 ) $.则要么$t = 2 $,要么$t + 2 = 2 $.解出$b - 2 $,此时有$\begin{cases}e = 4 \ b = 2 \end{cases} $.</p>
<p>综上,解出来的解有$\begin{cases}x ‘ = 2 \ y ‘ = 3 \ z ‘ = 4 \end{cases} , \begin{cases}x ‘ = 1 \ y ‘ = 2 \ z ‘ = 3 \end{cases} , \begin{cases}x ‘ = 2 \ y ‘ = 9 \ z ‘ = 16 \end{cases} $.</p>
<p>但其实有更厉害一点的做法,考虑升幂引理.</p>
<p>先看方程$2 ^x + 1 = 3 ^y $,考虑两边$\bmod 3 $知道$x $是奇数,于是$v _3 ( 2 ^x + 1 ) = v _3 ( 3 ) + v _3 ( x ) = y , 3 ^{ y - 1  } | x , x \geq 3 ^{ y - 1  } $,用这个放缩一下就行.</p>
<p>再看方程$2 ^x = 3 ^y + 1 $.仍然考虑两边$\bmod 4 $,知道$y $是奇数.$x = v _2 ( 3 ^y + 1 ) = v _2 ( 3 + 1 ) = 2 $,当场下班.</p>
<h4><span id="problem2">Problem2</span></h4><p>给定两个随机分布：</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , p − 1  } $中等概率随机一个$y $,令$x = y   \bmod   { 2 ^k  } $.</p>
<p>$x ∼ D _1 $:从${ 0 , 1 , … , 2 ^k - 1  } $中等概率随机一个$y $,令$x = y   $.</p>
<p>定义二者的统计距离为:$SD ( D _1 , D _2 ) = \frac { 1  } { 2  } \sum _{ i = 0  } ^{ 2 ^k - 1  } | P _{ D _1  } ( x = i ) - P _{ D _2  } ( x = i ) | $.</p>
<p>求证:$SD ( D _1 , D _2 ) ≤ \frac { 2 ^k  } { 4 p  } $.</p>
<h5><span id="solution2">Solution2</span></h5><p>令$w = p \bmod { 2 ^k  } $.则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( P _{ D _1  } ( x = 0 ) - P _{ D _2  } ( x = 0 ) ) + \frac { 2 ^k - w  } { 2  } ( P _{ D _2  } ( x = w ) - P _{ D _1  } ( x = w ) ) $.</p>
<p>令$k = \lfloor \frac { p  } { 2 ^k  } \rfloor = \frac { p - w  } { 2 ^k  } $不难发现$P _{ D _1  } ( x = 0 ) = \frac { k + 1  } { p  } , P _{ D _1  } ( x = w ) = \frac { k  } { p  } $.</p>
<p>则$SD ( D _1 , D _2 ) = \frac { w  } { 2  } ( \frac { p - w + 2 ^k  } { p 2 ^k  } - \frac { 1  } { 2 ^k  } ) + \frac { 2 ^k - w  } { 2  } ( \frac { 1  } { 2 ^k  } - \frac { p - w  } { p 2 ^k  } ) = \frac { 1  } { 2 ^{ k + 1  }  } ( \frac { w ( 2 ^k - w )  } { p  } + \frac { w ( 2 ^k - w )  } { p  } ) = \frac { w ( 2 ^k - w )  } { p 2 ^k  } $.</p>
<p>要证明$\frac { w ( 2 ^k - w )  } { p 2 ^k  } \leq \frac { 2 ^k  } { 4 p  } \Leftrightarrow w ( 2 ^k - w ) \leq ( 2 ^{ k - 1  } ) ^2 $.由基本不等式显然.</p>
<h4><span id="problem3">Problem3</span></h4><p>给你一个单增函数$f $,满足定义域和值域都是$\mathbb { N  } $,并且$f ( f ( n ) ) = 3 n $,求$f ( 2023 ) $.</p>
<h5><span id="solution3">Solution3</span></h5><p>首先我们不妨先试一下$f ( f ( 1 ) ) = 3 $.由于$f ( 1 ) \geq 2 $,且$f ( 1 ) \ne 3 $,所以$f ( 1 ) = 2 , f ( 2 ) = 3 $.</p>
<p>考虑$f ( 3 n ) $,必然存在一个$n &lt; m &lt; 3 n $,使得$f ( n ) = m , f ( m ) = 3 n $.</p>
<p>用这个找前几项,发现规律是把$n $写成三进制形式,如果首位是$1 $就变成$2 $,首位是$2 $就改为$1 $再在后面加个$0 $.容易验证这是合法的$f $且$f ( 2023 ) = 3882 $.</p>
<p>但问题没有解决,需要证明它是唯一的$f $.</p>
<p>考虑数学归纳假设现在$f ( x ) , x \in [ 1 , 3 k ] $都确定了.</p>
<p>注意到如果$f ( n ) = m , f ( m ) = 3 n , f ( 3 n ) = 3 m , f ( 3 m ) = 9 n $.所以如果$f ( n ) = m $,我们实际上有$f ( 3 ^k m ) = 3 ^{ k + 1  } n , f ( 3 ^k n ) = 3 ^k m $.数学归纳即可以证明$f ( 3 k + 3 ) $一定是确定的.</p>
<p>接下来要证明$f ( 3 k + 1 ) $和$f ( 3 k + 2 ) $一定是确定的.</p>
<p>手玩发现确定它们的方式有两种:</p>
<ol>
<li><p>$f ( 3 k ) + 3 = f ( 3 k + 3 ) $.</p>
</li>
<li><p>$\exists n , f ( n ) = 3 k + w ( w \in \{ 1 , 2 \} ) $.</p>
</li>
</ol>
<p>如果我们能说明至少可以取二者其一就行.</p>
<p>由归纳假设,不难发现当$k $在三进制下首位如果是$2 $,则一定满足(2).</p>
<p>当$k $在三进制下首位是$1 $,则一定满足(1).</p>
<p>于是证毕.</p>
<h4><span id="problem4">Problem4</span></h4><p>对于一个$n \times n $的包含$[ 1 , n ^2 ] $各一个的矩阵(下称为排列矩阵),定义一次操作为:将每行都任意重排;或将每列都任意重排.求证:</p>
<ol>
<li><p>如果一个排列矩阵满足每行恰有模$n $余$[ 0 , n - 1 ] $的数各一个,则称它是好的.求证:好的矩阵可以通过两次操作变为一个满足第$i $行第$j $列为$( i - 1 ) n + j $的矩阵(不妨称为有序矩阵).</p>
</li>
<li><p>求证:任意排列矩阵可以通过一次操作变为好的.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>这题原题啊,AGC037D.</p>
<p>(1)显然,注意到有序矩阵的每列$\bmod n $不相同,可以先将每行按照$\bmod n $排序,再每列排序即可.</p>
<p>(2)的话我们考虑一次列操作.将$\bmod n $不同的数字分类,然后建一个二分图:左侧的点是数字分的类,右侧的点代表行,注意到这个东西是$n $正则二分图,根据Hall定理一定存在完美匹配.</p>
<h4><span id="problem5">Problem5</span></h4><p>有$n ( \geq 2 ) $个硬币排成一个环.你被蒙上眼睛,你每次操作可以选择一个硬币的子集并将它们翻面.但是你每次操作之后,硬币的位置将会任意旋转(即变为原来的一个循环同构).如果你存在一种策略,使得对于任意初始局面和任意中途的旋转方案,有限步内一定可以令存在一个时刻所有硬币正面朝上,则称$n $是好的.求证:</p>
<ol>
<li><p>$4 $是好的.</p>
</li>
<li><p>如果$n $是奇数,那么$n $不是好的.</p>
</li>
<li><p>求出所有好的$n $.</p>
</li>
</ol>
<h5><span id="solution5">Solution5</span></h5><p>首先可以证明$2 $是好的.</p>
<p>这么干:如果一开始都正面向上就赢了.不然第一步全翻,这样如果一开始是反面向上也赢了.下一次随便翻一个,再下一次全翻,这样四次中至少赢了一次.</p>
<p>从上面的观察可以发现啊,我们场上一定会进行若干次全局翻转操作,并且最后一次一定是一个全局翻转,不然我们每次只需要让一个位置保持不被翻到就输麻了.</p>
<p>转全局太复杂了,考虑转操作,问题转化为现在你要排若干个操作,使得它们任意旋转后,仍然可以保证前缀异或和取到了所有的情况.注意到不妨让第一轮轮空,此时最少需要$2 ^n $步.</p>
<p>不妨每进行一次非全局操作就全局翻一次,这样$0 $和$1 $就没区别了.</p>
<p>先考虑全局异或和为偶数的时候:</p>
<p>注意到$1100 $来一个$1010 $之后啥也不变,但是$1010 $来一个$1010 $一定赢了.所以上来先来一个$1010 $,如果赢了就下班,没赢就来个$1100 $,这样$1100 $要么下班,要么变成了$1010 $,再重复上面的操作.</p>
<p>如果全局异或和为奇数,那就随便异或一下,再按照偶数的做.</p>
<p>总的来说,先按照偶数的操作,不会改变全局异或和.如果没结束说明是奇数,变一下重复以上操作.</p>
<p>总结一下的话就是操作序列是:$0000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 , 1000 , 1111 , 1010 , 1111 , 1100 , 1111 , 1010 , 1111 $.</p>
<p>上面的构造启发我们手玩一下$n = 3 $,注意到此时的问题在于$100 $和$110 $,都很完蛋.</p>
<p>我们先考虑弱化版问题:就是我们摘下了眼罩,但是选择策略在旋转之前.如果这种情况我们都做不到那蒙上眼更做不到了对吧.</p>
<p>我们不妨将所有的状态分为两类:一类叫做成功状态,即如果一个状态是成功的,那它可以通过有限次操作得到全$0 $;另一类叫做失败状态,即只要初值是它,一定有一种旋转的方式使得一直得不到全$0 $.</p>
<p>我们来仔细看一下这两个状态应该是啥样的:</p>
<p>对于一个成功状态,应该有一个固定的选择翻面策略,使得它可以在有限次操作内达到另一个更接近全$0 $的成功状态.我们不妨令一个成功状态的度为$d $表示它可以经过$d $步到达全$0 $,显然全$1 $的$d = 1 $,$n = 4 $的时候,$1010 $的$d = 2 $,因为其可以通过一次操作转化为全$1 $,$1100 $的$d = 3 $,因为其可以用一次操作转化为$1010 $.</p>
<p>仔细思考上面的过程,也就意味着:任何一个成功状态的所有出边,必然要指向$d $比它更小的成功状态.</p>
<p>对于一个失败状态,应该有一个任意的选择旋转策略,使得它怎么翻都还是失败状态.</p>
<p>这个定义还是挺粗糙的,我们先看失败状态吧.</p>
<p>显然$n = 3 $的时候,$\{ 110 , 100 \} $就是失败状态.</p>
<p>而对于$n $取任意来说,一定得存在一个$d = 2 $的成功状态.一个显然的$d = 2 $的成功状态要满足的条件是,假设它是$a $,那么存在一个数$b $,使得$a \oplus b $是全$1 $或者全$0 $.既然$a $和$b $旋转后只有两种结果,那么$b $的循环节必定为$2 $,也就是$b $一定要是$101 \cdots 010 $这样的,于是$n $是奇数的时候一定不符合,这就证明了(2).</p>
<p>同理寻找$d = 3 $的成功状态,现在我们已知的四种成功状态是$111 \cdots 111 $,$000 \cdots 000 $,$101 \cdots 010 $,$010 \cdots 101 $,所以考虑构造一个循环节长度为$4 $的串,使得异或完它是这上面四种其一,注意到$1100 \cdots 1100 $就是一个合法的串.</p>
<p>做到这里发现上面那个东西完全无法扩展啊.更要命的是我们现在还是睁着眼的,甚至没证明闭着眼是一样的.</p>
<p>找qyc讨论了一下得到了另一个思路的做法:</p>
<p>先证明$n = 2 ^k $一定是好的.考虑数学归纳,不妨这么干:构造一个长度为$2 ^{ k - 1  } $的串$b $,使得其$b _i = a _i \oplus a _{ i + 2 ^{ k - 1  }  } $.然后由数学归纳,可以造出$b $全$0 $的情况.而如果$b $全$0 $,则原串一定存在长为$2 ^{ k - 1  } $的循环节,并且消除循环节的过程不会改变$b $的值,仍然是数学归纳下去就做完了.</p>
<p>不然,设$n = 2 ^k m $,</p>
<p>模仿上面的过程,不妨使用数学归纳证明其不成立.仍然是构造$b $数组,由于$b $数组都不可能全$0 $,显然也不可能成立.</p>
<p>这个能不能顺便证明$n $是奇数一定不行呢?还真可以.</p>
<p>考虑你现在要卡掉蒙眼的对手的构造,你选出一个位置来备用,剩下了$n - 1 $个位置.</p>
<p>接下来无论对手怎么出,你都可以通过乱搞这个备用的位置,来保证前$n - 1 $个位置的异或值为$1 $.因此对手一定不能完成任务.</p>
<h3><span id="2024茶选">2024茶选</span></h3><h4><span id="problem1">Problem1</span></h4><p>连续扔一枚硬币,连续扔出三个正面则停止.假设硬币扔出正面反面的概率都为$50 \% $,求期望停止时间.</p>
<h5><span id="solution1">Solution1</span></h5><p>简单题,设$f _0 , f _1 , f _2 , f _3 $,然后有$\begin{cases}f _3 = 0 \ f _2 = \frac { 1  } { 2  } f _3 + \frac { 1  } { 2  } f _0 + 1 \ f _1 = \frac { 1  } { 2  } f _2 + \frac { 1  } { 2  } f _0 + 1 \ f _0 = \frac { 1  } { 2  } f _1 + \frac { 1  } { 2  } f _0 + 1 \end{cases} $,算出$f _0 = 14 $.</p>
<h4><span id="problem2">Problem2</span></h4><p>Alice和Bob玩游戏,一共有三轮.每一轮中,Alice选择一个实数,Bob将这个数填到下式中任意一个框中.进行三轮后,如果下式方程有三个不同的整数解则Alice赢,反之Bob赢,求是否有必胜策略.</p>
<script type="math/tex; mode=display">
x ^3 + □ x ^2 + □ x + □ = 0</script><h5><span id="solution2">Solution2</span></h5><p>纯粹的构造.</p>
<p>简单分析一下,不妨设三个解为$- A , - B , - C $,方程应该可以写作$( x + A ) ( x + B ) ( x + C ) = 0 $.</p>
<p>拆开有$x ^3 + ( A + B + C ) x ^2 + ( AB + AC + BC ) x + ABC = 0 $.</p>
<p>这么对称,不妨猜一手Alice先选择$0 $,讨论一下:</p>
<ol>
<li>Bob令$ABC = 0 $.不妨令$C = 0 $.</li>
</ol>
<p>此时方程变为$x ^2 + ( A + B ) x + AB = 0 $.直接秒了,随便选一个数就行(比如选$3 $,如果Bob令$AB = 3 $,就再选$4 $;如果令$A + B = 3 $,就再选$2 $)</p>
<ol>
<li>Bob令$A + B + C = 0 , C = - A - B $.</li>
</ol>
<p>不妨令$C ‘ = - C , D = AB $,则$AB + AC + BC = D - C ‘ ^2 , ABC = DC ‘ $.</p>
<p>接下来Alice要选择一个数字$k $,如果Bob又令$D - C ‘ ^2 = k $,发现在此时如果$k $是一个负的完全平方数,并且Alice接下来选择$0 $,当场就下班了.</p>
<p>所以不妨直接让$k = - n ^2 $,然后看当$DC ‘ = - n ^2 $的时候如何去解.此时有$AB ( A + B ) = n ^2 $.不难发现取勾股数就很优秀.</p>
<p>总结一下就是,Alice第二步选择$- 3 ^2 \times 4 ^2 \times 5 ^2 $,这样就赢了.</p>
<ol>
<li>Bob令$AB + AC + BC = 0 , C = - \frac { AB  } { A + B  } $.</li>
</ol>
<p>我是构造不出来了.但我可以抄答案,答案是你接下来选择$6 ^2 \times 7 ^3 $,两种情况如下:</p>
<script type="math/tex; mode=display">
\begin{aligned}
( x + 2 \times 7 ) ( x - 3 \times 7 ) ( x - 6 \times 7 ) & = 0 \\
( x - 2 \times 6 ^2 \times 7 ^2 ) ( x + 3 \times 6 ^2 \times 7 ^2 ) ( x + 6 \times 6 ^2 \times 7 ^2 ) & = 0 
\end{aligned}</script><p>后来又找人讨论了一下这个是咋得出来的啊.考虑$ABC \ne 0 $,我们有的条件其实是$\frac { 1  } { A  } + \frac { 1  } { B  } + \frac { 1  } { C  } = 0 $.方程现在是$x ^3 + ( A + B - \frac { AB  } { A + B  } ) x ^2 - \frac { A ^2 B ^2  } { A + B  } = 0 $.不妨令$a = A + B , b = AB $,方程实际上是$x ^3 + ( a - \frac { b  } { a  } ) x ^2 - \frac { b ^2  } { a  } = 0 $.最好能让$a $小一点,因此我们不妨直接取$a = 1 $,此时$A = - n , B = n + 1 , C = n ( n + 1 ) $,只要能构造这样的两组$A , B , C $使得它们的$a _1 - \frac { b _1  } { a _1  } = - \frac { b _2 ^2  } { a _2  } $即可.直接造看上去没啥前途,但是不难发现$A = - nk , B = ( n + 1 ) k , C = n ( n + 1 ) k $依然合法.此时有$k _1 = a _1 , b _1 = - n ( n + 1 ) a _1 ^2 , k _2 = a _2 , b _2 = - n ( n + 1 ) a _2 ^2 $,我们有$a _1 ( n ^2 + n + 1 ) = - n ^2 ( n + 1 ) ^2 a _2 ^3 $.取$n = 2 $试试看!此时有$7 a _1 = - 36 a _2 ^3 $.取$a _2 = 7 , a _1 = - 6 ^2 \times 7 ^2 $,这就是上面那组答案的构造过程.</p>
<h4><span id="problem3">Problem3</span></h4><p>人们之间可能会有讨厌的情况,讨厌关系是相互的.一个人最多讨厌另外$3 $个人.现在希望将全部的人分成两组,使得每个人在自己的组内至多只讨厌$1 $个人.这是一定可以办到的吗?</p>
<h5><span id="solution3">Solution3</span></h5><p>考虑增广,对于一个不合法的点,它应当连了两个同色点.不妨将这个点反色,那么同色边的数量一定减少,因此一定存在操作终点.而只要当前不合法就一定可以继续操作,因此操作终点一定合法.</p>
<h4><span id="problem4">Problem4</span></h4><p>有公式:</p>
<script type="math/tex; mode=display">
\sum _{ S \subseteq \{ 1 , 2 , \cdots , n \}  } ( P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) - P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 1 ) ) ^2 = 1</script><p>其中$f $是任意一个将$\{ 0 , 1 \} ^n \rightarrow \{ 0 , 1 \} $的函数,$\oplus $是二进制意义下的异或运算,$R $是$\{ 0 , 1 \} ^n $上的均匀分布,$R _i $表示第$i $位.再定义$\chi _S ( r ) = \prod _{ i \in S  } ( - 1 ) ^{ r _i  } $.</p>
<p>按照下面的步骤证明上面的式子,也就是说,求证:</p>
<ol>
<li><p>$\chi _S ( r ) \times \chi _S ( r ‘ ) = \chi _S ( r \oplus r ‘ ) $.</p>
</li>
<li><p>当$r \ne 0 $时,$\sum _{ S \subseteq \{ 1 , \cdots , n \}  } \chi _S ( r ) = 0 $.</p>
</li>
<li><p>$[ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $.</p>
</li>
<li><p>证明原命题.</p>
</li>
</ol>
<h5><span id="solution4">Solution4</span></h5><p>(1)显然.</p>
<p>(2)也很经典,挑选一个$j $,使得$r _j = 1 $,然后所有的集合分为两类:一类是包含$j $,一类不包含,两类集合一一对应并且$\chi $互为相反数.</p>
<p>(3)显然.</p>
<p>来看(4),注意到$P ( f ( R ) \oplus \bigoplus _{ i \in S  } R _i = 0 ) = \frac { 1  } { 2 ^n  } \sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] $,而$\sum _{ r  } [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 0 ] - [ f ( r ) \oplus \bigoplus _{ i \in S  } r _i = 1 ] = \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) $,要证明的只是$\sum _{ S  } \frac { 1  } { 4 ^n  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 = 1 $,而:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } ( \sum _r ( - 1 ) ^{ f ( r )  } \chi _S ( r ) ) ^2 \\
& = \sum _S \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } \sum _{ r '  } ( - 1 ) ^{ f ( r ) + f ( r ' )  } \sum _S \chi _S ( r \oplus r ' ) \\
& = \sum _{ r  } 2 ^n & = 4 ^n 
\end{aligned}</script><p>于是证毕.</p>
<h4><span id="problem5">Problem5</span></h4><p>Alice在手心上写了两个不同的实数.你可以看其中一只手上的,然后猜哪边的数大.设计一种策略使得不论两个数是什么,猜对的概率都严格大于$50 \% $.</p>
<h5><span id="solution5">Solution5</span></h5><p>我对这个题有亿点小疑问,但是先说策略.</p>
<p>随机(无需均匀)一个数$x $,然后随机一只手,看上面的数字$a $,如果$a \geq x $就认为$a $大,反之认为$b $大.只要随机到一个区间内的实数的概率不为$0 $即可.</p>
<p>但是怎么随机实数呢?好像可以按照正态分布随机,我其实也不太懂.</p>
<h4><span id="problem6">Problem6</span></h4><p>使用一些长方形的砖头搭墙.如果每块砖头都有至少一条边的长度是整数,且搭出的墙面是没有缝隙的长方形,求证:这个长方形也至少有一条边长是整数.</p>
<h5><span id="solution6">Solution6</span></h5><p>这个题是经典知乎题,下面搬一下知乎上面整理的这个题的答案:</p>
<p>数论证明:令$p $为素数,把整个图形放大$p $倍(也就是长度$1 $变成长度$p $).下面把每个交叉点$( x , y ) $换成其整数部分$( \lfloor x \rfloor , \lfloor y \rfloor ) $,我们就得到了一个新的大矩形,它被划分为很多两边长均为整数的小矩形,而且每个小矩形有一边长能被$p $整除.这样这个新的大矩形的面积也能被$p $整除,所以它的有一边长能被$p $整除.这条边只是被换成了它长度的整数部分,所以变化不超过$1 $,所以在放大之前这条边的长度和某个整数相差不超过$1 / p $.因为素数有无穷多个,所以原来的大矩形某一条边长度与某个整数相差无限小,证毕.</p>
<p>图论证明:令所有的交叉点为顶点.每个小矩形都有一边长为整数,我们把这两条边长为整数的边在图上标出(允许两顶点之间的重复边),另外两条边不连.这样除了大矩形的四个角以外每个顶点有$2 $条边或者$4 $条边(这是因为这个点,要么是处于一个丁字路口(两条边),要么是十字路口(四条边)),而大矩形四个角每个角只连了一条边.所以从大矩形一角开始存在一条欧拉路径在另一个角结束.因为图上连边的边长都是整数,把这个欧拉路径投影到大矩形的长宽,我们就得到了大矩形至少有一边长为整数.</p>
<p>组合证明:考虑Sperner引理(和染色有关的那个).假设结论不成立.把每个小矩形画上对角线,然后把所有交叉点$( x , y ) $染色:如果$x $是整数,染X颜色.如果$x $不是整数但$y $是整数,染Y颜色.如果都不是整数,染Z颜色.由Sperner引理,三顶点被染不同颜色的三角形有奇数个(简单来说就是,你考虑大矩阵的左侧两个点都是X颜色,右侧一个是Y一个是Z,并且在最下面这条边(两个端点分别被染成了X颜色和Y颜色)上面只可能出现X和Y两种颜色,由于这两种颜色交替出现,那么连接不同颜色的边就会有奇数个,同理对于全局来说,三条边上连接不同颜色的边总共奇数个,内部的每一条边会在两个三角形中被各算一次,因此三个顶点染成不同颜色的三角形应该有奇数个),但由题目条件这种三角形不存在(如果一个点被染成了X颜色,那么上面的点如果存在也该被染成了X颜色,Y颜色同理,俩总会矛盾一个),矛盾.</p>
<p>扫描线证明:设大矩形为$[ 0 , a ] \times [ 0 , b ] $,并假设$b $不是整数.把所有小矩形的下边界去掉,然后令$f ( t ) $为所有上边界$y $坐标不是整数,并且与直线$y = t $相交的小矩形的$x $方向边长之和.那么$f ( 0 ) = 0 $,而且当$f ( t ) $变化的时候,它一定会变成另一个整数(原因在于一个小矩阵(假设已加入扫描线)上方的矩阵,如果想要退出扫描线,则必然横向长度是整数.同理对于一个没有加入扫描线的小矩阵上方的矩阵,如果想要加入扫描线,也需要横向长度是整数).所以$f ( b ) $是整数.而因为$b $不是整数,$f ( b ) $就是最靠上的所有小矩形的宽之和,等于$a $,所以$a $是整数.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划相关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="动态规划的设计">动态规划的设计</span></h2><h3><span id="分析状态">分析状态</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个序列,初始为空,进行多次操作,每次在序列末尾等概率加入一个$[ 1 , m ] $中的数字,然后进行以下判断:</p>
<ol>
<li><p>如果当前序列末尾两个数字相同且小于$t $,假设都是$x $,那就将它们都删去,加入一个$x + 1 $.</p>
</li>
<li><p>如果当前序列没有可以删的数字,并且序列长度为$n $,终止操作.</p>
</li>
</ol>
<p>给定$n , m , t $,求最终序列的元素和的期望.</p>
<p>$n , m \leq 10 ^3 , t \leq 10 ^9 $.</p>
<p>首先$t \leq 10 ^9 $显然是没用的,因为它最多也就能这么凑:$m + n - 2 , m + n - 3 , \cdots , m , m $,合成一个$m + n - 1 $,因此我们令$t = \min \{ t , m + n - 1 \} $即可.</p>
<p>然后我们发现一个事实:如果这个序列某一个位置$i $,有$a _i &lt; a _{ i + 1  } $,那么无论后面怎么做,这里的$a _i $都必不可能被删除.以此,我们不妨设$f _{ i , j  } $表示序列长度为$i $,序列开头元素为$j $的期望.然后发现中间的枚举巨大麻烦,完全不可以转移.</p>
<p>题解的思维顺序感觉很乱,于是我来<del>马后炮一下</del>重整一下顺序.</p>
<p>首先,我们的限制一共有两种:一个是数的大小不能超过$t $,另一个是序列的长度不能超过$n $.我们不妨设$ans _{ n , t  } $表示在上述两种限制下的答案.接下来我们要做的,无非是开始分析转移$ans $需要求出哪些量,这些量又可以如何转移即可.</p>
<p>分析一下$ans _{ n , t  } $,考虑枚举一下开头元素是什么,那么第二个位置就不能是这个元素,然后后面再计算贡献,因此我们自然有$ans _{ n , t  } = \sum _{ x = 1  } ^t E ( n 个 位 置 , 第 一 个 位 置 是 x 并 且 没 有 被 删 去 ) $.</p>
<p>然后你就会发现这个问题真正难做的地方:我们这么顺着做,每次把第一个元素抠出去,但是这个元素是会影响后面的操作的!举个栗子:</p>
<p>如果插入的数是:$3 , 3 , 3 $,最终的答案应该是$4 , 3 $.</p>
<p>但如果我们一开始把第一个位置扣出去,就变成了$3 , [ 3 , 3 ] $,最终的答案就变成了$3 , 4 $.也就是说,这里的动态规划问题在转移子问题的时候,需要前面的那个位置作为信息.不妨设$g _{ i , j  } $表示当前后面还有$i - 1 $个位置,当前前面已经放好了一个$j $,这个$j $不能被删掉的期望,显然有$ans _{ n , t  } = \sum _{ x  } ^t g _{ n , x  } P ( 最 终 序 列 中 , 这 里 是 k ) $,问题只在于如何求$g $.这个$g _{ n , k  } $是钦定了这个位置放$k $的期望,后面我们需要将它乘上这个位置放$k $的概率才能得到真实的答案.这很合理,因为我们通常的一切概率与期望的递推通常都是有一个隐含的条件概率乘法的.</p>
<p>可能第一反应是,这个$g _{ n , k  } = ( k + \sum _{ j \ne k  } g _{ n - 1 , j  } ) $.但是实际上这个是不对的.这里的$k $不能删掉不意味着后面的$j $不能删掉,事实上后面的$j $爱怎么删怎么删,只要不搞出一个$k $来就可以.因此我们需要设$f _{ i , j  } $表示当前后面还有$i $个位置,第一个位置不能是$j $,也不能曾经是$j $(因为这里只要是$j $都应该与前面合并),剩下的乱选的方案数.这个东西看上去它就不好转移,因为它限制太强了.我们正难则反!设$f _{ i , j  } $表示后面还有$i $个位置,第一个位置现在或曾经是过$j $的期望.那么全集是什么呢?全集是$ans _i $.</p>
<p>还没完啊,我们还需要求一下这里是$k $的概率,由于还有一个类似的$f $,我们还要求一下这里曾经是$k $的概率.设前者为$q _{ i , k  } $,后者为$p _{ i , k  } $.我们来强调一下这里设计的原则:这里的$p $其实还蛮奇怪的,因为它设计的是:只要我当前在队首拿到了$k $,我立刻停止后面的操作.这很好理解,因为后面无论怎么玩,这里都曾出现过$k $了.但是这个理解方式可以帮助我们写出下面的转移方程.</p>
<p>对于前者,我们发现这里是$k $等价于这里是$k $并且后面没有出现过$k $,也就是$q _{ i , k  } = p _{ i , k  } ( 1 - p _{ i - 1 , k  } \times [ k &lt; t ] ) $.这里加一个限制是因为有不能超过$t $的限制.</p>
<p>对于后者,这里的$k $有很多种可能出现过,一种是直接加入,一种是合并而来,于是$p _{ i , k  } = \frac { 1  } { m  } [ k \leq m ] + p _{ i , k - 1  } p _{ i - 1 , k - 1  } $.</p>
<p>因此我们几经辗转,终于得到了$g $的转移式子:</p>
<script type="math/tex; mode=display">
q _{ i , k  } g _{ n , k  } = p _{ i , k  } ( k + ans _{ i - 1  } - f _{ i - 1 , k  } p _{ i - 1 , k  } )</script><p>就差$f $了.$f $有两种可能:要么最后仍然是$k $,要么这个$k $已经被杀掉了.于是:</p>
<script type="math/tex; mode=display">
p _{ i , k  } f _{ i , k  } = q _{ i , k  } g _{ i , k  } + ( p _{ i , k  } - q _{ i , k  } ) f _{ i , k + 1  }</script><h5><span id="example2cf1007e">Example2(CF1007E)</span></h5><p>首先我们需要发现一个很强的性质:作用到了第$i $个站台就会清空前面所有站台.清空后就和$a _i $无关了,而如果还没涉及到一定和$a _i $有关,那么涉及到了一半怎么办呢?我们考虑这里涉及到了一半,那么前面一定被清空了,我们根据前面的清空情况现场计算这里的答案.</p>
<p>这启发我们:我们可以对这个做文章,我们设$f _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量.$g _{ i , j  } $表示只考虑前$i $个站台,要撑$j $个单位时间,并且$[ 1 , i - 1 ] $全部清空需要的最少火车数.另外,这两个dp数组都要求不能有火车漏到后面,也就是火车不能坐上后面的人,不然设为$+ \infty $表示无法满足(对于全局,我们在$n + 1 $处放一个$a = + \infty , b = 0 , c = + \infty $来保证一定会满载).为什么需要$g $作为辅助dp数组呢?我们先对着$f $分析.</p>
<p>考虑$f _{ i , j  } $的转移,根据上面的分析,我们有两种可能:</p>
<p>第一种,前$j $轮中根本没接走站台$i $的人.此时需要满足$f _{ i - 1 , j  } \ne + \infty \land a _i + j \times b _i \leq c _i $.那么这里怎么更新$g $呢?设$L = sa _{ i - 1  } + sb _{ i - 1  } \times j $,显然$g _{ i , j  } = \lceil \frac { L  } { K  } \rceil $,并且需要保证此时没有用到$i $以后的站台,因此需要保证$\lceil \frac { L  } { K  } \rceil K \leq sa _{ i  } + sb _i \times j $.注意到由于这里保证了$f _{ i - 1 , j  } $是可以取到的,因此我们可以撑到第$j $秒,剩下的火车在$j + \varepsilon $秒全选.</p>
<p>第二种,前$j $轮中有火车接走站台$i $的人.设最后一次是在$r $时间接走的站台$i $,那么此时必然清空了$[ 1 , i - 1 ] $,这里用了$g _{ i , r  } $.然后为了防止这里在$[ r + 1 , j ] $这段时间中爆掉,因此还需要$w = \lceil \frac { \max \{ 0 , rem + ( j - r ) b _i - c _i \}  } { K  } \rceil $,其中$rem $是$r $时刻$i $剩下的人数.这些火车都要在$r $时刻之前解决(因为我们设了最后一次在$r $时间接走),不难发现我们其实不在乎前面具体怎么解决的,而只要在$r $这里保证没出问题就行.另外还要保证这个过程没有走到后面,也就有$wK \leq rem $.但是,接下来在$[ r + 1 , j ] $时刻就只需要对前面做操作,不过和一开始不一样的是,此时被清空了,因此我们设$f _{ i , j , 0  } $表示只考虑前$i $个站台,要撑$j $个单位时间需要的最少火车数量,但是$[ 1 , i ] $都被清空为$0 $过.</p>
<p>每一步看上去都很合理,但是如何想到可以这么dp的呢?说到底,dp是解决一个最优子问题的,我们发现我们知道时间,以及前面是否清空,就可以得知目前的状态.另外,由于我们是枚举目前的状态,因此中间的转移过程是易知的.</p>
<p>这个题的启发性大概有以下几点:</p>
<ol>
<li><p>设计状态的时候,只考虑记录经过的时间/前面的初始值/目前考虑到第几位,由上面三点可以还原出所有状态.</p>
</li>
<li><p>由于我们确定了当前考虑到了第几位,我们就可以进行递推:原因很简单,只要我们考虑到某一位,就一定会影响前面所有的位置(全部清空以至于到达这里).一开始我犯了一个错是将$g _{ 1 , t , 0 / 1  } $全部设为$0 $,因为我觉得无论如何$0 $位置都是清空的,但实际上这是错误的!因为在$t $时刻的$1 $位置不一定合法.这就是这个设计巧妙的地方:它时刻保证了前$i $个的合法性,并且如果我们想要让$i $位置合法,一定要求让$[ 1 , i - 1 ] $合法.</p>
</li>
<li><p>转移的时候,由于钦定了某一时刻是否选,因此我们可以直接算出从$r \rightarrow t $这个过程中会积累的量,这些量必然要在$r $时刻清理掉.由于钦定导致限制加强,因此这里就容易处理了.</p>
</li>
</ol>
<h3><span id="可删除dp">可删除dp</span></h3><h5><span id="example1">Example1</span></h5><p>定义一个有根树为大菊花,当且仅当这棵树的根的度数$\leq m \land \nexists x \ne root , \deg ( x ) &gt; 2 $.对于每一条边,求将这条边连接的两个点合并后,以新点为根的大菊花数量.$( n \leq 5 \times 10 ^5 , m \leq 50 ) $</p>
<p>注意到以一个点为根的大菊花数量是一个关于树的大小的背包合并.这样通过前缀后缀做到$O ( nm ^2 ) $.</p>
<p>注意到这个背包是可删除的,所以就能做到$O ( nm ) $.</p>
<h3><span id="dp分界点">dp分界点</span></h3><h4><span id="example12022zrtg十连测day7-permutation">Example1(2022zrtg十连测day7 Permutation)</span></h4><p>首先注意到$[ 3 , n ] $一定会被分成两段递减的序列,分别跟在$1 $和$2 $的后面,假设$1 $在$2 $前面,这样算出答案后乘以$n $即可.</p>
<p>注意到$i + 1 $一定可以放到$i $的前面,设$f _i $表示在$i $和$i + 1 $之间有分界点,这两个点后面分界合法的方案数.每次可以枚举下一个合法的分界点,不难发现这个分界点也即$i $的倍数$\pm 1 $之类的,于是可以实现,复杂度$O ( n \ln n ) $.</p>
<h3><span id="基于贪心的dp">基于贪心的dp</span></h3><h4><span id="example1cf1666e">Example1(CF1666E)</span></h4><p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第$i $条线段的右端点的位置一定是一段连续的区间.</p>
<p>设$f _i $表示第$i $个分界点可能的最小值,$g _i $表示第$i $个分界点可能的最大值.假设我们目前二分的最大值要小于等于$mx $,最小值要大于等于$mn $,那么我们有转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1  } & = \max \{ a _{ i + 1  } , f _i + mn \} \\
g _{ i + 1  } & = \min \{ a _{ i + 2  } , g _i + mx \} \\

\end{aligned}</script><p>注意到$f $与$g $的转移是无关的,而显然对于第$i $个分界点,它可以取$[ f _i , g _i ] $中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让$ans _{ i  } $表示第$i $条分界线是啥,那么我们$ans _i $是可以取$[ ans _{ i + 1  } - mx , ans _{ i + 1  } - mn ] $中的任何一个数字的,我们将其和上面求出的$[ f _i , g _i ] $求一下交集.如果交集为空,说明要么$ans _{ i + 1  } - mn &lt; f _i , f _{ i + 1  } &lt; ans _{ i + 1  } &lt; f _i + mn $,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差$\leq mx - mn $.</p>
<h3><span id="数位dp">数位dp</span></h3><h4><span id="example12022qbxt国庆day3string">Example1([2022qbxt国庆Day3]string)</span></h4><p>首先设$f _{ i , j  } $表示长度为$i $的,以$S [ n - j + 1 . . . n ] $为子序列的字符串个数.</p>
<p>考虑按位处理,每次将$T $的一个后缀设为极大,然后不断地向前扩展这个后缀的长度,直到所到的位置再改为极大就会超出$k $.这个时候我们停止更改,并且继续倒着修改,仍然修改每位,直到最后所积累的总数恰好为$k $.</p>
<p>当然,做的时候一定要时刻铭记后面的部分设为的是极大字符串还是极小字符串,这里设为极大是简单的,因为可以直接继承上一位的枚举.</p>
<p>考虑这个过程,我们每将一个位置的值设为更大,相当于松弛了后面的所有序列,因此也就是一个数位dp.</p>
<h4><span id="example2cf1194g">Example2([CF1194G])</span></h4><p>第一反应就是枚举$x ‘ $和$y ‘ $,然后用数位dp枚举$d $使得$x = dx ‘ , y = dy ‘ $.</p>
<p>但是有一个问题在于如果$\gcd ( x ‘ , y ‘ ) \ne 1 $怎么办,这样有可能会算重.我们发现我们只判断$\gcd ( x ‘ , y ‘ ) = 1 $的情况就行,然后写一个$2 ^8 $判断$x ‘ , 2 x ‘ , 3 x ‘ , 4 x ‘ $以及对应的$y ‘ $出现了没有.复杂度$( 9 ^4 \times 2 ^8 \times \log _{ 10  } n ) $,有点难过.</p>
<p>但是我们发现这个$2 ^8 $可能大了点,注意到只要出现一个我们就不用再记了,因此唯一需要记的是一对都没出现过的情况,这里只有$3 ^4 \times 2 $的状态量,就可以快一点.</p>
<h3><span id="树形dp">树形dp</span></h3><h4><span id="example1jloi2016侦察守卫">Example1([JLoi2016]侦察守卫)</span></h4><p>首先第一反应是记录子树内到子树根节点的最远的未被覆盖的点和最近的监测站,但是这样是$O ( nd ^2 ) $的复杂度.冷静一下,发现这两个一定只会有一个值有意义,这样就是$O ( nd ) $的了.</p>
<p>写的时候犯了个很蠢的错:树形dp由于需要合并,所以如果有多步转移,一定要先把所有dp值都会进行的dp转移写成赋值转移,把其它的写成取$\min $转移.</p>
<h3><span id="轮廓线dp插头dp">轮廓线dp(插头dp)</span></h3><h4><span id="example1">Example1</span></h4><p>现在有一个$[ 1 , n ] $的排列,现在要从中选出一个集合$S $,满足$\forall x \in S , 2 x \notin S , 3 x \notin S $,求方案数.</p>
<p>首先考虑将每个数分解为$a \times 2 ^b \times 3 ^c $的形式,显然$a $不相同的数之间互不干扰.</p>
<p>对于$a $相同的一群数,我们考虑将$( b , c ) $作为它在矩阵上的位置,不难发现上面的要求其实也就是选一个数就不能选它右边的数和下边的数,可以使用轮廓线dp转移.</p>
<h3><span id="高斯消元处理后效性">高斯消元处理后效性</span></h3><h4><span id="example1">Example1</span></h4><p>$n $个点的树,一开始位于一号点,每个点有一个颜色($0 $或$1 $),每次随机选择一个点$v $,从当前所在点移动到$v $并将$v $的颜色取反(不是将这条路径上的颜色取反),当整棵树颜色相同时停止,求期望移动距离(每条边的长度为$1 $,当然不为$1 $也能做).</p>
<p>$n \leq 100000 $.</p>
<p>首先我们发现这个树形结构很难搞,怎么办呢?</p>
<p>我会弱化问题!先考虑期望进行多少轮.</p>
<p>不难发现这个问题下,这个树没有任何意义,我们只需要看当前选中的点是$1 $还是$0 $就可以.不妨设$f _{ i  } $表示当前有$i $个点是$1 $,最后全$1 $或者全$0 $所需要的期望步数,显然$f _0 = f _n = 0 $,$f _{ i  } = \frac { 1  } { 2  } ( f _{ i + 1  } + f _{ i - 1  } ) + 1 $.欸,这不luoguP7099嘛.看来这个思路很对啊!</p>
<p>但是其实寄了,这个东西怎么想都很难拓展.一开始还想过计算每条边对期望的贡献,但也很难搞.</p>
<p>正确的做法是什么呢?正确的做法是我们统计每个点的贡献!你可能会很好奇这个点能有什么贡献,事实上,假设我们当前在$u $,只要当前没有结束,我们还要选点$v $,对答案的期望的贡献就是$u $到这棵树上所有点的距离之和除以$n $,而这是一个定值.也就是说,只要我们统计一下到了每个点$u $多少次(要求不是最后一次),我们就可以全部加一加乘一乘得到答案.我们脱离了树的结构!</p>
<p>我们设$f _{ i , j , 0 / 1  } $表示当前场面上有$i $个$1 $,$j $号点这里是$0 $还是$1 $,它在结束前能被期望选多少次,注意$f _{ n / 0 , j , 0 / 1  } = 0 $.但是这个转移显然有点垃圾,我们再冷静一下:似乎我们不在乎每个点具体编号,只在乎它当前的颜色,于是我们可以设$f _{ i , 0 / 1  } $表示当前有$i $个$1 $,$0 / 1 $染色的点在接下来的操作中期望选择多少次.</p>
<p>我们可以写出以下转移:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ 0 / n , 0 / 1  } & = 0 \\
f _{ i , 0  } & = \frac { i  } { n  } f _{ i - 1 , 0  } + \frac { n - i - 1  } { n  } f _{ i + 1 , 0  } + \frac { 1  } { n  } ( f _{ i + 1 , 1  } + [ i + 1 \ne n ] ) \\
f _{ i , 1  } & = \frac { i - 1  } { n  } f _{ i - 1 , 1  } + \frac { n - i  } { n  } f _{ i + 1 , 1  } + \frac { 1  } { n  } ( f _{ i - 1 , 0  } + [ i - 1 \ne 0 ] ) 
\end{aligned}</script><p>为啥最后加上了$[ i + 1 \ne n ] $呢?因为我们统计的是在没结束的情况下的答案.</p>
<p>乍一看这个转移成环并且极其复杂,可能需要高斯消元,但实际上不用,我们冷静观察一下:</p>
<p>我们假设我们已经求出了$f _{ i , 0 / 1  } $和$f _{ i - 1 , 0 / 1  } $,我们发现我们可以用这两个方程求出$f _{ i + 1 , 0 / 1  } $,然后就比较典了:我们将所有的函数表示成$af _{ 1 , 0  } + bf _{ 1 , 1  } + c $的形式(之所以这么表示,是因为我们架设了$f _{ 1 , 0 / 1  } $已经求出来了,虽然实际上没求出来),而由于我们有右边界,我们可以用它表示出$f _{ n , 0 / 1  } $,而$f _{ n , 0 / 1  } $我们已知,这样就可以解一个二元一次方程组.</p>
<h3><span id="最短路处理后效性">最短路处理后效性</span></h3><h4><span id="example12022qbxt国庆day2operation">Example1([2022qbxt国庆Day2]operation)</span></h4><p>首先注意到,$a _i = 1 $的时候和$a _i \ne 1 $的时候其实没有太大区别,我们在操作完后也需要用各种方式抵消影响.我们设$f _i $为$a _i = 1 $,而其他$a $全都为$0 $时的答案,不难发现最后的答案也就是$\sum { a _i f _i  } $.</p>
<p>而上面的转移自然是:$f _i = \min \{ b _i , w + \sum _{ j = l  } ^r f _j \} $.</p>
<p>但是,这个转移是有后效性的,不能直接进行dp,不过我们考虑用类似最短路的操作来处理.</p>
<p>换句话说,由于每次$f _i $最小的点不可能再被更新到,我们就把它设为已更新的点.当一个区间中的所有点都被标记为已更新后,我们就拿这个区间去更新别的点.</p>
<p>我们把每个线段挂到线段树上的节点,当我们把一个点标记为已更新,也就是检查这个点对应的线段树上叶子节点到根的路径上所有的线段树节点对应的区间是否全更新.均摊下来,一个区间只会被检查$\log n $次,这样就做完了.</p>
<h3><span id="组合意义">组合意义</span></h3><h5><span id="example1noi2009-管道取珠">Example1([NOI2009] 管道取珠)</span></h5><p>考虑组合意义,$\sum a _i ^2 $的意义也即满足操作序列$u $和操作序列$v $的最终结果相同的二元组$( u , v ) $的数量.</p>
<p>不妨设$dp _{ i , j , k  } $为第一个装置上方已经动了$i $个珠子,下放动了$j $个珠子,第二个装置上方动了$k $个珠子,下方动了$i + j - k $个珠子,并且两个装置截至目前的操作序列完全一样的方案数.显然$dp _{ n , m , n  } $即答案.</p>
<h5><span id="example2">Example2</span></h5><p>求长度为$n $的排列的$( \sum _{ i = 2  } ^{ n - 1  } [ a _i &lt; a _{ i - 1  } \And a _i &lt; a _{ i + 1  } ] ) ^k $的期望$( n \leq 10 ^9 , k \leq 500 ) $.</p>
<p>$O ( n ^2 k ^2 ) $是显然的,枚举最小值在哪就行.</p>
<p>注意到我们要求的是$\sum ans ^k $,而加入$1 $的时候,对于每个长度为$n - 1 $的排列,有$( n - 2 - 2 ans ) $个位置加入后会使答案加一,那我们要求的也就是:</p>
<script type="math/tex; mode=display">
\sum ( n - 1 - 2 ans ) ( ans + 1 ) ^k + \sum ( 2 ans + 2 ) ans ^k</script><p>推一推式子就可以做到$O ( nk ^2 ) $,然后上拉格朗日插值就做完了.</p>
<p>等一下,这是noip模拟赛啊,哪来的拉格朗日插值?</p>
<p>注意到我们可以考虑组合意义,$ans ^k $等价于从所有的地方中可重复地选出$k $个位置,如果随便选肯定可以钦定,问题在于可能会选出两个间隔为$1 $的位置,这就比较麻烦了.所以我们不妨直接把所有被选中的位置求出来,能合并成一段波动序列的合并.这样,我们设$f _{ i , j  } $表示已经选了$i $段波动序列,其中有$j $个谷的方案数.最后这些谷每个至少被选中一次,做一个辅助数组维护波动序列的数量即可,复杂度$O ( k ^3 ) $.</p>
<h3><span id="二项式定理展开">二项式定理展开</span></h3><h4><span id="example1">Example1</span></h4><p>求$\sum _{ i = 1  } ^n \sum _{ j = 1  } ^n ( a _i \oplus a _j ) ^2 $,$n \leq 10 ^5 $,$a _i \leq 10 ^9 $.</p>
<p>考虑设$f _i $表示只考虑前$i $低的位置,高位全部默认为$0 $的方案数.如果我们设$cnt _i $表示$a $中第$i $位为$1 $的数个数,那根据$( a + b ) ^2 = a ^2 + 2 ab + b ^2 $,我们只需要求出$g _{ i  } $表示只考虑前$i $低的位置,第$i + 1 $位是$1 $的数和第$i + 1 $位是$0 $的数两两异或之和,显然有$f _i = f _{ i - 1  } + 2 cnt _i \times 2 ^i \times g _{ i - 1  } + cnt _i 2 ^{ i + 1  } $.</p>
<p>$g $可以用$O ( n \log a ) $的复杂度求,这样总复杂度$O ( n \log ^2 a ) $.</p>
<h3><span id="线头dp">线头dp</span></h3><h5><span id="example120zr普及组五连测day1区间">Example1([20zr普及组五连测day1]区间)</span></h5><p>令$dp _{ i , j , k  } $表示目前倒到第$i $个水杯,前面还有$j $个延续过来的未结束的线头,目前已经选定了$k $个人,转移的话需要枚举当前有几个人在此开始以及有多少人在此结束,这样是$O ( n ^5 ) $的复杂度,不太能接受.但不妨考虑先将有几个人在此开始以及前面的继承处理到目前的数组中,然后再选择若干个人结束,这样分开了两个过程,于是实现了$O ( n ^4 ) $的复杂度.</p>
<h5><span id="example22022qbxt国庆day6rps">Example2([2022qbxt国庆Day6]rps)</span></h5><p>首先三次询问的做法没区别,我们只考虑r的情况.</p>
<p>注意到我们肯定是想拿s去把p杀掉,不然p就会把r杀掉.考虑一个线头dp,设$dp _{ i , 0 / 1 / 2  } $表示前$i $个数,0:无接头;1:有接头无线头;2:有线头的情况.这样一个线头每延申就会使答案减少,而如果我们把一个?改为s也会使答案减少,大概做一做.</p>
<h5><span id="example3coci2020-20212-svjetlo">Example3([COCI2020-2021#2] Svjetlo)</span></h5><p>首先发现,我们得到的序列不可能首尾相同,不然我们可以同时去掉开头和结尾.</p>
<p>然后发现,如果一棵子树内的点全部被点亮,这棵子树可以直接删去.这一步是必须做的,不然会多一步讨论.</p>
<p>我们设$dp _{ u , 0 / 1 , 1 / 2  } $为$u $的状态为$0 / 1 $,以$u $为根的子树内有$1 / 2 $个线头的方案数.注意如果子树内有$0 / 2 $个线头,那么会在$u $处存在两个接头;不然则会只存在一个接头.</p>
<p>通过不断将下方的点合并到当前子树的根节点上,我们可以完成整个过程.</p>
<p>注意到两个接头如果在相邻的两个节点就可以自动接起来,因此$dp _{ u , s , 2  } $的两个接头实际上一个位于$u $,另一个位于$u $的随便一个儿子.</p>
<p>换句话说,做线头dp的时候一定要注意,线头的相接是自然的过程(即两个线头相邻就会相接)还是需要手动接起来的过程.</p>
<h5><span id="example4cf626f">Example4(CF626F)</span></h5><p>先按照权值排序,一个人可以选择新建一个组,加入一个组,加入一个组并删除这个组</p>
<p>设$dp _{ i , j , k  } $表示目前走到$i $,前面分成$j $组,总贡献不超过$k $的方案数.做的过程中是一个线头dp,每次每组的贡献都要加上当前位置和前面位置的差值.</p>
<h5><span id="example5xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489-jtravel-in-sugar-country">Example5([XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain contest 1489) J]Travel in Sugar Country)</span></h5><p>一条线段上有$n ( \leq 100 ) $个商店,要从中选出$k ( \leq 10 ) $个不同的商店$s _1 , s _2 , \cdots , s _k $,使得按顺序遍历这$k $个商店的路径长度是$m ( \leq 30 ) $的倍数,求方案数.</p>
<p>这种来回走的也是一种线头dp的形式.</p>
<p>我们设$dp _{ i , j , w , l  } $表示目前在判断了$i $个商店,选了$j $个,并且目前整个图有$w $条”路径”(连续走动),走过的路在$\bmod m $一意义下为$l $的方案数.最后的答案就是$dp _{ n , k , 1 , 0  } $.</p>
<p>首先,我们对每个点求出$D ( 1 , x ) $,然后$D ( x , y ) = | D ( 1 , y ) - D ( 1 , x ) | $,不难发现$x $越大$D ( 1 , x ) $越大(不考虑取膜的问题),因此如果我们按照从左到右的顺序逐渐往里加入,那么我们就需要讨论这个新加入的点它的左右点的$D $和它的大小关系,也就是它左右点的加入时间,这显然可以使用线头dp实现.</p>
<p>我们先枚举一下起点和终点并将它们扔到图上,这样初始图上有一条路径($s _1 \rightarrow s _1 $),接下来,我们每插入一个点$x $,我们考虑它的贡献:</p>
<ol>
<li><p>新建一条路径,此时这个点的左右端点必然都是在他后面加入,它对总长度的贡献是$- 2 D ( 1 , x ) $,对方案数的贡献为$1 $.</p>
</li>
<li><p>插入到原来一条路径的开头/结尾.此时这个点有一个端点是比它早的,有一个会比它晚,对总长度的贡献为$0 $.</p>
</li>
<li><p>作为中心点合并两条路径,此时对总长度的贡献为$2 D ( 1 , x ) $.</p>
</li>
</ol>
<p>这样我们就做到了$O ( n ^4 km ) $的复杂度.如果我们加两维$0 / 1 $表示目前起点和终点是否加入,就可以把复杂度优化到$O ( n ^2 km ) $.</p>
<h3><span id="相对顺序不变">相对顺序不变</span></h3><p>如果遇到一些会不断改变当前状态的题目,有时可以考虑改变前后的一些元素的相对顺序是否改变.以及如果有两个物体相遇后交换位置的题目,如果物体本质相同,同样可以考虑直接穿过而不是交换.</p>
<h4><span id="example1bzoj4621tc605">Example1([bzoj4621]Tc605)</span></h4><p>注意到最终的序列一定是由若干个数字段组成,而数字段的顺序也即原本序列的顺序,于是此题显然.</p>
<h3><span id="拆分区间">拆分区间</span></h3><p>有的时候,注意到一个区间可以通过某些方式拆分成两个区间(断点可能是需要枚举的,也可能是固定的),从而可以递归处理/区间dp.</p>
<h4><span id="example122zr提高组十连测day4零二">Example1([22zr提高组十连测day4]零二)</span></h4><p>先考虑数字两两不同的时候怎么做,我们先找到$A $中的全局最大值所在位置和$B $中的全局最大值所在的位置.由于从堆中取出全局最大值后,堆一定成为了空堆.因此我们注意到此时$A $取出的数量和$B $的长度一定是相等的.</p>
<p>进一步考虑,这意味着一个全局最大值将把$B $序列分成两部分,这两部分将由$A $中相等的两部分分别生成.不妨假设这个全局最大值的位置是$x $,那么对于$[ 1 , x ] $这一段的$A $生成的$B $数组,它的最大值一定在末尾位置,而前面任意,显然它的数量等价于直接删掉最大值后的$A $能生成的$B $的数量.对于$[ 1 , x + 1 ] $则任意.</p>
<p>那么我们所需要做的就是求出$A $的某一段删掉若干次最大值后的序列所能生成的$B $的数量.不妨设$dp _{ l , r , i  } $表示$[ l , r ] $中所有$\leq i $的数字组成的序列所能生成的数量.</p>
<p>如果$[ l , r ] $这段区间中没有数字$i $,那显然$dp _{ l , r , i  } = dp _{ l , r , i - 1  } $,不然,我们可以枚举两端分开的位置,那这个位置一定在数字$i $的后面.于是可以转移.</p>
<p>至于可能出现相同数字的情况,我们只需要把每个数字的下标作为第二关键字即可,容易发现这样做之后转化为了两两不同的情况.</p>
<h4><span id="example2sdoi2010地精部落">Example2([SDOI2010]地精部落)</span></h4><p>注意到第$n $个元素一定是山峰.所以我们考虑用第$n $个元素分割整个区间为两部分.</p>
<p>设$f _n $为$n $个元素且开头为山谷的答案.枚举第$n $个元素在位置$k $($k - 1 $是奇数),则$f _k f _{ n - 1 - k  } \binom { n - 1  } { k  } \rightarrow f _n $.</p>
<h4><span id="example3">Example3</span></h4><p>给定数组$a $,每次可以选择一个数删掉并把两边的数接起来,要求操作过程中不能出现相邻的数相同,求方案数.$n \leq 500 $.</p>
<p>考虑枚举最后选的点,那么这个点左右一定互不相干.我们假设$f _{ l , r  } $为将$[ l , r ] $删干净后再去删$a _{ l - 1  } , a _{ r + 1  } $的方案数,然后枚举$[ l , r ] $中最后删哪个点即可做区间dp.</p>
<h4><span id="example4agc039e-pairing-points">Example4([AGC039E] Pairing Points)</span></h4><p>注意到这么一个事实:如果场上已经有了一个叉,那么接下来的边不能再穿过这个叉了.</p>
<p>首先需要破环为链,考虑从$1 $号点这里断开,枚举$1 $号点连接哪个点,然后就可以让$( 2 , 2 n ) $这些点断开了.我们设计$f _{ i , j , k  } $或$[ i , j ] ( k ) $表示区间$[ i , j ] $中的$k $向外连了一条边.答案是枚举$1 $号点连了哪个点,也就是$\sum _{ i = 3  } ^{ 2 n - 1  } f _{ 2 , 2 n , i  } $.</p>
<p>于是我们现在的问题在于如何求$f _{ i , j , k  } $.由于边要联通,所以与$k $相连的这条边必然被$[ i , j ] $中的某两个点所连接的边穿过.我们考虑枚举最靠外的那条边,假设为$x \leftrightarrow y $.这样整个区间被分为了两个部分:$[ i , k ] ( x ) , [ k , j ] ( y ) $.但是问题并没有得到解决.因为$[ i , x ] $和$[ y , j ] $之间的确不可能出现连边了,但$[ x , k ] $和$[ k , y ] $之间仍然可能出现连边.但我们发现:在$[ i , k ] $中一定存在一个分界线,使得分界线两侧是连到不同的两边的.</p>
<p>我们不妨再枚举一下这两个分界线,分别设为$p , q $.现在整个区间被分为了三个部分:$[ i , p ] ( x ) , [ p , q ] ( k ) , [ q , j ] ( y ) $,三个部分之间并没有连边,于是成功将区间拆分.</p>
<p>这个故事告诉我们:拆分区间的很重要的条件是:将一个区间拆分为若干相互无联系的区间,而我们的重点就是找到一种方式使得区间间相互无联系.</p>
<h4><span id="example5agc035d-add-and-remove">Example5([AGC035D] Add and Remove)</span></h4><p>首先自然想到区间dp.但是难以处理的是如果一个区间$[ l , r ] $中间删掉一个点$p $之后,$[ l , p - 1 ] $和$[ p + 1 , r ] $会拼起来,仍然会相互影响.</p>
<p>换一种方式,我们找到$[ l + 1 , r - 1 ] $中最后删除的点$p $,这样区间$[ l , r ] $的答案就是最终三个数的答案.这么枚举的好处是,我们发现删除$[ l + 1 , p - 1 ] $的时候,对$p $产生的贡献和删除$[ p + 1 , r - 1 ] $的时候对$p $的贡献是完全独立的,他俩可以分开.</p>
<p>再看每个位置的贡献,我们考虑计算出这个位置会对答案贡献多少倍,不妨假设$a _l $贡献了$x $倍,$a _r $贡献了$y $倍,那么由于$a _p $会两边都贡献到,所以$a _p $会对答案贡献$x + y $倍.</p>
<p>于是设计一个dp是:$f _{ l , r , x , y  } $表示删除$[ l + 1 , r - 1 ] $后,$xa _l + ya _r $最小是多少.自然有$f _{ l , r , x , y  } = \min \{ f _{ l , p , x , x + y  } + f _{ p , r , x + y , y  } + ( x + y ) a _p \} $.</p>
<p>至于复杂度,前两维肯定是$n ^2 $的空间复杂度,而后两维则意味着每次向下会由两个转移而来,最多转移$n $层,因此是$2 ^n $的空间,于是时间复杂度不会超过$O ( n ^3 2 ^n ) $,其实经过一些奇怪计算应该是不会超过$O ( 2 ^n ) $的.</p>
<h4><span id="example6cf607bzuma">Example6([CF607B]Zuma)</span></h4><p>这个题的关键在于拆分区间,因此一定要判断哪个点是最后删除的.</p>
<p>我们不妨设$f _{ l , r  } $表示删除$[ l , r ] $区间的代价.接下来我们无非要枚举$k $,使得$k $是最后删的.但发现这很难处理.</p>
<p>所以我们怎么办呢?我们考虑判断边界是如何删掉的.比如$l $,它要么是自己被删,要么一定是找到一个和它一样的点,这两个点一起删.我们注意到如果$a _l = a _k $,那么这等价于$f _{ l + 1 , k - 1  } + [ l = k - 1 ] + f _{ k + 1 , r  } $.因此可以做区间dp了.</p>
<h4><span id="example7loj-3215">Example7(LOJ 3215)</span></h4><p>首先考虑一下$m = 2 ^k - 1 $的情况,首先我们要判断有几个数最高位是$1 $,然后接下来判断第二位哪些数字是$1 $.</p>
<p>我们发现这类似一个拆分区间的过程,因为当我们决定了最高位之后,最高位是$1 $的就一定大于最高位是$0 $的了,这两个区间就没有影响了.因此可以设$f _{ l , r , k  } $表示$[ l , r ] $这个区间,前面已经有了$k $个$1 $的最大贡献.</p>
<p>那么对于$m \ne 2 ^k - 1 $的情况我们怎么办呢?我们只需要类似数位dp那样在状态里加一个lim防止超过$m $就行了.</p>
<h3><span id="相互独立">相互独立</span></h3><h5><span id="example12019zrtg十连测day1-origami">Example1(2019zrtg十连测day1 origami)</span></h5><p>看上去很不好做,先考虑宽为$1 $怎么做.</p>
<p>这个时候放在最下面的显然是一段区间,不难发现有一个暴力做法是,我们枚举这段区间$[ l , r ] $,然后看$[ 1 , l - 1 ] $和$[ r + 1 , m ] $能不能折进来.也就是判断以$r $和$r + 1 $为中心的回文串最大长度以及在这个范围内有没有已经折进来的区间.想到这一步,不难发现左右是独立的.</p>
<p>于是我们设$f _i $表示能不能折成以$[ 1 , i ] $为最下层,$g _i $表示能不能折成$[ i , n ] $为最下层,那$[ l , r ] $能折出来当且仅当$f _r = g _l = 1 $,做个前缀和就可以知道有多少个区间能折出来.</p>
<p>通过上面的启示,我们不难发现横着折和竖着折也是相互独立的,于是分别算出答案后乘起来就好.</p>
<h5><span id="example2cf1616g-just-add-an-edge">Example2(CF1616G Just Add an Edge)</span></h5><p>我们来一点一点捋这个题:</p>
<p>首先,任意一条路径一定形如$1 \rightarrow x \cup y \rightarrow n $,并且$1 \rightarrow x $和$y \rightarrow n $不交,然后添加边$x \rightarrow y $.</p>
<p>那么什么时候$1 \rightarrow x $和$y \rightarrow n $没有交并且他们的并是$[ 1 , n ] $呢?考虑将$1 \rightarrow x $这条路径上的点染色为$0 $,$y \rightarrow n $上的点染色为$1 $,由于边只有从前往后的,因此$[ 1 , y - 1 ] $必然为$0 $,$[ x + 1 , n ] $必然为$1 $.至于中间部分一定是一段一段地跳跃.</p>
<p>我们用dp做中间的跳跃过程,具体地,假设我们已经确定了$y $,现在想要找到$x $,我们现在假设染色的末尾是$( i , i + 1 ) $,也就是$i $染色和$i + 1 $的染色不一样,然后不断向后接上就行.</p>
<p>那么怎么优化这个dp呢?我们找到任意一个$p $,满足$p \nrightarrow p + 1 $,那么$p $和$p + 1 $永远不可能染同种颜色,我们直接以它为断点,自然发现$p $的左右两部分独立.</p>
<p>然后就是这题的细节部分,首先是计数的时候有可能算上了$p \rightarrow p + 1 $这条边,要特判.另外的问题是会发现首尾的位置很特殊,这里的做法是建立$0 $和$n + 1 $两个虚点,向所有点连边.</p>
<p>总之$O ( nm ) $的dp是自然的,而且会发现这个是一个类似连续性的东西,因此想到了在中间找断点中间合并,进一步发现左右两部分无关.</p>
<h3><span id="费用提前延后计算">费用提前/延后计算</span></h3><p>有的时候,我们注意到一个费用是很难及时算到dp数组里的,但是这个费用可能可以早在之前题前算上或之后再补上.</p>
<h5><span id="example122zr提高组十连测day3多">Example1([22zr提高组十连测day3]多)</span></h5><p>首先考虑已知一个序列,如何快速求它最后有几个位置不是$0 $.考虑从后往前枚举,每次判断当前数是否在以前已经枚举到过,如果枚举过就将其$- 1 $并重复判断操作,直到为$0 $或得到一个没有出现过的数.</p>
<p>考虑设计dp状态,判断一个位置是否能是$0 $相当于判断后面的已知序列的$mex $,这个要记入状态中,于是考虑设$dp _{ i , j  } $表示当前到了第$i $个位置,后面的数的$mex - 1 $是$j $的方案数.</p>
<p>但是如果直接这么设会发现,当前$i $的加入有可能会改变$mex $的值,而这个改变是很难处理的,因为如果$i $位置选择了$j + 1 $这个数字,那么$mex $要向上伸展到某一个值,而如果不选择$j + 1 $,也有可能选择一个更大的值后不断落到$j + 1 $,这意味着我们转移时需要枚举补上$j + 1 $这个数字后的$mex $并用刷表法转移.</p>
<p>不妨设这个数字是$k $.如果我们插入一个数字后直接更新当前的答案,可以发现这个$k $是没有办法处理的.所以考虑延后计算费用,即当我们插入的数字并没有引起$mex $的改变的时候,忽略此时带来的组合数贡献(因为这个数字可以任选,可以理解为将其暂时存下来后来需要它的时候再把它乘入答案);当我们引起改变的时候,我们从之前存下来的那些数字中取出一些补全$[ j + 2 , k ] $这些数字.</p>
<p>另外,注意到计算组合数的时候每个数字有两个,没有办法判断当前还剩下哪些数字,不妨直接认为两个相等的数字本质不同,算完答案后再整体除以$2 ^{ n  } $.</p>
<h5><span id="example2022zrnoip十连测day9-消失vanish">Example(2022zrnoip十连测day9-消失(vanish))</span></h5><p>$O ( n ^3 ) $的暴力是显然的:设$f _{ i , j , k  } $表示目前考虑到第$i $个位置,前面还有$j $个A,已经选了$k $个B的方案数,对A也类似做一做,最后枚举中点合并即可.</p>
<p>问题在于如何优化到$n ^2 $.</p>
<p>第一反应是删掉一维,但是这三维好像哪一位都不能删:第二维要累积答案,第三维要最后做合并.但是,注意到第二维和第三维可以合并!换句话说,我们做一个费用提前计算,每次加入A的时候,枚举它接下来要杀掉几个B,那我们接下来就额外多需要一些B.于是我们设$f _{ i , j  } $表示目前考虑到$i $,还需要$j $个B才能凑齐$c _B $个B的答案,就可以实现了.</p>
<p>咋说呢,大概是发现答案和后两维有关,而且注意到后两维之和是不大的,于是考虑把它俩合并起来做费用提前计算.</p>
<h3><span id="建立双射">建立双射</span></h3><h5><span id="example1sdoi2010地精部落">Example1([SDOI2010]地精部落)</span></h5><p>设$f _{ i , j  } $表示长度为$i $,开头为山峰且高度为$j $的方案数;$g _{ i , j  } $表示长度为$i $,开头为山谷且高度为$j $的方案数.注意到这俩显然是一个双射,也就是$f _{ i , j  } = g _{ i , i - j + 1  } $.</p>
<p>首先我们可以插入一个数,假如插入的数是山峰,那原本的所有大于等于$j $的数都向上平移一格,于是自然有:$f _{ i , j  } = \sum _{ k = 1  } ^{ j - 1  } g _{ i - 1 , k  } = \sum _{ k = 1  } ^{ j - 1  } f _{ i - 1 , i - k  } $.</p>
<p>另外,这个式子可以稍微转化为:$f _{ i , j  } = f _{ i - 1 , i - j + 1  } + f _{ i , j - 1  } = g _{ i - 1 , j - 1  } + f _{ i , j - 1  } $.</p>
<p>上式可以这么理解:我们讨论一下$j $和$j - 1 $是否相邻,如果相邻必然是$j $是山峰,$j - 1 $是山谷,不然则交换它俩后也仍然是合法的序列.</p>
<h5><span id="example22019zrtg十连测day1-group">Example2(2019zrtg十连测day1 group)</span></h5><p>首先注意到$2 k \leq n \land nk \leq 10 ^5 $,不难发现$k \leq 500 $.</p>
<p>冷静一下,发现如果我们把所有组长列出来按照经验排序,再把所有组员列出来按照经验排序,然后按照顺序匹对一定是最优的.</p>
<p>再冷静一下,类似卡特兰数,这等价于先把所有人按照经验从小到大排序,然后任意前缀选择的组长数量大于等于组员,枚举这个差量和前面选的组长的总量就可以做到$O ( nk ^2 ) $.当然其实只要控制组长的数量大于等于组员的数量即可.</p>
<p>注意经验相同的话要让想当组长的到前面.</p>
<p>另外当时还推了个性质:都可以的人群中一定存在一个分界点$w $,使得成为组长的经验$\geq w $,成为组员的经验$\leq w $,但是没用上这个性质.</p>
<h5><span id="example3agc056b">Example3(AGC056B)</span></h5><p>双序列计数,考虑把$x $双射到某个东西上.</p>
<p>考虑最后的图一定是个$DAG $,但同层之间没有啥限制,我们不妨假设同层的最左侧是最大值,这样就完成了映射.</p>
<p>设$dp _{ l , r , mx  } $表示只考虑$[ l , r ] $这一段的线段,然后最大值所在位置需要$\geq mx $的答案.转移的话枚举一手最大值扔哪,然后大概能做?</p>
<h3><span id="分维处理">分维处理</span></h3><p>简单来说就是如果问题有两维,我们找到简单的那一维处理.</p>
<h5><span id="example1cf1621gweighted-increasing-subsequences">Example1([CF1621G]Weighted Increasing Subsequences)</span></h5><h2><span id="动态规划的优化">动态规划的优化</span></h2><h3><span id="递进转移">递进转移</span></h3><p>瞎起的名,主要用于大量字符串算法.比如SA中的求height.</p>
<h5><span id="example1">Example1</span></h5><p>有$m $种礼物,每种礼物有无数个(有有限个也能做),$n $个朋友,第$i $个朋友喜欢第$j $个礼物的概率是$p _{ i , j  } $,$\forall i , \sum p _{ i , j  } = 1 $.</p>
<p>现在你可以选$n $件礼物.购买完成后你会按照朋友的编号逐个进行以下操作:如果自己手上的礼物有他喜欢的那一个,就将那个给他.求一种策略,最大化拿到喜爱的礼物的朋友个数的期望值.</p>
<p>$n \leq 3000 , m \leq 300 $.</p>
<p>首先一个显然的想法是:不同礼物对期望的贡献是独立的,也就是和的期望等于期望的和,我们只需要算出每个礼物的贡献即可.进一步地,我们需要求出$g _{ i , j  } $表示第$i $种礼物一共选了$j $个,被拿走的期望个数.然后我们只需要对其做背包就可以了.</p>
<p>那么$g $怎么求呢?这个是简单的,我们设$f _{ i , j  } $表示喜欢第$i $种礼物的人有$j $个的概率,不难发现$g _{ i , j  } = \sum _{ k = 0  } ^n \min \{ j , k \} f _{ i , k  } $.递推式就有$g _{ i , j  } = g _{ i , j - 1  } + \sum _{ k = j  } ^n f _{ i , k  } $.$f $同样是做一个背包.</p>
<p>但是,这两个背包的复杂度都是$O ( n ^2 m ) $的.我们需要对它们进行优化.</p>
<p>先看最后求答案的背包:自然的想法是,不难发现$g _{ i , j  } $满足四边形不等式,而其转移是经典的$k $点最短路,因此可以用决策单调性优化.</p>
<p>但实际上有点多此一举,事实上我们这么考虑:由于$g _i $是上凸函数,它的斜率逐渐减少,那么我们就必然是能选小的就选小的.我们可以设计一个贪心来解决这个问题:记录下来当前每种礼物选了几个,设为$c _i $,每次选当前$g _{ i , c _i + 1  } - g _{ i , c _i  } $最大的那个即可,这可以用堆实现.为啥这个是对的呢?因为$c _i $越大,能有的贡献就越小,不可能出现为了后面的贡献而让前面吃亏的情况,这就可以贪心了.于是第一个背包得到了解决.这里复杂度$O ( n ^2 \log n ) $,不太确定有没有$O ( n ^2 ) $的做法.</p>
<p>但是第二个背包,也就是$f $怎么求呢?我们发现我们没有必要把$g $全都求出来,只需要求目前需要的一部分就可以了,由于$\sum f = 1 $,因此后缀和可以改为前缀和,考虑到每往后推一位是$O ( n ) $的,但是只会往后推总共$O ( n ) $位,因此这里复杂度$O ( n ^2 ) $.</p>
<h5><span id="example2">Example2</span></h5><p>给一个字符串,求一个最大长度$L \leq \frac { n  } { 2  } $,使得前$L $个字符与后$L $个字符循环同构.</p>
<p>不难发现循环同构一定长这样:</p>
<script type="math/tex; mode=display">
ABSBA</script><p>我们枚举$A $的长度,然后就只需要求$B $,设$f _{ i  } $表示字符串去掉开头和结尾的$i $个字符后的border,有$f _{ i - 1  } \leq f _i + 1 $.然后就做完了.</p>
<h3><span id="反向操作">反向操作</span></h3><p>其实本质上是因为,DAG把边反向后仍然是一个DAG,这意味着我们大部分dp都可以进行反向操作.</p>
<h4><span id="example1cf1810g">Example1(CF1810G)</span></h4><p>其实这题有一个很自然的容斥做法,但我们先略过.</p>
<p>一般而言先考虑对于每个$k $暴力做.那怎么维护最大前缀和这个东西呢?如果我们从左往右扫,其实是很难维护的.因为我们无法接受加一维以维护它.更进一步为什么无法维护呢?因为你新加一个元素,它是不会影响前面的前缀和的,只会影响一个.这导致你的取$\max $操作很艰难.但如果!我把这个dp反过来,我设$f _{ i , j  } $表示<strong>从后往前</strong>dp到$i $,当前的最大前缀和是$j $的概率是多少,这个dp的转移极其简单:</p>
<script type="math/tex; mode=display">
P \times f _{ i , j  } \rightarrow f _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  }</script><p>最后在$f _{ 1 , j  } $处乘上$h _j $.</p>
<p>但是这样是$O ( n ^3 ) $的,怎么办呢?</p>
<p>考虑把这个dp反过来!我们设$g _{ i , j  } $表示如果初始只有$f _{ i , j  } = 1 $,dp到最后的答案是多少.于是只需要:</p>
<script type="math/tex; mode=display">
\begin{gathered}
P \times g _{ i - 1 , \max \{ 0 , j + a _{ i - 1  } \}  } \rightarrow g _{ i , j  } \\

\end{gathered}</script><p>我认真考虑过这个$P $应该乘在哪边.实际上确实应该在左边.原因比较简单,因为答案是一串乘法,你不能把这些$P $变成除法.但还有一个问题是,为什么反向的时候没有把这些反向呢?</p>
<p>原因是这类型dp比较特殊,我们要算的其实是一个类似DAG路径上的信息,因此边权无需改变.</p>
<h3><span id="矩阵加速">矩阵加速</span></h3><h4><span id="example1luogup4007小y和恐怖的奴隶主">Example1(luoguP4007小Y和恐怖的奴隶主)</span></h4><p>首先考虑直接将随从的状态压起来,拿组合数分析一下会发现状态数大概小于等于$200 $.也就是说转移矩阵大概是$200 \times 200 $的,设状态数为$S $.</p>
<p>继续考虑,如果直接做的话复杂度是$O ( TS ^3 \log n ) $,过不了.</p>
<p>我们考虑将一个$n $在$w $进制下分解,然后预处理每一位所对应的矩阵,这样复杂度来到了$O ( wS ^3 \log _w n + TS ^2 \log _w n ) $,平衡一下复杂度即可,大概取$w = 4 $会比较优秀.</p>
<h4><span id="example2noi-online3提高组魔法值">Example2([NOI Online#3提高组]魔法值)</span></h4><p>重新定义矩阵乘法:用$\oplus $替换原本的$+ $,然后用邻接矩阵作为转移矩阵.</p>
<p>直接做仍然过不了,不过可以用和上面那个题一样的方法来优化复杂度.</p>
<h4><span id="example3cf-1474f">Example3([CF 1474F])</span></h4><p>首先需要注意到,LIS的起点和终点一定在这条线的拐角处,也就是山谷和山峰处.</p>
<p>LIS的长度是好求的.问题在于计数上.</p>
<p>首先枚举一下LIS的起点和终点,但是接下来似乎怎么dp都需要和值域有关.而且如果从起点走到终点,判断中间具体的方案数,这个东西似乎也不能快速处理,一条线上的似乎也很难捆绑更新.</p>
<p>我们冷静一下,令$f _i = \sum _{ j , a _j = a _i - 1  } f _j $,这个东西一条直线上的位置不能捆绑更新的原因在于,随着我们从左往右走,是需要不断更新后面的$\sum $的值的,这一点很难处理.每次移动需要加入一条横线上的点对应的$f $.</p>
<p>再冷静一下,既然从左到右扫不行,我们能不能考虑从下往上扫呢?考虑设$f _{ i , j  } $表示所有$a _x = i $的$x $中第$j $小的$x $的答案,我们仍然可以从下往上扫.</p>
<p>但是,这么扫的复杂度仍然和值域有关.这怎么办呢?这个加入可规律多了,注意到在经过一个山峰或山谷之前,我们需要处理的点的数量和相对顺序都是恒定的,而它们的转移也之和上一次转移(上一条横线)有关,于是可以直接拿矩阵加速这个过程.</p>
<h4><span id="example4cf-1152f2">Example4([CF 1152F2])</span></h4><p>注意到$m $和$k $很小,这一定是突破口.</p>
<p>又注意到如果$a _{ i + 1  } &gt; a _i $,那么限制很强,反之很弱.而且又要求没有相同的数字.考虑从小到大加入数字,这样每加入一个数字$x + 1 $,我们考虑它只能插入$[ x + 1 - m , x ] $后面,我们直接用一个二进制数$S $表示$[ x + 1 - m , x ] $中的数字是否存在,然后就可以在转移上直接调用$popcount ( S ) $.设$dp _{ i , j , S  } $表示目前考虑完了数字$i $,插入了$j $个数字,存在情况是$S $.直接对它做矩阵加速就可以做到$O ( ( 2 ^m k ) ^3 \log n ) $.</p>
<h4><span id="example5noi2020-美食家">Example5([NOI2020] 美食家)</span></h4><p>设$dp _{ i , j  } $表示第$i $天走到城市$j $的最大收益,一眼矩阵加速.</p>
<p>但是有两个问题需要解决:</p>
<p>第一个问题是,怎么处理美食节.这个没什么,在两个美食节之间做矩阵加速,在美食节节点上特殊处理一下就行.不过这样复杂度要乘上$k $.我们可以一开始就预处理出转移矩阵的二的幂次,然后这里就可以加快速度.</p>
<p>第二个问题是,怎么处理边权.一个自然的想法是拆边,但边很多,拆不过来.怎么办呢?我们可以拆点.将一个点拆成若干个点连起来,对于一条边就找到对应的点连过去就行.</p>
<h3><span id="分步合并">分步合并</span></h3><p>大概是有的时候如果询问比较多,我们可能需要处理前缀/后缀数组然后拼起来答案.</p>
<p>这个时候我们会发现,如果要拼起来答案就要枚举一个区间,但是实际上可以一步一步来.</p>
<h4><span id="example2022qbxt国庆day6permutation">Example([2022qbxt国庆Day6]permutation)</span></h4><p>首先遇到排列先扔平面直角坐标系上.</p>
<p>考虑合法序列一定长什么样,如果我们把这个序列的若干个下降子段拿一个矩阵括起来,那这些矩阵显然横纵坐标都不能相交.</p>
<p>我们设$f _{ l , r  } $表示$a _l $和$a _r $必选的前提下,$[ l , r ] $这个区间的下降子序列个数.</p>
<p>然后,我们考虑枚举删掉点,对着剩下来的序列做dp.</p>
<p>考虑设$dp _{ i , j  } $表示前$i $个点,最大值为$j $的方案数,不难发现最后一个矩阵的最小值一定是$a _{ i  } $.然后$dp _{ a , b  } = \sum _{ i &lt; a , j &lt; b  } dp _{ i , j  } f _{ i + 1 , a  } $.</p>
<p>这个转移是$n ^4 $的,但是这显然是一个前缀和的形式,于是做一下二维前缀和就可以做到$n ^2 $,这样我们就得到了一个复杂度$O ( n ^3 ) $的东西.</p>
<p>继续考虑,由于是多个点,我们考虑维护前缀后缀然后在这个点拼起来.注意到,如果我们想求这个点不选的方案数,那还需要枚举它左右两边选的点,很麻烦,所以我们求一下这个点必选的方案数.这样我们每次需要枚举这个点$i $,它所在矩阵的最左边的点$k $,最右边的点$k $,然后此时的答案为$pre [ j - 1 ] [ a [ k ] - 1 ] \times nxt [ k + 1 ] [ a [ j ] + 1 ] \times f [ j ] [ i ] \times f [ i ] [ k ] $.</p>
<p>冷静一下,这样一步枚举了两边的分界点,所以可能不是很优秀,我们一步一步来.</p>
<p>设$g _{ i , j  } $为接下来我们要选$[ i , j ] $,$i $是矩阵左端点,$j $任意且这两个点必在矩阵中,左右两边的方案数.初始条件$g _{ i , j  } = pre [ i - 1 ] [ a [ j ] - 1 ] \times nxt [ j + 1 ] [ a [ i ] + 1 ] $.</p>
<p>然后我们不断转移右端点,将右端点往里缩,这一步可以使用树状数组优化,最后更新答案即可.</p>
<p>很厉害.</p>
<h3><span id="合并更新">合并更新</span></h3><h4><span id="example2022zrtg十连测day7-zero">Example(2022zrtg十连测day7 Zero)</span></h4><p>设$k = \max \{ i , j \} $,首先可以求出$x , y , z $分别表示:</p>
<ol>
<li><p>$x $:只包含第一行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$y $:只包含第二行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
<li><p>$z $:同时包含两行的格子的以$k $为右端点的和为$0 $的最小矩形的左端点$- 1 $.</p>
</li>
</ol>
<p>那么自然有转移:</p>
<script type="math/tex; mode=display">
\begin{gathered}
f ( i , k ) \leftarrow \max \{ f ( i , k - 1 ) , f ( i , y ) + 1 \} \\
f ( k , j ) \leftarrow \max \{ f ( k - 1 , j ) , f ( x , j ) + 1 \} \\
f ( k , k ) \leftarrow \max \{ f ( k , k - 1 ) , f ( k - 1 , k ) , f ( z , z ) + 1 \} 
\end{gathered}</script><p>转移正确的原因是两维转移顺序无所谓,所以可以乱转移.</p>
<p>冷静一下这个过程,我们先只考虑第一个转移:注意到$f ( i , k ) $关于$i $不降,于是显然当$f ( i , y ) \ne f ( i , k - 1 ) $的时候才会由$f ( i , y ) + 1 $转移过来.我们不妨设$p _i $表示最小的位置满足$f ( i , p _i ) = f ( i , k - 1 ) $,那转移也就是$f ( i , k ) \leftarrow f ( i , k - 1 ) + [ p _i \leq y ] $.并且每进行一次转移,都会满足$p _i \leq y $的$p _i $设为$k $.</p>
<p>也就是说我们需要维护:我们令一个点为它对应的$i $在当前$k $的$f $值,将这个点放到$p _i $位置上.然后我们每次找到$y $并把所有在$y $位置前的点都合并到$k $这个点上,并打一个加法$tag $,这显然可以并查集启发式合并.</p>
<p>把前两个转移这么一起做,然后用二分可以得到两个转移分别的$p _k $.</p>
<p>最后还需要处理一下$f _{ k , k  } $,暴力转移即可.</p>
<p>有一个问题是为啥能想到按照$\max \{ i , j \} $为顺序进行转移,这里是由于转移顺序无区别,我们需要规定一个顺序进行转移,于是考虑到找到较长的那一部分进行转移.</p>
<h3><span id="交换状态和值">交换状态和值</span></h3><p>通常是dp值较小而状态较大的情况,而且二者间通常需要满足单调性.</p>
<h5><span id="example1cf1620f">Example1(CF1620F)</span></h5><p>首先讨论一下最大值最小值之类的不难发现:这题是二分图的充要条件是$\nexists 1 \leq i &lt; j &lt; k \leq n $,$a _i &gt; a _j &gt; a _k $.</p>
<p>然后相当于是整个序列可以拆分成两个上升子序列,一个想法是$dp _{ i , j  } $表示现在做到$i $,另一个上升子序列的终点是$j $,是否合法.然后继续做.但这样复杂度挂掉了.</p>
<p>咋优化咧?注意到dp状态很大而值很小,且显然在$i $一定的情况下,$j $的值越小越容易满足.所以设$dp _i $表示一个上升子序列的终点是$i $,另一个上升子序列的终点最小是多少,这样就可以做了.</p>
<h5><span id="example2agc033d">Example2(AGC033D)</span></h5><p>首先自然的设计是$dp _{ l , r , u , d  } $,然后优化一下就是$O ( n ^4 ) $.然后咋做?</p>
<p>注意到答案不超过$\log $级别,所以设$dp _{ l , r , u , c  } $表示答案为$c $的时候,最大的$d $是多少.然后就$O ( n ^3 \log n ) $.</p>
<h5><span id="example3">Example3</span></h5><p>给定一个序列,两个人博弈.Alice每次可以使序列最左边的数$a _i $减去$[ 1 , a _i ] $中的一个数字,减成$0 $就删掉.Bob可以对最右边的数做类似的操作,不能操作者输.问结果.$( n \leq 2000 ) $</p>
<p>先考虑一个$O ( n ^2 a ^2 ) $的dp,比较显然,因为一个人取数显然要么取$1 $要么全取,又发现不可能两个人一起取一堆(先取的那个人取完就赢了),于是设$dp _{ l , r , x , y  } $表示目前Alice在取第$l $堆,Bob在取第$r $堆,第$l $堆为$x $,第$r $堆为$y $的情况下谁赢.直接转移.</p>
<p>诶,好像优化不动了,无论咋做都要知道当前这堆数字是啥啊,那就一定要把$a $存状态里诶.</p>
<p>能不能再更新一下策略,注意到最后Alice如果要全选的话,剩下的是$1 $还是更大的数好像无所谓.那:如果$a _1 = x $的时候,Alice能赢,那$a _1 = x + 1 $的时候Alice一定能赢.也就是这个东西满足单调性.又冷静一下,如果两个人不断一直持续选$1 $,那最后一定会选到一个人清空堆为止.而且清空堆的那个一定输了.因为如果清空了还赢了,那他一开始就直接清空了.不可能一开始选着选着一个人还没清空堆另一个人就跑了.这个性质启示我们或许后两维可以删掉一维,因为大部分情况下那一维都应该等于$a _l $或$a _r $.</p>
<p>然后咧?另一维怎么去掉呢?</p>
<p>等一下,我们开一个四维的dp存$0 / 1 $是不是太奢侈了?</p>
<p>所以我们把一个状态改为dp的值,设$dp _{ l , r  } $表示当前Alice在$l $,Bob在$r $,Bob还没动$a _r $的前提下,$a _l $至少要是多少Alice才能赢,Bob做一个类似的dp.最后只需要比较$dp _{ 1 , 1  } $和$a _1 $的大小就行.</p>
<p>问题来了,这玩意咋转移啊?</p>
<p>首先,如果当前Alice开始选$l $,Bob开始选$r $,那Alice的获胜条件显然是$dp _{ l , r  } \leq a _r $</p>
<p>如果可以全选(也就是Alice开始选$l + 1 $,Bob开始选$r $的时候Alice能赢),就直接让$dp _{ l , r  } = 1 $.不然,由于清空堆的人要输,所以Alice为了不输,必须要让$dp _{ l , r - 1  } $也满足条件,一个自然的想法是$dp _{ l , r - 1  } + a _r + 1 $,但是这个值好像没有必要:因为Bob并不是只有会不断清空$a _r $的,如果目前的$[ l + 1 , r ] $这个状态,Bob的值已经赢不了了,那我Alice就可以直接把左边清空.所以一旦Bob走到了不能稳赢$[ l + 1 , r ] $的值,Bob就必须全清空,所以如果我们设$g _{ l , r  } $是Bob的$dp $数组,那其实这里应该是$a _r + 1 + dp _{ l , r - 1  } - g _{ l + 1 , r  } $,因为Bob的策略一定是一步一步走到$g _{ l + 1 , r  } $后清空,这个情况我们已经杀了他了.</p>
<h5><span id="example4uoj708">Example4(uoj708)</span></h5><p>自然的想法是$dp _{ i , j  } $表示$i $子树内划分成$j $个连通块是否合法,然后我们发现如果$j $满足条件,那么$j + 2 $一定满足条件(判掉一些边界情况).</p>
<h3><span id="斜率优化">斜率优化</span></h3><p>一般的斜率优化就略了.</p>
<p>值得一提的是,斜率优化还有一种理解方式是:将前面的点当作直线,后面的当作一条平行于$y $轴的直线进行查询.</p>
<h5><span id="example1codechef-tsum2">Example1(Codechef TSUM2)</span></h5><p>点分治+斜率优化,注意需要使用第二种理解方式的斜率优化.</p>
<p>不过第一种应该也可以用.</p>
<h3><span id="wqs二分">WQS二分</span></h3><p>能用WQS二分解决的问题通常形如:需要在$n $个物品中选择恰好$m $个,使得最后答案最大.并且如果令$f _i $表示选了$i $个的最大答案,$f _i $必须是凸函数且是单调不降的.</p>
<p>遇到这种问题,我们通常二分一个数$C $,每选择一个物品就减去$C $的答案.不难发现这样我们一定能逼近$f _m $.</p>
<h3><span id="四边形不等式">四边形不等式</span></h3><p>对于定义在$\mathbb { Z  } $上的二元函数$w $,若对定义域上任意$a , b , c , d ( a \leq b \leq c \leq d ) $都有$w ( a , c ) + w ( b , d ) \leq w ( a , d ) + w ( b , c ) $,也就是交叉小于包含,则称函数$w $满足四边形不等式.如果等式成立,那么我们称其满足四边形恒等式.</p>
<p>不难发现这意味着:$w $所形成的矩阵中的任意一个子矩阵的差分(左上角+右下角-左下角-右上角)都小于等于$0 $.</p>
<p>如果它还满足$\forall 1 \leq l ‘ \leq l \leq r \leq r ‘ \leq n , w ( l , r ) \leq w ( l ‘ , r ‘ ) $，我们称其满足区间包含单调性.</p>
<p>需要声明的一点是:四边形不等式只能处理$\min $型dp的问题,对于$\max $型dp需要取相反数改成$\min $.</p>
<h4><span id="判定性质定理">判定/性质定理</span></h4><h5><span id="定理1">定理1</span></h5><p>若二元函数$w ( x , y ) $满足$w ( a , b ) + w ( a + 1 , b + 1 ) \leq w ( a , b + 1 ) + w ( a + 1 , b ) $.其中$a &lt; a + 1 \leq b &lt; b + 1 $,则$w $满足四边形不等式.</p>
<p>证明:</p>
<p>对于$a + 1 &lt; c $ 有</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a , c ) + w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) \\
w ( a + 1 , c + 1 ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\

\end{aligned}</script><p>同时有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) & \leq w ( a + 1 , c + 1 ) + w ( a + 2 , c ) \\
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a + 1 , c + 1 ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( a + 1 , c ) + w ( a + 2 , c + 1 ) - w ( a + 2 , c ) & \leq w ( a , c + 1 ) + w ( a + 1 , c ) - w ( a , c ) \\
w ( a + 2 , c + 1 ) + w ( a , c ) & \leq w ( a + 1 , c ) + w ( a + 2 , c + 1 ) 
\end{aligned}</script><p>同理可推至四边形不等式定义式.</p>
<p>事实上,这意味着一个$2 \times 2 $的子矩阵的差分满足条件,那么自然满足四边形不等式,无需推导.</p>
<h5><span id="定理2">定理2</span></h5><p>若$w _1 ( l , r ) , w _2 ( l , r ) $满足四边形不等式(或区间包含单调性),则$\forall c _1 , c _2 \geq 0 $,$( c _1 w _1 + c _2 w _2 ) $满足四边形不等式(或区间包含单调性).</p>
<p>证明显然.</p>
<h5><span id="定理3">定理3</span></h5><p>若$\exists f ( x ) , g ( x ) $使得$w ( l , r ) = f ( r ) - g ( l ) $,则$w $满足四边形恒等式.当$f , g $单调递增时,$w $还满足区间包含单调性.</p>
<p>证明显然.</p>
<h5><span id="定理4">定理4</span></h5><p>设$h $是一个单调递增的下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形不等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式和区间包含单调性.</p>
<p>令$l _1 \leq l _2 \leq r _1 \leq r _2 $,由于$w $满足四边形不等式,于是有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) + w ( l _2 , r _2 ) & \leq w ( l _1 , r _2 ) + w ( l _2 , r _1 ) \\
0 & \leq w ( l _1 , r _1 ) - w ( l _2 , r _1 ) & \leq w ( l _1 , r _2 ) - w ( l _2 , r _2 ) 
\end{aligned}</script><p>令$t = w ( l _1 , r _2 ) - w ( l _2 , r _2 ) $,我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( l _1 , r _1 ) & \leq w ( l _2 , r _1 ) + t \\
w ( l _1 , r _2 ) & = w ( l _2 , r _2 ) + t \\
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _2 , r _1 ) + t ) - h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = h ( w ( l _2 , r _2 ) + t ) - h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>不妨令$\Delta h ( x ) = h ( x + t ) - h ( x ) $,由于$h $是下凸函数,所以$\Delta h $函数单调递增.</p>
<p>那么也就有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq \Delta h ( w ( l _2 , r _1 ) ) \\
h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) & = \Delta h ( w ( l _2 , r _2 ) ) 
\end{aligned}</script><p>由于$w ( l _2 , r _1 ) \leq w ( l _2 , r _2 ) $,所以$\Delta h ( w ( l _2 , r _1 ) ) \leq \Delta h ( w ( l _2 , r _2 ) ) $于是:</p>
<script type="math/tex; mode=display">
\begin{aligned}
h ( w ( l _1 , r _1 ) ) - h ( w ( l _2 , r _1 ) ) & \leq h ( w ( l _1 , r _2 ) ) - h ( w ( l _2 , r _2 ) ) \\
h ( w ( l _1 , r _1 ) ) + h ( w ( l _2 , r _2 ) ) & \leq h ( w ( l _1 , r _2 ) ) + h ( w ( l _2 , r _1 ) ) 
\end{aligned}</script><p>证毕.</p>
<h5><span id="定理5">定理5</span></h5><p>设$h $是一个下凸函数(一阶导数单调递增),若$w ( l , r ) $满足四边形恒等式和区间包含单调性,则复合函数$h ( w ( l , r ) ) $也满足四边形不等式.</p>
<p>证明类似定理4,因为满足四边形恒等式所以不必用到$h $单调递增的性质.</p>
<h4><span id="决策单调性">决策单调性</span></h4><p>对于形如$f _i = \min _{ 1 \leq j &lt; i  } \{ f _j + w ( j , i ) \} $的状态转移方程,记$p _i $为$f _i $的最优决策.若$p $在$[ 1 , n ] $上单调不降,则称$f $具有决策单调性.</p>
<p>值得一提的是,我们也可以把题目中的$\min $改为$\max $,并且把$+ w $改为$- w $,那么下面的结论同样成立.</p>
<h5><span id="最短路型dp">最短路型dp</span></h5><p>定理：对于形如$f _i = \min _{ 1 \leq j &lt; i  } { f _j + w ( j , i )  } $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.</p>
<p>证明:</p>
<p>$\forall i \in [ 1 , n ] , \forall j \in [ 0 , p _i - 1 ] $,根据$p $的定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } + w ( p _i , i ) & \leq f _j + w ( j , i ) \\
f _{ p _i  } - f _j & \leq w ( j , i ) - w ( p _i , i ) \\

\end{aligned}</script><p>而对于$k \in [ i + 1 , n ] $,根据$w $的四边形不等式,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
w ( j , i ) + w ( p _i , k ) & \leq w ( j , k ) + w ( p _i , i ) \\
w ( j , i ) - w ( p _i , i ) & \leq w ( j , k ) - w ( p _i , k ) \\

\end{aligned}</script><p>联立得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ p _i  } - f _j & \leq w ( j , k ) - w ( p _i , k ) \\
f _{ p _i  } + w ( p _i , k ) & \leq w ( j , k ) + f _j \\

\end{aligned}</script><p>即:$j $对$k $的更新一定不如$p _i $对$k $的更新更优,因此$p _k \in [ p _i , n ] $,因此$f $有决策单调性.</p>
<h6><span id="example1loj6039雅礼集训2017day5珠宝">Example1(LOJ6039[雅礼集训2017Day5]珠宝)</span></h6><p>首先发现代价很小但是物品很多,于是想到按照代价分类.然后同种代价要选肯定由价值从小往大选,这一段可以前缀和做.</p>
<p>于是我们设$f _i $表示价值为$i $的答案,自然有:$f _i = \max \{ f _{ i - kc  } + sum _{ c , k  } \} $.</p>
<p>如果我们把$c $相同的分层,那这显然是一个最短路型dp,其中$w ( i , j ) = sum _{ c , \frac { i - j  } { c  }  } $.</p>
<p>显然这个转移只会让$\mod c $相同的相互转移,于是后面的$w ( i , j ) $可以理解为一段数字的和,自然满足四边形不等式($\max $也满足,因为交叉等于包含).</p>
<h5><span id="k点最短路型dp">k点最短路型dp</span></h5><p>对于形如$f _{ x , j  } = \min _{ i = 1  } ^{ x - 1  } \{ f _{ i , j - 1  } + w _{ i , x  } \} $的状态转移方程,若$w $满足四边形不等式,则$f $有决策单调性.证明同上.</p>
<p>值得一提的是,如果形如$f _x = \min _{ i = 1  } ^{ x - 1  } { w _{ i , x  }  } $,我们也可以看作$k $点最短路型的$k = 1 $的特例.</p>
<h6><span id="example1-基站选址">Example1 基站选址</span></h6><p>令$f ( i , j ) $为在第$j $个位置建造第$i $个基站的代价最小值,那么我们有转移:</p>
<script type="math/tex; mode=display">
f ( i , j ) = \min _{ 1 \leq k < j  } \{ f ( i - 1 , k ) + \sum _{ l = k + 1  } ^{ j - 1  } w _l [ d _l - s _l > d _k ] [ d _l + s _l < d _j ] + c _j \}</script><p>考虑后面的式子,不难发现满足四边形不等式(可能出现包含的时候中间部分贡献一次答案,交叉的时候中间部分不贡献答案的情况),于是可以使用四边形不等式优化.</p>
<p>考虑使用二分维护决策单调性,那么后面的是一个经典的二维数点.但由于维护决策单调性时$d _k $单调递增,更新答案时$d _j $单调递增,于是可以直接使用线段树维护,复杂度$O ( nk \log n ) $.当然也可以直接用一个主席树维护.</p>
<p>也可以考虑分治维护,更加好写,复杂度$O ( nk \log ^2 n ) $.</p>
<p>另外,我们可以再使用WQS二分处理第一维,复杂度$O ( n \log k \log n ) $.</p>
<h6><span id="example2cf-gym-102984f">Example2(CF gym 102984F)</span></h6><p>自然的设计是$f _{ i , j , k  } $表示前$i $个,已经打了$j $个,末尾有连续$k $个的最大价值.但是这个状态都已经超了.</p>
<p>我们可以用一下经典套路,把它转化为$f _{ i , j  } $表示前$i $个,目前打了$j $个且第$i $个没打中,然后每次枚举一个打中了的区间,这样看上去就有了优化的可能性.而如果我们把它改成$f _{ i , j  } $表示前$i $个,目前有$j $个没打中而且第$i $个没打中,这就是经典的k点最短路dp.</p>
<p>接下来我们尝试证明决策单调性:$dp _{ i , j  } = \max \{ dp _{ k , j - 1  } + \sum _{ l = k + 1  } ^{ i - 1  } C _{ l - k  } A _l + P \} $.</p>
<p>令$w ( l , r ) = \sum _{ k = l + 1  } ^{ r - 1  } C _{ k - l  } A _k + P $,接下来我们证明:$w ( l + 1 , r ) + w ( l , r - 1 ) \geq w ( l , r ) + w ( l + 1 , r - 1 ) $即可.讨论一下每个$A $面前的系数就能发现这是成立的.</p>
<h5><span id="区间型dp">区间型dp</span></h5><p>引理:在状态转移方程$f _{ i , j  } = \min _{ i \leq k &lt; j  } \{ f _{ i , k  } + f _{ k + 1 , j  } + w ( i , j ) \} $中(通常$f _{ i , i  } = w ( i , i ) = 0 , f _{ i , i + 1  } = w _{ i , i + 1  } $),如果$w $满足四边形不等式和区间包含单调性,那么$f $也满足四边形不等式.</p>
<p>证明:</p>
<p>只需证明$f _{ i , j  } + f _{ i + 1 , j + 1  } \leq f _{ i , j + 1  } + f _{ i + 1 , j  } $即可,考虑$j - i = 1 $的时候,显然成立.</p>
<p>使用数学归纳,假设当$b - a &lt; k $时,$f $满足四边形不等式,考虑$j - i = k $的情况:</p>
<p>设$f _{ i , j + 1  } $的最优决策为$x $,$f _{ i + 1 , j  } $的最优决策为$y $,则有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j + 1  } + f _{ i + 1 , j  } & = f _{ i , x  } + f _{ x + 1 , j + 1  } + w ( i , j + 1 ) + f _{ i + 1 , y  } + f _{ y + 1 , j  } + w ( i + 1 , j ) \\

\end{aligned}</script><p>对于$f _{ i , j  } $和$f _{ i + 1 , j + 1  } $来说,$x $和$y $不一定最优,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , x  } + f _{ x + 1 , j  } + w ( i , j ) + f _{ i + 1 , y  } + f _{ y + 1 , j + 1  } + w ( i + 1 , j + 1 ) \\

\end{aligned}</script><p>$w $和归纳假设都可以比较两个式子右边的大小,最终得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , j  } + f _{ i + 1 , j + 1  } & \leq f _{ i , j + 1  } + f _{ i + 1 , j  } \\

\end{aligned}</script><h6><span id="定理">定理</span></h6><p>记$p _{ i , j  } $为$f _{ i , j  } $的最优决策,若$f $满足四边形不等式,那么对于$\forall i &lt; j ， 有 p _{ i , j - 1  } \leq p _{ i , j  } \leq p _{ i + 1 , j  } \ $.</p>
<p>证明:</p>
<p>记$p = p _{ i , j  } $,$\forall k , i &lt; k \leq p $,因为$f $满足四边形不等式,所以有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , k  } + f _{ i + 1 , p  } & \leq f _{ i , p  } + f _{ i + 1 , k  } \\
f _{ i + 1 , p  } - f _{ i + 1 , j  } & \leq f _{ i , p  } - f _{ i , k  } 
\end{aligned}</script><p>根据$p $定义,有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i , p  } + f _{ p + 1 , j  } & \leq f _{ i , k  } + f _{ k + 1 , j  } \\
f _{ i , p  } - f _{ i , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } 
\end{aligned}</script><p>由上两式移项联立,得到:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f _{ i + 1 , p  } - f _{ i + 1 , k  } & \leq f _{ k + 1 , j  } - f _{ p + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } \\
f _{ i + 1 , p  } + f _{ p + 1 , j  } + w _{ i + 1 , j  } & \leq f _{ i + 1 , k  } + f _{ k + 1 , j  } + w _{ i + 1 , j  } \\

\end{aligned}</script><p>因此对于$f _{ i + 1 , j  } $,$p $比任意的$k &lt; p $更优,因此$p _{ i + 1 , j  } \geq p _{ i , j  } $,另一方向同理.</p>
<h4><span id="四边形不等式判断凸性">四边形不等式判断凸性</span></h4><p>判断一个函数的凸性只需判断$f ( k ) + f ( k + 2 ) \geq 2 f ( k + 1 ) $,而这只需证明$k $的时候的答案和$k + 2 $时的答案可以调整出两个$k + 1 $的答案(不一定是最小答案)并且这两个$k + 1 $的答案的和小于等于$k $时和$k + 2 $时的答案之和即可.</p>
<h5><span id="example1cf1661f">Example1(CF1661F)</span></h5><p>首先考虑四个点$( a , b , c , d ) $,注意到其一定满足四边形不等式,也就是$w _{ ac  } + w _{ bd  } \geq w _{ ad  } + w _{ bc  } $.</p>
<p>我们现在想证明,设$f _k $为新增$k $个传送机后的减少的答案,我们考虑证明$f _k + f _{ k + 2  } \geq 2 f _{ k + 1  } $.</p>
<p>我们画出$f _k $时选的点和$f _{ k + 2  } $时选的点,注意到我们可以用这两次调整出两个$k + 1 $的答案,并且这两个答案的和小于等于$f _k + f _{ k + 2  } $,于是证明了最小的$f _{ k + 1  } $是更小的.</p>
<p>于是我们可以使用二分,每次二分一个最小增加量$w $,然后对于每一段二分出在这一段中再增加一个传送机的增加量小于等于$w $的最大的传送机数量,然后就可以做了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">OI中的线性代数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<ul>
<li><a href="#oi中的线性代数">OI中的线性代数</a><ul>
<li><a href="#线性基">线性基</a><ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2cf1100fivan-and-burgers">Example2([CF1100F]Ivan and Burgers)</a></li>
<li><a href="#example3luogup8337-ynoi2004-rsxc">Example3(luoguP8337 [Ynoi2004] rsxc)</a></li>
<li><a href="#example4uoj703赵云八卦阵">Example4([uoj703]赵云八卦阵)</a></li>
</ul>
</li>
<li><a href="#杂题">杂题</a><ul>
<li><a href="#example1cf1270ixor-on-figures">Example1([CF1270I]Xor on Figures)</a></li>
<li><a href="#example2petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-fpassing-finals">Example2([Petrozavodsk Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) F]Passing Finals)</a></li>
</ul>
</li>
<li><a href="#逆矩阵求解线性方程组">逆矩阵求解线性方程组</a><ul>
<li><a href="#example1codeforces-cf1266h-red-blue-graph">Example1(codeforces CF1266H Red-Blue Graph)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/" class="post-title-link" itemprop="url">OI中的常见套路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A5%97%E8%B7%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="本质相同">本质相同</span></h3><h5><span id="example1">Example1</span></h5><p>对于所有满足以下条件的长度为$n $的序列$\{ a \} $,我们称它是好的:</p>
<script type="math/tex; mode=display">
\begin{aligned}
a _1 & = 1 \\
\forall 2 & \leq i & \leq n , a _i & \leq \max \{ a _1 , \cdots , a _{ i - 1  } \} + 1 
\end{aligned}</script><p>对于每一个数$1 \leq x \leq n $,求它在每个好的序列中出现的次数的平方和.其中$1 \leq n \leq 3000 $,任意模数.</p>
<p>首先注意到可以枚举每个数$x $出现的次数,这样就转化为对满足某些位置是$x $的好的序列计数.</p>
<p>对于一个没有限制的好的序列,设$f _{ i , j  } $表示$[ 1 , i ] $中填了$[ 1 , j ] $(其中$j $必填)的方案数,不难发现这就是第二类斯特林数.</p>
<p>这样,对于一个$x $,我们可以枚举它第一次出现的位置以及出现的次数,以及它第一次出现的位置后面的大于等于它的数的数量,合并即可.复杂度$O ( n ^4 ) $.</p>
<p>再思考一下,似乎我们不用枚举它出现的次数,而是可以直接用$g _{ i , j , 0 / 1 / 2  } $表示在$[ 1 , i ] $中填$[ 1 , j ] $,$1 $出现次数的平方和.同样枚举后面有多少大于等于它的位置,然后就可以把这些位置抽出来作为一个子序列,这个子序列就可以认为$x $就是$1 $.复杂度$O ( n ^3 ) $.</p>
<p>如果写出上面的式子的话,会发现最难处理的是一个形如$x ^k $的项,表示$x $第一次出现的位置后面仍然选比它小的数字的位置的方案数.这个怎么办呢?自然的想法是想在dp中顺便把它算了.</p>
<p>再进一步想,我们之所以合并麻烦,是因为取了两段上升区间.如果我们能求出一个上升区间和一个下降区间,在交点处合并呢?</p>
<p>但是这样怎么统计平方和呢?我们发现如果在$[ 1 , k ] $中选了$[ 1 , i ] $,那么$[ 1 , i ] $在$[ k + 1 , n ] $中是本质完全相同的,因此还是可以用上面的dp求.</p>
<h3><span id="排列转环">排列转环</span></h3><h5><span id="example1p8416">Example1(P8416)</span></h5><p>这题牛逼.</p>
<p>首先考虑一维的情况,一维情况下最劣应该是$2 , 3 , . . . , n , 1 $这样的.</p>
<p>为啥捏?因为注意到操作数$= n - $排列环数,这样的排列环数为$1 $,显然是最小的.加上列也差不多,所以$k _0 = 2 n ( n - 1 ) = 2 n ^2 - 2 n $.</p>
<p>而我们显然可以通过两次操作把一个位置归位,最后剩一行再随便做做,这样的答案就是$2 n ^2 - n + 1 $,如果我们想赢,那就需要在上面的$n - 1 $行每行省出一步操作.</p>
<p>这咋做呢?类似上面的做法,也考虑找环然后省一步,对于一行,我们找到所有应该放在这里的值以及它们所在的列,把它们应该在的列和实际在的列连边,一定能找到至少一个环(自环也算),删环就可以省一步操作.</p>
<h5><span id="example2">Example2</span></h5><p>给序列$a $和排列$b $,有若干次操作:</p>
<ol>
<li><p>修改操作:给定$x , y $,将$a _x $改为$y $.</p>
</li>
<li><p>查询操作:给定$l , r , x $,查区间$[ l , r ] $内最长的子区间$[ l ‘ , r ‘ ] $,使得对$\forall l ‘ \leq i &lt; r ‘ $,有$a _{ i + 1  } = b _{ a _i  } $,且存在$l ‘ \leq i \leq r ‘ $使得$a _i = x $.需要输出满足条件的子区间的长度最大值.</p>
</li>
</ol>
<p>一步一步来,首先处理出所有的极长的满足条件的段,不难发现修改一个点只会断掉一个段或者连接两个段,影响是$O ( 1 ) $的.</p>
<p>难点在于,我们如何处理要求其中存在一个$x $这种东西.</p>
<p>注意到$b $是排列,上置换,不难发现$b $其实就是一个置换,也就是说每一个极长的段一定是一个置换环内部的元素,我们可以快速定位到$x $所在的置换环.但这样还是不能做.</p>
<p>考虑由于是单点查询$x $,我们可以直接将数组也做置换,这样一个置换环就在一个区间内部,意味着一个极长的段一定是一个区间或者两个区间(原区间的一段前缀和一段后缀).</p>
<p>现在对于区间查询,我们考虑特殊处理和端点相交的段,这个是平凡的.这样我们只需要处理出完全被区间包含的那些段该怎么做.把右端点缩一缩,就等价于左端点完全被区间包含的那些点.也就是以$a $为横坐标,$l $为纵坐标,这样这些就相当于对一条横线取$\max $,然后查询一段竖着的线段的最大值.注意到一行不可能有两个横线,因此可以线段树分治+线段树维护,复杂度$O ( n \log ^2 n ) $.</p>
<h3><span id="规定转移顺序">规定转移顺序</span></h3><h5><span id="example1">Example1</span></h5><p>给定一张$n $个点的图,每个点有一个$[ 1 , k ] $的颜色,求这张图有多少个子图是一棵树并且在这棵树中每种颜色恰好出现了一次.</p>
<p>首先无根树转有根树计数,设$dp _{ i , S  } $表示以$i $为根,已经选了$S $集合中的颜色的方案数.转移的时候枚举出边(注意可能会算重,只要是会算重的都考虑钦定某种颜色在其中一个块里),复杂度$O ( m 3 ^k ) $.</p>
<p>冷静一下,想到斯坦纳树,于是再设一个$g _{ x , S  } $表示以$x $为根且$x $只有一个儿子,$S $的定义类似的方案数.这样我们就可以用斯坦纳树的换根技巧计数.很厉害.</p>
<p>这个故事告诉我们:对于图论计数问题(尤其是和树有关),$m $大概率可以转化为$n $,但是需要一些小技巧(例如斯坦纳树)</p>
<h5><span id="example2p7142">Example2(P7142)</span></h5><p>类似宝藏那个题,我们考虑设$f _{ d , S _1 , S _2  } $表示$S _1 $中的点到$1 $的距离$&lt; d $,$S _2 $中的点到$1 $的距离$= d $.然后枚举到$1 $的距离$= d + 1 $的点集,这一部分复杂度是$O ( n 3 ^n ) $,预处理一下不同情况的答案即可.</p>
<h3><span id="复杂度均摊">复杂度均摊</span></h3><p>大概是如果多组询问那复杂度是错误的,但是如果我全局求,那我$\sum $起来的总复杂度大概是对的.经典问题是树上背包.</p>
<h5><span id="example1">Example1</span></h5><p>给定一颗二叉树,求对于每一个$x $,满足$x , y , z $互不相同的三元组$( x , y , z ) $的价值(定义为两两距离之和对$L $取膜)的最大值是多少.$n \leq 3000 $.</p>
<p>乍一看,二叉树,想到换根后做dsu on tree+set.但是$O ( n ^2 \log ^2 n ) $实在是跑不过去.冷静一下,除去三点共线的情况,考虑三个点在二叉树上的两两LCA一定只有两个点,枚举其中深度较浅的那个点并枚举其子树中的两个点和子树外的一个点.假设其子树内有$x $个点对,子树外有$y $个点,注意到$\sum x = n ^2 \land \sum y \leq n ^2 $,于是总复杂度$O ( n ^2 \log n ) $.</p>
<h3><span id="字典序相关">字典序相关</span></h3><p>题目中询问满足条件的字典序第$k $小之类的问题,通常采用转化为计数问题.</p>
<h5><span id="example12022noip十连测day88ady">Example1([2022noip十连测day8]8ady)</span></h5><p>首先,我们肯定想如果知道$a $,我们怎么求出$b $.</p>
<p>首先不难发现,我们可以这么还原:先开一个堆,然后先将前$m - 1 $个位置扔进堆里,从第$m $个位置开始,假设现在到了第$i $个位置$( m \leq i \leq n ) $,每次将$a _i $扔进堆里,并从堆中取最小元素扔到$i - m + 1 $位置,最后把堆清空到剩下的位置即可.</p>
<p>大量实验证明:这种反向构造思路,你用个堆通常是做不动的.</p>
<p>我们考虑有没有别的做法.</p>
<p>一个一个数地考虑,$b _1 $在$a $中的位置应该在哪?显然是应该在$[ 1 , m ] $中,而且根据上面的堆的做法,显然它应该是$[ 1 , m ] $中最小的数字,换句话说,我们需要满足:$[ 1 , m ] $中除它以外的数字都比它大.</p>
<p>我们继续考虑$b _2 $,显然它在$a $中应该在$[ 1 , m + 1 ] $中,并且需要满足$[ 1 , m + 1 ] $中的所有数字除了$b _1 $,都比它大.</p>
<p>以此类推.不难注意到对于一个数$b _i $,其中$1 \leq i \leq n - m + 1 $,它能填回的原序列的位置一定最大最大是$[ 1 , m + i - 1 ] $,并且如果它能填到区间$[ l , r ] $中,这个区间中除去在它之前填进来的数字以外,均比它大.</p>
<p>但是,这显然是个上界.这个区间能不能缩小一下呢?</p>
<p>对于一个$i $,我们找到最大的$j $满足$1 \leq j &lt; i $并且$b _j &gt; b _i $(有可能找不到).</p>
<p>冷静一下,显然,$b _i $不能填到$[ 1 , j + m - 1 ] $.(因为如果它扔在这里,那它就:在$j $出堆前入堆,在$j $出堆后出堆,显然不合法)</p>
<p>也就是说,我们将每个数能填的区间缩小为了$[ j + m , i + m - 1 ] $.</p>
<p>那是不是说每个数只要填在这个区间中,就一定合法呢?</p>
<p>我们考虑一个数$i $以及所有比它小且在它后面的数字$j $,当$j = i + 1 $时,显然$j $只有一种选择,直接填上;当$j = i + 2 $时,若$i + 1 $已经选择好了,那$j $显然也只有一种选择,填上.这样,对于所有$i $,如果它前面有一个大于它的数字,那它一定只有一个位置可以填.</p>
<p>这样我们就可以简化为:给定$b $数组单调递增的问题.不难发现该条件下$i $可以选择的区间是$[ 1 , i + m - 1 ] $,且满足条件一定有解.</p>
<p>冷静一下,这个时候假设新序列长度为$len $,那显然一共有$m ^{ len  } $个满足条件的$a $序列.注意到这个级别是指数级别.</p>
<p>所以前面一定是按顺序填,直到后面才会打乱顺序.而后面的长度大概也就是个$\log _m k $,枚举枚举就行.</p>
<h3><span id="前缀和与差分">前缀和与差分</span></h3><h5><span id="example1loj3266">Example1(loj3266)</span></h5><p>把点都扔到坐标系上,显然到一个点曼哈顿距离相等的数一定在一个正方形(对角线平行于坐标轴)上.</p>
<p>我们考虑如果已知两个点,怎么找第三个点的坐标,显然是两个正方形的边界的交点,那也就是说,曼哈顿距离下,一个等边三角形必定有两个点所在直线与坐标轴成$45 \degree $角,那这两个点必然和另一个点组成了一个等腰直角三角形(欧几里得意义下),我们枚举等腰直角三角形的直角顶点和直角边长就可以确认这两个点的坐标,而另一个点一定在一条与坐标轴成$45 \degree $的斜线上,可以使用前缀和做.</p>
<p>注意到有的点对可能会被算两遍,要特判.</p>
<h5><span id="example2">Example2</span></h5><p>小孔在玩卡牌游戏.众所周知,在卡牌游戏里,过牌是很关键的,所以目前小孔的牌库中,只可能有数字牌$0 , 1 , 2 , 3 , 4 $.</p>
<p>数字牌$x $的含义是当你打出它的时候,会从牌库的顶端抽$x $张牌到自己手里,若牌库中不足$x $张牌,则将牌库抽空为止.打出的数字牌$x $会放入弃牌堆中.在题目中你可以认为这张牌不会再被用到了.</p>
<p>目前,牌库里有$n $张牌,从牌堆顶到牌堆底数第$i $张牌为数字牌$a _i $.在开始回合时,发牌员会进行一次切牌,切牌的结果是从牌堆顶到牌堆底的牌的顺序变为了$a _s , a _{ s + 1  } , . . . , a _n , a _1 , . . . , a _{ s − 1  } $.</p>
<p>接着,小孔会抽$k $张牌堆顶的牌到自己手上.每次小孔可以打出一张牌,但这一回合中小孔至多打出$p $张牌.小孔可以在任意时刻结束回合.</p>
<p>请问,这一回合中若小孔使用最优策略,那么牌库里最少还剩多少牌.进一步地,有$q $次这样的询问,每次询问给定三个整数$s , k , p $,你需要输出牌库里最少还剩多少牌.$( n , q \leq 3 \times 10 ^5 ) $.</p>
<p>每次询问是独立的,也就是说每次询问并不会以任何方式影响到之后的询问.</p>
<p>首先我们想一下我们需要知道什么:我们需要知道其在这一回合中打出的各种牌的数量是多少.而只要知道这一点,我们自然得到了答案是多少.注意到每次一定优先打出手头上最大的牌.</p>
<p>我们设$sum _{ t , i  } $表示从开始到抽完第$i $张牌<strong>之前</strong>,在只用大于$t $的牌的前提下,还能往下抽多少张牌.显然$sum _{ t , 0  } = 0 $并且$sum _{ t , i  } = sum _{ t , i - 1  } + a _{ i - 1  } [ a _{ i - 1  } &gt; t ] - 1 $.注意到$sum _{ t , i  } = 0 $就抽不了第$i $张牌了.不考虑还能抽负数张牌的情况,注意到$sum $数组具有可差分性!</p>
<p>那我们一开始抽了$k $张牌,也就是令$sum _{ s + 1  } \leftarrow sum _{ s + 1  } + k $,那第一个不能继续抽牌的地方显然也就是第一个满足$sum _{ i  } - sum _{ s  } \leq 0 $的地方,用原本的$sum $数组表示也就是$sum _{ i  } + k \leq sum _{ s  } $.那第二个地方呢?由于后面的$sum $都加上$k $了,第二个地方也就是满足$sum _j \leq sum _{ i  } - t $的地方(不过注意到后面要倍增,所以直接写$sum _j &lt; sum _i $也可以,这样方便用单调栈维护这个东西).以此类推,注意到这个东西和询问无关,可以使用倍增预处理,处理的过程中判断一下还有没有大小为$t $的牌以及用牌总数是否小于等于$p $即可.都是可以用前缀和之类的东西预处理的.最后从小的牌开始选,选完之后的牌就可以当成$0 $牌了.另外要注意:我们要保证目前一定有大小为$t $的牌选,所以需要在做之前判断一下最后一次选择大小为$t $的牌的位置是在哪里.</p>
<p>等一下,注意到我们好像没啥办法判断还有没有大小为$t $的牌.有一个方法是:我们直接令所有$\leq t - 1 $的牌变成$t $,并处理出不用$\leq t - 1 $的牌能跑到的最右点,然后取个$\min $.</p>
<p>想出$sum $数组并发现可差分性后,这个题突然就变可做了.问题来了:咋想到的$sum $数组,又是怎么发现的可差分性?</p>
<p>首先,由于切牌这个环节会变化起点.所以有两种可能:要么是像倍增那样起点不定,要么是像差分一样其它起点的答案可以由原本的起点答案得到.那想到差分后呢?又注意到一定会先选较大的牌,所以大概率可以分层考虑:这样就先把问题转化为只有$0 / 1 $或者是只有$0 / 1 / 2 $的情况再继续考虑.由于要多组询问,所以答案一定是可以通过某种方式迅速算出来的,考虑到只要得到每种牌选的次数就可以快速算答案.又有一定是比它大的牌都选完了才选它,于是考虑第一次选不了其它牌只能选它的地方.注意到这个地方可以使用前缀和在变换起点的情况下求.于是由前缀和判断差分性质.</p>
<h3><span id="二分答案">二分答案</span></h3><h5><span id="example12022qbxt国庆day6kth">Example1([2022qbxt国庆Day6]kth)</span></h5><p>考虑$f $的取值不会很多,我们可以枚举$f $的取值,并把相同取值的归类.也就是,对于$f = i $的类别里也就是后$i $位为$0 $,第$i $位为$1 $的那些数.</p>
<p>注意到每个类别内部是很有序的,也就是说我们可以采取类似初赛归并排序的方法二分,找到前$k $大的和.</p>
<p>调了一年,这个故事告诉我们,如果一个东西暴力调整能过/复杂度均摊,就不要写一些很丑的很难写的即使更快的东西去做.</p>
<h5><span id="example2">Example2</span></h5><p>给你一棵$n $个点的树,每条边是一个字符(字符集是小写字母),一个点的所有相邻边边权不同.</p>
<p>有$m $次操作:每次询问给出点$x $和字符串$S $,$S $中不包含相同字符,$| S | = 26 $,每次修改会修改一条边边权.</p>
<p>从$x $点开始,每次对与$x $点相邻的边,对这些边找出其边权在$S $中出现的位置,找出边权出现位置最靠前的边,然后走过去.</p>
<p>每次询问走过的边直接从树上删除,一条边正反方向算同一条边,也就是说没法$x \rightarrow y \rightarrow x $.</p>
<p>这个过程会停机,你需要输出在哪个点停下来,询问之间独立.</p>
<p>这题最重要的思想在于:我们首先需要将这个问题改成一个判定性问题:判定性问题显然弱于找到答案.</p>
<p>怎么判定呢?对于一条路径,如果我们要沿着它走,那么我们就可以确定每个点的最小边(或者次小边),这等价于给出若干个边之间的大小关系,可以使用bitset维护一下,最后判定即可.我们发现判定数组是可以合并的,于是这玩意可以扔到线段树上维护.</p>
<p>会了判定这题就做完了,做树链剖分,然后开始从下往上跳重链,能跳到顶端就跳,不然二分跳到哪里,下去是同理的,只不过下去的二分需要多个$\log n $.</p>
<h3><span id="整体二分">整体二分</span></h3><p>通常解决在二分的情况下,单次check的复杂度比较高的问题.思想是把所有询问共同的check一起做.</p>
<p>整体二分的具体复杂度往往需要现场分析.</p>
<p>最常用的整体二分的写法是分治.但是有的问题(例如不能撤销)可能不太好写分治.</p>
<p>还有一种方式是,我们把所有询问一字排开,然后求出每个询问当前二分的$mid $,然后顺序处理或者别的什么处理方式做这些$mid $.</p>
<h5><span id="example1agc002dstamp-rally">Example1([AGC002D]Stamp Rally)</span></h5><p>直接整体二分,注意需要做可撤销并查集之类的东西.</p>
<h3><span id="分治">分治</span></h3><h5><span id="example1平面最近点对">Example1(平面最近点对)</span></h5><p>按照$x $轴排序,递归做两边的子问题,假设两边问题的最小值为$d $,对着$d $做中间的问题.</p>
<h5><span id="example2cf1764g3-doremys-perfect-ds-class-hard-version">Example2([CF1764G3] Doremy’s Perfect DS Class (Hard Version))</span></h5><p>有一个$[ 1 , n ] $的排列$p $,每次可以询问$l , r , k $,交互库会返回$\lfloor \frac { p _l  } { k  } \rfloor , \lfloor \frac { p _{ l + 1  }  } { k  } \rfloor , \cdots , \lfloor \frac { p _r  } { k  } \rfloor $中不同数字的个数,你需要在$20 $次询问内找到$p $中$1 $的位置.</p>
<p>第一反应就是令$k = 2 $,然后如果$n $是奇数,不难发现此时只有$1 $自己一个人一组.一个自然的想法是,我们可以对于每个位置$i $,查询$[ 1 , i - 1 ] $和$[ 1 , i ] $的答案,如果答案一样,那这个位置肯定不是$1 $.如果不一样,我们再查一下$[ i , n ] $和$[ i + 1 , n ] $.由于$1 $不会和左右任意一个人配对,不难发现如果这两种情况都不一样,那这里一定是$1 $,这样我们就做到了$2 n - 2 $次查询.</p>
<p>那么如何优化呢?我们冷静一下,如果我们查询一个区间$[ l , r ] $,那么得到的答案自然是$len - $配对数字都在区间内的对数,因此我们自然也能得到这个区间的未配对数.这个时候发现,对于位置$i $,如果我们查询$[ 1 , i ] $和$[ i + 1 , n ] $,由于这两个区间内没配对的数字要么是$1 $,要么会和另一个区间中的数字配对,因此这两个区间中,未配对数多的那个一定包含$1 $.这样就可以通过$k $不断向下二分,最后只需要$20 $步操作就可以解决$n $是奇数的情况.</p>
<p>那么$n $是偶数怎么办呢?这个时候$1 $和$n $都没人配对.我们需要找到$n $并将它杀掉.注意到$k $可以取别的数,我们如果只是让$k = 2 $未免有些弱,而且看上去也区分不了$1 $和$n $,而不难发现,令$k = n $就可以找到$n $在哪里,于是可以先找$n $再找$1 $,需要$40 $步.</p>
<p>那怎么继续优化呢?我们还是令$k = 2 $,查询$[ 1 , i ] $和$[ i + 1 , n ] $,我们发现此时会有两种情况:</p>
<ol>
<li><p>左右两边未配对数量相差$2 $,这个时候$1 $和$n $一定都在较大的那边,直接递归.</p>
</li>
<li><p>左右两边未配对数量相等,这个时候一定$1 $在一边,$n $在另一边,我们可以通过一次查询$k = n $判断哪边是$n $.</p>
</li>
</ol>
<p>于是只需要$21 $次.</p>
<p>但是还是不够,我们从哪里抠出那一次呢?发现最后处理区间$[ i , i + 1 ] $还需要两步操作,我们看看能不能省掉一步.</p>
<ol>
<li><p>$1 $和$n $都在$[ i , i + 1 ] $中,我们显然只需要查询一步就可以知道哪边是$n $.</p>
</li>
<li><p>只有$1 $在$[ i , i + 1 ] $中,我们考虑利用一下前面的信息.注意到我们一定已经知道$[ 1 , i - 1 ] , [ i , n ] , [ 1 , i + 1 ] , [ i + 2 , n ] $的答案(如果区间为空或者区间为$[ 1 , n ] $显然我们也知道答案),假设这个区间中的两个数是$1 $和$x $,$x \in ( 1 , n ) $,那么$x $一定有一个和它配对的数字,我们考虑通过$[ 1 , i - 1 ] $和$[ 1 , i + 1 ] $就可以知道和$x $配对的数字在$[ 1 , i - 1 ] $还是在$[ i + 2 , n ] $.接下来只需要一步判断就可以找到$1 $了.</p>
</li>
</ol>
<h5><span id="example3xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopentraisn-contest-1489d-nice-set-of-points">Example3(XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(opentraisn contest 1489)D  Nice Set of Points)</span></h5><p>给定一个点集$S = \{ ( x , y ) \} $,$( x _1 , y _1 ) $和$( x _2 , y _2 ) $可达当且仅当$x _1 = x _2 \lor y _1 = y _2 $.称一个点集是好的当且仅当这个点集中任意两个点的最短距离是它们的曼哈顿距离.给出一个点集,大小为$N $,$1 \leq N \leq 1000 $,加入不多于$10000 - N $个点使得这个点集变成好的.</p>
<p>找一条分界线$x = d $,我们将这条线左右两边的点全都作出在这条线上的投影点,将这些投影点全都加入,不难发现左右两边之间的路径就合法了,继续递归就行.</p>
<h5><span id="example4cf1442dsum">Example4([CF1442D]Sum)</span></h5><p>一个自然的想法是由于越靠后的可能越优秀,所以应该是要不断往后挖的.具体地,我们发现只可能有一个数组被选了一部分,剩下的数组要么不选,要么全选.</p>
<p>为什么呢?假设有两个数组各选了一部分,不妨假设它们最后选的数分别是$a $和$b $,下一个未选的数分别是$c $和$d $,有$c \geq a , d \geq b $,假设$a \geq b $,那么自然有$c \geq b $,于是我们把$b $删掉换成$c $一定更优秀.</p>
<p>有了这个性质后,我们可以枚举是哪个数组只选了一部分,然后求出剩下部分的背包,背包部分可以求前缀和后缀最后合并起来,我们的复杂度就是$O ( nk ^2 ) $.</p>
<p>但这个复杂度还是不太够,如何优化呢?</p>
<p>注意到这里的背包是支持撤销操作的,我们考虑一个分治做法:每次做到$[ l , r ] $的时候,假设此时$[ 1 , l - 1 ] $和$[ r + 1 , n ] $都加入答案了,我们把$[ mid + 1 , r ] $也加入背包,然后递归求解$[ l , mid ] $,然后再撤销,同样的方法求解右边的答案.复杂度$O ( nk \log n ) $.</p>
<h5><span id="example5agc044d">Example5(AGC044D)</span></h5><p>这题在于分治后归并,考虑我们是可以快速判断一个串是否是原串的子序列的,就是判断它们的编辑距离是否恰好等于长度之差.而我们也可以快速判断每个字母在原串中出现了多少次,只需要询问$L $个这个字母然后看编辑距离就是替换的次数.这样我们考虑对字母分治,$[ l , r ] $表示只用到$[ l , r ] $中的字母,得到的极长的原串的子序列是什么.边界情况$[ l , l ] $是好处理的,对于$[ l , r ] $,我们考虑归并,合并$[ l , mid ] $和$[ mid + 1 , r ] $的时候不断判断当前串是否是子序列就行.</p>
<h3><span id="倍增">倍增</span></h3><p>顺便一提,倍增比二分方便的一点在于:倍增能迅速确定答案的规模,这在复杂度与答案规模有关的时候至关重要.</p>
<h5><span id="example1scoi2015国旗计划">Example1([SCOI2015]国旗计划)</span></h5><p>先破环成链,然后设$f _{ i , j  } $表示从$i $这个人,途径$2 ^j $个人后能到达的最远的人是谁,然后就可以直接通过倍增处理.</p>
<h5><span id="example2pkusc2018星际穿越">Example2([PKUSC2018]星际穿越)</span></h5><h5><span id="example3cf1523h-hopping-around-the-array">Example3(CF1523H Hopping Around the Array)</span></h5><p>类似国旗计划,只不过需要用背包合并一维.</p>
<p>不过吧,这题有个问题在于最后的询问,我们要每次判断当前越界的点的代价是否小于等于dp数组的代价,如果小就回撤dp数组(因为无论如何都必不可能在这里选择).</p>
<h5><span id="example4loj3665">Example4(loj3665)</span></h5><p>思考一下发现,走相同的步数能到的点一定是一段区间,于是考虑使用倍增算法,设$f _{ x , i  } $表示从$x $走$2 ^i $步能到的区间,转移是简单的RMQ问题.</p>
<p>但是初值怎么求呢?先考虑右端点怎么求.对于每个路线$j $,它会把$[ A _j , A _j + k - 1 ] $能到达的右端点与$B _j $取$\max $,由于查询在修改之后,所以这个东西很好做.</p>
<h5><span id="example5cf1707e">Example5(CF1707E)</span></h5><p>引理1:如果$[ l , r ] \subseteq [ L , R ] $,则$f ( ( l , r ) ) \subseteq f ( ( L , R ) ) $.</p>
<p>引理2:如果$[ L , R ] = [ l _1 , r _1 ] \cup [ l _2 , r _2 ] $,则$f ( ( L , R ) ) = f ( ( l _1 , r _1 ) ) \cup f ( ( l _2 , r _2 ) ) $.</p>
<p>引理1显然,引理2是因为$[ L , R ] $中的最大值和最小值一定都被后面的两个部分取到.</p>
<p>于是,考虑$[ l , r ] = \cup _{ i = l  } ^{ r - 1  } [ i , i + 1 ] $,就可以倍增了.</p>
<p>考虑求出每个单点的倍增数组,那么总区间的倍增数组也就是这些数组的最小值和最大值.</p>
<p>大概做一下.</p>
<h5><span id="example622zr提高组十连测day6百分号">Example6([22zr提高组十连测day6]百分号)</span></h5><p>首先看上去多组询问给定起点终点看上去就很像倍增.</p>
<p>一个很自然的设计是$L _{ x , i  } $表示从$x $这个点跳$2 ^i $所能到达的最左端的点,$R _{ x , i  } $同理.但是能跳到最远的点不一定能跳到一个较近的点,那咋办呢?</p>
<p>冷静一下,注意到我们好像还没有用到括号序列的性质:两个跳跃要么包含要么不交,不可能出现第三种情况.</p>
<p>所以,如果目前能跳到的最远的点为$l , r $,那么再跳一步能到达的最远的点一定是从$l $或$r $跳过去的.考虑反证这个结论,设能从$( l , r ) $中的一个点$k $跳到更远的点,那么由于之前没跳到过$k $就跳到$l $了,所以一定存在一个$i &gt; k $,$i \rightarrow l $,而如果存在$j &lt; l $,$k \rightarrow j $,显然不满足性质.</p>
<p>同理,我们最后处理询问答案的时候,考虑从$x $和$y $都跳.先从$x $跳到再跳一步就会跳过$y $的位置,然后把$y $跳到再跳一步就会跳过$x $的位置,那么现在的$x $和$y $一定相邻,不然分别跳一步就会出现包含的情况,于是一定是最优解.</p>
<h3><span id="对称建立双射">对称/建立双射</span></h3><h5><span id="example1cf1627f">Example1(CF1627F)</span></h5><p>冷静一下考虑,分界线一定是一个中心对称图形,分成的两部分一定中心对称.那这条分界线一定过中心点.</p>
<p>我们考虑这么一点:如果所有点对都在矩阵一边,我们就可以直接求中心点到矩阵一边的最短路然后对称一下就好了.</p>
<p>而矩阵上遍布点对怎么办呢?我们在和每个点对对称的位置把这个点对复制一遍,然后从中心点找到一条到边界的最短路,把它对称一下即可.</p>
<h5><span id="example2ah2017hnoi2017抛硬币">Example2([AH2017/HNOI2017]抛硬币)</span></h5><p>设$A $的正面朝上为$S _A $,$B $的为$S _B $.设$p _1 = \sum [ S _A &gt; S _B ] , p _2 = \sum [ S _A = S _B ] , p _3 = \sum [ S _A &lt; S _B ] $.</p>
<p>当$a = b $,翻转所有硬币,自然有$p _1 = p _3 $,又设$P = p _1 + p _2 + p _3 = 2 ^{ a + b  } $,于是求得$p _2 $即可得到答案.而$p _2 = \sum _{ i = 0  } ^a \binom { a  } { i  } \binom { b  } { i  } $,用范德蒙德卷积的变式,有$p _2 = \binom { a + b  } { a  } $.</p>
<p>同样,当$a &gt; b $时.我们设$p _4 = \sum [ a - S _A &gt; b - S _B ] , p _5 = \sum [ a - S _A = b - S _B ] , p _6 = \sum [ a - S _A &lt; b - S _B ] $.同样是翻转硬币的套路,自然有$p _4 = p _1 , p _5 = p _2 , p _6 = p _3 $.注意到:$S _A \leq S _B \Rightarrow a - S _A &gt; b - S _B $,但逆命题不成立.不妨设$p _7 = \sum [ S _A &gt; S _B \land a - S _A &gt; b - S _B ] $.自然有:</p>
<script type="math/tex; mode=display">
p _1 = p _4 = p _7 + p _2 + p _3 = p _7 + P - p _1</script><p>于是只要求出$p _7 $就可以求得$p _1 $.</p>
<p>考虑$p _7 $如何求,注意到$[ S _A &gt; S _B \land a - S _A &gt; b - S _B ] = [ 0 &lt; S _A - S _B &lt; a - b ] $,我们可以枚举$S _A - S _B $,然后继续用范德蒙德卷积的变式.</p>
<h5><span id="example32022qbxt国庆day4c">Example3([2022qbxt国庆Day4]C)</span></h5><p>直接考虑对于每一对位置$( i , j ) , i &lt; j $,计算它们可能产生的逆序对贡献.注意到每一对对答案的贡献会大概接近$0 . 5 $,我们考虑构造一个双射,判断双射左右是否都会贡献.</p>
<p>设$d _i $为$i $个数的错排数量,根据错排公式有$d _n = ( n - 1 ) ( d _{ n - 1  } + d _{ n - 2  } ) $.接下来讨论一下这两个位置的取值:</p>
<ol>
<li><p>如果$a _i = j , a _j = i $,那么一定贡献了逆序对,这里总共贡献为$d _{ n - 2  } \cfrac { n ( n - 1 )  } { 2  } $,一半的贡献也就是$\cfrac { d _{ n - 2  } n ( n - 1 )  } { 4  } $.</p>
</li>
<li><p>如果$a _i = j , a _j = k , k \ne i \lor a _i = k , a _j = i , k \ne j $,考虑前后两者形成双射.如果$k $在$i $和$j $之间,那么无论前者还是后者,都一定贡献逆序对;不然,则两种情况一定只有一种会贡献逆序对.前者多出的贡献应该是$\cfrac { n ( n - 1 ) ( n - 2 )  } { 6  } ( d _{ n - 2  } + d _{ n - 3  } ) $,也就是先选出$i &lt; k &lt; j $,如果$a _k = i $,那么剩余的可能性就是$d _{ n - 3  } $;不然,也就是说$a _k \ne i $,类似于错排公式,剩余的可能性为$d _{ n - 2  } $.另外,由于$d _{ n - 2  } + d _{ n - 3  } = \cfrac { d _{ n - 1  }  } { n - 2  } $,所以上面的贡献也就是$\cfrac { n ( n - 1 )  } { 6  } d _{ n - 1  } $.</p>
</li>
<li><p>如果$i , j , a _i , a _j $互不相同,那我们交换$a _i $和$a _j $一定可以构造出另一组答案,并且这两组答案中一定只有一组贡献了逆序对,于是二者形成双射.</p>
</li>
</ol>
<p>除去上面的部分的贡献是$\cfrac { d _n n ( n - 1 )  } { 4  } $.于是总贡献为:$n ( n - 1 ) ( \cfrac { d _{ n - 1  }  } { 6  } + \cfrac { d _n + d _{ n - 2  }  } { 4  } ) $.</p>
<h5><span id="example4arc115d">Example4(ARC115D)</span></h5><p>第一反应感觉完全不可做.</p>
<p>思考一下,如果我们随便选边肯定完蛋了:我们又不知道选出了几个奇度点,这不完蛋了?</p>
<p>先考虑要求全是偶度点怎么办?</p>
<p>由于点只有奇度点和偶度点两种,如果我能先随便选个边集,再把它删到全是偶度点好像就赢了.但是一方面我咋删啊,一方面这样删有可能删出重复的.又注意到删一条边就一定可以让两个点的奇偶性改变.</p>
<p>我们考虑求出原图的一棵生成树,然后剩下的边随便选.之后从生成树深度较大的点开始考虑:如果这个点是奇度点,我们就把它的父边删掉.容易发现这样是双射.而如果有奇度点的话可以先组合数选出来然后同样做上面的操作,容易发现是一样的.</p>
<p>不同的连通块可以分别做最后卷起来.</p>
<h5><span id="example5hihocoder1230">Example5(Hihocoder1230)</span></h5><p>这题最重要的一点在于观察到一组$a $如果有解,那么一定是唯一解.为啥呢?我们考虑如何构造一个解:从小位到高位枚举,如果当前位所有数异或起来是$1 $,那么$x $这一位也必然是$1 $,然后加上后进位.这是由于序列长度是奇数.然后就每次对于$a \in [ x , m + x ] $计数,做FWT就行.</p>
<h5><span id="example623省选10连测-day5b">Example6(23省选10连测 day5B)</span></h5><p>首先我们要知道,一轮冒泡排序的过程等价于:从前往后考虑每一个点,如果它前面存在一个比它大的点,就将它和前面的点交换.</p>
<p>于是我们考虑令$b _i = \sum _{ j = 1  } ^{ i - 1  } [ a _j &gt; a _i ] $.也就是每次冒泡排序,这个$b _i $都会变成$\max \{ b _i - 1 , 0 \} $.显然$b _i $需要满足的条件是$b _i \in [ 0 , n - i ] $,接下来我们证明:只要满足这个条件,$b $和$a $就是双射关系.根据$a $还原$b $是简单的,那么如何根据$b $还原$a $呢?我们只需要从大向小考虑元素,就可以判断元素插入哪里.</p>
<p>有了这个条件后,我们不妨设原序列是$a ‘ $,其对应$b ‘ $,那么显然$b _i = \max \{ 0 , b _i ‘ - m \} \leq \max \{ 0 , n - i - m \} $.也就是说,如果$b _i = 0 $,那么$b _i ‘ \in [ 0 , m ] $,反之$b _i ‘ = b _i + m $.但问题在于:我们如何保证$b _i ‘ \in [ 0 , n - i ] $呢?不难发现,冒泡排序每次会把前面最大的数扔到后面,也就是说整个序列最后的$m $个数一定有序,那我们分开考虑:对于最后的$m $个数,它一开始在序列中的相对顺序是无所谓的:无论如何都会扔到最后.而对于其它的数,如果$b _i = 0 $,$b _i ‘ \in [ 0 , m ] $,由于最后都已经凑出$m $个数了,从大向小将数字插入,一定可以使这一部分满足条件.而如果$b _i &gt; 0 $,由于有判定条件$b _i \leq \max \{ 0 , n - i - m \} $,显然满足.于是我们设一共有$k $个$b _i = 0 $的位置(也就是前缀最大值位置),于是自然有$f ( a , m ) = ( m + 1 ) ^k m ! $.注意这个式子的前提在于判定每个$b _i \leq \max \{ 0 , n - i - m \} $以及$a $的最后$m $个位置是$n - m + 1 , \cdots , n - 1 , n $.到这里不难发现只要满足后者前者必定满足.现在只需要统计前缀最大值的个数就可以解决这个问题了.这个设计个$dp _{ i , j  } $表示前$i $个数的最大值是$j $就行.</p>
<h3><span id="拆多项式">拆多项式</span></h3><p>通常适用于数据范围中有一项的范围不大的情况,然后拆成多项式后可以带入另一项较大的值.</p>
<h5><span id="example122zr提高组十连测day5可">Example1([22zr提高组十连测day5]可)</span></h5><p>首先考虑数位dp,每次枚举当前的$k $个数中还有$x $个数被limit,这次又有$y $个数不用被limit,再枚举一下当前各位之和,然后可以写一个转移,复杂度$O ( k ^4 \lg x ) $</p>
<p>然后想了好久发现这个东西好像优化不动了.</p>
<p>冷静一下,注意到问题在于枚举,我们不妨把枚举换成容斥试试.设$g ( x ) $为$\sum a $为$x $的方案数,那么可以通过容斥得知:</p>
<script type="math/tex; mode=display">
g ( n ) = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><p>我们最后要求的答案也就是$\sum f ( n ) g ( n ) $,继续推式子:</p>
<script type="math/tex; mode=display">
ans = \sum _{ n = 0  } ^{ kx  } f ( n ) g ( n ) = \sum _{ n = 0  } ^{ kx  } f ( n ) \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><script type="math/tex; mode=display">
= \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ n = 0  } ^{ kx  } f ( n ) \binom { n - i ( x + 1 ) + k - 1  } { k - 1  }</script><p>看上去好像推不动了.</p>
<p>冷静一下,会发现$n $的取值远远大于$i , k $的取值.于是我们选择把组合数拆成一个$k - 1 $次多项式,这样只需要处理出这个多项式的每一项的系数,然后就可以预处理后面的东西.</p>
<p>拆二项式系数的时候要注意特判上指标小于下指标的情况.</p>
<script type="math/tex; mode=display">
ans = \sum _{ i = 0  } ^k ( - 1 ) ^i \binom { k  } { i  } \sum _{ j = 0  } ^{ k - 1  } c _{ i , j  } \sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j</script><p>其中$c _{ i , j  } = [ n ^j ] \binom { n - i ( x + 1 ) + k - 1  } { k - 1  } $.</p>
<p>这样我们就成功地分离出了一项$\sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j $,接下来考虑怎么处理这一项.</p>
<p>考虑枚举$i $,然后设$dp _{ j , limit  } = \sum _{ n = 0  } ^{ limit  } f ( n ) n ^j $,考虑拿数位dp做这个东西,枚举当前位置$cnt $的取值$w $,根据二项式定理,$dp _{ a + b , limit  } \leftarrow \binom { a + b  } { b  } dp _{ b , limit  } f ( w ) ( w 10 ^{ cnt  } ) ^a $,那么$\sum _{ n = i ( x + 1 )  } ^{ kx  } f ( n ) n ^j = dp _{ j , kx  } - dp _{ j , i ( x + 1 ) - 1  } $.</p>
<p>这样我们需要枚举$i , a , b , cnt $得到一组答案,然后还需要把这些答案合并起来,复杂度$O ( k ^3 \lg x ) $.</p>
<h3><span id="抽屉原理">抽屉原理</span></h3><h5><span id="example1unr-6小火车">Example1([UNR #6]小火车)</span></h5><p>首先考虑证明一定有解:</p>
<p>注意到我们可以先选择出两个不完全相同的集合,如果这两个集合的和相等,那么我们把只在第一个集合的$b $设为$- 1 $,只在第二个集合的$b $设为$1 $,都在或都不在的设为$0 $,那么这显然就是一组解.</p>
<p>而由于$p &lt; 2 ^n $,根据抽屉原理,显然存在这么两个集合.</p>
<p>考虑对于一个权值区间$[ l , r ] $,如果有超过$r - l + 1 $个集合的和在这个区间内,那一定有两个集合可以组成一个解.</p>
<p>假设现在已知权值区间$[ l , r ] $一定有解,我们判断$[ l , mid ] $中是否有超过$mid - l + 1 $个集合,使用折半搜索再合并可以快速求出权值和为某个定值的集合有多少个.然后可以使用双指针判断,继续递归下去判断即可.复杂度$O ( 2 ^{ \frac { n  } { 2  }  } n ) $.</p>
<h5><span id="example2noi2021量子通信">Example2([NOI2021]量子通信)</span></h5><p>考虑$k \leq 15 $,所以如果我们把两个零一串每$16 $个分一块,那么两个零一串相差少于$k $处,则一定有一块完全相等.由于数据随机,这个概率为$\cfrac { 1  } { 2 ^{ 16  }  } $.</p>
<p>考虑把在一块中是某个数的零一串全都集合到一起,然后暴力判断,复杂度约为$O ( \cfrac { n ^2 q  } { 2 ^{ 16  } w  } ) $.</p>
<h3><span id="拆贡献">拆贡献</span></h3><h5><span id="example12022qbxt国庆day7fenwick">Example1([2022qbxt国庆Day7]fenwick)</span></h5><p>注意到要变换多次,考虑每个值的贡献.</p>
<p>一个点要往后更新,不难通过平行求和法则一个值$v $对它向后跳$w $步的贡献为$\binom { w + k  } { w  } $.但是有修改很难办,怎么办?注意到如果我们暴力跳,查询的时候复杂度是$O ( 1 ) $的,我们没必要让它这么低.我们把所有值对$p $这个点的更新存到一个数组里,显然只有$\log n $种步数.最后每次查询的时候用组合数一起更新即可.</p>
<h5><span id="example2qoj5097-小-p-爱学习">Example2([QOJ5097] 小 P 爱学习)</span></h5><p>这个题的厉害之处在于完全将贡献拆开.</p>
<p>我们不妨设最后将所有的数分成了$k $组,那么显然我们只要算出两个东西就可以得到此时的答案的和:</p>
<ol>
<li><p>$\sum _{ x _{ 1 , . . . , k  }  } \prod _{ i = 1  } ^k a _{ x _i  } \ $.</p>
</li>
<li><p>$\sum _{ 1 \leq x _1 , . . . , x _k \leq n , \sum x = n  } \frac { ( nm - k ) !  } { \prod _{ i = 1  } ^k ( x _i m - 1 ) !  } \ $.</p>
</li>
</ol>
<p>第一个显然就是个背包,问题在于第二个的分子部分,我们用生成函数,设$F = \sum _{ i = 1  } ^{ n  } \frac { 1  } { ( im - 1 ) !  } x ^i $,我们要求的就是$[ x ^n ] F ^k , \forall 1 \leq k \leq n $.</p>
<p>这个东西可以做BSGS,也就是光速幂.这样就可以用$O ( n ^2 \sqrt { n  } ) $预处理,用$O ( n ) $查询单个$k $.</p>
<h5><span id="example3luogu4211-lnoi2014lca">Example3(Luogu4211 [LNOI2014]LCA)</span></h5><p>将$dep $拆成到根节点的路径上的点的数量,差分一下$[ l , r ] $,这样就只需要求$z $和一个前缀点的LCA的$dep $.将这个操作离线下来,我们对于每一个点把它到根节点的路径上的点全部$+ 1 $,查询每个点到根节点上的权值和就行.</p>
<p>CF757G是一样的,只不过好像需要卡卡空间?</p>
<h3><span id="二进制拆位">二进制拆位</span></h3><h5><span id="example1luogu5354-ynoi2017由乃的oj">Example1(Luogu5354 [Ynoi2017]由乃的OJ)</span></h5><p>对每一位分开处理,对于线段树上每个区间,设$f _{ 0  } $表示一开始$v $的这一位是$0 $,最后的答案是$1 $还是$0 $,显然可以合并,拿bitset优化一下.</p>
<h3><span id="bitset优化暴力">bitset优化暴力</span></h3><h5><span id="example12022qbxt国庆day4d">Example1([2022qbxt国庆Day4]D)</span></h5><p>先想一个很明显的优化:我们记录一下每个字符出现的位置,当我们判断当前字符串是否出现过的时候,我们直接从这个字符串开头的字符存在的位置进行判断.</p>
<p>如果我们记录下每个字符在母串中的某个位置是否存在,我们就可以基本脱离母串进行判断.注意到只需要用bitset优化这个过程就可以做到$O ( \sum tlen + \cfrac { nq  } { w  } ) $.</p>
<h5><span id="example2noi2020-制作菜品">Example2([NOI2020] 制作菜品)</span></h5><p>这题首先要根据数据范围,注意到$m \geq n - 1 $的时候存在贪心解法.</p>
<p>具体怎么做呢?我们将原料按照质量排序,每次选最小的那个,不够的话就选最大的那个的一部分,重新排序后递归处理.</p>
<p>为啥这个是对的呢?根据鸽笼原理,最大的那个的质量一定大于等于$\frac { mk  } { n  } $,而最小的那个数和最大的那个数之和一定大于等于$0 + \frac { mk  } { n - 1  } \geq k $,因此一定有解.</p>
<p>接下来我们就只需要做$m = n - 2 $的情况.</p>
<p>那么这个怎么做呢?我们发现每道菜和两个原材料有关,于是不妨抽象成图论模型:将这两个原材料所代表的点用一条边连起来:我们发现有$n - 2 $条边和$n $个点,这个图必不联通.也就是说如果有解,必然可以分成两个集合,这两个集合互不相关.如果我们分成了两个集合,一个集合有$a $个原材料,另一个集合有$n - a $个原材料,我们就可以第一个集合做$a - 1 $道菜,第二个集合做$n - a - 1 $道菜,自然解决了问题.</p>
<p>接下来的问题在于01背包,用bitset优化一下.</p>
<h3><span id="简化能更新答案的集合">简化能更新答案的集合</span></h3><p>简单来说就是当你注意到一个答案只有可能由某些地方贡献,我们就只判断这些地方的贡献.有的时候不仅需要减小集合,还需要使这个集合尽可能好维护,这个时候可能会向集合里放一些不合法但不可能更新答案的选项.</p>
<h5><span id="example1cf1149d-abandoning-roads">Example1(CF1149D Abandoning Roads)</span></h5><p>首先一个把只有$a $边的连通块缩起来,那$1 $到$i $的最短路显然是通过几个$b $连接若干个连通块来到$i $.</p>
<p>由于防止用$b $边链接连通块的时候连出环,我们需要用一个$dp _{ S , x  } $表示从$1 $经过$S $集合的连通块到$x $的最短路.</p>
<p>但是集合数量可能很多,怎么办?</p>
<p>注意到,如果这个集合只有一个点,那显然不可能重复经过;如果这个集合只有两个点,那重复经过意味着想用一条长度为$2 b $的边代替一条长度为$a $的边,显然也不优秀;同理集合只有三个点也不优秀.</p>
<p>于是只有点数$\geq 4 $的集合是有用的,复杂度$O ( 2 ^{ \frac { n  } { 4  }  } m \log n ) $.</p>
<h5><span id="example2">Example2</span></h5><p>给定$n $个正整数,要求将$n $个正整数分到$k $个集合中,每个集合恰好$\cfrac { n  } { k  } $个数(保证$k | n $)且每个集合中不能有相同的数.设一个方案的代价是每个集合的极差之和,求最小代价,$n \leq 70 $.</p>
<p>首先$O ( 3 ^n ) $很好设计不说了.</p>
<p>注意到这题看上去就不太能多项式复杂度,我们考虑简化一下状态数.考虑做$O ( 3 ^n ) $的时候,我们是将$\cfrac { n  } { k  } $个数打包成一个集合再塞进去,这样看上去就不太优秀,我们考虑能不能一个数一个数塞进去.</p>
<p>我们现在有$k $个集合,要塞进去一个数到一个集合中.注意到最后的代价实际上和很多数是没啥关系的.考虑先把数字从小到大排序,然后挨个插入集合.如果插入一个数之前,这个集合是空的,那这个数对答案有负的贡献;如果插入一个数之后,这个集合是满的,那这个数对答案有正的贡献;反之无贡献.</p>
<p>于是我们可以枚举目前集合填成啥样了,这样状态数变成了$( \cfrac { n  } { k  } + 1 ) ^k $.</p>
<p>这样还是过不去,我们再冷静一下,显然我们只关心每个集合填了多少个数而不关心具体是哪个集合,于是我们把每个集合的大小排序后再压成状态,这样状态数就是$\sum _{ i = 0  } ^{ k  } { \binom { i + \frac { n  } { k  }  } { \frac { n  } { k  }  }  } \ $,根据目前填到第几个数分一分类就会发现这部分上限是$O ( n \binom { 2 \sqrt { n  }  } { \sqrt { n  }  } ) $.</p>
<p>不过我们还需要保证一个集合里不能有相同的元素.这里我们考虑将相同的元素一起放并规定放的顺序.因为放进去的集合在放这种元素前是有大小顺序的,我们每次放进最大的集合中.换句话说,我们设$f _{ i , j , S  } $表示目前放到$i $,状态是$S $,并且$a _i $放进去的那个集合目前大小是$j + 1 $(放前是$j $).</p>
<p>算一下复杂度是$O ( n ^2 \binom { 2 \sqrt { n  }  } { \sqrt { n  }  } ) $的,实际上远远跑不满,甚至写了个map来做双射也跑过去了.</p>
<h5><span id="example3">Example3</span></h5><p>给定一张有向图,多组询问,每次询问三个数$p , x , y $,求是否能从$p $出发只经过$[ x , y ] $中的边且经过的边的编号单调递减到达$1 $号节点.</p>
<p>冷静一下,先加边,注意到如果加$u \rightarrow v $这条边的时候,不存在一条从$v $到$1 $的路径,那这条边显然没有用.</p>
<p>做完这一步后,我们注意到可以在加边的过程中对于每个$u $维护从$u $到$1 $的所有合法路径经过的最小编号的边的最大值$maxn _u $,这样就可以对于每个点维护若干个二元组$( l , r ) $,只要对于$p $,存在一个二元组$[ l , r ] \in [ x , y ] $就合法.</p>
<h5><span id="example4petrozavodsk-winter-2014-moscow-su-tapir-contestopenstrain-contest-1435-ccombinations-strike-back">Example4([Petrozavodsk Winter-2014. Moscow SU Tapir Contest(openstrain contest 1435) C]Combinations Strike Back)</span></h5><p>给定一个大小为$n $的可重集,多次询问,每次询问查询插入一个数$x $后,这个集合大小为$k $的可重子集共有多少个,每次询问互相独立.$n , q \leq 1 . 2 \times 10 ^5 $,答案对$1051721729 = 1003 \times 2 ^{ 20  } + 1 $取膜.</p>
<p>自然的想法是上生成函数.</p>
<p>假设数字$i $在原集合中共有$b _i $个,那么原集合大小为$k $的可重子集数量显然为$[ z ^k ] \prod _{ i = 1  } ^n \frac { z ^{ b _i + 1  } - 1  } { z - 1  } $.</p>
<p>插入一个数字$x $,自然就是乘上一个$\frac { z ^{ b _x + 2  } - 1  } { z ^{ b _x + 1  } - 1  } $.但如果每次都乘的话复杂度显然不行.怎么办?</p>
<p>注意到答案与插入的数字本身无关,只和这个数字在原集合中出现了多少次有关.而原集合最多有$\sqrt { n  } $(自然根号)个出现次数不同的数字,预处理一下就行.</p>
<h5><span id="example5cf1621gweighted-increasing-subsequences">Example5([CF1621G]Weighted Increasing Subsequences)</span></h5><p>一个自然的想法是拆出每个点$x $的贡献,再枚举终点$y $,这样问题就转化为了以$y $结尾并且包含$x $的LIS计数,这样做到$O ( n ^2 ) $的复杂度.</p>
<p>那么怎么继续优化呢?我们还是想拆出每个点的贡献,但是如何不枚举终点$y $呢?我们考虑枚举一下和它做贡献的点$z $满足$a _z &gt; a _x $并且终点$y $满足$y &lt; z $,但是这样的$z $有很多个,不难发现取最后一个就行.如果我们对整个序列取后缀$\max $,就可以得到所有可能被当作$z $的点,而且更强的性质是,只要这些点不在LIS中,LIS的终点$y $必然有$y &lt; z $,这是显然的.做一下补集转化,就变成了计数包含$x $和$z $的LIS数量.</p>
<p>注意到$z $的数量不多,且所有数字按照权值排序后被这些$z $分成了若干个区间.所以颠倒值域和下标重新做LIS就行.</p>
<h5><span id="example6cf919f-a-game-with-numbers">Example6(CF919F A Game With Numbers)</span></h5><p>最小表示法表示每个人的手牌.</p>
<p>不过要注意有可能成环.我们考虑用刷表法更新,最后刷不出来的点就是和.</p>
<h5><span id="example7ioi2014holiday">Example7([IOI2014]holiday)</span></h5><p>首先发现走的一定是一个区间,然后发现这个区间$[ l , r ] $的$l $随$r $的增大具有决策单调性,然后做完了,上主席树就行.</p>
<h5><span id="example8cf1446d2">Example8(CF1446D2)</span></h5><p>我们假设目前得到的答案区间是$[ l , r ] $,也就是说$[ l , r ] $无论如何不可能扩展成更大的区间了.那这需要满足什么条件呢?注意到全局众数一定是答案,如果它不是答案,我们就可以往两边拓展,直到满足区间众数是答案且区间合法.显然可以实现.然后做根号分治.</p>
<p>这个是怎么想到的呢?我们考虑一个区间如何拓展成更大的区间:如果每个数出现次数不降,显然是一个更大的区间.这同样是在说:如果我们能找到一段区间,使得加上这段区间后,原本不是区间众数的数成为了区间众数,并且区间仍然合法,那就一定更为优秀.再注意到如果一个数在全局出现次数多于区间众数,这一定可以实现,进而推出全局众数的结论.</p>
<p>你以为结束了?没有,我们下面给出一个$O ( n \log n ) $的做法:</p>
<p>首先,我们假设全局众数是$x $,枚举和它一起成为区间众数的数字$y $,剩下的数先不管,那么区间大概长这个样:xyxyyxyxxxxxx.</p>
<p>我们发现这一段x一定是没有意义的:xyxyyxyxx[xxxx].</p>
<p>我们对于每一个$y $出现的位置,找到其左右两边离他最近的没有被标记的$x $标记一下,没有被标记的$x $一定没有意义.这样对于一组解$( x , y ) $,合法的端点数量只有$O ( y 出 现 的 次 数 ) $次.每次判断每个端点是否可以做右端点,拿$set $维护一下后缀和就可以实现$O ( n \log n ) $.</p>
<p>当然,这里得到的区间不一定是合法的(有可能$x , y $出现的次数都不是最多的,但没关系,这种一定不优秀).</p>
<p>【luoguP4062 [Code+#1]Yazid 的新生舞会】也是这个标记的思路,标记的话用一下链表之类的大概能做.</p>
<h4><span id="支配对问题">支配对问题</span></h4><p>lxl起的名字.</p>
<p>这里的思路其实大概就是:我们将一些很废物的二元组杀了,然后将剩下的二元组进行贡献答案.我们称这种一个二元组严格强于另一个二元组的限制称作支配关系.</p>
<h5><span id="第一类支配对">第一类支配对</span></h5><p>虽然总数很多,但是本质不同的很少.</p>
<h6><span id="example1luogup7880-ynoi2006-rldcot">Example1(luoguP7880 [Ynoi2006] rldcot)</span></h6><p>我们这么考虑:如果现在有三个点$a , b , c , a &lt; b &lt; c $,它们两两LCA都是$d $,那么显然$( a , c ) $这一对是没有用的,有用的是$( a , b ) $和$( b , c ) $.进一步你发现这等价于什么呢:我们从下往上合并子树,每次做启发式合并,假设当前要把子树$A $合并到子树$B $上,考虑所有的点对$( a , b ) , a \in A , b \in B $的贡献,显然,能贡献到$a $的$b $只有$a $的前驱和后继,这样我们就只找到了$O ( n \log n ) $个点对,它们等价于$O ( n \log n ) $个矩形,最后把$dep $相等的合并一下,随便做做.</p>
<h6><span id="example2luogup8528-ynoi2003-铃原露露">Example2(luoguP8528 [Ynoi2003] 铃原露露)</span></h6><p>和Example1基本差不多.</p>
<h5><span id="第二类支配对">第二类支配对</span></h5><p>虽然总数很多,但是有用的很少.</p>
<h6><span id="example1cf765f">Example1(CF765F)</span></h6><p>典.</p>
<h6><span id="example2codechef-minxorseg">Example2(CodeChef MINXORSEG)</span></h6><p>这个题比较厉害,仍然考虑$a &lt; b &lt; c $,我们看如果$a \oplus c &gt; \max \{ a \oplus b , b \oplus c \} $的充要条件是什么.</p>
<p>简单分类讨论一下,不难发现这意味着$LCP ( a , c ) &gt; LCP ( a , b ) $.于是有用的贡献对只有$O ( n \log v ) $个.</p>
<h6><span id="example3luogu9058-ynoi2004-rpmtdq">Example3(Luogu9058 [Ynoi2004] rpmtdq)</span></h6><p>这题更为逆天.</p>
<p>首先,这题有两个维度:树和序列,我们要先处理掉其中一维.lxl:树这一维度更加困难,因此我们应该是选择困难的那一维分治掉.</p>
<p>考虑边分治,然后就只需要处理两棵子树间的贡献.但是对于一棵子树内的点,我们要找到在另一棵子树中有可能和它产生贡献的点对,这个咋做呢?</p>
<p>牛逼的一步来了,我们考虑对于每个点,算出它到分治中心的距离$r $,然后找另一棵子树中到分治中心距离$\leq r $的点$x $与它贡献,但是这还是有很多点,其实只需要找这些点中的$x $的前驱后继就可以了.因为如果$x &lt; b &lt; c $,$b $和$c $在同一边,那么$( b , c ) $一定比$( a , c ) $更加优秀.</p>
<h6><span id="example4cf1635f-closest-pair">Example4(CF1635F Closest Pair)</span></h6><p>首先,由于匹配无序,我们考虑对于一对数$( i , j ) $,只在$w $较大的那个位置来更新答案.</p>
<p>不妨假设较大的为$i $,我们考虑$i $有可能和谁来更新答案.</p>
<p>如果现在有两个数$k &lt; j , w _k \leq w _i \land w _j \leq w _i $,如果$w _k \geq w _j $,那肯定选$( j , i ) $更优秀;不然,如果选$( k , i ) $比选$( j , i ) $更优秀,那么我们会发现$( k , j ) $比$( k , i ) $更要优秀,因此答案一定会由$( k , j ) $更新而不是由$( k , i ) $更新.通过这里的分析我们发现,每个数只有可能和它左右两边的第一个$w $小于等于它的数更新.</p>
<p>于是我们可以找到$O ( n ) $个可能更新答案的点对,设点对为$( x , y ) $,我们每次查找一个区间$[ l , r ] $,即要找到所有在$[ l , r ] $内的点对并将它们的答案取min.</p>
<p>这一步可以将$( x , y ) $当作二维平面的点,查询当作一个左下角为$( l , l ) $,右上角为$( r , r ) $的矩阵,就是一个经典的矩阵取min的操作.</p>
<h6><span id="example5icpc2017-wfmoney-for-nothing">Example5([ICPC2017 WF]Money for nothing)</span></h6><p>注意到抽象问题后等价于有若干个A点$( x _1 , y _1 ) $和若干个B点$( x _2 , y _2 ) $,我们想要找到一个A点和一个B点使得$( x _1 - x _2 ) ( y _1 - y _2 ) $最大.也就是它们作为右上和左下顶点的矩形面积最大.</p>
<p>怎么做这个问题呢?首先我们必须要发现的一点是:对于A点来说,如果有两个点$( a _1 , b _1 ) $和$( a _2 , b _2 ) $满足$a _1 \leq a _2 $,$b _1 \leq b _2 $,那么前者一定更优秀.把那些废点删掉后,就会得到一个横坐标递增,纵坐标递减的点的序列.对于B点是同理的.</p>
<p>这个序列看上去就很亲切了,接下来简单证明一下是满足决策单调性的就可以判断答案了.</p>
<h3><span id="奇偶染色">奇偶染色</span></h3><h5><span id="example1">Example1</span></h5><p>一个$9 \times 9 $的网格,一开始上面有$65 $个蚂蚁,每个蚂蚁每分钟会四联通移动一格,每个蚂蚁每三分钟所在的格子不能在一条直线上,求证:一定会有一个时间,两只蚂蚁在同一个格子里.</p>
<p>sol1:</p>
<p>注意到如果条件不成立,则一定存在若干条路径,蚂蚁在路径上转圈,也就是找到长度和尽可能大的路径不交地覆盖矩阵,注意到一定是使用$2 \times 2 $的矩阵路径,于是最多有$64 $只蚂蚁.(感性理解)</p>
<p>sol2:</p>
<p>考虑对奇偶染色,设$( i , j ) = \begin{cases}white &amp; 2 \nmid ( i + j ) \ blue &amp; 2 \mid i \land 2 \mid j \ yellow &amp; \text { otherwise  } \end{cases} $.</p>
<p>我们把黄格子和蓝格子称为彩格子,注意到如果一开始一只蚂蚁在白格子,一分钟后必定在彩格子.一开始一只蚂蚁在蓝格子,两分钟后必定在黄格子.</p>
<p>因为最多有$16 $个蓝格子,所以一开始黄格子和蓝格子上分别最多有$16 $只蚂蚁,从而白格子上最多有$32 $只蚂蚁,总共最多$64 $只,得证.</p>
<h5><span id="example2cf1521e">Example2(CF1521E)</span></h5><p>首先考虑我们显然可以一行空一行放,也就是说如果最大的$a _i &gt; n \times \lceil \frac { n  } { 2  } \rceil $的话显然不可以,如果能放的位置少于$\sum a $显然也不可以.</p>
<p>类似lyz那个题,我们考虑删去行列编号均为偶数的点,这样就满足了一个子矩阵不能全放的限制.</p>
<p>然后呢?我们考虑将所有能放的位置排序.先把所有的位置分成三类:$( \mathrm { even  } , \mathrm { odd  } ) , ( \mathrm { odd  } , \mathrm { odd  } ) , ( \mathrm { odd  } , \mathrm { even  } ) $,不同类位置按照这个顺序排,不然按照相对位置排.然后直接从头开始放.如果不合法,一定是同种颜色放到了$( \mathrm { even  } , \mathrm { odd  } ) $和$( \mathrm { odd  } , \mathrm { even  } ) $,并且相同类别是按照相对位置排序的,于是一定不满足最大的$a _i \leq n \times \lceil \frac { n  } { 2  } \rceil $的限制条件.所以这么做一定是对的.</p>
<p>好!冷静一下,咋想到的啊.</p>
<p>首先这种题肯定要找到一些看上去就很显然的边界,当你发现找不到的时候,大概率就一定有解了(大概率).</p>
<p>然后呢?注意到不合法一定是同种颜色放到了$( \mathrm { even  } , \mathrm { odd  } ) $和$( \mathrm { odd  } , \mathrm { even  } ) $,又观察到每种位置的数量和一个边界限制条件很像,于是就可以构造出来了.</p>
<p>所以大概是说,这种构造题要先想判断边界的条件,然后对着做.</p>
<h5><span id="example3cf1615f">Example3(CF1615F)</span></h5><p>太牛逼了这个题.</p>
<p>首先,找边界条件:啥时候$s $不能变成$t $呢?一个自然的想法是数$1 $的个数的奇偶性,但这样显然不对($01 $和$10 $不能互相转移),我们需要一个更强的条件.</p>
<p>然后:注意到每次操作是相邻的两个数,于是我们有:奇数位置的和-偶数位置的和是定值.但是:注意到这个操作是有限制的!它只能对相邻相同的位置做.</p>
<p>然后我也不知道咋想到的,可能是因为找到限制条件后只要不改变限制条件就可以随便转化?反正我们先把偶数位置全部取反,这样操作就变成了交换相邻数字(如果相邻数字不相同,取反后相同,交换无用).</p>
<p>就可以dp了.</p>
<h5><span id="example4cf1517g">Example4(CF1517G)</span></h5><p>按照横纵坐标的奇偶性,分四种情况染色.注意到四边形接下来的路径一定会形如$1 \rightarrow 2 \rightarrow 3 \rightarrow 4 $,建立分层图跑最小割.</p>
<h3><span id="捆绑更新答案">捆绑更新答案</span></h3><h5><span id="example12022qbxt国庆day6binary">Example1([2022qbxt国庆Day6]binary)</span></h5><p>首先因为有$- 1 $,我们先考虑一个朴素的暴力,从$L $到$R $枚举现在被匹配的数$i $,我们假设之前匹配到$p - 1 $,那我们接下来一定是要找到一个最小的$x \geq p $能把$i $给匹配掉,仔细思考这个过程,由于是二进制考虑最高位,不难发现我们只需要找到$( p \land i ) \oplus i $的最高位$1 $,然后把$p $的这一位改成$1 $,然后后面的位置全部设成$0 $,如果$i \subseteq p $那么就不用改.</p>
<p>冷静一下,二进制大概率是没啥通项公式的,还是要一点一点做.但是我们枚举每一个数实在是太慢了,我们考虑一个地方:$i \subseteq p $就不用改,下一步$i + = 1 , p + = 1 $,如果没有发生进位还是不用改,这个过程看上去就很可以优化.</p>
<p>所以我们考虑:当遇到$i \subseteq p $的时候,我们就捆绑更新.如果不满足就暴力更新.重复这个过程,每次不断暴力更新$\rightarrow $捆绑更新$\rightarrow $暴力更新$\rightarrow . . . $.每次捆绑更新至少会更新一个$lowbit $,而暴力更新的情况下,每次$p $至少会多包含一位$i $.就算后面进位把这一位消掉了,由于这里进位了,那下一步一定可以直接包含掉,于是复杂度也是$\log n $的,反复做一下就做完了,这里能分析复杂度$O ( T \log ^2 R ) $.我们冷静一下,发现二者复杂度算重了,捆绑更新会帮助暴力更新多匹配$1 $,于是复杂度$O ( T \log R ) $.但是肯定跑不满,考场甚至写了个上界$O ( T \log ^2 R ) $的仍然跑的飞快.</p>
<h5><span id="example2">Example2</span></h5><p>给定一棵树和一个值域为$n $序列$a $,每次询问给出$l , r , x $.</p>
<p>设$f ( x , y ) $为点$x $朝着$y $的方向走一步后得到的点,求$x $在经过$a [ l \cdots r ] $操作后得到的答案.</p>
<p>这么考虑:这题看上去就需要把任何一个数字$x $,通过若干个点变成了一个$f ( x ) $,我们要做的就是把$f ( x ) $求出来,这玩意很难求,考虑分块,单点用长剖做$O ( 1 ) $求$k $级祖先,然后对于每个整块预处理出它的$f $就可以了.</p>
<p>接下来的问题在于如何快速处理一个块的答案,考虑把所有的$x $扔到树上,然后一起维护它们的$f ( x ) $.这玩意看上去好像有点不太能做.</p>
<p>牛逼的一步来了:考虑对于每个块内的$\sqrt { n  } $个点,建立这些点的虚树,对于不在虚树上的点,它们一定会往虚树的方向跑(其实也就是向上跑),然后处理出时间扫描线转化成在虚树上的点的问题.对于在虚树上的点,考虑虚树一共有$O ( \sqrt { n  } ) $条边(也就是原树上的路径),我们用一个双端队列维护每条边上的点,显然每次每条边只会有$O ( 1 ) $的入队和出队,这样就实现了$O ( n ) $的预处理单个块.</p>
<h3><span id="单独更新答案">单独更新答案</span></h3><h5><span id="example1">Example1</span></h5><p>一个数轴上有$n $个小球,第$i $个小球在$x _i $坐标处.数轴上还有$m $个洞.第$i $个洞在$y _i $坐标处.你每秒可以以相同矢量速度移动所有小球.当一个小球和一个洞重合时,小球就会进洞.求一共可能出现多少种最终情况.(我们认为,两种”最终情况”不同,当且仅当存在一个球在两种情况中进入了不同的魔法洞中)</p>
<p>考场的想法:按照洞分类,把被同样两个洞夹起来的球一起处理,显然会有一段区间往左走一段区间往右走,按照这种区间的长度排序,然后硬dp,复杂度$O ( n ^3 ) $.</p>
<p>实际的做法:我们抛弃区间,单独考虑每个球.对于每个球而言,有用的信息只有它到左端点的距离和它到右端点的距离.我们把这两个距离缩为$( x _i , y _i ) $.接下来我们要给每个点$0 / 1 $染色,如果是$0 $代表它要到左边的洞里,如果是$1 $代表要到右边的洞里.那什么染色条件是无解的呢?</p>
<p>如果存在两个点$a $和$b $,$col _a = 0 $,$col _b = 1 $,那显然当$x _a \geq x _b \land y _a \leq y _b $时无解.换句话说,如果$col _b = 1 \land x _a \geq x _b \land y _a \leq y _b $,那么$col _a = 1 $.我们不妨按照$x $降序排序,$x $相同的按照$y $升序排列.那就会先决定$b $再决定$a $.注意到:如果$a $能确定$c $的状态,那$b $一定也能确定$c $的状态.因此我们采取这个策略:如果$x _a \geq x _b \land y _a \leq y _b \land col _b = 1 $,那我们直接不管$a $;反之,则考虑一下$a $的两种取值即可.具体一点,我们设$f _{ i , 0 / 1  } $表示以$i $结尾,$col _i = 0 / 1 $的方案数,然后顺着做就好.注意到:我们其实不关心$col _x $具体是啥,我们只关心最后的方案数.所以其实可以直接删去第二维.</p>
<p>zhq对这题的理解:</p>
<p>这可以等价成求一个上升子序列.上升子序列说的是如果$x _i &lt; x _j , y _i &gt; y _j $,$i $”选了”,$j $就必须”不选”.但是钦定必须选和必须不选,这两个限制是一样的.就是说,$j $没有选择的权力了.</p>
<p>这个说法很有意思,但是要注意:类似说法成立当且仅当我们认为$j $选了和认为$j $没选对后面不会产生影响.</p>
<h5><span id="example2petrozavodsk-summer-2015-moscow-ipt-contestopenstrain-contest-1464-jtwo-airlines">Example2([Petrozavodsk Summer-2015. Moscow IPT Contest(openstrain contest 1464) J]Two Airlines)</span></h5><p>这是一道交互题.给定一张$n $个点的完全图,每两个点之间是红色的边或是蓝色的边.可以询问$2 n $次某两个点之间的边的颜色,求一条哈密顿回路使得这条路上的颜色段最多有两个.</p>
<p>考虑将点逐个加入.假设现在的哈密顿回路的两种颜色分别是$r _s \rightarrow r _t $和$b _s \rightarrow b _t $,当前要加入$x $,我们每次询问$x $和$r _t $和$b _t $之间的颜色,如果可以加入链就加入.如果不能加入,必然意味着$x $和$r _t $之间是蓝边,和$b _t $之间是红边,我们查一下$r _t $和$b _t $之间是什么边,然后将其中一个点与$x $一起扔到对面就行.</p>
<p>不过这样用了$3 n $次询问,考虑先询问$r _t $和$b _t $之间的颜色,这样就能省掉一种.</p>
<h3><span id="寻找不变量">寻找不变量</span></h3><h5><span id="example1noip2021-方差">Example1([NOIP2021] 方差)</span></h5><p>首先我们注意到:设$b _i = a _i - a _{ i - 1  } $这个操作相当于交换$b _{ i - 1  } $和$b _i $.</p>
<p>接下来推一下式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
n ^2 S ^2 & = n \sum _{ i = 1  } ^n a _i ^2 - ( \sum _{ i = 1  } ^n a _i ) ^2 \\
& = n \sum _{ i = 1  } ^n ( \sum _{ j = 1  } ^i b _j ) ^2 - ( \sum _{ i = 1  } ^n ( n - i + 1 ) b _i ) ^2 \\
& = n \sum _{ i = 1  } ^n \sum _{ j = 1  } ^i b _j \sum _{ k = 1  } ^i b _k - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{ k = 1  } ^n ( n - k + 1 ) b _k \\
& = n \sum _{ j = 1  } ^n b _j \sum _{ k = 1  } ^n b _k \times ( n - \max \{ j , k \} + 1 ) - \sum _{ j = 1  } ^n ( n - j + 1 ) b _j \sum _{ k = 1  } ^n ( n - k + 1 ) b _k \\
& = n \sum _{ j = 1  } ^n b _{ n - j + 1  } \sum _{ k = 1  } ^n b _{ n - k + 1  } \times \min \{ j , k \} - \sum _{ j = 1  } ^n jb _{ n - j + 1  } \sum _{ k = 1  } ^n kb _{ n - k + 1  } 
\end{aligned}</script><p>令$c $为$b $的倒置数组,则原式</p>
<script type="math/tex; mode=display">
\begin{aligned}
& = n \sum _{ j = 1  } ^n c _{ j  } \sum _{ k = 1  } ^n c _{ k  } \times \min \{ j , k \} - \sum _{ j = 1  } ^n jc _{ j  } \sum _{ k = 1  } ^n kc _{ k  } \\
& = 2 \sum _{ j = 1  } ^n nc _j \sum _{ k = 1  } ^j c _k k - 2 \sum _{ j = 1  } ^n jc _{ j  } \sum _{ k = 1  } ^j kc _{ k  } + \sum _{ i = 1  } ^n c _i ^2 i ( i - 1 ) \\
& = 2 \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^j c _k k + \sum _{ i = 1  } ^n c _i ^2 i ( i - 1 ) \\
& = \sum _{ j = 1  } ^n ( n - j ) c _j \sum _{ k = 1  } ^n c _k k + \sum _{ i = 1  } ^n ( n - 1 ) ic _i ^2 
\end{aligned}</script><p><del>推到这一步发现好像没啥用但是推了好久懒得删了</del></p>
<p>冷静一下,由于一开始的数列是单调递增的,所以改变后的数列一定也是单调递增的(差分数组均$\geq 0 $).感性上理解,我们肯定是想让尽可能多的数接近绝对值,于是让重新排列后的差分数组呈现单最小值的峰看上去就很优秀.</p>
<p>这样我们设计$dp _{ i , S  } $表示现在填到第$i $小的$b $,$\sum a = S $的情况下最小的$\sum a ^2 $,复杂度$O ( n ^2 a ) $.</p>
<p>注意到$a $很小的时候大部分$b $都是$0 $,于是可以优化为$O ( na ^2 ) $.</p>
<h5><span id="example2agc030e-less-than-3">Example2([AGC030E] Less than 3)</span></h5><p>注意到:当我们把一个位置取反的时候,这个位置相邻的左右两个位置一定有一个$0 $和一个$1 $,所以我们的操作等价于移动$0 $和$1 $的分界线.</p>
<p>然后枚举一下从边界多产生了多少个分界线就行.</p>
<h3><span id="组合意义">组合意义</span></h3><h5><span id="example1arc110d">Example1(ARC110D)</span></h5><p>注意到这相当于先把一个长度等于$m $的序列划分成$n + 1 $段,再从第$i $段选出$a _i $,其中$a _{ n + 1  } = 0 $.</p>
<p>于是自然是$\binom { n + m  } { \sum a + n  } $.</p>
<h5><span id="example2abc231g">Example2(ABC231G)</span></h5><p>乍一看,感觉完全不可做.因为一开始给定$a $了,感觉上好像也不太能组合意义.</p>
<p>如果没有$a _i $怎么做?我们设$f _n $表示将$k $个小球分到$n $个盒子后的答案.那乘法相当于:分完后,在每个盒子中取出一个小球的方案数.于是$f _n = \binom { k  } { n  } n ! n ^{ k - n  } $.</p>
<p>那给定$a $咋做呢?我们注意到上面的式子好像可以对于任意$n $快速求.于是将原式子拆为:$\prod ( a _i + b _i ) $,那答案就是选出$n - x $个$a $和选出$x $个$b $的答案.前者可以背包,后者也就是$f _x = \binom { k  } { x  } x ! n ^{ k - x  } $.</p>
<h5><span id="example3agc060d">Example3(AGC060D)</span></h5><p>不妨设$C _p = \{ i | p _i &gt; p _{ i + 1  } , 1 \leq i &lt; n \} $.</p>
<p>用一下组合意义,注意到答案等于:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2</script><p>中间那个地方看上去是经典的计数容斥,我们对着它做容斥:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ p  } [ S = C _p ] ) ^2 = \sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C _p ] ) ^2</script><p>这个咋做呢?我们考虑用组合意义展开:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } ( \sum _{ S \subseteq T  } \sum _{ p  } ( - 1 ) ^{ | T | - | S |  } [ T \subseteq C _p ] ) ^2 \\
& = \sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) 
\end{aligned}</script><p>注意到$S $屁用没有,直接交换枚举顺序.</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ S  } \sum _{ S \subseteq T _1 , T _2  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = \sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) 
\end{aligned}</script><p>考虑$( \sum _{ p  } [ T _1 \subseteq C _p ] ) $怎么求,注意到这等价于所有$T _1 $中的位置全都被钦定为$&gt; $,而其他位置任意,如果我们设所有以大于号连接的部分的长度为$l _1 , l _2 , . . . , l _k $,那么这里的答案就是$n ! \prod _{ i = 1  } ^k \frac { 1  } { l _i !  } $.</p>
<p>但我们很快发现了难点:$2 ^{ | T _1 \cap T _2 |  } $这个东西是难求的,怎么办呢?</p>
<p>我们考虑一下这个东西的意义:其实也就是在$T _1 $和$T _2 $中都是$&gt; $的位置,这个好像不太好求,因为$&gt; $是很平常的,但如果取补集就不一样了,取补集后意味着都是任意的位置的数量,而我们上面已经发现了:如果有一个位置对前后两个数字的约束是独立的,那我们可以把前后两个位置拆开.于是我们有:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{ T _1 , T _2  } 2 ^{ | T _1 \cap T _2 |  } ( - 1 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = \sum _{ T _1 , T _2  } 2 ^{ ( ( n - 1 ) - | T _1 \cup T _2 | ) - ( n - 1 )  } ( - 2 ) ^{ | T _1 | + | T _2 |  } ( \sum _{ p  } [ T _1 \subseteq C _p ] ) ( \sum _p [ T _2 \subseteq C _p ] ) \\
& = 2 ^{ 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 |  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ | T _2 |  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T _1 \cup T _2 |  } 
\end{aligned}</script><p>其中$n - 1 - | T _1 \cup T _2 | $意味着均不在$T _1 $和$T _2 $中的位置的数量.为了给每一段连续的$&gt; $都分配权值,我们进行一个细小的修改:</p>
<script type="math/tex; mode=display">
2 ^{ - 1 - n  } ( n ! ) ^2 \sum _{ T _1  } ( ( - 2 ) ^{ | T _1 | + 1  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( ( - 2 ) ^{ | T _2 | + 1  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ n - 1 - | T _1 \cup T _2 |  }</script><p>写到这里应该就能发现,接下来必然要对$n - 1 - | T _1 \cup T _2 | $做整体操作.那我们再这么搞可能就很难受,我们采取这样的方式:对$T _1 $和$T _2 $求补集,这样它们的含义就变成了除了集合中的元素,剩下的全部被钦定为了$&gt; $,我们自然有:</p>
<script type="math/tex; mode=display">
\begin{gathered}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\

\end{gathered}</script><p>这里已经很显然了,我们大概要做一个不断加段的做法,那此时$| T _1 \cap T _2 | $这个限制就显得尤其强,如果只是$S \subseteq T _1 , T _2 $就会好做很多:我们可以钦定$S $作为分界线,然后把两边的东西卷起来.因此我们暴力拆开后面的式子:</p>
<script type="math/tex; mode=display">
\begin{aligned}
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) 2 ^{ | T _1 \cap T _2 |  } \\
& = 2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } \sum _{ S \subseteq T _1  } ( \frac { 1  } { ( - 2 ) ^{ | T _1 | + 1  }  } \frac { 1  } { \prod l _{ 1 , i  } !  } ) \sum _{ S \subseteq T _2  } ( \frac { 1  } { ( - 2 ) ^{ | T _2 | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) \\

\end{aligned}</script><p>令$f ( T ) = \sum _{ S \subseteq T  } ( \frac { 1  } { ( - 2 ) ^{ | T | + 1  }  } \frac { 1  } { \prod l _{ 2 , i  } !  } ) \ $,则原式即:</p>
<script type="math/tex; mode=display">
2 ^{ 1 + n  } ( n ! ) ^2 \sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2</script><p>考虑下面这个东西怎么求:</p>
<script type="math/tex; mode=display">
\sum _{ S  } ( \sum _{ S \subseteq T  } f ( T ) ) ^2</script><p>注意到,如果我们把每一段($[ T _i , T _{ i + 1  } ) $)的贡献求和,那么$f ( T ) $相当于这些和乘起来,那么$( \sum _{ S \subseteq T  } f ( T ) ) ^2 $就是这些和的平方乘起来.换句话说,我们自然有$ans _n = \sum _{ m  } ans _{ n - m  } g ^2 _{ m  } $,其中$g _m $表示长度为$m $的一段的贡献之和.而$g _{ n  } = \sum _m g _{ n - m  } \frac { 1  } { - 2 m !  } $.二者都可以使用分治FFT或多项式求逆解决.更进一步地,$h _i = \frac { 1  } { - 2 i !  } , G = \frac { 1  } { 1 - H  } , F = \frac { 1  } { 1 - G  } $.</p>
<p>这题还有一个做法:tyy的变魔术做法.</p>
<p>还是容斥,考虑将$( &gt; , &gt; ) $容斥掉,这样我们有若干种对:$2 ( &lt; , &lt; ) , 1 ( e , e ) , - ( e , &lt; ) , - ( &lt; , e ) $,然后我们发现两个序列联系得太紧了,我们考虑分配系数:$&lt; \rightarrow \sqrt { 2  } $,$e \rightarrow - \frac { 1  } { \sqrt { 2  }  } $,但是这样发现$( e , e ) $算错了,你把剩下的补上就行.你会发现这个式子和上面我们推的是等价的,但是变魔术.</p>
<h3><span id="复杂度抵消">复杂度抵消</span></h3><h5><span id="example1cf1439b">Example1(CF1439B)</span></h5><p>首先注意到度数小于$k - 1 $的点一定没用,于是可以不断删点.删点后的图度数全部$\geq k - 1 $.</p>
<p>首先如果剩下的点度数全都$\geq k $那就直接找到答案,不然,我们看一下度数为$k - 1 $的点:它要么在团里,要么没用.不妨直接暴力判断是否在团里,复杂度$O ( k ^2 ) $.</p>
<p>欸等一下,这总复杂度$O ( mk ^2 ) $了啊,这咋办?</p>
<p>首先,删完点后的度数全都$\geq k - 1 $,注意到此时的点数是$O ( \frac { m  } { k  } ) $的.所以复杂度$O ( mk ) $.</p>
<p>好像还是过不去,这咋办?</p>
<p>冷静一下,如果$k \geq \sqrt { m  } $,显然不可能存在团.于是复杂度$O ( m \sqrt { m  } ) $.</p>
<h3><span id="寻找关系式">寻找关系式</span></h3><h5><span id="example1">Example1</span></h5><p>一张有向图,边有两种颜色,从$s $开始随机游走,维护一个权值.经过第一种颜色的边,权值$+ 1 $.经过第二种颜色的边,权值归$0 $.保证$t $没有出边,所有点均能到$t $.询问到$t $时权值的期望和方差.$n \leq 100 $.</p>
<p>(注意方差为平方的期望减去期望的平方.)</p>
<p>注意到难点在于权值归$0 $.所以一个点到$t $的期望权值一定和到达它时的权值有关系.</p>
<p>然后就来到了降维打击的时间:我们可以使用数学归纳法证明,如果到一个点$u $的权值是$x $,那它到达$t $的权值一定形如$a _u x + b _u $.</p>
<p>如果要严谨一点的话,我们发现第一种颜色的边会影响常数项,第二种颜色的边会影响一次项,因此最后的答案一定是一次函数.</p>
<p>最后可以使用高斯消元直接求出每个点权值的$a _u $和$b _u $,就可以求出期望.</p>
<p>至于方差是同理的,你注意到平方的期望一定是一个二次函数.</p>
<h3><span id="特判边界">特判边界</span></h3><h5><span id="example12022icpc杭州e">Example1(2022ICPC杭州E)</span></h5><p>第一反应肯定是一点一点调整成$\{ 1 , 2 , . . . , n \} $的形式,写个暴力验证一下发现当$n \geq 4 $的时候的确都可以调整成功.</p>
<p>假设目前形如:$[ 1 , k ] , A , k + 1 , B $.我们考虑如何调整:</p>
<ol>
<li>$| B | \ne 0 $.</li>
</ol>
<p>我们有:</p>
<script type="math/tex; mode=display">
\{ [ 1 , k ] , A , k + 1 , B \} \rightarrow \{ B , A , k + 1 , [ 1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , B , A \}</script><ol>
<li>$| B | = 0 , | A | = 0 $.</li>
</ol>
<p>直接合并就行.</p>
<ol>
<li>$| B | = 0 , | A | \geq 2 $.</li>
</ol>
<p>假设$A = A _1 A _2 $,我们有:</p>
<script type="math/tex; mode=display">
\{ [ 1 , k ] , A _1 , A _2 , k + 1 \} \rightarrow \{ A _2 , k + 1 , A _1 , [ 1 , k ] \} \rightarrow \{ [ 1 , k + 1 ] , A _1 , A _2 \}</script><ol>
<li>$| B | = 0 , | A | = 1 $.</li>
</ol>
<p>此时一定有$k \geq 2 $,发现有点难构造,但是我们猜测是可以构造出来的.不难证明这个问题等价于将$\{ 1 , 2 , 4 , 3 \} $调整为$\{ 1 , 2 , 3 , 4 \} $,写个暴力跑一下就行.</p>
<h3><span id="摩尔投票">摩尔投票</span></h3><h5><span id="example1cf643gchoosing-ads">Example1([CF643G]Choosing Ads)</span></h5><p>将摩尔投票扩展一下.我们现在想求其中出现次数大于等于$\lfloor \frac { n  } { p  } \rfloor $的数字,令$k = \lfloor \frac { 100  } { p  } \rfloor $,我们考虑每次取出$k + 1 $个两两不同的数字并且全部杀掉,那么做完这一步操作后,该满足条件的仍然满足条件(讨论一下),于是拿线段树维护当前的五个数的出现数量,每次对着杀就行.</p>
<h3><span id="寻找周期性">寻找周期性</span></h3><h5><span id="example1cf1463fmax-correct-set">Example1([CF1463F]Max Correct Set)</span></h5><p>自然的想法是$O ( n 2 ^{ \max ( x , y )  } ) $作dp.</p>
<p>接下来比较牛逼的是,注意到如果$S _1 $满足条件,令$m = x + y $那么$S _1 \cup ( S _1 + m ) $也满足条件.</p>
<p>我们考虑$S _1 $中满足条件意味着什么,意味着$\forall a , b \in S _1 , a &lt; b $,$b - a \ne x \land b - a \ne y $,这意味着$m + b - a \ne x \land m + b - a \ne y $,这同样意味着$m + a - b = x + y + a - b \ne x + y - x \land m + a - b \ne x + y - y $.</p>
<p>因此,只要我们找到了一个长度为$m $的可行解,我们一定可以将其不断扩展到全部集合.</p>
<p>进一步地,我们一定能证明:原集合中的最优解是以一个长度为$m $的可行解作为周期的.</p>
<p>这个是为啥呢?我们设$n = km + c $,那么我们直接求出一个长度为$m $的解,满足前$c $位对答案的贡献的权值是$k + 1 $,后$m - c $位贡献的权值为$k $,然后直接求答案.注意到如果最大答案另有其人,我们一定可以拿其中的某一段不断循环得到更大的答案,这就不符合我们的假设了.</p>
<h3><span id="补集转化">补集转化</span></h3><h5><span id="example1">Example1</span></h5><p>给定一个$n $个点$m $条边的无向图,求给每一条边定向使得$1 $和$2 $能到达同一个点(可以是$1 $或$2 $)的方案数.$n \leq 15 , m \leq \frac { n ( n - 1 )  } { 2  } $.</p>
<p>考虑正难则反,算不存在的概率(事实上也确实很好理解,因为存在性问题通常都要取补集),这时候我们发现:此时$1 $能到达一个集合$S $,$2 $能到达一个集合$T $,$S $和$T $无交,并且两个集合之间不可能存在边,因此我们只需要算$f ( S ) $表示$1 $能到达$S $中的点的方案数即可,$2 $同理.</p>
<p>那么这个怎么算呢?我们仍然考虑正难则反,如果$1 $不能到达$S $中的所有点,那么$1 $一定只能到达$S $中的一部分点,枚举这一部分,假设是$T $,就可以用$f ( T ) $算$f ( S ) $的答案.</p>
<h3><span id="二进制分组">二进制分组</span></h3><h5><span id="example1loj3273">Example1(loj3273)</span></h5><p>先考虑没有插入怎么做,注意到所有的线会扫出一个空白区域:这个空白区域由一条折线围成,而所有的点都在折线外或在折线上,更进一步地,在折线外的点没有动,就是初始位置.</p>
<p>这启发我们分开维护,每次扫线的时候更新折线,把该扔进来的扔进来,由于折线上的点$( x , y ) $,随着$x $的增大$y $不增,因此是简单维护的,用一下平衡树就行.</p>
<p>问题在于如何维护插入点.我们使用二进制分组,将所有点分为大小为$0 , 1 , 2 , 4 , \cdots , 2 ^k $大小的组,当然有些组可能没被分出来.然后如果有两个大小都是$2 ^k $的组,我们暴力合并二者,得到一个还没被折线扫过的新的大小为$2 ^{ k + 1  } $的组.</p>
<h5><span id="example2luogu7447-ynoi2007-rgxsxrs">Example2(Luogu7447 [Ynoi2007] rgxsxrs)</span></h5><p>一眼看上去和CF702F很像,但是区间操作感觉很艰难,怎么做呢?</p>
<p>我们对值域分块:分成$[ 0 , 1 ) , [ 1 , 2 ) , [ 2 , 4 ) , [ 4 , 8 ) , \cdots $,这样只会分成$\log V $段,每段内部维护平衡树来处理下标.那么对于一个$x $,它会把后面的段全部打上一个$tag $,有些位置要掉落到下面的段上,这个维护每个段的最小值就可以处理(最多只会掉落$\log n $段),问题是和$x $在同一块内的没有办法打tag,但这一部分一定会掉落到下面的段,一块处理.</p>
<p>好,下面开始思想总结:</p>
<p>首先,我们发现这个区间和值域都很难处理,但是感觉值域更加重要,应该是对值域做均摊(也就是类似CF702F的打tag操作和暴力修改操作分开),于是考虑到对值域分块然后内部平衡树,然后发现可以做了吧.不太清楚,也有可能只是值域分块的套路.</p>
<p>Luogu9069是同款思路,判一下负数.</p>
<h5><span id="example3cf1515i-phoenix-and-diamonds">Example3(CF1515I Phoenix and Diamonds)</span></h5><p>俗称带修T-shirt.</p>
<p>做法大概是这样的:我们考虑对于每次给出的$c $,不妨假设它在$[ 2 ^k , 2 ^{ k + 1  } ) $这个块上,那么如果它减去了任何一个还在这个块里的数字,那就一定会掉落到下一个块中.这样就又有均摊了.</p>
<p>但是我们不一定能减去一个还在这个块里的数字,我们怎么做呢?</p>
<p>我们考虑最后的操作一定是减去若干个小于这个块的,最后有可能再减去一个这个块的,然后$c $就掉到了下一个块,考虑先按照价值排序,然后维护$f _i $表示排名在$i $前面且代价在更小的块中的代价和,我们要找到最靠左的小于$c - 2 ^k $的$f $,这个可以做线段树二分维护.</p>
<p>[IOI2021]地牢游戏 类似,但是因为是在图上做,所以把二分要改成倍增.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/" class="post-title-link" itemprop="url">英美戏剧与电影大作业</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%BD%9C%E4%B8%9A-%E8%8B%B1%E7%BE%8E%E6%88%8F%E5%89%A7%E4%B8%8E%E7%94%B5%E5%BD%B1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h3><span id="the-bright-morning-stara-sequel-to-a-streetcar-named-desire">The Bright Morning Star(A Sequel to <em>A Streetcar Named Desire</em>)</span></h3><p>MATRON: This is her room. [<em>She knocks on the door.</em>] Miss DuBois,</p>
<p>here is someone who wants to visit you.</p>
<p>MITCH [<em>overwrought</em>]: Thank you. Has anyone visited her before? And</p>
<p>has she recovered?</p>
<p>MATRON: No, no. Although she has recovered a lot, sometimes she’ll</p>
<p>crouch over and tremble in corners as if someone will hurt her, and</p>
<p>she’ll try to hit anyone who wants to touch her when she’s insane.</p>
<p>[*She pushes the door open and lets Mitch in. The room where Blanche</p>
<p>lives now is a pure white space without windows, and a naked bulb</p>
<p>brightens the whole room as if it were daylight. There is a collapsible</p>
<p>bed in the corner of the room and a Bible on the table. Blanche sits on</p>
<p>a chair in a blue dress and stares at Mitch, which makes Mitch feel a</p>
<p>little guilty. Then the Matron goes out and leaves Mitch in the room.*]</p>
<p>MITCH [<em>keeping his head lower, staring at his hands</em>]: Hello, Miss</p>
<p>… DuBois.</p>
<p>BLANCHE [<em>happily</em>]: Hello, Mitch. I’m glad that you could visit me.</p>
<p>You know, I haven’t spoken to anybody for a long time. I … I didn’t</p>
<p>mean that the Doctor and the Matron treated me badly, and I also didn’t</p>
<p>mean that you are just a … talkative partner in my heart. [*Her voice</p>
<p>dies out nervously.*] You know that, you know that … did you bring</p>
<p>some whiskey or lemon coke for me?</p>
<p>MITCH: No, the Matron said that you can’t have any liquor.</p>
<p>BLANCHE: That’s a pity. Did you bring some unwashed grapes for me?</p>
<p>MITCH: What?</p>
<p>BLANCHE [<em>smiled</em>]: That’s just a joke.</p>
<p>MITCH [<em>relieved</em>]: It’s a relief to see you more delighted and</p>
<p>energetic now. [<em>There is a pause.</em>] The room is so … white, like a</p>
<p>… marble palace.</p>
<p>BLANCHE [<em>delightedly</em>]: Yes. Yes, I know that you mean to say “Ivory</p>
<p>tower”. The room is neat and … it is better than Elysian Fields,</p>
<p>right? I feel like a new human being with the white walls, the light,</p>
<p>and the Bible here. And Shep Huntleigh called me a few seconds ago. Soon</p>
<p>I’ll leave here and go to the real palace, being old and full of days.</p>
<p>The Lord will bless the latter end of mine more than my beginning.</p>
<p>[*The music of the polka rises, faint in the distance. She gets</p>
<p>crazy<em>] No, no, I don’t want to hear it again! [</em>Mitch gets</p>
<p>shocked.*] I’m sorry for that. I … I don’t know why sometimes I</p>
<p>behave like … like … Oh, how is your mother?</p>
<p>MITCH [<em>sadly</em>]: She has passed on.</p>
<p>BLANCHE: I’m sorry to hear that. [<em>There is a pause.</em>] Oh, don’t let</p>
<p>silence ruin our meeting. We haven’t met for …</p>
<p>MITCH: Seven months.</p>
<p>BLANCHE: Yes, seven months … It’s difficult for me to count the days</p>
<p>because there’s no calendar, nor sun … How about Stella’s baby? When I</p>
<p>feel lonely at night, I will miss the lovely baby. I haven’t seen him</p>
<p>… or her? Oh, it is not important, you know, Stella is my precious</p>
<p>little sister, and her baby is my precious little nephew … although</p>
<p>the baby’s father is … Stanley.</p>
<p>MITCH [<em>avoiding Blanche’s eyes</em>]: That’s why I came here, Blanche, I</p>
<p>have known the brutal thing that Stanley had done. I feel angry and …</p>
<p>sorry for it. I want to confess my behavior to you and … beseech your</p>
<p>forgiveness. [<em>His voice dies out.</em>]</p>
<p>BLANCHE: What thing? I must forget something. Pardon me, let me remember</p>
<p>for a moment … [*She starts shaking all over and panting for</p>
<p>breath.<em>] No, no, no! [</em>She screams*] That’s enough.</p>
<p>MITCH [<em>bravely</em>]: You know, Blanche. I … I’m sorry for what Stanley</p>
<p>… and I have done.</p>
<p>BLANCHE: I forgive you! You are the man that is without sin.</p>
<p>MITCH [<em>shocked</em>]: No, no, I’m not …</p>
<p>BLANCHE [<em>raising her voice</em>]: You are the one! It is you who lighten</p>
<p>my life … although just for a while. But that is not your fault. I</p>
<p>don’t deserve the light for my sinful self. It must be God’s punishment</p>
<p>…</p>
<p>MITCH [<em>restlessly</em>]: No, Blanche, you are …</p>
<p>BLANCHE: A courtesan, I’ve known it.</p>
<p>MITCH [<em>embarrassedly</em>]: No, Blanche, I didn’t mean that.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: So why do you come here? To remind me</p>
<p>of the past which I try to forget, to sneer at my fate that I have been</p>
<p>trapped in this prison, or just because you want to have a sweet rest</p>
<p>without guilt?</p>
<p>MITCH [<em>embarrassedly</em>]: No, no, Blanche, I come here with kindness. I</p>
<p>know the memory of Stanley is so harsh for you and I … I have no</p>
<p>hostility to mention it. And … and, you see, the room is not so bad as</p>
<p>a prison. It is safe. No one will hurt you here.</p>
<p>BLANCHE [<em>coldly</em>]: And no one will love me here.</p>
<p>[<em>They keep silent for a while.</em>]</p>
<p>MITCH [<em>nervously</em>]: Maybe we can turn the light off. The room is too</p>
<p>bright.</p>
<p>BLANCHE [<em>with a bitter smile</em>]: Don’t touch the button. From the</p>
<p>first day I came here, the merciful Doctor and the Matron kept the bulb</p>
<p>on because they thought I’d be cured when there was no night. It works!</p>
<p>Now I love the light, it makes the room like a … white coffin. Yes, a</p>
<p>white coffin made of white woods.</p>
<p>MITCH: Don’t talk about death. You said you were afraid of it.</p>
<p>BLANCHE [<em>faintly</em>]: That was the past. In the past, I always wanted</p>
<p>to get away from death. Before I met you, I escaped to desire; after I</p>
<p>met you, I was lost in hope. In the past, I clutched at anything that</p>
<p>would tell me that I’m alive, and when there was no solid thing in</p>
<p>reality, I tried to clutch at myself … although I’m not solid enough.</p>
<p>The seven months I have spent here helped me understand death. Maybe</p>
<p>death isn’t just about crying and darkness but salvation and light. I</p>
<p>thought I dreamt about Jesus a few days ago and he said, “Today shalt</p>
<p>thou be with me in paradise.” I wanted to ask him what paradise is like</p>
<p>but … I could speak no word, and then I woke up ... But, but I could</p>
<p>imagine it! You see, the room is … is as stainless as heaven. You see</p>
<p>I’m more delighted and energetic here! It is doubtless that I’ll keep</p>
<p>delighted and energetic in heaven after I pass on … if I can go to</p>
<p>heaven by entering in at the strait gate … Do you think I can?</p>
<p>MITCH: Yes, of course.</p>
<p>BLANCHE [<em>laughed</em>]: God love you for a liar! But let me tell you the</p>
<p>truth: I’ve chosen a wide way that leadeth to destruction … it’s real</p>
<p>… but why I talk about the truth …</p>
<p>MITCH: I’m serious. I have made up my mind to come here … and I want</p>
<p>to take you away.</p>
<p>BLANCHE: I am not clean enough.</p>
<p>MITCH: Everyone is not clean enough. Everyone has … a sinful past. The</p>
<p>world is broken, Blanche …</p>
<p>BLANCHE: No, Mitch. I\’m too delicate and painful, but you … are</p>
<p>realistic and natural. How can we live together … just because we long</p>
<p>for a partner? Sick people have such deep, sincere attachments. But the</p>
<p>truth is that I’m sick and you’re not. How can you forbear me when I’m</p>
<p>on the edge of lunacy and want magic?</p>
<p>MITCH: If we … get married, I swear that you won’t be on the edge of</p>
<p>lunacy.</p>
<p>BLANCHE [<em>sobbing</em>]: I will. I’m too vulnerable and the world is …</p>
<p>always too harsh. [<em>There is a pause.</em>] It’s getting late. Maybe the</p>
<p>bright morning star has risen.</p>
<p>MITCH: But …</p>
<p>BLANCHE [<em>cutting him off, keeping sobbing</em>]: Will you attend my</p>
<p>funeral in the future? I have no idea when it will be held. But I know</p>
<p>it will come soon.</p>
<p>MITCH: Don’t say that.</p>
<p>BLANCHE: It’s a pity I can’t attend my own funeral. But I could imagine</p>
<p>it. It will be quiet and stainless, with pretty flowers … right?</p>
<p>MITCH [<em>hesitantly</em>]: Yes.</p>
<p>BLANCHE: Will I be buried at sea at noon in the summer?</p>
<p>MITCH [<em>sobbing</em>]: Yes.</p>
<p>BLANCHE: I wonder if you will cry for me that day. But don’t … don’t</p>
<p>answer me. Let it be a mystery, a fantastic mystery, just like the end</p>
<p>of a fairy tale. I had read so many fairy tales when I was young and I</p>
<p>always imagined that I’m a princess living in a palace, in a magic</p>
<p>palace, waiting for my prince and then having a happy ending. Everyone</p>
<p>believes that the protagonists of stories will have a happy ending, and</p>
<p>I’ll also believe it. Do you know the French story <em>La Porte étroite</em>?</p>
<p>MITCH: You know, I read few books.</p>
<p>BLANCHE: It’s my mother’s favorite novel. Do you believe that at the end</p>
<p>of the story, the hero and the heroine get married and have a happy</p>
<p>ending?</p>
<p>MITCH [<em>sobbing</em>]: I believe it.</p>
<p>BLANCHE [<em>smiled palely</em>]: Why are you so sad? Oh, don’t cry. Tears</p>
<p>are so precious that you should save them for more precious people.</p>
<p>[*Mitch covers his face with his hands. Blanche wants to wipe away his</p>
<p>tears at first, but then she hesitates and turns back.*]</p>
<p>BLANCHE: God shall wipe away all tears from our eyes, for the former</p>
<p>things are passed away.</p>
<p>MITCH [<em>raising his head with eyes full of tears, hesitantly</em>]: Do you</p>
<p>… do you still remember the inscription?</p>
<p>BLANCHE: What inscription? I have forgotten about it.</p>
<p>MITCH: Alright … alright, I’ll go. Good night, Miss DuBois.</p>
<p>BLANCHE: I shall say “Good night” till it be morrow.</p>
<p>[<em>MITCH leaves.</em>]</p>
<p>BLANCHE: And if God choose, I shall but love thee better after death.</p>
<p>[<em>The lights fade away.</em>]</p>
<p><strong>END</strong></p>
<h3><span id="summary">SUMMARY</span></h3><p>At the end of <em>A Streetcar Named Desire,</em> Blanche says she has forgotten</p>
<p>something. In this sequel, Mitch visits the asylum where Blanche is</p>
<p>living to express his wish to take Blanche away. Blanche refuses him</p>
<p>despite her love for Mitch. While living in the asylum, Blanche has</p>
<p>understood more about death and love. She knows she is not clean enough</p>
<p>and wants to go to heaven and love Mitch after death.</p>
<p>Or is this sequel just Blanche’s another dream before death? In the</p>
<p>Bible, there is no night nor sun in heaven, just like the room.</p>
<h3><span id="theme">THEME</span></h3><p>It’s an attempt to explain Blanche’s change after Stanley’s rape. Before</p>
<p>that, she was afraid of death and tried to avoid harsh light. But after</p>
<p>that, she claimed that she’d be buried at noon. I tend to link it to her</p>
<p>chase for a fancy world like heaven.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/" class="post-title-link" itemprop="url">青蛙王子</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E9%9D%92%E8%9B%99%E7%8E%8B%E5%AD%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/" class="post-title-link" itemprop="url">海的女儿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E6%B5%B7%E7%9A%84%E5%A5%B3%E5%84%BF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/" class="post-title-link" itemprop="url">卖火柴的小女孩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B9%A0%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">习作</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->
<!-- tocstop -->
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/22/%E4%B9%A0%E4%BD%9C-%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/page/5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
