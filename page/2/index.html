<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LWLAymh的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="LWLAymh的博客">
<meta property="og:url" content="http://lwlaymh.github.io/page/2/index.html">
<meta property="og:site_name" content="LWLAymh的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LWLAymh的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LWLAymh的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://LWLAymh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-概率与期望" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T14:25:04.238Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script type="math/tex; mode=display">
随机试验：\\不能预先确知结果，但是可以知道可能的结果和范围，可以在相同条件下重复实验</script><script type="math/tex; mode=display">
样本空间：随机试验所有可能结果组成的集合</script><script type="math/tex; mode=display">
样本空间的任意一个子集称之为事件</script><script type="math/tex; mode=display">
事件发生：在一次试验中，事件的一个样本点发生</script><script type="math/tex; mode=display">
独立事件：如果P(AB)=P(A)P(B)，则称A和B是独立的</script><script type="math/tex; mode=display">
\begin{array}{c}
积：交\cap\\
和：并\cup\\
差：-\\
补：总集-A\\
互斥：A\cap B=\empty\\
包含：\subseteq\\
相等：=
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{c}
交换律：A\cup B=B\cup A，A\cap B=B\cap A\\
结合律：A\cup(B\cup C)=(A\cup B)\cup C，A\cap(B\cap C)=(A\cap B)\cap C\\
分配律：A\cup(B\cap C)=(A\cup B)\cap (A\cup C)\\
A\cap(B\cup C)=(A\cap B)\cup (A\cap C)\\
对欧律：\overline{A\cup B}=\overline{A}\cap\overline{B}，\overline{A\cap B}=\overline{A}\cup\overline{B}
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{c}
0\leq P(A)\\
\sum P(A)=1\\
若\forall i,j，有A_i\cap A_j=\empty（互不相容），则有P(\bigcup_{i=1}^nA_i)=\sum_{i=1}^nP(A_i)\\
如果A\subset B，则有P(B-A)=P(B)-P(A)\\
P(A\cup B)=P(A)+P(B)-P(AB)
\end{array}</script><script type="math/tex; mode=display">
条件概率：已知事件B发生时事件A发生的概率为P(A|B)=\frac{P(AB)}{P(B)}\\
乘法原理：P(AB)=P(A|B)P(B)</script><script type="math/tex; mode=display">
条件概率可以仍然可以使用概率的其他性值</script><script type="math/tex; mode=display">
期望E[f(X)]=\sum f(x)P(X=x)\\
E[\sum c_iX_i]=\sum c_iE[X_i]\\
E[A+B]=E[A]+E[B]</script><script type="math/tex; mode=display">
贝叶斯公式：如果有\{B_i\}是样本空间的一个划分\\
即\forall i,j，有B_i\cap B_j=\empty\\
并且有\bigcup_{i=1}^nB_i=全集\\
则有P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(AB_i)}{P(A)\sum P(B_j)}=\frac{P(A B_i)}{\sum_{j=1}^n P(A\cap B_j)}=\frac{P(A|B_i)P(B_i)}{\sum_{j=1}^n P(A|B_j)P(B_j)}\\
简化形式：P(B|A)=\frac{P(A|B)P(B)}{P(A)}</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/08/14/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" data-id="cl6tfw0fr0006xkvtep6hah6i" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-反演" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/%E5%8F%8D%E6%BC%94/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T14:25:04.208Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>反演:</p>
<p>假设有两个函数$f$和$g$满足:$f(n)=\sum_{k}a_{n,k}g(k)$,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>$n$个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f(n)$为$n$个人随便站的方案数,$g(n)$为$n$个人都站错的方案数.</p>
<p>如果知道$g$的表达式,我们可以通过枚举有多少人站错位置来得到$f$,即:$f(n)=\sum_{k=0}^nC_n^kg(k)$.</p>
<p>接下来我们要用$f$表示$g$:</p>
<p>首先有$g(n)=\sum_{m=0}^n[n-m=0]C_n^mg(m)\\$</p>
<p>根据二项式定理,有$\sum_{k=0}^n(-1)^kC_n^k=[n=0]\\$</p>
<p>显然可以带入,知:$g(n)=\sum_{m=0}^n\sum_{k=0}^{n-m}(-1)^kC_{n-m}^kC_n^mg(m)\\$.</p>
<p>考虑组合意义,$C_{n-m}^kC_n^m$意为在$n$中选出两个大小分别为$m$和$k$的子集,因而等价于$C_n^kC_{n-k}^m$.</p>
<script type="math/tex; mode=display">
g(n)=\sum_{m=0}^n\sum_{k=0}^{n-m}(-1)^kC_n^kC_{n-k}^mg(m)\\=\sum_{k=0}^n(-1)^kC_n^k\sum_{m=0}^{n-k}C_{n-k}^mg(m)\\
=\sum_{k=0}^n(-1)^kC_n^kf(n-k)\\=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)\\</script><p>我们将以上过程称为二项式反演,一般形式如下:</p>
<script type="math/tex; mode=display">
f(n)=\sum_{k=0}^nC_n^kg(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^{n-k}C_n^kf(k)</script><p>二项式反演还有另一个形式,即:</p>
<script type="math/tex; mode=display">
f(n)=\sum_{k=0}^n(-1)^k\binom{n}{k}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^k\binom{n}{k}f(k)</script><p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g(n)=n!\sum_{0\leq k\leq n}\cfrac{(-1)^k}{k!}\\$.</p>
<p>不难发现$n!$的后面形如$e^{-1}$的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<script type="math/tex; mode=display">
g(n)=\cfrac{n!}{e}-n!\sum_{k>n}\cfrac{(-1)^k}{k!}\\
=\cfrac{n!}{e}-\cfrac{(-1)^{n+1}}{n+1}\sum_{0\leq k}(-1)^k\cfrac{(n+1)!}{(k+n+1)!}</script><p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g(n)=\lfloor\cfrac{n!}{e}+\cfrac{1}{2}\rfloor+[n=0]$.</p>
<p>另外,观察$g$关于$f$的表达式,不难求出$g$的递推式:$g(n)=ng(n-1)+(-1)^n$.</p>
<h3 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h3><script type="math/tex; mode=display">
Example：\\
已知f(n)=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array} \right\}g(k)\\
求g(n)\\
\\
反转公式：
\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array} \right]\left\{ \begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}=\sum_{k=0}^n\left\{ \begin{array}{c}n\\k\end{array} \right\}\left[ \begin{array}{c}k\\m\end{array} \right](-1)^{n-k}=[m=n]\\
证明见“特殊的数.md”文件\\
那么g(n)=\sum_{m=0}^n[m=n]g(m)\\
=\sum_{m=0}^n\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array} \right]\left\{ \begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}g(m)\\
=\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array} \right](-1)^{n-k}\sum_{m=0}^k\left\{ \begin{array}{c}k\\m\end{array} \right\}g(m)=\sum_{k=0}^n\left[ \begin{array}{c}n\\k\end{array} \right](-1)^{n-k}f(k)\\
由于反转公式的对称性，交换第一类第二类斯特林数也是成立的\\
Example：\\
已知f(m)=\sum_{n=m}^M(-1)^{m-n}\left[ \begin{array}{c}n\\m\end{array} \right]g(n)\\
求g(m)\\
g(m)=\sum_{n=m}^M[n=m]g(n)\\
=\sum_{n=m}^M\sum_{k=0}^M\left[ \begin{array}{c}n\\k\end{array} \right]\left\{ \begin{array}{c}k\\m\end{array} \right\}(-1)^{n-k}g(n)\\
=\sum_{k=0}^M\left\{ \begin{array}{c}k\\m\end{array} \right\}f(k)\\</script><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><script type="math/tex; mode=display">
Example：\\
求长度为n且仅包含小写英文字母且循环节长度恰为n的字符串个数\\
不妨设f(n)表示长度为n的字符串个数\\
g(n)表示长度为n且周期为n的字符串个数\\
有f(n)=\sum_{d|n}g(d)\\
不妨定义\mu(n)满足\sum_{d|n}\mu(d)=[n=1]\\
根据下文多重子集卷积的内容\\
可知\mu(\prod_{p\in prime}p^\alpha)=\prod_p[\alpha=1](-1)\\
那么我们有g(n)=\sum_{m|n}[\frac n m=1]g(m)\\
带入，有g(n)=\sum_{m|n}\sum_{d|\frac n m}\mu(d)g(m)\\
注意到[d|\frac n m]=[md|n]=[m|\frac n d]\\
有g(n)=\sum_{d|n}\mu(d)\sum_{m|\frac n d}g(m)=\sum_{d|n}\mu(d)f(\frac n d)=\sum_{d|n}\mu(\frac n d)f(d)\\
以上被称为莫比乌斯反演，\mu被称为莫比乌斯函数\\
一般形式如下：\\
f(n)=\sum_{d|n}g(d)\\g(n)=\sum_{d|n}\mu(\frac n d)f(d)\\
ps:\\考虑\sum_{d|n}\mu(d)=[n=1]的性质\\
我们实际上使用的是[m|n]\sum_{d|\frac n m}\mu(d)=[n=m]\\
令c=md，左边=\sum_{c|n}[m|c]\mu(\frac c m)=\sum([c|n])([m|c]\mu(\frac c m))\\
令A_{c,n}=[c|n]，B_{m,c}=[m|c]\mu(\frac c m)\\
那我们有BA=I\\
刚才的过程相当于：
已知Ax=b\\
x=Ix\\
x=(BA)x\\
x=B(Ax)\\
x=Bb\\
\\
Example：\\
已知f(n)=\sum_{n|d}g(d)\\
求g(n)\\
g(n)=\sum_{n|d}[\frac d n=1]g(d)=\sum_{n|d}\sum_{c|\frac d n}\mu(c)g(d)=\\\sum_{c|d}\sum_{nc|d}\mu(c)g(d)=\sum_{c}\mu(c)f(nc)
=\sum_{n|d}\mu(\frac d n)f(d)\\
Example:\\
若g(x)=\sum_{1\leq d}f(\cfrac x d),求f(x).\\
\\
Solution:\\
我们有\sum_{1\leq d}g(\cfrac{x}d)\mu(d)=\sum_{d\geq 1}\mu(d)\sum_{k\geq 1}f(\cfrac{x}{kd})\\
=\sum_{m\geq 1}f(\cfrac{x}{m})\sum_{d,k\geq 1}[m=dk]\mu(d)\\
=\sum_{m\geq 1}f(\cfrac{x}{m})\sum_{d|m}\mu(d)\\
=f(x)
\\\\
Problem：求\sum_{i=1}^{n}\sum_{j=1}^mgcd(i,j)\\
\\
技巧1：增加枚举量\\
原式=\sum_{i=1}^n\sum_{j=1}^mid[gcd(i,j)]=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}\varphi(d)\\
技巧2：交换枚举顺序\\
原式=\sum_{d=1}^{\min(n,m)}\sum^{\lfloor\frac n d\rfloor}_{i=1}\sum^{\lfloor\frac m d\rfloor}_{j=1}\varphi(d)\\
技巧3：分离无关变量\\
原式=\sum^{\min(n,m)}_{d=1}\varphi(d)\times\lfloor\cfrac n d\rfloor\times \lfloor\cfrac m d\rfloor\\

考虑由于\lfloor \cfrac n d\rfloor和\lfloor \cfrac m d\rfloor所对应的取值最多只有\sqrt{n}+\sqrt{m}种不同的取值\\因此只需处理出\varphi(d)的前缀和即可在O(\sqrt{n}+\sqrt{m})的复杂度解决此问题\\
至于处理出\lfloor \cfrac n d\rfloor和\lfloor \cfrac m d\rfloor所对应的取值则需要用到数论分块\\
\\
Problem：求\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)=1]\\
\\
和上一道题几乎没区别，唯一不同的是需要处理的函数从id变为了\epsilon
\\
\\
Problem：求\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)\in prime]\\
\\
考虑增加枚举量，则原式=\sum_{i=1}^{n}\sum_{j=1}^m\sum_{p\in prime}[gcd(i,j)=p]\\
=\sum_{p\in prime}\sum^{\lfloor\cfrac n d\rfloor}_{i=1}\sum^{\lfloor\cfrac m d\rfloor}_{j=1}[gcd(pi,pj)=p]\\
=\sum_{p\in prime}\sum^{\lfloor\cfrac n p\rfloor}_{i=1}\sum^{\lfloor\cfrac m p\rfloor}_{j=1}[gcd(i,j)=1]=\sum_{p\in prime}\sum_{d=1}^{\min(\lfloor\cfrac m p\rfloor,\lfloor\cfrac n p\rfloor)}\mu(d)\lfloor\cfrac n {pd}\rfloor\lfloor\cfrac m {pd}\rfloor\\
于是转化为上一道题，但复杂度仍不可接受\\
技巧4：换元\\考虑设x=pd，则变为\sum_{x=1}^{\min(n,m)}\sum_{p\in prime且p|x}</script><h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><script type="math/tex; mode=display">
无论是二项式反演还是莫比乌斯反演，他们都满足f(n)所依赖的g(k)有k\leq n\\
根据上面的情况，我们发现A是一个下三角矩阵，B是A^{-1}，很可求\\
现在来推导满足k\leq n的一般情况反演\\
f(n)=\sum_{k=1}^na_{n,k}g(k)\\
不妨设算子\mu(n,m)，满足\sum_{k=1}^na_{n,k}\mu(k,m)=\sum_{k=1}^n\mu(n,k)a_{k,m}=[n=m]\\
即AB=BA=I\\
g(n)=\sum_{m=1}^n[n=m]g(m)=\sum_{m=1}^n\sum_{k=1}^n\mu(n,k)a_{k,m}g(m)=\sum_{k=1}^n\mu(n,k)f(k)</script><h3 id="集合幂级数"><a href="#集合幂级数" class="headerlink" title="集合幂级数"></a>集合幂级数</h3><script type="math/tex; mode=display">
见同文件夹“集合幂级数.md”文件\\
Example：\\
多重子集反演：允许元素出现多次\\
已知f(S)=\sum_{T\subseteq S}g(T)\\
求g(S)\\
定义\mu(S)，若S包含重复元素则为0，否则为(-1)^{|S|}\\
可以知道\sum_{T\subseteq S}\mu(T)=[S=0]\\
于是f(S)=\sum_{T\subseteq S}g(T)\\
g(S)=\sum_{T\subseteq S}\mu(S-T)f(T)\\</script><h3 id="单位根反演（离散傅里叶变换）"><a href="#单位根反演（离散傅里叶变换）" class="headerlink" title="单位根反演（离散傅里叶变换）"></a>单位根反演（离散傅里叶变换）</h3><script type="math/tex; mode=display">
Example：\\
给定两个长度为n的数列a和b\\
求数列c，其中c_r=\sum_{p,q}[(p+q)\mod n=r]a_pb_q\\
其中n=2^k\\
考虑单位根\epsilon满足\epsilon^n=1，即\epsilon=e^{-\frac{2\pi i}{n}}\\
根据等比数列求和，如果\epsilon^v\ne 1，即v\mod n\ne 0\\
我们有\sum_{k=0}^{n-1}\epsilon^{vk}=\frac {\epsilon ^{nv}-1}{\epsilon^v-1}\\
那么我们有：\frac1 n\sum_{k=0}^{n-1}\epsilon^{vk}=[v\mod n=0]\\
注意到[(p+q)\mod n=r]=[(p+q-r)\mod n]\\
=\frac 1 n \sum_{k=0}^{n-1}\epsilon ^{(p+q-r)k}=\frac 1 n\sum_{k=0}^{n-1}\epsilon^{-rk}\epsilon^{pk}\epsilon^{qk}\\
c_r=\sum_{p,q}[(p+q)\mod n=r]a_pb_q\\
=\sum_{p,q}\frac 1 n\sum_{k=0}^{n-1}\epsilon^{-rk}\epsilon^{pk}\epsilon^{qk}=\frac 1 n\sum_{k=0}^{n-1}\epsilon^{-rk}\sum_{p}\epsilon^{pk}a_p\sum_{q}\epsilon^{qk}b_q\\
不妨令f_m=\sum_{k=0}^{n-1}\epsilon^{mk}g_k\\
g_m=\frac 1 n\sum_{k=0}^{n-1}\epsilon^{-mk}f_k</script><h3 id="一般情况-1"><a href="#一般情况-1" class="headerlink" title="一般情况"></a>一般情况</h3><script type="math/tex; mode=display">
由上我们发现，反演解决了一些在下标上的二元运算卷积\\
c_r=\sum_{p,q}[f(p,q)=r]a_pb_q\\
而我们需要把f分成两个独立的部分，通常正变换一下，处理一下，逆变换回来\\</script><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><script type="math/tex; mode=display">
Problem：UOJ\ ROUND5\ C\\
给出多项式f,g,h\\
有\sum_{j=1}^nf(gcd(i,j))g(i)h(j)x_j\equiv b_i(\mod p)\\
已知b，求x\\
\\
Solve：\\
考虑使用莫比乌斯反演求f_r(n)使得f(n)=\sum_{d|n}f_r(d)\\
则原式即\sum_{j=1}^n\sum_{d}[d|i][d|j]f_r(d)g(i)h(j)x_j\equiv b_i(\mod p)\\
\sum_{d|i}f_r(d)\sum_{j=1}^n[d|j]h(j)x_j\equiv \frac{b_i}{g(i)}(\mod p)\\
令z_d=\sum_{j=1}^n[d|j]h(j)x_j\\
有\sum_{d|i}f_r(d)z_d\equiv \frac{b_i}{g(i)}(\mod p)\\
可以用莫比乌斯反演求左边，进而求出z_d\\
而z_d=\sum_{j=1}^n[d|j]h(j)x_j，我们可以再次使用莫比乌斯反演求出h(j)x_j，进而求x_j\\</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/08/14/%E5%8F%8D%E6%BC%94/" data-id="cl6tfw0fm0001xkvt7h5i9yr5" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-多项式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T14:25:04.193Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="多项式基础"><a href="#多项式基础" class="headerlink" title="多项式基础"></a>多项式基础</h2><h3 id="复数相关"><a href="#复数相关" class="headerlink" title="复数相关"></a>复数相关</h3><p>欧拉公式:$e^{i\pi}=-1$.</p>
<p>也就是$e^{2i\pi}=1$,同时又有$e^{i\theta}=cos\theta+i·sin\theta$,证明使用复平面的单位圆.</p>
<p>单位根:对于$x^n=1$,我们会有$n$个根,设第$k$个根为$\omega_n^k$.那么我们有:$\omega_n^k=e^{2\pi\frac k ni}=cos(2\pi\frac kn)+i·sin(2\pi\frac kn)$.</p>
<p>单位根有以下性质:</p>
<ol>
<li>折半引理:$\omega_{2n}^{2k}=\omega_n^k\\$,由我们上面推导的通项公式即可证明.</li>
<li>消去引理:$\omega_n^{k+\frac n 2}=-\omega_n^k\\$,同样使用通项，运用三角恒等变换可证明.</li>
</ol>
<h3 id="点值表示法和系数表示法"><a href="#点值表示法和系数表示法" class="headerlink" title="点值表示法和系数表示法"></a>点值表示法和系数表示法</h3><script type="math/tex; mode=display">
代数基本定理：一个n-1次多项式在复数域上有且只有n-1个根\\
多项式有点值表示法和系数表示法两种\\
系数表示法：A(x)=\sum_{i=0}^{n-1}a_ix^i\\
点值表示法：y_i=\sum_{j=0}^{n-1}a_jx_i^j\\
\\
定理：一个n-1次多项式在n个不同点的取值唯一确定了该多项式\\
证明：\\
考虑反证法，假设命题不成立，则存在两个n-1次多项式A(x)和B(x)\\
且\forall i\in[0,n-1],A(x_i)=B(x_i)\\
令C(x)=A(x)-B(x)，那么C(x)至多是一个n-1次多项式\\
且\forall i\in[0,n-1]，C(x_i)=0\\
也就是C(x)有n个根，与代数基本定理不符合\\
\\
已知多项式点值表示法求系数表示法的过程被称为插值\\</script><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><script type="math/tex; mode=display">
构造多项式\sum_{i=0}^{n-1}y_i(\prod_{j=0且j\ne i}^{n-1}\frac {x-x_j}{x_i-x_j})\\
显然当x=x_i时，该多项式的答案为y_i</script><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><script type="math/tex; mode=display">
考虑两个多项式相乘，如果我们已知他们的点值表示法，显然可以直接相乘\\
这为我们提供了一种思路：先将系数表示法转化为点值表示法，进行相乘之后再转化回系数表示法\\</script><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><script type="math/tex; mode=display">
将n次单位根（n=2^w）分别带入A(x)得到点值向量A(\omega_n^k)\\
如果朴素带入，复杂度显然不可接受\\
考虑A(x)=\sum_{i=0}^{n-1}a_ix^i=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^i+\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^i\\
=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{2k}+x\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{2k}\\
令A_1(x)=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{k}\\
A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\
那么A(x)=A_1(x^2)+xA_2(x^2)\\
接下来分类讨论：\\
\forall 0\leq k\leq \frac n 2-1，k\in\mathbb{N}\\
我们有A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})\\
根据折半引理，
A(\omega_n^k)=A_1(\omega_{\frac n 2}^k)+\omega_n^kA_2(\omega^k_{\frac n 2})\\
\forall \frac n 2\leq k+\frac n 2\leq n-1\\
A(\omega_n^{k+\frac n 2})=A_1(\omega_n^{2k+n})+\omega_n^{k+\frac n 2}A_2(\omega_n^{2k+n})\\
根据消去引理，A(\omega_n^{k+\frac n 2})=A_1(\omega_{\frac n 2}^k)-\omega_n^kA_2(\omega_{\frac n 2}^k)\\
以上，我们可以递归处理A_1和A_2，然后合并得到A的答案，可以分治</script><h4 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h4><script type="math/tex; mode=display">
设A(\omega_n^k)=d_k\\
构造多项式F(x)=\sum_{i=0}^{n-1}d_ix^i\\
我们求出F(x)的点值表示，设c_k=F(\omega_n^{-k})\\
也即c_k=\sum_{i=0}^{n-1}d_i(\omega_n^{-k})^i=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}\\
当j=k时，显然\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n\\
否则根据等比数列求和公式，\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=\frac{\omega^0_n[(\omega_n^{j-k})^n-1]}{\omega_n^{j-k}-1}=0\\
所以，\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n[j=k]\\
那么我们有c_k=a_kn\\
a_k=\frac{c_k}{n}</script><h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><script type="math/tex; mode=display">
递归写法显然\\
递归过程中，第k层相当于在根据数在第k位的二进制数是1还是0来分类\\
那显然可以求出最后一层的数组，然后向上合并\\
合并的过程被称为蝴蝶操作\\
假设A_1(\omega_{\frac n 2}^k)和A_2(\omega_{\frac n 2}^k)分别存在a[k]和a[\frac n 2+k]中，我们设t=\omega_n^ka[k+\frac n 2]\\
那么可以写出合并：\\
a[k+\frac n 2]:=a[k]-t\\
a[k]:=a[k]+t</script><h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><script type="math/tex; mode=display">
由于FFT中的单位根会产生精度误差，因此在膜意义下，通常会选择NTT来进行多项式乘法\\</script><script type="math/tex; mode=display">
NTT与FFT的运算过程基本相同，证明过程基本相同，唯一不同的是将单位根改为了原根\\
根据上面FFT的证明过程，我们知道：只需要证明原根满足以下条件，就可以进行变换\\
设原根为g，g_n=g^{\frac {p-1}n}\\
那需要满足：\\
1. g_n^n=g_n^0=1，证明显然\\
2. 折半引理，g_{2n}^{2k}=g_{n}^k，证明显然\\
3. 消去引理，g_{n}^{k+\frac n 2}=-g^k_n\\
由于g^{\frac {p-1}2}=-1，该结论显然成立\\
由上我们证明了，我们完全可以使用g_n代替\omega_n进行变换\\
ps：注意到998244352=2^{23}\times 7\times 17\\
而2^{23}\approx 8\times 10^6\\
因而，当n\leq 8\times 10^6的时候，g_n可以直接求出\\
（这也是为什么大部分ntt题目都使用998244353作为模数的原因</script><h3 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a>分治FFT</h3><script type="math/tex; mode=display">
给定g(x)，求f(x)=\sum_{y=1}^xf(x-y)g(y)，答案对998244353取膜\\</script><script type="math/tex; mode=display">
假如我们已经知道了f(x)，x\in[1,\frac n 2]\\
那我们可以计算出这段部分对f(y)，y\in[\frac n 2+1,n]的贡献\\
这显然是一个卷积的形式，我们直接计算f和g的乘积并贡献上去</script><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><script type="math/tex; mode=display">
对于多项式P(x)，找到Q(x)使得Q(x)P(x)\equiv 1(\mod x^n)\\
显然Q(x)是唯一的</script><script type="math/tex; mode=display">
首先不妨设n=2^k\\
如果我们已知P(x)Q_{k-1}(x)\equiv 1(\mod x^{2^{k-1}})\\
同时肯定有P(x)Q_{k}(x)\equiv 1(\mod x^{2^{k-1}})\\
相减得到Q_k(x)-Q_{k-1}(x)\equiv 0(\mod x^{2^{k-1}})\\
两边平方：Q_k^2(x)+Q^2_{k-1}(x)-2Q_k(x)Q_{k-1}(x)\equiv 0(\mod x^{2^k})\\
两边乘一下P(x)\\
Q_k(x)-2Q_{k-1}(x)+P(x)Q_{k-1}^2(x)\equiv 0(\mod x^n)\\
Q_k(x)\equiv 2Q_{k-1}(x)-P(x)Q_{k-1}^2(x)(\mod x^n)\\
根据主定理，这么做复杂度是O(nlog_2n)的</script><h2 id="集合幂级数"><a href="#集合幂级数" class="headerlink" title="集合幂级数"></a>集合幂级数</h2><script type="math/tex; mode=display">
形如\sum_{i=0}^{2^n-1}a_ix^i，其中二进制数i表示\{1,2,...,n\}的一个子集，用|i|表示该子集大小\\
下述级数如无特别说明均为集合幂级数</script><script type="math/tex; mode=display">
高维前缀和：
c_i=\sum_{j\subseteq i}a_j\\
高维后缀和：
c_i=\sum_{j\supseteq i}a_j\\
上述过程又称快速莫比乌斯变换（FMT）</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与-或卷积"><a href="#与-或卷积" class="headerlink" title="与/或卷积"></a>与/或卷积</h3><script type="math/tex; mode=display">
或卷积：c_i=\sum_{j}\sum_{k}[j \or k=i]a_jb_k\\
与卷积：c_i=\sum_{j}\sum_{k}[j\and k=i]a_jb_k\\
考虑如何求a和b的或卷积：\\
引理：\\
若j,k\subseteq i,则j\or k\subseteq i，逆命题同样成立\\
若j,k\supseteq i,则j\and k\supseteq i，逆命题同样成立\\
\\
设a，b，c的高维前缀和分别为A，B，C\\
A_iB_i=(\sum_{j\subseteq i}a_j)(\sum_{k\subseteq i}b_k)=\sum_{j,k\subseteq i}a_ib_k=\sum_{k\or j\subseteq i}a_ib_k=C_i\\
现在考虑已知C求c，本质上是一个反演\\
注意到\sum_{r\subseteq p}(-1)^{|r|}=\sum_{k=0}^{|p|}C_{|p|}^k(-1)^k=[p=0]\\
c(p)=\sum_{q\subseteq p}[p-q=0]c(q)=\sum_{q\subseteq p}\sum_{r\subseteq (p-q)}(-1)^{|r|}c(q)\\
=\sum_{r\subseteq p}(-1)^{|r|}\sum_{q\subseteq (p-r)}c(q)=\sum_{r\subseteq p}(-1)^{r}f(p-r)=\sum_{r\subseteq p}(-1)^{|p|-|r|}C(r)\\
于是C(S)=\sum_{T\subseteq S}c(T)\\
c(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}C(T)\\
\\
因而做两遍高维前缀和再反推回去即可\\
复杂度O(2^nn)\\
与卷积即改为高维后缀和</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异或卷积"><a href="#异或卷积" class="headerlink" title="异或卷积"></a>异或卷积</h3><script type="math/tex; mode=display">
c_i=\sum_j\sum_k[j\oplus k=i]a_jb_k\\
快速沃尔什变换（FWT）：\\
定义集合幂级数FWT(a)，满足FWT(a)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}a_j\\
那么有：FWT(c)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}c_j=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}[k\oplus l=j]a_kb_l\\
=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|(k\oplus l)\and i|}a_kb_l=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|k\and i|}a_k(-1)^{|l\and i|}b_l\\
=FWT(a)_iFWT(b)_i\\
时间复杂度O(2^nn)\\
FMT可以看作是FWT在解决或卷积，与卷积时的特例</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=mpow(2,mod-2)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">				a[j+k]=t*(x+y)%mod;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">				a[j+k+mid]=t*(x-y+mod)%mod;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h3><script type="math/tex; mode=display">
c_i=\sum_{j}\sum_{k}[j\and k=\phi,j\or k=i]a_jb_k\\
意识到该卷积与或卷积的差别在于，或卷积会多累加一些[j\and k\ne \phi]的答案\\
而[j\and k=\phi,j\or k=i]=[|j|+|k|=|i|,j\or k=i]\\
因而可以将原集合按照元素个数分组，做FMT，然后再n^2次结合，并做IFMT，最终将结果累计\\
复杂度O(2^nn^2)</script><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们定义一个幂级数形如$A(z)=\sum_{k\geq 0}a_kz^k$,并使$[z^n]A(z)=a_n$.则称$A(z)$是$\langle a_0,a_1,…\rangle$的生成函数.</p>
<h3 id="生成函数的运算"><a href="#生成函数的运算" class="headerlink" title="生成函数的运算"></a>生成函数的运算</h3><ol>
<li>$\alpha A(z)+\beta B(z)=\sum_{n\geq 0}(\alpha f_n+\beta g_n)z^n$.</li>
<li>$z^mA(z)=\sum_{n\geq 0}g_{n}z^{n+m}=\sum_{n\geq m}g_{n-m}z^n$.</li>
<li>$A(cz)=\sum_{n\geq 0}c^nf_nz^n$.</li>
<li>$A’(z)=\sum_{n\geq 1}ig_iz^{i-1}$.</li>
<li>$\int A(z)dz=\sum_{n\geq 0}\cfrac{1}{n+1}g_nz^{n+1}$.</li>
<li>$A(z)B(z)=\sum_{n\geq 0}(\sum_{k=0}^nf_kg_{n-k})z^n$.</li>
<li>$\cfrac{1}{1-z}A(z)=\sum_{n\geq 0}(\sum_{k=0}^ng_k)z^n$.</li>
</ol>
<h3 id="常见序列生成函数"><a href="#常见序列生成函数" class="headerlink" title="常见序列生成函数"></a>常见序列生成函数</h3><ol>
<li>$\cfrac{1}{1-z}=\sum_{k\geq 0}z^k\\$,$\cfrac{1}{1+cz}=\sum_{k\geq 0}c^kz^k\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$(1+z)^r=\sum_{k\geq 0}\binom{r}{k}z^k\\$,$(1-z)^r=\sum_{k\geq 0}(-1)^k\binom{r}{k}z^k\\$.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol>
<li>$\cfrac{1}{1-z^m}=\sum_{n\geq 0}[n|m]z^n\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$\cfrac{1}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{n+k}{n}z^k,n\in\mathbb{N}\\$,$\cfrac{z^n}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{k}{n}z^k,n\in\mathbb{N}\\$</li>
</ol>
<p>直接使用二项式定理展开$(1-z)^{-n-1}$,可以得到:</p>
<script type="math/tex; mode=display">
(1-z)^{-n-1}=\sum_{k\geq 0}(-1)^k\binom{-n-1}{k}z^k</script><p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<script type="math/tex; mode=display">
\cfrac{1}{(1-z)^2}=\sum_{n\geq 0}(n+1)z^n\\\cfrac{z}{(1-z)^2}=\sum_{n\geq 0}nz^n</script><p>根据$(1)$求导即可得到此式.</p>
<ol>
<li>$e^z=\sum_{k\geq 0}\cfrac{z^k}{k!}\\$.</li>
<li>$\ln(\cfrac{1}{1-z})=\sum_{n\geq 1}\cfrac{1}{n}z^n$.</li>
<li>$\ln(1+z)=\sum_{k\geq 0}(-1)^k\cfrac{z^{k+1}}{k+1}\\$.</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<h3 id="阶乘的扩展定义"><a href="#阶乘的扩展定义" class="headerlink" title="阶乘的扩展定义"></a>阶乘的扩展定义</h3><p>对于复数的阶乘,我们通常定义:</p>
<script type="math/tex; mode=display">
\cfrac{1}{z!}=\lim_{n\rightarrow +\infin}\binom{n+z}{z}n^{-z}</script><p>同时我们定义$\Gamma(z+1)=z!$,有:$(-z)!\Gamma(z)=\cfrac{\pi}{\sin(\pi z)}$.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<script type="math/tex; mode=display">
z^{\underline{w}}=\cfrac{z!}{(z-w)!}\\
z^{\overline{w}}=\cfrac{\Gamma(z+w)}{\Gamma(z)}</script><p>通过以上我们还可以有二项式系数的定义:</p>
<script type="math/tex; mode=display">
\binom{z}{w}=\lim_{\zeta\rightarrow z,\omega\rightarrow w}\cfrac{\zeta!}{\omega!(\zeta-\omega)!}</script><h3 id="超几何级数"><a href="#超几何级数" class="headerlink" title="超几何级数"></a>超几何级数</h3><h4 id="超几何函数"><a href="#超几何函数" class="headerlink" title="超几何函数"></a>超几何函数</h4><p>我们定义超几何函数$F(a_1,…,a_m;b_1,…b_n;z)=F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$\cfrac{0}{0}=1$之类的式子,可以发现当$z=0$时任意超几何函数总是$=1$.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0$或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4 id="特殊的超几何函数"><a href="#特殊的超几何函数" class="headerlink" title="特殊的超几何函数"></a>特殊的超几何函数</h4><h5 id="合流超几何函数"><a href="#合流超几何函数" class="headerlink" title="合流超几何函数"></a>合流超几何函数</h5><p>我们通常把形如$M(a;b;z)=F\left(\begin{array}{r|}a\\b\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}}{b^{\overline{k}}k!}$的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}1\\1\end{array}z\right)=e^z</script><p>也即常见生成函数中的$(6)$.</p>
<h5 id="高斯超几何函数"><a href="#高斯超几何函数" class="headerlink" title="高斯超几何函数"></a>高斯超几何函数</h5><p>我们把形如$F\left(\begin{array}{r|}a,b\\c\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}b^{\overline{k}}}{c^{\overline{k}}k!}$的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\1\end{array}z\right)=\cfrac{1}{1-z}$.</li>
</ol>
<p>即常见生成函数$(1)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}-a,1\\1\end{array}-z\right)=(1+z)^a$.</li>
</ol>
<p>即常见生成函数$(2)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}a,1\\1\end{array}z\right)=\cfrac{1}{(1-z)^a}$.</li>
</ol>
<p>即常见生成函数$(4)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\2\end{array}-z\right)=\cfrac {\ln(1+z)}z$.</li>
</ol>
<p>即常见生成函数$(7)$.</p>
<h4 id="超几何级数的应用"><a href="#超几何级数的应用" class="headerlink" title="超几何级数的应用"></a>超几何级数的应用</h4><p>我们先考虑改写超几何级数的形式:</p>
<p>$F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}t_k,t_k=\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>不难发现$t_0=1$,而:</p>
<script type="math/tex; mode=display">
\cfrac{t_{k+1}}{t_k}=\cfrac{z^{k+1}}{z^k}\cfrac{k!}{(k+1)!}\cfrac{\prod_{i=1}^ma_i^{\overline{k+1}}}{\prod_{i=1}^ma_i^{\overline{k}}}\cfrac{\prod_{i=1}^nb_i^{\overline{k}}}{\prod_{i=1}^nb_i^{\overline{k+1}}}\\
=\cfrac{\prod_{i=1}^m(k+a_i)}{\prod_{i=1}^n(k+b_i)}\cfrac{z}{k+1}</script><p>换句话说,$\cfrac{t_{k+1}}{t_k}$是关于$k$的一个有理函数.而根据代数基本定理,任意$k$的有理函数在$\mathbb{C}$内都可以分解为以上的形式(如果缺少$k+1$项则需要上下同时乘以$k+1$以补上).</p>
<p>换句话说,对于一个无穷级数$\sum_{k\geq 0}t_k$,我们先将$\cfrac{t_{k+1}}{t_k}$表示回超几何函数,设为$F$.</p>
<p>那么有:$\sum_{k\geq 0}t_k=t_0F$.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$\Gamma$函数的定义)来使这些公式全部成立.But who cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>求证:$\sum_{k\leq n}\binom{r+k}{k}=\binom{r+n+1}{n}\Leftrightarrow F\left(\begin{array}{r|}1,-n\-n-r\end{array}1\right)=\cfrac{r+n+1}{r+1},n\in\mathbb{N}\\$.</p>
<p>首先考虑:</p>
<script type="math/tex; mode=display">
\sum_{k\leq n}\binom{r+k}{k}=\sum_{k\geq 0}\binom{r+n-k}{n-k}</script><p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<script type="math/tex; mode=display">
\binom{r+n}{n}F\left(\begin{array}{r|}1,-n\\-n-r\end{array}1\right)=\binom{r+n+1}{n}</script><p>两边同时除以$\binom{r+n}{n}$得到上式.</p>
<h5 id="二项式系数与超几何函数"><a href="#二项式系数与超几何函数" class="headerlink" title="二项式系数与超几何函数"></a>二项式系数与超几何函数</h5><p>通过范德蒙德卷积,不难验证:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b\\c\end{array}1\right)=\cfrac{\Gamma(c-a-b)\Gamma(c)}{\Gamma(c-a)\Gamma(c-b)},-b\in\mathbb{N}</script><p>这个公式的一个特例是:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,-n\\c\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\
\sum_{k\geq 0}\cfrac{a^{\overline{k}}(-n)^{\overline{k}}}{c^{\overline{k}}k!}=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\</script><p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b,-n\\c,a+b-n-c+1\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}(c-b)^{\overline{n}}}{c^{\overline{n}}(c-a-b)^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}(b-c)^{\underline{n}}}{(-c)^{\underline{n}}(a+b-c)^{\overline{n}}},n\in\mathbb{N}\\</script><p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3 id="生成函数的应用"><a href="#生成函数的应用" class="headerlink" title="生成函数的应用"></a>生成函数的应用</h3><h4 id="求解递归关系"><a href="#求解递归关系" class="headerlink" title="求解递归关系"></a>求解递归关系</h4><p>我们假设已经有了$R(z)=\sum_{k\geq 0}g_kz^k$,并且$R(z)=\cfrac{P(z)}{Q(z)}$,其中$P(z)$和$Q(z)$都是多项式,我们想要找到一种方式求解$[z^n]R(z)$.</p>
<p>考虑有理函数$S(z)=\sum_{k=1}^m\cfrac{a_k}{1-\rho_kz}\\$,不难发现$[z^n]S(z)=\sum_{k=1}^ma_k\rho_k^n\\$.</p>
<p>那么可以证明,只要$Q(z)=0$无重根并且无零根,那么就存在一组系数满足$S(z)=R(z)$.</p>
<p>我们这么定义”反射”运算,若$Q(z)=\sum_{k=0}^mq_kz^k\\$,则其反射多项式为$Q^R(z)=\sum_{k=0}^mq_kz^{m-k}\\$.</p>
<p>若$Q(z)=q_0\prod_{k=1}^m(1-\rho_kz)$,则显然有$Q^R(z)=q_0\prod_{k=1}^m(z-\rho_k)\\$.</p>
<p>那么显然这里求出来的这组数$\rho$就是$S(z)$中的那组$\rho$.</p>
<p>而我们有$a_k=\cfrac{-\rho_kP(\cfrac{1}{\rho_k})}{Q’(\rho_k)}$.</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>已知$n!=\sum_{k}\binom{n}{k}g_{n-k},n\in\mathbb{N}\\$,求$g_n$.</p>
<p>首先两边同时除以$n!$并将组合数用阶乘形式展开,我们有:</p>
<script type="math/tex; mode=display">
1=\sum_{k}\cfrac{g_{n-k}}{k!(n-k)!}.</script><p>如果我们令$D(z)=\sum_{k\geq 0}\cfrac{g_{k}}{k!}z^k$,则有:</p>
<script type="math/tex; mode=display">
\cfrac{1}{1-z}=e^zD(z)\\
D(z)=\cfrac{1}{1-z}e^{-z}\\
D(z)=(\sum_{k\geq 0}z^k)(\sum_{k\geq 0}(-1)^k\cfrac{z^k}{k!})\\
[z^n]D(z)=\sum_{k=0}^n\cfrac{(-1)^k}{k!}</script><p>于是$g_n=n!\sum_{k=0}^n\cfrac{(-1)^k}{k!}\\$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/08/14/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" data-id="cl6tfw0fr0007xkvt98zlglwu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-递归式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/14/%E9%80%92%E5%BD%92%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-08-14T14:25:04.101Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="递归问题详解"><a href="#递归问题详解" class="headerlink" title="递归问题详解"></a>递归问题详解</h2><h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><p>三个柱子，$n$个面积互不相等的有孔圆盘一开始按照面积从上往下以此增大的顺序套在其中一个柱子上.</p>
<p>现在每次可以将某根柱子顶端的圆盘移动到另一根柱子顶端，要求这根柱子原本没有圆盘或者柱子顶端圆盘面积大于该圆盘.</p>
<p>求最小移动次数，使得所有圆盘移动到另一根柱子上.</p>
<p>不妨令$T_n$表示答案，显然$T_0=0,T_1=1,T_2=3$.</p>
<p>而我们一定可以找到一种方案，使得前n-1个圆盘先移动到其中一根柱子上，然后将最下面的圆盘移动到目标柱子.</p>
<p>最后再把$n-1$个圆盘移动到目标柱子.</p>
<p>由于这是一个可行解而不一定是最优解，我们有：$T_n\leq 2T_{n-1}+1，其中n&gt;0$.</p>
<p>而，如果我们要移动最大的圆盘，一定要保证前n-1个圆盘已经移走到一根柱子上.</p>
<p>因此一定有：$2T_{n-1}+1\leq T_n$.</p>
<p>于是有$T_n=2T_{n-1}+1,0&lt;n$.</p>
<h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>汉诺塔问题,所有圆盘一开始均在最左边的塔A上,要将他们全都移动到最右边的塔C上,不允许在二塔之间直接移动,求最小操作次数.</p>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>考虑设$ T_n$为n个圆盘时的最小操作次数.假设已知$T_{n-1}$,我们考虑如何移动.</p>
<p>首先因为不能直接在AC之间移动,因此一定是先要把最大的圆盘移动到中间塔上,这一步要求先把所有圆盘移动到C上,然后需要再把这些圆盘移动回A上,因此,显然有:$T_{n}=3T_{n-1}+2,T_0=0$. </p>
<p>考虑如何求该式子的封闭形式,令$W_n=T_n+1$,显然有$W_n=3W_{n-1},W_0=1$,显然$W_n=3^n$,有$T_n=3^n-1$.</p>
<p>顺便一提,由上面的过程可以发现,这是唯一的最小操作次数方法,因此《具体数学》中的Problem3(证明每根柱子都会出现一种从上至下的正确摆法)显然可证明.</p>
<h4 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem 4"></a>Problem 4</h4><p>汉诺塔问题,问是否存在一种符合规则的初始摆放方式,使得将其全部移动到其中一根柱子所用次数小于等于$2^n-1$.</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution 4"></a>Solution 4</h4><p>不存在.</p>
<p>观察汉诺塔问题的操作可知,任何时候,都只有两根柱子上会有圆盘.</p>
<p>我们不妨将$2^n-1$看作一个状态,它预示着这两根柱子上分别套着哪些圆环,这意味着任何状态都会被取到.</p>
<p>因此,任何状态作为起始都不可能有少于$2^n-1$种操作.</p>
<h4 id="Problem-10"><a href="#Problem-10" class="headerlink" title="Problem 10"></a>Problem 10</h4><p>汉诺塔问题,但是移动圆盘时只能从A移动到B,从B移动到C,从C移动到A.一开始所有圆盘都在A,求将它们全部移动到B的最小操作次数,以及将他们从B移动回A的最小操作次数.</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution 10"></a>Solution 10</h4><p>令$Q_n$为将n个圆盘从A移动到B的最小操作次数,令$R_n$为将n个圆盘从B移动回A的最小操作次数.</p>
<p>先考虑边界情况,$Q_0=0,R_0=0$.</p>
<p>我们考虑,由于柱子间在移动过程中是无区别的,因此$Q_n$的实质是将n个圆盘移动到它的下一个柱子的最小操作次数,$R_n$的实质是将n个圆盘移动到它的上一个柱子的最小操作次数.</p>
<p>在将最大的圆盘移动到下一根柱子前,一定要先把上面的圆盘全部移动到上一根柱子上,最后再移动回来.</p>
<p>显然有$Q_n=2R_{n-1}+1,1\leq n$.</p>
<p>在将最大的圆盘移动到上一根柱子前,一定要先把他移动到下一根柱子上,这个步骤要求我们把其他的圆盘移动到上一根柱子上.在这之后,我们又要把所有圆盘放到上一根柱子上来让最大圆盘到目标柱子,最后再移动回来.</p>
<p>有$R_n=R_{n-1}+1+Q_{n-1}+1+R_{n-1}=Q_n+Q_{n-1}+1,1\leq n$.</p>
<h4 id="Problem-11"><a href="#Problem-11" class="headerlink" title="Problem 11"></a>Problem 11</h4><p>汉诺塔问题,但是每种大小的圆盘有两个,且其中一个可以摆放在另一个的上面.</p>
<p>a.如果相同圆盘无区别,求最小操作次数.</p>
<p>b.如果相同圆盘有区别,且最后需要还原原本二者的上下顺序,求最小操作次数.</p>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution 11"></a>Solution 11</h4><p>a.仍然令$T_n$为n对圆盘的最小操作次数,显然$T_n=2T_{n-1}+2,T_0=0$,可解得$T_n=2^{n+1}-2$.</p>
<p>b.令$Q_n$为n对圆盘的最小操作次数,观察a问题,我们可以发现a问题转移之后,只有最下面的两个圆盘会交换顺序.而如果我们在b问题中只关注最下层两个圆盘的顺序,我们发现$Q_n=T_{n-1}+1+T_{n-1}+1+T_{n-1}+1+T_{n-1}=4T_{n-1}+3=2^{n+2}-5$.</p>
<p>我们进行了四次a操作,那么次下面两个圆盘自然就顺序与原本相同了,因此这里的$Q_n$就是答案.</p>
<h4 id="Problem-12"><a href="#Problem-12" class="headerlink" title="Problem 12"></a>Problem 12</h4><p>类似Problem11,但第$i$大的圆盘有$k_i$个.</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution 12"></a>Solution 12</h4><p>无区别,只是$T_n=2T_{n-1}+k_n,T_0=0$.</p>
<p>如果求封闭形式的话,显然有$T_n=\sum_{i=1}^n2^{n-i}k_i$.</p>
<h3 id="递归式的封闭形式"><a href="#递归式的封闭形式" class="headerlink" title="递归式的封闭形式"></a>递归式的封闭形式</h3><p>在上述问题中，我们已经有了以下式子：</p>
<p>$T_n=2T_{n-1}+1,n&gt;0,T_0=0$.</p>
<p>如果$n$很大，那么一步一步去计算是很复杂的，现在我们想知道一种更为快速的求出$T_n$的方法.</p>
<p>换句话说，我们想要把$T_n$表示为只与n有关的式子，我们称其为该递归式的封闭形式.</p>
<h4 id="Problem-8"><a href="#Problem-8" class="headerlink" title="Problem 8"></a>Problem 8</h4><p>解递归式:$Q_n=\begin{cases}\alpha&amp;n=0\\\beta&amp;n=1\\\frac{(1+Q_{n-1})} {Q_{n-2}}&amp;n&gt;1\end{cases}$,保证$\forall n,Q_n&gt;0$.</p>
<h4 id="solution8"><a href="#solution8" class="headerlink" title="solution8"></a>solution8</h4><p>注意到$Q_2=\frac{\beta+1}{\alpha},Q_3=\frac{\beta+\alpha+1}{\beta\alpha},Q_4=\frac{1+\alpha}{\beta},Q_5=\alpha,Q_6=\beta$.</p>
<p>显然该递归式存在长度为$5$的循环节.</p>
<h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p>观察T序列的前几项，可以发现似乎有$T_n=2^n-1$.</p>
<p>现在我们来证明它：</p>
<p>1.该公式对于$n=0$成立，显然可验证.</p>
<p>2.若该公式对$n=k$时成立，那该公式必然对$n=k+1$成立.</p>
<p>因为有$T_{k+1}=2T_k+1=2\times 2^k+2-1=2^{k+1}-1$.</p>
<p>以上过程被称为数学归纳法.</p>
<h4 id="Problem-9"><a href="#Problem-9" class="headerlink" title="Problem 9"></a>Problem 9</h4><p>求证:$\prod_{i=1}^nx_i\leq (\frac{\sum_{i=1}^nx_i}{n})^n,\forall i\in N_+,1\leq i\leq n,0\leq x_i$.</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution 9"></a>Solution 9</h4><p>使用反向归纳法.</p>
<p>1.$n=2$时,即基本不等式,显然成立.</p>
<p>2.若该式子对$n=k$时成立,则该式子对n=2k时也成立.</p>
<p>不妨令$A_1=\sqrt[k]{\prod _{i=1}^k x_i},B_1=\sqrt[k]{\prod _{i=k+1}^{2k}x_i},A_2=(\frac{\sum_{i=1}^kx_i}{k}),B_2=(\frac{\sum_{i=k+1}^{2k}x_i}k)$,显然有$A_1\leq A_2,B_1\leq B_2$.</p>
<p>同时有$(\frac{A_2+B_2}{2})\geq \sqrt{A_2B_2}\geq \sqrt{A_1B_1}$.</p>
<p>3.若该式子对$n=k$时成立,则该式子对$n=k-1$的时候也成立.</p>
<p>令$x_k=\frac{\sum_{i=1}^{k-1}x_i}{k-1}$,有$x_k\prod_{i=1}^{k-1}x_i\leq (x_k)^k$.</p>
<p>则显然$n=k-1$时也成立.</p>
<p>由1和2,我们知道了对于n是二的整数次幂的情况,该公式成立,由3,我们又可以知道该公式对于任意一个存在比他大的二的整数次幂的数成立,因此该公式成立.</p>
<h4 id="换元"><a href="#换元" class="headerlink" title="换元"></a>换元</h4><p>考虑令$U_n=T_n+1$，显然有：</p>
<p>$T_n+1=2T_{n-1}+2$.</p>
<p>即$U_n=2U_{n-1}$，显然$U_n=2^n$，则$T_n=2^n-1$.</p>
<h4 id="转化和式"><a href="#转化和式" class="headerlink" title="转化和式"></a>转化和式</h4><p>考虑递归式$a_nT_n=b_nT_{n-1}+c_n$.</p>
<p>如果我们能找到一个不为0的求和因子$s_n$并满足$s_nb_n=s_{n-1}a_{n-1}$.</p>
<p>那么我们两面同时乘以$s_n$，显然有：</p>
<p>$s_na_nT_n=s_{n-1}a_{n-1}T_{n-1}+c_ns_n$.</p>
<p>令$S_n=s_na_nT_n$.</p>
<p>显然有$S_n=s_0a_0T_0+\sum_{i=1}^ns_ic_i$.</p>
<p>则$T_n=\frac{S_n}{s_na_n}$.</p>
<p>而我们也会发现$s_n=\frac{\prod_{i=1}^{n-1}a_i}{\prod_{i=1}^nb_i}$.</p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>快速排序时间复杂度</p>
<p>结论：排序$n$个数时，其期望复杂度满足：</p>
<p>$C_0=C_1=0$.</p>
<p>$C_n=n+1+\frac{2}{n}\sum_{i=0}^{n-1}C_k,n&gt;1$.</p>
<p>不妨考虑两边同时乘以$n$.</p>
<p>有 $ nC_n=n^2+n+2\sum_{i=0}^{n-1}C_i,n&gt;1 $ .</p>
<p>显然也有$(n-1)C_{n-1}=(n-1)^2+n-1+2\sum_{i=0}^{n-2}C_i,n&gt;2$.</p>
<p>二式相消，有$nC_n-(n-1)C_{n-1}=2n+2C_{n-1},n&gt;2$.</p>
<p>而同时有$C_2=3$.</p>
<p>即：$nC_n=(n+1)C_{n-1}+2n,n&gt;2$，可以使用转化和式的方法解决.</p>
<h4 id="成套方法"><a href="#成套方法" class="headerlink" title="成套方法"></a>成套方法</h4><p>如果我们有<br>$f(n)=\begin{cases}<br>\alpha &amp; n=1\\<br>2f(\frac n 2)+\beta &amp; n=2k,k\in \mathbb{N_+}\\<br>2f(\frac {n-1}2)+\gamma &amp;n=2k+1,k\in \mathbb{N_+}<br>\end{cases}$</p>
<p>其中$n=2^m+l$且$2^m\leq n&lt;2^{m+1}$.</p>
<p>该如何求出$f(n)$的封闭形式呢？</p>
<p>由于所有的未知数都是以加法运算连接，显然有$f(n)=A(n)\alpha+B(n)\beta+C(n)\gamma$,而有$A、B、C$互不影响且$\alpha\beta\gamma$与$ABC$无关.</p>
<p>那无论$\beta$和$\gamma$的取值如何，$A(n)$都不会受到影响，我们考虑$\beta=\gamma=0$的特殊情况,此时显然有$A(n)=2^m$.</p>
<p>接下来，我们考虑取$\alpha\beta\gamma$的特殊值，去得到ABC之间的关系.</p>
<p>例如，当$f(n)=1$时，由递推式可知$\alpha=1,\beta=\gamma=-1$,那么有$A(n)-B(n)-C(n)=f(n)=1$.</p>
<p>同理，$f(n)=n$时，可知$\alpha=1,\beta=0,gamma=1$,此时有$A(n)+C(n)=f(n)=n$.</p>
<p>显然可以通过解方程求得$B(n)$和$C(n)$.</p>
<p>这个方法显然是通用方法,式子仅仅是例子,事实上,只要我们能证明$ABC$互不影响且$\alpha\beta\gamma$与$ABC$无关,我们就可以使用这个方法.</p>
<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><p>考虑n个人围成一圈，从第一个人开始，每隔一个人就杀掉一个人.</p>
<p>如10个人围成一圈时，杀人的顺序是2,4,6,8,10,3,7,1,9.</p>
<p>问最后幸存下来的人编号.</p>
<p>首先一定有J(1)=1.</p>
<p>考虑第一遍杀掉n号或者n-1号之后，对整个圆圈进行重新编号.</p>
<p>那么当人数是偶数时，我们有J(2n)=2J(n)-1.</p>
<p>当人数是奇数时，我们杀掉一号，然后有J(2n+1)=2J(n)+1.</p>
<p>整理得到：<br>$J(n)=\begin{cases}<br>1 &amp; n=1\\<br>2J(\frac n 2)-1 &amp; n=2k,\in \mathbb{N_+}\\<br>2J(\frac {n-1}2)+1 &amp;n=2k+1,\in \mathbb{N_+}<br>\end{cases}$</p>
<p>仍然可以使用数学归纳，如果令$n=2^m+l且2^m\leq n&lt;2^{m+1}$.<br>有$J(n)=2l+1$.</p>
<h4 id="Problem-15"><a href="#Problem-15" class="headerlink" title="Problem 15"></a>Problem 15</h4><p>求约瑟夫问题中最后一名被杀死的人的编号.</p>
<h4 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution 15"></a>Solution 15</h4><p>显然有<br>$J(n)=\begin{cases}<br>2 &amp; n=2\\<br>2J(\frac n 2)-1 &amp; n=2k+2,k\in \mathbb{N_+}\\<br>2J(\frac {n-1}2)+1 &amp;n=2k+1,k\in \mathbb{N_+}<br>\end{cases}$</p>
<p>封闭形式的话可以使用一般方法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/08/14/%E9%80%92%E5%BD%92%E5%BC%8F/" data-id="cl6tfw0g1000dxkvtdow411vn" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/14/%E5%8D%9A%E5%BC%88%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E6%95%B4%E5%80%BC%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 LWLAymh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>