<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="高数基础补档 复数相关 分圆多项式 Example(尺规做正n边形问题) 正五边形问题 正七边形 正n边形       泰勒展开   多项式 多项式基础 点值表示法和系数表示法 拉格朗日插值   多项式运算 多项式乘法 快速傅里叶变换(FFT) DFT   范德蒙德矩阵理解   分治FFT 多项式除法 多项式ln 牛顿迭代 多项式开方 多项式exp 多项式快速幂 多项式运算全家桶(重载运算符版">
<meta property="og:type" content="article">
<meta property="og:title" content="多项式与生成函数">
<meta property="og:url" content="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="高数基础补档 复数相关 分圆多项式 Example(尺规做正n边形问题) 正五边形问题 正七边形 正n边形       泰勒展开   多项式 多项式基础 点值表示法和系数表示法 拉格朗日插值   多项式运算 多项式乘法 快速傅里叶变换(FFT) DFT   范德蒙德矩阵理解   分治FFT 多项式除法 多项式ln 牛顿迭代 多项式开方 多项式exp 多项式快速幂 多项式运算全家桶(重载运算符版">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-04T16:04:36.330Z">
<meta property="article:modified_time" content="2025-04-14T16:40:02.181Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/","path":"2024/10/05/学习-多项式与生成函数/","title":"多项式与生成函数"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>多项式与生成函数 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我永远喜欢言和和！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">高数基础补档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">复数相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.</span> <span class="nav-text">分圆多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Example(尺规做正n边形问题)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">正五边形问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">正七边形</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.1.1.3.</span> <span class="nav-text">正n边形</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">泰勒展开</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">多项式基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.</span> <span class="nav-text">点值表示法和系数表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.2.</span> <span class="nav-text">拉格朗日插值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">多项式运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.1.</span> <span class="nav-text">多项式乘法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">快速傅里叶变换(FFT)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">DFT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">IDFT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.2.1.1.3.</span> <span class="nav-text">写法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">快速数论变换(NTT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">范德蒙德矩阵理解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.2.</span> <span class="nav-text">分治FFT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.3.</span> <span class="nav-text">多项式求逆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.4.</span> <span class="nav-text">多项式除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.5.</span> <span class="nav-text">多项式ln</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.6.</span> <span class="nav-text">牛顿迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.7.</span> <span class="nav-text">多项式开方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.8.</span> <span class="nav-text">多项式exp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.9.</span> <span class="nav-text">多项式快速幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.10.</span> <span class="nav-text">多项式运算全家桶(重载运算符版)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">集合幂级数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.1.</span> <span class="nav-text">与&#x2F;或卷积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.2.</span> <span class="nav-text">异或卷积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.3.</span> <span class="nav-text">快速沃尔什变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">线性代数角度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.3.3.1.1.</span> <span class="nav-text">或卷积</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.3.3.1.2.</span> <span class="nav-text">与卷积</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.3.3.1.3.</span> <span class="nav-text">异或卷积</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">生成函数角度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.4.</span> <span class="nav-text">子集卷积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.5.</span> <span class="nav-text">集合占位幂级数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.6.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">Example1([AGC034F] RNG and XOR)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">Example2([QOJ5089]环覆盖)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">Example3(CF1034E Little C Loves 3 III)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">Example4(CF1336E2 Chiori and Doll Picking)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.5.</span> <span class="nav-text">Example5(CF 1326F2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.6.6.</span> <span class="nav-text">Example6(qoj5019)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">生成函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.</span> <span class="nav-text">普通生成函数(OGF)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.2.</span> <span class="nav-text">运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.3.</span> <span class="nav-text">常见序列生成函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.</span> <span class="nav-text">指数生成函数(EGF)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.2.</span> <span class="nav-text">封闭式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.3.</span> <span class="nav-text">EXP的组合意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.4.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">Example1(POJ3734)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">Example2(圆排列)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">Example3(错排数)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">Example4(点带编号无向连通图计数)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">Example5(不动点计数)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.6.</span> <span class="nav-text">Example6([CF891E]Lust)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.4.7.</span> <span class="nav-text">Example7</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.3.</span> <span class="nav-text">狄利克雷生成函数(DGF)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.1.</span> <span class="nav-text">基本运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.2.</span> <span class="nav-text">封闭式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.3.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">Example1(luoguP3768)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text">阶乘的扩展定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.</span> <span class="nav-text">超几何级数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.1.</span> <span class="nav-text">超几何函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.2.</span> <span class="nav-text">特殊的超几何函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">合流超几何函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">高斯超几何函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.3.</span> <span class="nav-text">超几何级数的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">二项式系数与超几何函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.6.</span> <span class="nav-text">求微分方程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.6.1.</span> <span class="nav-text">Example1(luogu4931)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.7.</span> <span class="nav-text">生成函数的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.7.1.</span> <span class="nav-text">求解递归关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.7.2.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.7.3.</span> <span class="nav-text">Example2([QOJ5169] 夹娃娃)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.7.4.</span> <span class="nav-text">Example3([十二省联考 2019] 皮配)</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm神仙的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://wminus.github.io/" title="https:&#x2F;&#x2F;wminus.github.io" rel="noopener" target="_blank">麦麦的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="多项式与生成函数 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多项式与生成函数
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-05 00:04:36" itemprop="dateCreated datePublished" datetime="2024-10-05T00:04:36+08:00">2024-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-15 00:40:02" itemprop="dateModified" datetime="2025-04-15T00:40:02+08:00">2025-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- toc -->
<ul>
<li><a href="#高数基础补档">高数基础补档</a><ul>
<li><a href="#复数相关">复数相关</a><ul>
<li><a href="#分圆多项式">分圆多项式</a><ul>
<li><a href="#example尺规做正n边形问题">Example(尺规做正n边形问题)</a><ul>
<li><a href="#正五边形问题">正五边形问题</a></li>
<li><a href="#正七边形">正七边形</a></li>
<li><a href="#正n边形">正n边形</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#泰勒展开">泰勒展开</a></li>
</ul>
</li>
<li><a href="#多项式">多项式</a><ul>
<li><a href="#多项式基础">多项式基础</a><ul>
<li><a href="#点值表示法和系数表示法">点值表示法和系数表示法</a></li>
<li><a href="#拉格朗日插值">拉格朗日插值</a></li>
</ul>
</li>
<li><a href="#多项式运算">多项式运算</a><ul>
<li><a href="#多项式乘法">多项式乘法</a><ul>
<li><a href="#快速傅里叶变换fft">快速傅里叶变换(FFT)</a><ul>
<li><a href="#dft">DFT</a></li>
</ul>
</li>
<li><a href="#范德蒙德矩阵理解">范德蒙德矩阵理解</a></li>
</ul>
</li>
<li><a href="#分治fft">分治FFT</a></li>
<li><a href="#多项式除法">多项式除法</a></li>
<li><a href="#多项式ln">多项式ln</a></li>
<li><a href="#牛顿迭代">牛顿迭代</a></li>
<li><a href="#多项式开方">多项式开方</a></li>
<li><a href="#多项式exp">多项式exp</a></li>
<li><a href="#多项式快速幂">多项式快速幂</a></li>
<li><a href="#多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</a></li>
</ul>
</li>
<li><a href="#集合幂级数">集合幂级数</a><ul>
<li><a href="#与或卷积">与/或卷积</a></li>
<li><a href="#异或卷积">异或卷积</a></li>
<li><a href="#快速沃尔什变换">快速沃尔什变换</a><ul>
<li><a href="#线性代数角度">线性代数角度</a><ul>
<li><a href="#或卷积">或卷积</a></li>
<li><a href="#与卷积">与卷积</a></li>
<li><a href="#异或卷积-1">异或卷积</a></li>
</ul>
</li>
<li><a href="#生成函数角度">生成函数角度</a></li>
</ul>
</li>
<li><a href="#子集卷积">子集卷积</a></li>
<li><a href="#集合占位幂级数">集合占位幂级数</a></li>
<li><a href="#example">Example</a><ul>
<li><a href="#example1agc034f-rng-and-xor">Example1([AGC034F] RNG and XOR)</a></li>
<li><a href="#example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</a></li>
<li><a href="#example3cf1034e-little-c-loves-3-iii">Example3(CF1034E Little C Loves 3 III)</a></li>
<li><a href="#example4cf1336e2-chiori-and-doll-picking">Example4(CF1336E2 Chiori and Doll Picking)</a></li>
<li><a href="#example5cf-1326f2">Example5(CF 1326F2)</a></li>
<li><a href="#example6qoj5019">Example6(qoj5019)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#生成函数">生成函数</a><ul>
<li><a href="#普通生成函数ogf">普通生成函数(OGF)</a><ul>
<li><a href="#概念">概念</a></li>
<li><a href="#运算">运算</a></li>
<li><a href="#常见序列生成函数">常见序列生成函数</a></li>
</ul>
</li>
<li><a href="#指数生成函数egf">指数生成函数(EGF)</a><ul>
<li><a href="#基本运算">基本运算</a></li>
<li><a href="#封闭式">封闭式</a></li>
<li><a href="#exp的组合意义">EXP的组合意义</a></li>
<li><a href="#example-1">Example</a><ul>
<li><a href="#example1poj3734">Example1(POJ3734)</a></li>
<li><a href="#example2圆排列">Example2(圆排列)</a></li>
<li><a href="#example3错排数">Example3(错排数)</a></li>
<li><a href="#example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</a></li>
<li><a href="#example5不动点计数">Example5(不动点计数)</a></li>
<li><a href="#example6cf891elust">Example6([CF891E]Lust)</a></li>
<li><a href="#example7">Example7</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</a><ul>
<li><a href="#基本运算-1">基本运算</a></li>
<li><a href="#封闭式-1">封闭式</a></li>
<li><a href="#example-2">Example</a><ul>
<li><a href="#example1luogup3768">Example1(luoguP3768)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#阶乘的扩展定义">阶乘的扩展定义</a></li>
<li><a href="#超几何级数">超几何级数</a><ul>
<li><a href="#超几何函数">超几何函数</a></li>
<li><a href="#特殊的超几何函数">特殊的超几何函数</a><ul>
<li><a href="#合流超几何函数">合流超几何函数</a></li>
<li><a href="#高斯超几何函数">高斯超几何函数</a></li>
</ul>
</li>
<li><a href="#超几何级数的应用">超几何级数的应用</a><ul>
<li><a href="#example-3">Example</a></li>
<li><a href="#二项式系数与超几何函数">二项式系数与超几何函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#求微分方程">求微分方程</a><ul>
<li><a href="#example1luogu4931">Example1(luogu4931)</a></li>
<li><a href="#求解递归关系">求解递归关系</a></li>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</a></li>
<li><a href="#example3十二省联考-2019-皮配">Example3([十二省联考 2019] 皮配)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="高数基础补档">高数基础补档</span></h2><h3><span id="复数相关">复数相关</span></h3><p>棣莫弗定理:$(cos\theta+i\sin\theta)^n=\cos(n\theta)+i\sin(n\theta)$.</p>
<p>欧拉公式:$e^{i\pi}=-1$.</p>
<p>也就是$e^{2i\pi}=1$,同时又有$e^{i\theta}=cos\theta+i·sin\theta$,证明直接使用泰勒展开.</p>
<p>单位根:对于$x^n=1$,我们会有$n$个根,设第$k$个根为$\omega_n^k$.那么我们有:$\omega_n^k=e^{2\pi\frac k ni}=cos(2\pi\frac kn)+i·sin(2\pi\frac kn)$.</p>
<p>单位根有以下性质:</p>
<ol>
<li>折半引理:$\omega_{2n}^{2k}=\omega_n^k\\$,由我们上面推导的通项公式即可证明.</li>
<li>消去引理:$\omega_n^{k+\frac n 2}=-\omega_n^k\\$,同样使用通项，运用三角恒等变换可证明.</li>
</ol>
<h4><span id="分圆多项式">分圆多项式</span></h4><p>上复平面,设$S_k=(\cos\frac{2k\pi}{n},\sin\frac{2k\pi}{n})$,也就是$z_k=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}$是方程$z^n-1=0$的复根.我们把这个方程写开:</p>
<script type="math/tex; mode=display">
z^n-1=(z-1)(z^{n-1}+z^{n-2}+\cdots+1)=0</script><p>不难发现$z=1$是平凡解.</p>
<p>我们不妨定义$f(x)=\prod_{k=1}^n(1+X^k)=\sum_{k\geq 0}a_kX^k$,事实上我们有:</p>
<script type="math/tex; mode=display">
\frac{1}{n}\sum_{j=1}^nf(\omega_n^j)=\frac{1}{n}\sum_{j=1}^n\sum_{k\geq 0}a_k\omega^{kj}_n\\
=\frac{1}{n}\sum_{k\geq 0}a_k\sum_{j=1}^n\omega_{n}^{kj}\\
=\sum_{j\geq 0}a_{jn}+\frac{1}{n}\sum_{k\geq 0,n\nmid k}a_k\frac{1-\omega^{nj}_n}{1-\omega^{k}_n}\omega_{n}^j\\
=\sum_{j\geq 0}a_{jn}</script><p>事实上,我们令$d=\frac{n}{\gcd(j,n)}$,容易发现$f(\omega_n^j)=(\prod_{k=1}^d(1+\omega_n^{kj}))^{\frac{n}{d}}$,又容易发现$n|jd$.</p>
<p>接下来观察$X^d-1=\prod_{k=1}^d(X-\omega_{n}^{kj})$,带入$X=-1$得到$f(\omega_n^j)=\begin{cases}2^{\frac{n}{d}}&amp;d\in \text{odd}\\0&amp;d\in\text{even}\end{cases}$.</p>
<p>接下来考虑拿到$\sum_{j}a_{jn}$,只需求$\frac{1}{n}\sum_{j=1}^nf(\omega_n^j)=\frac{1}{n}\sum _{d\in \text{odd},\gcd(j,n)=\frac{n}{d}}2^{\frac{n}{d}}=\frac{1}{n}\sum_{d\in\text{odd}}\varphi(d)2^{\frac{n}{d}}$.</p>
<h5><span id="example尺规做正n边形问题">Example(尺规做正n边形问题)</span></h5><p><del>碰瓷高斯问题.</del></p>
<p>一步一步来.根据尺规作图理论:尺规作图只可以实现$+,-,\times,\div,\sqrt[2]{}$五种操作.而对于正$n$边形,显然只要我们能将$\cos\frac{2\pi}{n}$用只含上述五种操作和若干整数表示出来,那就一定可行.</p>
<h6><span id="正五边形问题">正五边形问题</span></h6><p>观察正五边形在复平面上的图像,注意到有两对点互为共轭复数,我们令:</p>
<script type="math/tex; mode=display">
\sigma_1=z_1+z_4\\
\sigma_2=z_2+z_3</script><p>不难验证:</p>
<script type="math/tex; mode=display">
\sigma_1+\sigma_2=-1\\
\sigma_1\sigma_2=-1</script><p>可以求出复合条件的解,将$z$带入又有:</p>
<script type="math/tex; mode=display">
\sigma_1=2\cos\frac{2\pi}{5}\\
\sigma_2=2\cos\frac{4\pi}{5}</script><p>于是我们显然可以求得.</p>
<h6><span id="正七边形">正七边形</span></h6><p>类似正五边形,最后会导出三次方程:根中含有三次根号,因此不行.</p>
<h6><span id="正n边形">正n边形</span></h6><p><del>要解决正17边形,只需要解决正n边形,然后令n=17即可</del>.</p>
<p><del>你问我咋想到的下面的证明?问高斯去.</del></p>
<p>下面其实用到了ntt知识,但我懒得扔下面了.</p>
<p>先假设$n\in prime$,我们用$p$代替$n$.</p>
<p>我们有$z_1=\cos\frac{2\pi}{p}+i\sin\frac{2\pi}{p}$,由于其它的$z$都可以表示成它的幂,因此我们记$\varepsilon =z_1$.</p>
<p>我们现在想要这么分组:</p>
<script type="math/tex; mode=display">
\sigma_{k+1}=\sum_{1\leq l\leq p-1,f(l,k)=1}\varepsilon^l</script><h3><span id="泰勒展开">泰勒展开</span></h3><p>即$f(x)=g(x)=f(x_0)+\sum_{k\geq 1}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k\\$.$x_0=0$的时候是麦克劳林级数.</p>
<p>麦克劳林展开是生成函数的基础,我们所谓的生成函数的封闭形式其实就是麦克劳林展开的逆运算(可能也不能完全等价,但笔者能力不够,暂且这么理解).</p>
<h2><span id="多项式">多项式</span></h2><h3><span id="多项式基础">多项式基础</span></h3><h4><span id="点值表示法和系数表示法">点值表示法和系数表示法</span></h4><p>代数基本定理:一个$n-1$次方程在复数域上有且只有$n-1$个根.</p>
<p>定理:一个$n-1$次多项式在$n$个不同点的取值唯一确定了该多项式.</p>
<p>证明:考虑反证法,假设命题不成立,则存在两个$n-1$次多项式$A(x)$和$B(x)$且有$\forall i\in[0,n-1],A(x_i)=B(x_i)\\$.</p>
<p>令$C(x)=A(x)-B(x)$,那么$C(x)$至多是一个$n-1$次多项式且$\forall i\in[0,n-1],C(x_i)=0\\$,也就是$C(x)$有$n$个根,与代数基本定理不符合.</p>
<p>由上面的内容,多项式有点值表示法和系数表示法两种:</p>
<p>系数表示法:$A(x)=\sum_{i=0}^{n-1}a_ix^i\\$.</p>
<p>点值表示法:$y_i=\sum_{j=0}^{n-1}a_jx_i^j\\$.</p>
<p>已知多项式点值表示法求系数表示法的过程被称为插值.</p>
<h4><span id="拉格朗日插值">拉格朗日插值</span></h4><p>构造多项式$\sum_{i=0}^{n-1}y_i(\prod_{j=0\and j\ne i}^{n-1}\frac {x-x_j}{x_i-x_j})\\$.显然当$x=x_i$时,该多项式的答案为$y_i$.</p>
<p>另外,如果$x_i=i$,不难发现这个式子可以写成:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}y_i(\prod_{j=1\and j\ne i}^{n}\frac {x-x_j}{x_i-x_j})\\\\
=\sum_{i=1}^ny_i(\prod_{j=1\and j\ne i}^n\cfrac{x-j}{i-j})\\
=\sum_{i=1}^ny_i(-1)^{n-i}(\cfrac{1}{(i-1)!(n-i)!}\prod_{j=1,j\ne i}^{n}(x-j))</script><h3><span id="多项式运算">多项式运算</span></h3><p>考虑两个多项式相乘,如果我们已知他们的点值表示法,显然可以直接相乘.</p>
<p>这为我们提供了一种思路:先将系数表示法转化为点值表示法,进行相乘之后再转化回系数表示法.</p>
<p>这引出以FFT为代表的多项式乘法,并拓展到了多种多项式运算.</p>
<h4><span id="多项式乘法">多项式乘法</span></h4><h5><span id="快速傅里叶变换fft">快速傅里叶变换(FFT)</span></h5><h6><span id="dft">DFT</span></h6><p>将$n$次单位根(默认$n$是二的整次幂,如果少了的话补零,设$n=2^w$)分别带入$A(x)$得到点值向量$A(\omega_n^k)\\$.</p>
<p>如果朴素带入,复杂度显然不可接受.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
A(x)=\sum_{i=0}^{n-1}a_ix^i\\=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^i+\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^i\\
=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{2k}+x\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{2k}\\</script><p>令$A_1(x)=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{k},<br>A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\$,那么$A(x)=A_1(x^2)+xA_2(x^2)\\$.</p>
<p>接下来分类讨论:</p>
<p>$\forall 0\leq k\leq \frac n 2-1,k\in\mathbb{N}\\$,我们有:</p>
<script type="math/tex; mode=display">
A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})\\</script><p>根据折半引理:</p>
<script type="math/tex; mode=display">
A(\omega_n^k)=A_1(\omega_{\frac n 2}^k)+\omega_n^kA_2(\omega^k_{\frac n 2})\\</script><p>这样我们处理完了前半部分.</p>
<p>$\forall \frac n 2\leq k+\frac n 2\leq n-1,k\in\mathbb{N}\\$,我们有:</p>
<script type="math/tex; mode=display">
A(\omega_n^{k+\frac n 2})=A_1(\omega_n^{2k+n})+\omega_n^{k+\frac n 2}A_2(\omega_n^{2k+n})\\</script><p>根据消去引理:</p>
<script type="math/tex; mode=display">
A(\omega_n^{k+\frac n 2})=A_1(\omega_{\frac n 2}^k)-\omega_n^kA_2(\omega_{\frac n 2}^k)\\</script><p>综上,我们可以递归处理$A_1$和$A_2$,然后合并得到$A$的答案,可以分治.</p>
<h6><span id="idft">IDFT</span></h6><p>设$A(\omega_n^k)=d_k\\$,构造多项式$F(x)=\sum_{i=0}^{n-1}d_ix^i\\$.</p>
<p>我们求出$F(x)$的点值表示,设$c_k=F(\omega_n^{-k})\\$,也即:</p>
<script type="math/tex; mode=display">
c_k=\sum_{i=0}^{n-1}d_i(\omega_n^{-k})^i\\=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}\\</script><p>当$j=k$时,显然$\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n\\$.</p>
<p>否则根据等比数列求和公式,$\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=\frac{\omega^0_n[(\omega_n^{j-k})^n-1]}{\omega_n^{j-k}-1}=0\\$.</p>
<p>所以$\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n[j=k]\\$.</p>
<p>那么我们有$c_k=na_k,<br>a_k=\frac{c_k}{n}\\$.</p>
<h6><span id="写法">写法</span></h6><p>递归写法显然.</p>
<p>递归过程中,第$k$层相当于在根据数在第$k$位的二进制数是$1$还是$0$来分类.那显然可以求出最后一层的数组,然后向上合并.</p>
<p>(没找到fft的代码,懒得写了,直接用的ntt的,注意快速幂要处理幂为负数的情况).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	rev[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> limit,ll *a,ll t)</span></span>&#123;<span class="comment">//DFT:t=1;IDFT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;rev[i])std::<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;i+=n)&#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">				ll wakn=w*a[i+k+mid]%mod;</span><br><span class="line">				ll ak=a[i+k];</span><br><span class="line">				a[i+k]=ak+wakn;<span class="built_in">Mod</span>(a[i+k]);</span><br><span class="line">				a[i+k+mid]=ak-wakn+mod;<span class="built_in">Mod</span>(a[i+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">mpow</span>(limit,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)&#123;</span><br><span class="line">			a[i]=a[i]*inv%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="快速数论变换ntt">快速数论变换(NTT)</span></h5><p>由于FFT中的单位根会产生精度误差,因此在膜$998244353$意义下,通常会选择NTT来进行多项式乘法.</p>
<p>NTT与FFT的运算过程基本相同,证明过程基本相同,唯一不同的是将单位根改为了原根.</p>
<p>根据上面FFT的证明过程,我们知道,设原根为$g$,$g_n=g^{\frac {p-1}n}\\$,只需要证明原根满足以下条件,就可以进行变换:</p>
<ol>
<li>$g_n^n=g_n^0=1$且$\forall 0\leq i&lt;j&lt;n,g_n^i\ne g_n^j$,证明由原根的性质.</li>
<li>折半引理:$g_{2n}^{2k}=g_{n}^k$,证明显然.</li>
<li>消去引理:$g_{n}^{k+\frac n 2}=-g^k_n\\$.由于$g^{\frac {p-1}2}=-1$,该结论显然成立.</li>
</ol>
<p>由上我们证明了,我们完全可以使用$g_n$代替$\omega_n$进行变换.</p>
<p>另外,注意到$998244352=2^{23}\times 7\times 17\\$,而$2^{23}\approx 8\times 10^6\\$.因而,当$n\leq 8\times 10^6$的时候,$g_n$可以直接求出.这也是为什么大部分NTT题目都使用$998244353$作为模数的原因.</p>
<h5><span id="范德蒙德矩阵理解">范德蒙德矩阵理解</span></h5><p>范德蒙德矩阵形如:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&\alpha_1&\cdots&\alpha_1^{n-1}\\1&\alpha_2&\cdots&\alpha_2^{n-1}\\\vdots&\vdots&\ddots&\vdots\\1&\alpha_m&\cdots&\alpha_m^{n-1}\end{bmatrix}\in\mathbb{R}^{m\times n}</script><p>如果取单位根,我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&1&\cdots&1\\1&\omega_n^1&\cdots&\omega_2^{n-1}\\\vdots&\vdots&\ddots&\vdots\\1&\omega_n^{n-1}&\cdots&\omega_n^{(n-1)^2}\end{bmatrix}\in\mathbb{R}^{n\times n}</script><p>这就是我们在做FFT(一个线性变换)的时候的变换矩阵.所以我们有:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&1&\cdots&1\\1&\omega_n^1&\cdots&\omega_2^{n-1}\\\vdots&\vdots&\ddots&\vdots\\1&\omega_n^{n-1}&\cdots&\omega_n^{(n-1)^2}\end{bmatrix}^{-1}=\frac{1}{n}\begin{bmatrix}1&1&\cdots&1\\1&\omega_n^{-1}&\cdots&\omega_2^{-(n-1)}\\\vdots&\vdots&\ddots&\vdots\\1&\omega_n^{-(n-1)}&\cdots&\omega_n^{-(n-1)^2}\end{bmatrix}</script><h4><span id="分治fft">分治FFT</span></h4><p>给定$g(x)$和$f(0)$,求$f(x)=\sum_{y=1}^xf(x-y)g(y)$,答案对$998244353$取膜.</p>
<p>考虑分治,假如我们已经知道了$f(x),x\in[1,\frac n 2]$.那我们可以计算出这段部分对$f(y)，y\in[\frac n 2+1,n]$的贡献.</p>
<p>这显然是一个卷积的形式,我们直接计算$f$和$g$的乘积并贡献上去.</p>
<h4><span id="多项式求逆">多项式求逆</span></h4><p>对于多项式$P(x)$,找到$Q(x)$使得$Q(x)P(x)\equiv 1\pmod {x^{n}}\\$.显然$Q(x)$是唯一的.</p>
<p>首先不妨设$n=2^k\\$.</p>
<p>如果我们已知$P(x)Q_{k-1}(x)\equiv 1\pmod {x^{2^{k-1}}}\\$,同时肯定有$P(x)Q_{k}(x)\equiv 1\pmod {x^{2^{k-1}}}\\$,相减得到$Q_k(x)-Q_{k-1}(x)\equiv 0\pmod {x^{2^{k-1}}}\\$.</p>
<p>两边平方:</p>
<script type="math/tex; mode=display">
Q_k^2(x)+Q^2_{k-1}(x)-2Q_k(x)Q_{k-1}(x)\equiv 0\pmod {x^{2^k}}\\</script><p>两边乘一下$P(x)$:</p>
<script type="math/tex; mode=display">
Q_k(x)-2Q_{k-1}(x)+P(x)Q_{k-1}^2(x)\equiv 0\pmod {x^n}\\
Q_k(x)\equiv 2Q_{k-1}(x)-P(x)Q_{k-1}^2(x)\pmod {x^n}\\</script><p>根据主定理，这么做复杂度是$O(n\log_2n)$的.</p>
<p>同时,多项式求逆可以解决上面提到的分治FFT.我们注意到分治FFT的条件等价于:</p>
<script type="math/tex; mode=display">
F(x)\equiv F(x)G(x)+f_0\pmod {x^{n+1}}\\
F(x)=\frac{f(0)}{1-G(x)}\pmod {x^{n+1}}</script><p>于是可以直接做多项式求逆.</p>
<h4><span id="多项式除法">多项式除法</span></h4><p>对于$n$次多项式$F(x)$和$m$次多项式$G(x)$,找到$Q(x),R(x)$使得$F(x)=G(x)Q(x)+R(x)\\$.</p>
<p>考虑对于$n$次多项式$F(x)$,令$F_R(x)=x^n F(\cfrac{1}{x})$,如果设$f_i$为其$x^i$项前的系数,不难发现$f_R(i)=f(n-i)$.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
F(x)=G(x)Q(x)+R(x)\\
F(\cfrac{1}{x})=G(\cfrac{1}{x})Q(\cfrac{1}{x})+R(\cfrac{1}x)\\
x^nF(\cfrac{1}{x})=x^mG(\cfrac{1}{x})x^{n-m}Q(\cfrac{1}{x})+x^{n-m+1}x^{m-1}R(\cfrac{1}{x})\\
F_R(x)=G_R(x)Q_R(x)+x^{n-m+1}R_R(x)\\
F_R(x)\equiv G_R(x)Q_R(x)\pmod {x^{n-m+1}}\\
Q_R(x)\equiv F_R(x)G_R^{-1}(x)\pmod {x^{n-m+1}}</script><p>于是只要做一遍多项式求逆即可求得$Q(x)$,再做一遍相减既可以得到$R(x)$.</p>
<h4><span id="多项式ln">多项式ln</span></h4><p>给出$n-1$次多项式$A(x)$,求一个多项式$B(x)$,满足$B(x)\equiv \ln A(x)$.</p>
<p>我们有:</p>
<script type="math/tex; mode=display">
B(x)\equiv \ln A(x)\pmod {x^n}\\
B'(x)\equiv \cfrac{A'(x)}{A(x)}\pmod {nx^{n-1}}\\
B(x)\equiv \int \cfrac{A'(x)}{A(x)}dx\pmod {x^n}\\</script><p>另外,考虑中间求导的过程中,其实模数也要相应发生变化,但是由于模数是从更高次变低,而最后积分的时候又要变回来,所以可以直接忽略变化.</p>
<p>定理:在模意义下当且仅当$[x^0]f(x)=1$的时候,$f(x)$有对数多项式.</p>
<p>我们对最后再做一步:</p>
<script type="math/tex; mode=display">
B(x)\equiv \int_0^x \cfrac{A'(t)}{A(t)}dt+B(0)\pmod {x^n}\\</script><p>首先$B(0)=\ln A(0)=\ln a_0$,如果$a_0\in\mathbb{Q}\and a_0\ne 1$,则$B(0)\notin \mathbb{Q}$,因此不能放到模意义下,自然不存在对数多项式.</p>
<p>若$[x^0]f(x)=1$的时候,$B(0)=0$,因此可以直接求出答案.</p>
<h4><span id="牛顿迭代">牛顿迭代</span></h4><p>给定多项式$G(x)$,求一个多项式$F(x)$满足$G(F(x))\equiv 0\pmod {x^n}$.</p>
<p>首先$n=1$的时候,也就是求$G(F(x))\equiv 0\pmod x$.这个要根据具体题目具体分析求出.</p>
<p>假设我们已经求出了在$\bmod x^{\lceil\frac{n}{2}\rceil}$意义下的答案$F_0(x)$,我们考虑在$F_0(x)$处做泰勒展开:</p>
<script type="math/tex; mode=display">
G(F(x))=\sum_{k=0}^{+\infty}\frac{G^{(k)}(F_0(x))}{k!}(F(x)-F_0(x))^k\equiv 0\pmod{x^n}\\</script><p>考虑$F(x)-F_0(x)$,由于$F_0(x)\equiv F(x)\pmod{x^{\lceil\frac{n}{2}\rceil}}$,因此,因此$(F(x)-F_0(x))^2\equiv 0\pmod{x^n}$.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{+\infty}\frac{G^{(k)}(F_0(x))}{k!}(F(x)-F_0(x))^k\equiv 0\pmod{x^n}\\
G(F_0(x))+G'(F_0(x))(F(x)-F_0(x))\equiv 0\pmod{x^n}\\
F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\pmod{x^n}</script><p>牛顿迭代可以用来证明多项式求逆的式子同样正确.</p>
<h4><span id="多项式开方">多项式开方</span></h4><p>给定$h(x)$,设$g(f(x))=f^2(x)-h(x)$,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
f(x)\equiv f_0(x)-\frac{f^2(x)-h(x)}{2f_0(x)}\equiv \frac{f^2(x)+h(x)}{2f_0(x)}\pmod{x^n}</script><p>还没完,用牛顿迭代前一定要求$g(a)\equiv 0\pmod {x^n}$的解,也就是$[x^0]h(x)$的开根,用二次剩余算.</p>
<h4><span id="多项式exp">多项式exp</span></h4><p>给定$h(x)$,设$g(f(x))=\ln f(x)-h(x)$,求零点.</p>
<p>根据牛顿迭代,有:</p>
<script type="math/tex; mode=display">
f(x)\equiv f_0(x)-\frac{\ln f_0(x)-h(x)}{\frac{1}{f_0(x)}}\pmod{x^n}\\
\equiv f_0(x)(1-\ln f_0(x)+h(x))\pmod{x^n}</script><p>还没完,还需要求$g(a)\equiv 0\pmod {x^n}$的解,注意到存在$\exp$当且仅当$[x^0]g(x)\equiv 0$,此时$f(x)\equiv 1\pmod{x}$.</p>
<h4><span id="多项式快速幂">多项式快速幂</span></h4><p>求$\ln$后求$\exp$即可,唯一的问题是为什么指数可以对$p$取膜.</p>
<p>我们有一个结论:</p>
<script type="math/tex; mode=display">
f(x^p)\equiv f(x)^p\pmod p</script><p>这个结论很简单,注意到$(a+b)^p\equiv a^p+b^p\pmod p$即可.</p>
<p>而又由于$n&lt;p$,因此$f(x)^p\equiv f(0)\pmod p$,通常取$f(0)=1$,于是就可以直接对$p$取膜.</p>
<h4><span id="多项式运算全家桶重载运算符版">多项式运算全家桶(重载运算符版)</span></h4><p>我们必须指出的一点是,虽然重载运算符很好看,但是大部分情况下还是需要指针传参.例如在这里,由于做$\exp$的时候的直接数组传参,会导致$\exp$的复杂度退化到$O(n\log^2n)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> qwq 300007</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gn=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rev[qwq];</span><br><span class="line">ll inv[qwq];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">poly</span>&#123;</span><br><span class="line">	ll x[qwq];</span><br><span class="line">	<span class="type">int</span> limit,k;</span><br><span class="line">&#125;a;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mod</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=mod)x-=mod;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mpow</span><span class="params">(ll x,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;<span class="number">0</span>)k+=mod<span class="number">-1</span>;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k=k&gt;&gt;<span class="number">1</span>,x=x*x%mod)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_inv</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;qwq<span class="number">-7</span>)<span class="keyword">return</span> <span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">if</span>(inv[x])<span class="keyword">return</span> inv[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> inv[x]=<span class="built_in">mpow</span>(x,mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_rev</span><span class="params">(<span class="type">int</span> limit,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;limit;++i)&#123;</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(poly *a,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="built_in">init_rev</span>((a-&gt;limit),(a-&gt;k));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(rev[i]&gt;i)std::<span class="built_in">swap</span>(a-&gt;x[i],a-&gt;x[rev[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;(a-&gt;limit);mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		ll wn=<span class="built_in">mpow</span>(gn,t*(mod<span class="number">-1</span>)/n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(a-&gt;limit);i+=n)&#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*wn%mod)&#123;</span><br><span class="line">				ll wakn=w*(a-&gt;x[i+k+mid])%mod;</span><br><span class="line">				ll ak=(a-&gt;x[i+k]);</span><br><span class="line">				a-&gt;x[i+k]=ak+wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k]);</span><br><span class="line">				a-&gt;x[i+k+mid]=ak-wakn;<span class="built_in">Mod</span>(a-&gt;x[i+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">get_inv</span>(a-&gt;limit);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a-&gt;limit;++i)&#123;</span><br><span class="line">			a-&gt;x[i]=(a-&gt;x[i])*inv%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> %(poly x,<span class="type">int</span> k)&#123;<span class="comment">//对x^&#123;2^k&#125;取膜 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="number">1</span>&lt;&lt;k);i&lt;x.limit;++i)x.x[i]=<span class="number">0</span>;</span><br><span class="line">	x.k=k;</span><br><span class="line">	x.limit=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> +(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]+=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> -(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit);</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]-=y.x[i];<span class="built_in">Mod</span>(x.x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span>*(ll x,poly y)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;y.limit;++i)&#123;</span><br><span class="line">		y.x[i]=x*y.x[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> *(poly x,poly y)&#123;</span><br><span class="line">	x.limit=std::<span class="built_in">max</span>(x.limit,y.limit)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	x.k=std::<span class="built_in">max</span>(x.k,y.k)+<span class="number">1</span>;</span><br><span class="line">	y.limit=x.limit;y.k=x.k;</span><br><span class="line">	<span class="built_in">ntt</span>(&amp;x,<span class="number">1</span>);<span class="built_in">ntt</span>(&amp;y,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]=x.x[i]*y.x[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ntt</span>(&amp;x,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">poly q_inv,tmp_inv;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">invpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">		q_inv.x[i]=tmp_inv.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q_inv.x[<span class="number">0</span>]=<span class="built_in">mpow</span>(x.x[<span class="number">0</span>],<span class="number">-1</span>);q_inv.limit=<span class="number">1</span>,q_inv.k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)&#123;</span><br><span class="line">			tmp_inv.x[i]=x.x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		tmp_inv.limit=q_inv.limit=lim;</span><br><span class="line">		tmp_inv.k=q_inv.k=k;</span><br><span class="line">		q_inv=<span class="number">2ll</span>*q_inv-q_inv*q_inv%k*tmp_inv%k;</span><br><span class="line">	&#125;</span><br><span class="line">	q_inv.limit=x.limit;q_inv.k=x.k;</span><br><span class="line">	<span class="keyword">return</span> q_inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> poly <span class="keyword">operator</span> /(poly x,poly y)&#123;</span><br><span class="line">	<span class="type">int</span> lim=x.limit,k=x.k;</span><br><span class="line">	x=x*<span class="built_in">invpoly</span>(y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=lim;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x.limit=lim,x.k=k;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Dpoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//求导 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x.limit;++i)&#123;</span><br><span class="line">		x.x[i<span class="number">-1</span>]=x.x[i]*i%mod;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">Spoly</span><span class="params">(poly x)</span></span>&#123;<span class="comment">//积分 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x.limit<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">		x.x[i+<span class="number">1</span>]=x.x[i]*<span class="built_in">get_inv</span>(i+<span class="number">1</span>)%mod;</span><br><span class="line">		x.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">lnpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Spoly</span>(<span class="built_in">Dpoly</span>(x)/x);</span><br><span class="line">&#125;</span><br><span class="line">poly q_exp,tmp_exp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">exppoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">0</span>);<span class="comment">//无解</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(x.limit&lt;&lt;<span class="number">1</span>);++i)&#123;</span><br><span class="line">		q_exp.x[i]=tmp_exp.x[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q_exp.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_exp.x[i]=x.x[i];</span><br><span class="line">		tmp_exp.limit=q_exp.limit=lim;</span><br><span class="line">		tmp_exp.k=q_exp.k=k;</span><br><span class="line">		q_exp=(q_exp+q_exp*(tmp_exp-<span class="built_in">lnpoly</span>(q_exp)))%k;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> q_exp;</span><br><span class="line">&#125; </span><br><span class="line">poly q_sqrt,tmp_sqrt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">sqrtpoly</span><span class="params">(poly x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//如果不是1要做二次剩余</span></span><br><span class="line">	q_sqrt.x[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> lim=<span class="number">2</span>,k=<span class="number">1</span>;lim&lt;=x.limit;lim=lim&lt;&lt;<span class="number">1</span>,++k)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;++i)tmp_sqrt.x[i]=x.x[i];</span><br><span class="line">		tmp_sqrt.limit=q_sqrt.limit=lim;</span><br><span class="line">		tmp_sqrt.k=q_sqrt.k=k;</span><br><span class="line">		q_sqrt=(q_sqrt*q_sqrt%k+tmp_sqrt)/(<span class="number">2ll</span>*q_sqrt)%k;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> q_sqrt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> poly <span class="title">powpoly</span><span class="params">(poly x,ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x[<span class="number">0</span>]!=<span class="number">1</span>);<span class="comment">//无解</span></span><br><span class="line">	x=k*<span class="built_in">lnpoly</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">exppoly</span>(x);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3><span id="集合幂级数">集合幂级数</span></h3><p>集合幂级数形如$\sum_{i=0}^{2^n-1}a_ix^i$,其中二进制数$i$表示$\{1,2,…,n\}$的一个子集,用$|i|$表示该子集大小,等价于对二进制使用的popcount函数.</p>
<p>下述级数如无特别说明均为集合幂级数.</p>
<h4><span id="与或卷积">与/或卷积</span></h4><p>高维前缀和:$c_i=\sum_{j\subseteq i}a_j\\$.</p>
<p>高维后缀和:$c_i=\sum_{j\supseteq i}a_j\\$.</p>
<p>上述过程又称快速莫比乌斯变换(FMT).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br></pre></td></tr></table></figure>
<p>或卷积:$c_i=\sum_{j}\sum_{k}[j \or k=i]a_jb_k\\$.</p>
<p>与卷积:$c_i=\sum_{j}\sum_{k}[j\and k=i]a_jb_k\\$.</p>
<p>二者求法类似,考虑如何求$a$和$b$的或卷积:</p>
<p>引理:</p>
<p>若$j,k\subseteq i$,则$j\or k\subseteq i$,逆命题同样成立.</p>
<p>若$j,k\supseteq i$,则$j\and k\supseteq i$,逆命题同样成立.</p>
<p>设$a,b,c$的高维前缀和分别为$A,B,C$,我们有:</p>
<script type="math/tex; mode=display">
A_iB_i=(\sum_{j\subseteq i}a_j)(\sum_{k\subseteq i}b_k)\\=\sum_{j,k\subseteq i}a_ib_k\\=\sum_{k\or j\subseteq i}a_ib_k\\=C_i\\</script><p>现在考虑已知$C$求$c$,本质上是一个反演.注意到$\sum_{r\subseteq p}(-1)^{|r|}=\sum_{k=0}^{|p|}C_{|p|}^k(-1)^k=[p=0]\\$,我们有:</p>
<script type="math/tex; mode=display">
c(p)=\sum_{q\subseteq p}[p-q=0]c(q)\\=\sum_{q\subseteq p}\sum_{r\subseteq (p-q)}(-1)^{|r|}c(q)\\
=\sum_{r\subseteq p}(-1)^{|r|}\sum_{q\subseteq (p-r)}c(q)\\=\sum_{r\subseteq p}(-1)^{r}C(p-r)\\=\sum_{r\subseteq p}(-1)^{|p|-|r|}C(r)\\</script><p>于是有$c(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}C(T)\\$(实际上就是个差分的过程).</p>
<p>因而做两遍高维前缀和再反推回去即可,复杂度$O(2^nn)$.</p>
<p>与卷积即改为高维后缀和.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="异或卷积">异或卷积</span></h4><p>异或卷积:$c_i=\sum_j\sum_k[j\oplus k=i]a_jb_k\\$.</p>
<p>引理:$(i\oplus j)\and k=(i\and k)\oplus (j\and k)$.</p>
<p>证明的话考虑如果$k=0$,二者显然相等;当$k=1$的时候,左右都等价于$(i\oplus j)$.</p>
<p>快速沃尔什变换(FWT):</p>
<p>定义集合幂级数$FWT(a)$,满足$FWT(a)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}a_j\\$.</p>
<p>那么有:</p>
<script type="math/tex; mode=display">
FWT(c)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}c_j\\=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}[k\oplus l=j]a_kb_l\\
=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|(k\oplus l)\and i|}a_kb_l\\=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|k\and i|}a_k(-1)^{|l\and i|}b_l\\
=FWT(a)_iFWT(b)_i\\</script><p>时间复杂度$O(2^nn)$.</p>
<p>逆运算的话考虑实现过程,反向就行.不过可以把过程中乘上的$\frac{1}2$都提出来乘到最后.</p>
<p>FMT可以看作是FWT在解决与/或卷积时的特例.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">				a[j+k]=x+y;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">				a[j+k+mid]=x-y;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">		ll inv=<span class="built_in">mpow</span>(limit,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;limit;++i)a[i]=a[i]*inv%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="快速沃尔什变换">快速沃尔什变换</span></h4><h5><span id="线性代数角度">线性代数角度</span></h5><p>我们来重定义一下所谓的FWT.</p>
<p>首先类比FFT,我们希望存在一个线性变换$FWT$,使得</p>
<ol>
<li>若$c_i=\sum_{j\oplus k}a_jb_k$,则$FWT(c)=FWT(a)FWT(b)$.</li>
<li>这个线性变换是可逆的.</li>
<li>做这个线性变换和其逆变换的复杂度都可以接受.</li>
</ol>
<p>我们设$FWT(A)_i=\sum_{j}w(i,j)A_j$,我们想要做的就是构造一组满足上述条件的$w$.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
FWT(C)_i=FWT(A)_iFWT(B)_i\\
\sum_{j}w(i,j)C_j=\sum_{j,k}w(i,j)w(i,k)A_jB_k</script><p>再考虑:</p>
<script type="math/tex; mode=display">
C=A*B\\
C_i=\sum_{k\oplus l=i}A_kB_l\\
\sum_{j}w(i,j)C_j=\sum_jw(i,j)\sum_{k\oplus l=j}A_kB_l\\
\sum_{j,k}w(i,j)w(i,k)A_jB_k=\sum_jw(i,j)\sum_{k\oplus l=j}A_kB_l\\
\sum_{j,k}w(i,j)w(i,k)A_jB_k=\sum_{j,k}A_jB_kw(i,j\oplus k)</script><p>比较两边系数,有$w(i,j)w(i,k)=w(i,j\oplus k)$.只要满足这个条件,我们就能构造出一组满足条件(1)的线性变换.如果这个线性变换对应的矩阵可逆,那么就满足了条件(2).</p>
<p>而由于$\oplus$是集合的运算,我们可以对二进制分开考虑.换句话说,如果$a=\sum_{i=0}a_i2^i,b=\sum_{i=0}b_i2^i$,那么$w(a,b)=\prod_{i=0}w(a_i,b_i)$一定是满足条件的.</p>
<p>这样我们就可以只求一个$2\times 2$的线性变换矩阵就好.我们接下来将对三种常见的基础位运算($\or,\and,xor(\oplus)$)分别讨论这个矩阵.我们先来解决第三个问题:如何快速求出$FWT(a)$呢?</p>
<p>考虑和FFT一样折半,令$i_0$为$i$的最高位是否是$1$,$i’$为$i$去掉最高位后的二进制数字,令$n=2^m$我们有:</p>
<script type="math/tex; mode=display">
FWT(A)_i=\sum_{j=0}^{2^m-1}w(i,j)A_j\\
=\sum_{j=0}^{2^{m-1}-1}w(i,j)A_j+\sum_{j=2^{m-1}}^{2^m-1}w(i,j)A_j\\
=w(i_0,0)\sum_{j=0}^{2^{m-1}-1}w(i',j')A_j+w(i_0,1)\sum_{j=2^{m-1}}^{2^m-1}w(i',j')A_j</script><p>这样就实现了规模减半,复杂度$O(mn)$.</p>
<p>下面我们设FWT的变换矩阵为$\begin{bmatrix}w(0,0)&amp;w(0,1)\\w(1,0)&amp;w(1,1)\end{bmatrix}$.顺便一提,不难发现,最后对整体做的矩阵是这个矩阵的克罗内多积.</p>
<h6><span id="或卷积">或卷积</span></h6><p>取矩阵$\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}$.其逆矩阵为$\begin{bmatrix}1&amp;0\-1&amp;1\end{bmatrix}$.</p>
<h6><span id="与卷积">与卷积</span></h6><p>取矩阵$\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}$.其逆矩阵为$\begin{bmatrix}1&amp;-1\\0&amp;1\end{bmatrix}$.</p>
<h6><span id="异或卷积">异或卷积</span></h6><p>取矩阵$\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}$.其逆矩阵为$\begin{bmatrix}\frac{1}2&amp;\frac12\\\frac12&amp;-\frac12\end{bmatrix}$.</p>
<h5><span id="生成函数角度">生成函数角度</span></h5><p>我们再从生成函数角度理解一下FWT.</p>
<p>我们重新定义幂乘法:$x^Sx^T=x^{S\oplus T}$,显然幂乘法该满足的性质它都满足.</p>
<p>观察FWT的式子:</p>
<script type="math/tex; mode=display">
FWT(A)_S=\sum_{T=0}^{2^n-1}(-1)^{|S\and T|}a_T\\
IFWT(A)_S=\frac{1}{2^n}FWT(A)_S</script><p>这等价于:</p>
<script type="math/tex; mode=display">
[x^S]FWT(A)=\sum_{T=0}^{2^n-1}(-1)^{|S\and T|}a_T\\
[x^S]IFWT(A)=[x^S]\frac{1}{2^n}FWT(A)</script><h4><span id="子集卷积">子集卷积</span></h4><p>子集卷积:$c_i=\sum_{j}\sum_{k}[j\and k=\empty,j\or k=i]a_jb_k\\$.</p>
<p>意识到该卷积与或卷积的差别在于:或卷积会多累加一些$[j\and k\ne \empty]$的答案,而$[j\and k=\phi,j\or k=i]=[|j|+|k|=|i|,j\or k=i]\\$.</p>
<p>因而可以将原集合按照元素个数分组做FMT,然后再$n^2$次结合,并做IFMT,最终将结果累计,复杂度$O(2^nn^2)$.</p>
<h4><span id="集合占位幂级数">集合占位幂级数</span></h4><p>其实就是设$g_{i,j}=z^if_j$,然后做卷积(类似子集卷积).</p>
<h4><span id="example">Example</span></h4><h5><span id="example1agc034f-rng-and-xor">Example1([AGC034F] RNG and XOR)</span></h5><p>设$f_i(n)$表示操作$n$次后第一次变成$i$的概率,$g_i(n)$表示操作$n$次后变成$i$的概率.$F,G$分别是其生成函数.</p>
<p>注意到$G_i=F_iG_0,F_i=\frac{G_i}{G_0}$,而$F_i’(1)$就是期望.接下来的问题在于如何求$G$.</p>
<p>接下来涉及到的东西就很本质了,我们一开始先把$a_i\rightarrow \frac{a_i}{\sum a}$,然后做$A=FWT(a)$,注意这里$A_0=\sum a=1$,FWT自身有很好的性质:$a=\frac{1}{2^N}FWT(A)$.我们做$n$次操作后得到的概率数组也就是$\frac{1}{2^N}FWT(A^n)$.展开FWT的式子,自然有:</p>
<script type="math/tex; mode=display">
g_i(n)=\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}A_j^nx^n\\
G_i=\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}\frac{1}{1-A_jx}\\
F_i=\frac{G_i}{G_0}\\
F_i'=\frac{G_i'G_0-G_0'G_i}{G_0^2}\\
=\frac{(\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}\frac{A_j}{(1-A_jx)^2})(\sum_{j=0}^{2^N-1}\frac{1}{1-A_jx})-(\sum_{j=0}^{2^N-1}\frac{A_j}{(1-A_jx)^2})(\sum_{j=0}^{2^N-1}(-1)^{|i\and j|}\frac{1}{1-A_jx})}{(\sum_{j=0}^{2^N-1}\frac{1}{1-A_jx})^2}</script><p><del>(我草这个式子太顶级了)</del></p>
<p>但是我们冷静一下,这个题与普通生成函数不同的地方在于,我们要求$F’_i(1)$,因此我们直接把$x=1$带入算一算就好.不过由于$A_0=1$,我们必须要解决分母为$0$的情况,解决的方法是分母乘上$(1-x)$,这样就消掉了$j=0$的项,同时分子由于是减法可以抵消一下.</p>
<p>然后大概做做吧,感觉太顶级了.</p>
<h5><span id="example2qoj5089环覆盖">Example2([QOJ5089]环覆盖)</span></h5><p>合法显然当且仅当每个点度数为偶数,考虑直接拿一个二进制数将每个点度数奇偶性压起来,如果选中一条边$u\leftrightarrow v$就异或上$(2^u+2^v)$.最后要求这个二进制数是$0$.我们用一个二元组$(a,F)$表示在集合幂级数上异或上$a$,在多项式上乘上$F$.显然一条边是$(0,1)+(2^u+2^v,x)$.注意到这是可以定义乘法运算和标量乘法运算的,也就能做FWT,而且在做FWT的时候要么乘上$1+x$要么乘上$1-x$,做完FWT得到的每一个$FWT_i$一定形如$(1+x)^k(1-x)^{m-k}$,做IFWT的时候直接求$\frac{1}{2^N}\sum (1+x)^k(1-x)^{m-k}$即可.</p>
<p>仔细想想这个过程:有一句名言是只要看到生成函数就一定存在分配律,这里也是一样的,由于存在一种选择:选不选这条边,因此这里也就有了两种情况:$(0,1)$和$(2^u+2^v,x)$,分开两种情况就实现了FWT.</p>
<p>问题在于对于每个$i$求$k$,也就是对于每个$i$求有多少条边满足$|i\and(2^u+2^v)|=1$,也就是求有多少条边一段链接在了$i$的内部,另一端连接在了外部,这个补集转化一下,做高维前缀和.</p>
<h5><span id="example3cf1034e-little-c-loves-3-iii">Example3(CF1034E Little C Loves 3 III)</span></h5><p>仍然是子集卷积,转化为$c_i=\sum_{j}\sum_{k}[|j|+|k|=|i|,j\or k=i]a_jb_k\\$.然后我们将$a_j$乘上$4^j$,将$b_k$乘上$4^k$,最后把$c_i$除去$4^i$对$4$取膜就行.</p>
<p>还有个用到FWT的本质的矩阵做法,大概是手推矩阵然后再手推求逆.</p>
<h5><span id="example4cf1336e2-chiori-and-doll-picking">Example4(CF1336E2 Chiori and Doll Picking)</span></h5><p>先考虑easy version.首先求出线性基,如果线性基的大小$k$比较小,我们可以直接$2^k$枚举一下.而如果线性基较大,我们先消成最简线性基,然后主元位置有多少个$1$取决于选了多少个元素,其他位置共有$m-k$个,可以直接状压进状态.这样复杂度就是$O(\min\{2^k,m^22^{m-k}\})$.</p>
<p>那么我们怎么优化呢?首先$k$较大的时候有点难做,我们看看能不能优化到$2^{m-k}$.</p>
<p>考虑设$f_i^c=[|i|=c]$,将线性基能做出的线性空间设为$A$,$A_S=1$当且仅当线性基能异或出$S$(最后再把那些废元素贡献到答案里).那么$popcount=c$的答案就是$IFWT(FWT(F)FWT(A))_0$.考虑$IFWT_0=\frac{1}{2^m}\sum_{i=0}^{2^m-1}FWT(F)_iFWT(A)_i$,问题在于这个东西好像也不好做.</p>
<p>然后接下来开始一波顶级操作(下面的操作全部基于行向量+行操作):</p>
<p>引理1:$FWT(A)$要么是$2^k$,要么是$0$.</p>
<p>考虑:</p>
<script type="math/tex; mode=display">
A* A=A\times 2^k</script><p>这句是为啥呢?因为对于右边的每一个数字$x$和左边的一个数字$y$,如果它们都在线性基中,一定存在一个数字$z$满足$y\oplus z=x$,不然就是$0$.</p>
<p>于是我们有:</p>
<script type="math/tex; mode=display">
FWT(A)_i\cdot FWT(A)_i=FWT(A)_i\times 2^k\\
FWT(A)_i=0\or2^k</script><p>引理2:$FWT(A)_i=2^k\Leftrightarrow \forall x,A_x\ne 0,|i\and x|\equiv 0\pmod 2$.</p>
<p>直接展开上面的式子,用$\sum_{S\subseteq T}(-1)^{|S|}=[T=\empty]$.</p>
<p>引理3:$FWT(A)$中值为$2^k$的位置构成一个线性基.</p>
<p>只需要证明封闭性就好,注意到如果$i$满足条件,$j$满足条件,一开始做FWT时我们已经注意到:$(i\oplus j)\and x=(i\and x)\oplus (j\and x)$.于是这个引理也显然成立.</p>
<p>引理4:$FWT(A)$中值为$2^k$的位置构成的线性基的大小是$m-k$.</p>
<p>设这些位置构成的空间是$B$,$B_S=1$当且仅当$S$在这个空间中.我们有:</p>
<script type="math/tex; mode=display">
FWT(A)=B\times 2^k\\
A=IFWT(B)\times 2^k</script><p>注意到$a_0=1$,也就是$\frac{2^k}{2^m}\sum b=1,\sum b=2^{m-k}$,这就证明了引理.</p>
<p>引理5:将$A$的线性基对应的矩阵从前往后消成最简,$B$的线性基对应的矩阵从后往前消成最简,上$A$下$B$拼成一个$m\times m$的矩阵,那么这个矩阵关于主对角线对称.</p>
<p>首先根据$rank(A)+rank(B)=k+m-k=m$可以知道主对角线一定全是$1$,然后我们任取$A$中的一个基$x$和$B$中的一个基$y$,应该有$|x\and y|\equiv 0\pmod 2$.不难发现此时必定对称(画个图,不对称的话考虑主元对他俩的贡献就不是偶数了).</p>
<p>通过这个引理可以由$A$得知$B$长什么样.</p>
<p>引理6:$FWT(F^c)_i$只和$|i|$有关.</p>
<p>因为$F^c_i$只和$|i|$有关,这里考虑一下对称性就可以.因此设$w_{d}^c=FWT(F^c)_i,|i|=d$.</p>
<p>然后注意到$w_d^c=\sum_{i=0}^{2^m-1}(-1)^{|i\and (2^d-1)|}[|i|=c]$.组合意义展开一下:</p>
<script type="math/tex; mode=display">
w_d^c=\sum_{j=0}^{d}(-1)^{j}\binom{d}{j}\binom{m-d}{c-j}</script><p>接下来怎么做呢?令$g_d=\sum_{i=0}^{2^m-1}[A_i=1][|i|=d]$,这里可以$O(2^{m-k})$,然后乘起来就行了.</p>
<p>太顶级了吧.</p>
<h5><span id="example5cf-1326f2">Example5(CF 1326F2)</span></h5><p>首先发现”如果没有边那么是$0$”这个限制太强了,如果我们能改为”如果是$0$,那么可有边可无边”的话,整个序列就会被$1$的段分成若干两两无关的链.显然这是一步或卷积,这样我们就只需要求后者.如果设$g_{len,S}$表示长度为$len$,一段长度为$len-1$的连续的$1$对应的集合是$S$的方案数,不难发现我们最后只需要做一个类似子集卷积的东西就行(前面的每个段会自动在后面放个$0$).</p>
<p>但是还没完,题目让我们求每一个,我们不难发现我们这样划分之后答案只取决于链的长度的可重集合,而本质不同的集合的数量很少,直接枚举就行.</p>
<h5><span id="example6qoj5019">Example6(qoj5019)</span></h5><p>首先可以类似数位dp设计一个$dp_{i,S}$表示目前dp到了第$i$位,然后前面的$limit$是$S$.接下来分类讨论当前的最大值限制是$1$还是$0$.</p>
<p>这个题知道题解其实没什么难的,但是这个题告诉了我们:FWT作为一种线性变换,它是可以和其它线性变换一起做的,也就是说你是可以将其中的若干位做FWT,剩下若干位做其它的东西的.</p>
<h2><span id="生成函数">生成函数</span></h2><h3><span id="普通生成函数ogf">普通生成函数(OGF)</span></h3><h4><span id="概念">概念</span></h4><p>我们定义一个幂级数形如$A(z)=\sum_{k\geq 0}a_kz^k$,并使$[z^n]A(z)=a_n$.则称$A(z)$是$\langle a_0,a_1,…\rangle$的生成函数.</p>
<h4><span id="运算">运算</span></h4><ol>
<li>$\alpha A(z)+\beta B(z)=\sum_{n\geq 0}(\alpha f_n+\beta g_n)z^n$.</li>
<li>$z^mA(z)=\sum_{n\geq 0}g_{n}z^{n+m}=\sum_{n\geq m}g_{n-m}z^n$.</li>
<li>$A(cz)=\sum_{n\geq 0}c^nf_nz^n$.</li>
<li>$A’(z)=\sum_{n\geq 1}ig_iz^{i-1}$.</li>
<li>$\int A(z)dz=\sum_{n\geq 0}\cfrac{1}{n+1}g_nz^{n+1}$.</li>
<li>$A(z)B(z)=\sum_{n\geq 0}(\sum_{k=0}^nf_kg_{n-k})z^n$.</li>
<li>$\cfrac{1}{1-z}A(z)=\sum_{n\geq 0}(\sum_{k=0}^ng_k)z^n$.</li>
</ol>
<h4><span id="常见序列生成函数">常见序列生成函数</span></h4><ol>
<li>$\cfrac{1}{1-z}=\sum_{k\geq 0}z^k\\$,$\cfrac{1}{1-cz}=\sum_{k\geq 0}c^kz^k\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$(1+z)^r=\sum_{k\geq 0}\binom{r}{k}z^k\\$,$(1-z)^r=\sum_{k\geq 0}(-1)^k\binom{r}{k}z^k\\$.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol>
<li>$\cfrac{1}{1-z^m}=\sum_{n\geq 0}[n|m]z^n\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$\cfrac{1}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{n+k}{n}z^k,n\in\mathbb{N}\\$,$\cfrac{z^n}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{k}{n}z^k,n\in\mathbb{N}\\$</li>
</ol>
<p>直接使用二项式定理展开$(1-z)^{-n-1}$,可以得到:</p>
<script type="math/tex; mode=display">
(1-z)^{-n-1}=\sum_{k\geq 0}(-1)^k\binom{-n-1}{k}z^k</script><p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<script type="math/tex; mode=display">
\cfrac{1}{(1-z)^2}=\sum_{n\geq 0}(n+1)z^n\\\cfrac{z}{(1-z)^2}=\sum_{n\geq 0}nz^n</script><p>根据$(1)$求导即可得到此式.</p>
<ol>
<li>$e^z=\sum_{k\geq 0}\cfrac{z^k}{k!}\\$.</li>
<li>$\ln(\cfrac{1}{1-z})=\sum_{n\geq 1}\cfrac{1}{n}z^n$.</li>
<li>$\ln(1+z)=\sum_{k\geq 0}(-1)^k\cfrac{z^{k+1}}{k+1}\\$.</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<ol>
<li>$\frac{1-\sqrt {1-4x}}{2x}=\sum_{k\geq 0}\frac{\binom{2k}{k}}{k+1}x^k$.</li>
</ol>
<p>也即卡特兰数$C_k$的生成函数,证明考虑:</p>
<script type="math/tex; mode=display">
xC^2+1=C</script><p>然后得到两个根,带入$x=0$舍掉一个.</p>
<h3><span id="指数生成函数egf">指数生成函数(EGF)</span></h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53079223">https://zhuanlan.zhihu.com/p/53079223</a></p>
<p>序列$\{a\}$的指数生成函数定义为形式幂级数$\hat F(x)=\sum a_n\frac{x^n}{n!}$.注意$[x^n]\hat F(x)=a_n$.</p>
<h4><span id="基本运算">基本运算</span></h4><p>我们有:</p>
<script type="math/tex; mode=display">
\hat F(x)\hat G(x)=\sum_{j\geq 0}a_j\frac{x^j}{j!}\sum_{k\geq 0}b_k\frac{x^k}{k!}\\
=\sum_{k\geq 0}x^k\sum_{j=0}^ka_jb_{k-j}\frac{k!}{j!(k-j)!}\frac{1}{k!}\\
=\sum_{k\geq 0}\frac{x^k}{k!}\sum_{j=0}^ka_jb_{k-j}\binom{k}{j}</script><p>即$\lang\sum_{i=0}^n\binom{n}{i}a_ib_{n-i}\rang$的EFG.</p>
<p>注意到有一个特例是$x\hat F(x)$就是$\lang\binom{n}{n-1}a_i\rang$的EGF.</p>
<h4><span id="封闭式">封闭式</span></h4><ol>
<li>$e^x=\sum_{k\geq 0}\frac{x^k}{k!}$</li>
</ol>
<p>直接泰勒展开就可以得到</p>
<ol>
<li>$e^{px}=\sum_{k\geq 0}p^k\frac{x^k}{k!}$</li>
</ol>
<p>换元后可以得到.一个经典特例是$e^{-x}=\sum_{k\geq 0}(-1)^k\frac{x^k}{k!}$.</p>
<ol>
<li>$\frac{e^x+e^{-x}}{2}=\sum_{k\geq 0}[2|k]\frac{x^k}{k!}$.</li>
</ol>
<p>显然.</p>
<ol>
<li>$(1+x)^n=\sum_{k\geq 0}n^{\underline{k}}\frac{x^k}{k!}$.</li>
</ol>
<p>做二项式定理就显然了.</p>
<ol>
<li>$\ln(1+x)=\sum_{k\geq 1}(-1)^{k-1}(k-1)!\frac{x^k}{k!}$.</li>
<li>$\ln(1-x)=\sum_{k\geq 1}(k-1)!\frac{x^k}{k!}$.</li>
</ol>
<p>都可以通过泰勒展开证明.</p>
<h4><span id="exp的组合意义">EXP的组合意义</span></h4><p>我们设$F_k(n)$为$n$个有标号元素划分成$k$个非空无序集合的情况,$f_i$为$i$个元素组成一个集合的时候,其上特定组合结构的数量(就是一个一个只和$|S|$有关的定义在集合上的函数),有:</p>
<script type="math/tex; mode=display">
F_k(n)=\frac{n!}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}}{a_j!}</script><p>设$\hat{F}(x)=\sum_{n\geq 0}f_n\frac{x^n}{n!}$,再设:</p>
<script type="math/tex; mode=display">
\hat G_k(x)=\sum_{n\geq 0}F_k(n)\frac{x^n}{n!}\\
=\sum_{n\geq 0}x^n\frac{1}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}}{a_j!}\\
=\sum_{n\geq 0}\frac{1}{k!}\sum_{\sum_{i=1}^ka_i=n}\prod_{j=1}^k\frac{f_{a_j}x^{a_j}}{a_j!}\\
=\frac{1}{k!}\hat F^k(x)</script><script type="math/tex; mode=display">
\sum_{k\geq 0}\hat G_k(x)=\exp \hat F(x)</script><p>或者直接递推:</p>
<script type="math/tex; mode=display">
F_k(x)=\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\frac{1}{k}\\</script><script type="math/tex; mode=display">
\hat G_k(x)=\sum_{n\geq 0}\frac{x^n}{n!}F_k(n)\\
=\sum_{n\geq 0}\frac{x^n}{n!}\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\frac{1}{k}\\
=\frac{1}{k}\sum_{n\geq 0}\frac{x^n}{n!}\sum_{i=1}^{n-k+1}\binom{n}{i}F_{k-1}(n-i)f_i\\
=\frac{1}{k}\hat G_{k-1}(x)\hat F(x)\\
=\frac{1}{k!}\hat F^k(x)</script><p>简而言之,$[x^n]\hat F(x)$是将$n$个有标号的元素放到同一个无序集合的方案数,而$[x^n]\exp \hat F(x)$是将$n$个有标号的元素分成若干个无编号的非空无序集合的方案数.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1poj3734">Example1(POJ3734)</span></h5><p>对于红黄色砖块,其选取方案为$\{1,0,1,0,\cdots\}$,对应的EGF是$\frac{e^x+e^{-x}}{2}$.</p>
<p>对于蓝绿色砖块,选取方案是$e^x$.</p>
<p>乘起来有:</p>
<script type="math/tex; mode=display">
\hat F(x)=(\frac{e^x+e^{-x}}{2})^2e^{2x}\\
=\frac{(e^{2x}+2+e^{-2x})e^{2x}}{4}\\
=\frac{e^{4x}+2e^{2x}+1}{4}\\
=\frac{1}{4}+\sum_{k\geq 0}\frac{4^i+2^{i+1}}{4}\frac{x^i}{i!}</script><p>于是有$[x^n]\hat F(x)=4^{n-1}+2^{n-1}$.</p>
<h5><span id="example2圆排列">Example2(圆排列)</span></h5><p>长度为$n$的排列数的指数生成函数是$\hat P(x)=\sum_{n\geq 0}\frac{n!x^n}{n!}=\frac{1}{1-x}$.</p>
<p>长度为$n$的圆排列的指数生成函数是$\hat Q(x)=\sum_{n\geq 0}\frac{(n-1)!x^n}{n!}=\frac{x^n}{n}=-\ln (1-x)=\ln\frac{1}{1-x}$.</p>
<p>于是有$\exp\hat Q(x)=\hat P(x)$.</p>
<p>这个怎么理解呢?考虑一个排列可以分成若干个置换环,而一个集合能形成的置换环数量显然就是圆排列.</p>
<h5><span id="example3错排数">Example3(错排数)</span></h5><p>从置换环的角度考虑,错排是指置换环中不存在自环的排列,也就是说不存在长度为$1$的置换环,其EGF显然是$\sum_{n\geq 2}\frac{x^n}{n}=-\ln(1-x)-x$,错排数的EGF对其取$\exp$即可.</p>
<h5><span id="example4点带编号无向连通图计数">Example4(点带编号无向连通图计数)</span></h5><p>考虑如果$n$个点带编号的无向连通图的EGF是$\hat F(x)$,那么$n$个点带标号无向图的EGF就是$\exp \hat F(x)$,后者直接计数,前者对后者做一次$\ln$就好.</p>
<h5><span id="example5不动点计数">Example5(不动点计数)</span></h5><p>求有多少个映射$f:\{1,2,\cdots,n\}\mapsto\{1,2,\cdots,n\}$满足$f\circ f\circ \cdots \circ f$(共$k$个$f$)$=f\circ f\circ \cdots\circ f$(共$k-1$个$f$).</p>
<p>考虑将$i\rightarrow f_i$,这等价于对深度不超过$k$的基环树(环的长度为$1$)计数,等价于对深度不超过$k$的有根树计数.注意到删去根节点后等价于对深度不超过$k-1$的有根树计数,因此$\hat F_k(x)=x\exp \hat F_{k-1}(x)$.</p>
<h5><span id="example6cf891elust">Example6([CF891E]Lust)</span></h5><p>假设$k$次操作后$a_i$减少了$b_i$,实际上要求的就是$\prod_{i=1}^na_i-\prod_{i=1}^n(a_i-b_i)$.</p>
<p>考虑对所有情况下的$\prod_{i=1}^n(a_i-b_i)$求和,注意到$k$次操作,使得$i$出现$b_i$次的方案数是$\frac{k!}{\prod_{i=1}^nb_i!}$.直接设$a_j$的EGF是</p>
<script type="math/tex; mode=display">
\hat F_{j}(x)=\sum_{i\geq 0}(a_j-i)\frac{x^i}{i!}\\=\sum_{i\geq 0}a_j\frac{x^i}{i!}-\sum_{i\geq 1}\frac{x^i}{(i-1)!}\\
=a_je^x-xe^x=(a_j-x)e^x</script><p>答案就是$[x^k]\prod_{j=1}^n\hat F_j(x)$.</p>
<h5><span id="example7">Example7</span></h5><h3><span id="狄利克雷生成函数dgf">狄利克雷生成函数(DGF)</span></h3><p>对于序列$f_n$,定义其DGF为$\tilde F(x)=\sum_{i\geq 1}\frac{f_i}{i^x}$.注意到若$f$是积性函数,那么$\tilde{F}(x)=\prod_{p\in prime}\sum_{i\geq 0}\frac{f_{p^i}}{p^{ix}}\\$.</p>
<h4><span id="基本运算">基本运算</span></h4><p>对于两个序列$f,g$,其DGF之积对应的是两者的狄利克雷卷积序列的DGF:</p>
<script type="math/tex; mode=display">
\tilde{F}(x)\tilde{G}(x)=\sum_{i}\sum_{j}\frac{f(i)g(j)}{(ij)^x}\\
=\sum_{i}\frac{1}{i^x}\sum_{d|i}f(d)g(\frac{i}{d})</script><h4><span id="封闭式">封闭式</span></h4><ol>
<li>$\epsilon(x)=[x=1]$.</li>
</ol>
<p>显然为$\tilde{E}(x)=1$.</p>
<ol>
<li>$I(x)=1$.</li>
</ol>
<p>其封闭式是黎曼函数$\zeta(x)$,事实上,我们有:</p>
<script type="math/tex; mode=display">
\zeta(x)=\prod_{i\geq 1}\frac{1}{i^x}\\=\prod_{p\in prime}\sum_{i\geq 0}\frac{1}{p^{ix}}\\=\prod_{p\in prime}\frac{1}{1-p^{-x}}</script><ol>
<li>$\mu(n)$.</li>
</ol>
<p>其DGF为$\tilde{M}(x)=\prod_{p\in prime}(1-p^{-x})$.注意到$\zeta(x)\tilde{M}(x)=1,\tilde{M}(x)=\frac{1}{\zeta(x)}$.</p>
<ol>
<li>$id(n)=n$.</li>
</ol>
<p>有$\tilde{ID}(n)=\prod_{i\geq 1}\frac{i}{i^x}=\prod_{i\geq 1}\frac{1}{i^{x-1}}=\zeta(x-1)$.</p>
<ol>
<li>$I_k(n)=n^k$.</li>
</ol>
<script type="math/tex; mode=display">
\tilde{I_k}(x)=\prod_{i\geq 1}\frac{1}{i^{x-k}}=\zeta(x-k)</script><ol>
<li>$\varphi(n)$.</li>
</ol>
<p>注意到:</p>
<script type="math/tex; mode=display">
\tilde{\Phi}(x)=\prod_{p\in prime}(1+\frac{p-1}{p^x}+\frac{p(p-1)}{p^{2x}}+\cdots)\\
=\prod_{p\in prime}\frac{1-p^{-x}}{1-p^{1-x}}\\
=\tilde{\Phi}(x)=\frac{\zeta(x-1)}{\zeta(x)}</script><p>也注意到$\tilde{\Phi}(x)I(x)=\zeta(x-1)=\tilde{ID}(x)$.</p>
<ol>
<li>$\sigma_k(n)=\sum_{d|n}d^k$.</li>
</ol>
<p>注意到$\sigma_k(n)=I_k(n)*I_0(n)$,也就是说$\tilde{S}(x)=\zeta(x-k)\zeta(x)$.</p>
<ol>
<li>$u(n)=|\mu(n)|$.</li>
</ol>
<p>$\tilde{u}(n)=\frac{\zeta(n)}{\zeta(2n)}$.</p>
<h4><span id="example">Example</span></h4><h5><span id="example1luogup3768">Example1(luoguP3768)</span></h5><p>考虑对于$f(n)=n^2\varphi(n)$构造积性函数$g(n),h(n)$使得$f*g=h$.</p>
<p>注意到:</p>
<script type="math/tex; mode=display">
\tilde{F}(x)=\prod_{p\in prime}(1+\sum_{k\geq 1}\frac{p^{3k-1}(p-1)}{p^{kx}})\\=\prod_{p\in prime}\frac{1-p^{2-x}}{1-p^{3-x}}=\frac{\zeta(x-3)}{\zeta(x-2)}</script><p>也就是$f*I_2=I_3$.</p>
<h3><span id="阶乘的扩展定义">阶乘的扩展定义</span></h3><p>对于复数的阶乘,我们通常定义:</p>
<script type="math/tex; mode=display">
\cfrac{1}{z!}=\lim_{n\rightarrow +\infin}\binom{n+z}{z}n^{-z}</script><p>同时我们定义$\Gamma(z+1)=z!$,有:$(-z)!\Gamma(z)=\cfrac{\pi}{\sin(\pi z)}$.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<script type="math/tex; mode=display">
z^{\underline{w}}=\cfrac{z!}{(z-w)!}\\
z^{\overline{w}}=\cfrac{\Gamma(z+w)}{\Gamma(z)}</script><p>通过以上我们还可以有二项式系数的定义:</p>
<script type="math/tex; mode=display">
\binom{z}{w}=\lim_{\zeta\rightarrow z,\omega\rightarrow w}\cfrac{\zeta!}{\omega!(\zeta-\omega)!}</script><h3><span id="超几何级数">超几何级数</span></h3><h4><span id="超几何函数">超几何函数</span></h4><p>我们定义超几何函数$F(a_1,…,a_m;b_1,…b_n;z)=F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$\cfrac{0}{0}=1$之类的式子,可以发现当$z=0$时任意超几何函数总是$=1$.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0$或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4><span id="特殊的超几何函数">特殊的超几何函数</span></h4><h5><span id="合流超几何函数">合流超几何函数</span></h5><p>我们通常把形如$M(a;b;z)=F\left(\begin{array}{r|}a\\b\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}}{b^{\overline{k}}k!}$的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}1\\1\end{array}z\right)=e^z</script><p>也即常见生成函数中的$(6)$.</p>
<h5><span id="高斯超几何函数">高斯超几何函数</span></h5><p>我们把形如$F\left(\begin{array}{r|}a,b\\c\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}b^{\overline{k}}}{c^{\overline{k}}k!}$的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\1\end{array}z\right)=\cfrac{1}{1-z}$.</li>
</ol>
<p>即常见生成函数$(1)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}-a,1\\1\end{array}-z\right)=(1+z)^a$.</li>
</ol>
<p>即常见生成函数$(2)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}a,1\\1\end{array}z\right)=\cfrac{1}{(1-z)^a}$.</li>
</ol>
<p>即常见生成函数$(4)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\2\end{array}-z\right)=\cfrac {\ln(1+z)}z$.</li>
</ol>
<p>即常见生成函数$(7)$.</p>
<h4><span id="超几何级数的应用">超几何级数的应用</span></h4><p>我们先考虑改写超几何级数的形式:</p>
<p>$F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}t_k,t_k=\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>不难发现$t_0=1$,而:</p>
<script type="math/tex; mode=display">
\cfrac{t_{k+1}}{t_k}=\cfrac{z^{k+1}}{z^k}\cfrac{k!}{(k+1)!}\cfrac{\prod_{i=1}^ma_i^{\overline{k+1}}}{\prod_{i=1}^ma_i^{\overline{k}}}\cfrac{\prod_{i=1}^nb_i^{\overline{k}}}{\prod_{i=1}^nb_i^{\overline{k+1}}}\\
=\cfrac{\prod_{i=1}^m(k+a_i)}{\prod_{i=1}^n(k+b_i)}\cfrac{z}{k+1}</script><p>换句话说,$\cfrac{t_{k+1}}{t_k}$是关于$k$的一个有理函数.而根据代数基本定理,任意$k$的有理函数在$\mathbb{C}$内都可以分解为以上的形式(如果缺少$k+1$项则需要上下同时乘以$k+1$以补上).</p>
<p>换句话说,对于一个无穷级数$\sum_{k\geq 0}t_k$,我们先将$\cfrac{t_{k+1}}{t_k}$表示回超几何函数,设为$F$.</p>
<p>那么有:$\sum_{k\geq 0}t_k=t_0F$.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$\Gamma$函数的定义)来使这些公式全部成立.But who cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5><span id="example">Example</span></h5><p>求证:$\sum_{k\leq n}\binom{r+k}{k}=\binom{r+n+1}{n}\Leftrightarrow F\left(\begin{array}{r|}1,-n\-n-r\end{array}1\right)=\cfrac{r+n+1}{r+1},n\in\mathbb{N}\\$.</p>
<p>首先考虑:</p>
<script type="math/tex; mode=display">
\sum_{k\leq n}\binom{r+k}{k}=\sum_{k\geq 0}\binom{r+n-k}{n-k}</script><p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<script type="math/tex; mode=display">
\binom{r+n}{n}F\left(\begin{array}{r|}1,-n\\-n-r\end{array}1\right)=\binom{r+n+1}{n}</script><p>两边同时除以$\binom{r+n}{n}$得到上式.</p>
<h5><span id="二项式系数与超几何函数">二项式系数与超几何函数</span></h5><p>通过范德蒙德卷积,不难验证:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b\\c\end{array}1\right)=\cfrac{\Gamma(c-a-b)\Gamma(c)}{\Gamma(c-a)\Gamma(c-b)},-b\in\mathbb{N}</script><p>这个公式的一个特例是:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,-n\\c\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\
\sum_{k\geq 0}\cfrac{a^{\overline{k}}(-n)^{\overline{k}}}{c^{\overline{k}}k!}=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\</script><p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b,-n\\c,a+b-n-c+1\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}(c-b)^{\overline{n}}}{c^{\overline{n}}(c-a-b)^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}(b-c)^{\underline{n}}}{(-c)^{\underline{n}}(a+b-c)^{\overline{n}}},n\in\mathbb{N}\\</script><p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3><span id="求微分方程">求微分方程</span></h3><h4><span id="example1luogu4931">Example1(luogu4931)</span></h4><p>二项式反演:</p>
<script type="math/tex; mode=display">
ans_k=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}\binom{n}{i}\binom{n}{i}i!(2n-2i)!2^i\\
=\sum_{i=k}^n(-1)^{i-k}\frac{1}{k!(i-k)!}\frac{n!}{(n-i)!}\frac{n!}{(n-i)!}(2n-2i)!2^i\\
=(n!)^2\frac{2^k}{k!}\sum_{i=k}^n(-1)^{i-k}\frac{1}{(i-k)!}\binom{2n-2i}{n-i}2^{i-k}\\
=(n!)^2\frac{2^k}{k!}\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}</script><p>注意到后者只与$n-k$有关,不妨设其为$f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}$,预处理一下就可以做到$O(n^2+nT)$.</p>
<p>加强版咋做?我们继续看看式子:</p>
<script type="math/tex; mode=display">
ans=(n!)^2\frac{2^k}{k!}f_{n-k}\\
f_{n}=\sum_{i=0}^{n}\frac{(-2)^{i}}{i!}\binom{2n-2i}{n-i}</script><p>注意到$f$是一个卷积的形式,设其生成函数为$F_n$,$g_n=\frac{(-2)^n}{n!},h_n=\binom{2n}{n}$,我们自然有$F=GH$.</p>
<p>考虑$G$和$H$的生成函数形式,先看$G$,显然用泰勒展开:</p>
<script type="math/tex; mode=display">
G=\sum_{n\geq 0}\frac{(-2x)^n}{n!}=e^{-2x}</script><p>再看$H$,是卡特兰数的生成函数,有:</p>
<script type="math/tex; mode=display">
H=\frac{1}{\sqrt{1-4x}}</script><p>这下简单了,答案是:</p>
<script type="math/tex; mode=display">
(n!)^2\frac{2^k}{k!}[x^{n-k}]\frac{e^{-2x}}{\sqrt {1-4x}}</script><p>现在看$F$,平方一下有:</p>
<script type="math/tex; mode=display">
(1-4x)F^2=e^{-4x}</script><p>两边求导:</p>
<script type="math/tex; mode=display">
-4F^2+(1-4x)2F\times F'=-4e^{-4x}\\
-4F^2+(1-4x)2F\times F'=-4(1-4x)F^2\\
(2-8x)F'=16xF\\</script><p>得到了一个线性递推形式,更进一步地:</p>
<script type="math/tex; mode=display">
2(i+1)f_{i+1}-8if_i=16f_{i-1}\\
if_i=4(i-1)f_{i-1}+8f_{i-2}</script><p>技术总结一下:其实就是你想要得到一个递推式,然后注意到这玩意要写成微分方程的形式,所以开始往那边凑.</p>
<h3><span id="生成函数的应用">生成函数的应用</span></h3><h4><span id="求解递归关系">求解递归关系</span></h4><p>我们假设已经有了$R(z)=\sum_{k\geq 0}g_kz^k$,并且$R(z)=\cfrac{P(z)}{Q(z)}$,其中$P(z)$和$Q(z)$都是多项式,我们想要找到一种方式求解$[z^n]R(z)$.</p>
<p>考虑有理函数$S(z)=\sum_{k=1}^m\cfrac{a_k}{1-\rho_kz}\\$,不难发现$[z^n]S(z)=\sum_{k=1}^ma_k\rho_k^n\\$.</p>
<p>那么可以证明,只要$Q(z)=0$无重根并且无零根,那么就存在一组系数满足$S(z)=R(z)$.</p>
<p>我们这么定义”反射”运算,若$Q(z)=\sum_{k=0}^mq_kz^k\\$,则其反射多项式为$Q^R(z)=\sum_{k=0}^mq_kz^{m-k}\\$.</p>
<p>若$Q(z)=q_0\prod_{k=1}^m(1-\rho_kz)$,则显然有$Q^R(z)=q_0\prod_{k=1}^m(z-\rho_k)\\$.</p>
<p>那么显然这里求出来的这组数$\rho$就是$S(z)$中的那组$\rho$.</p>
<p>而我们有$a_k=\cfrac{-\rho_kP(\cfrac{1}{\rho_k})}{Q’(\rho_k)}$.</p>
<h4><span id="example1">Example1</span></h4><p>已知$n!=\sum_{k}\binom{n}{k}g_{n-k},n\in\mathbb{N}\\$,求$g_n$.</p>
<p>首先两边同时除以$n!$并将组合数用阶乘形式展开,我们有:</p>
<script type="math/tex; mode=display">
1=\sum_{k}\cfrac{g_{n-k}}{k!(n-k)!}.</script><p>如果我们令$D(z)=\sum_{k\geq 0}\cfrac{g_{k}}{k!}z^k$,则有:</p>
<script type="math/tex; mode=display">
\cfrac{1}{1-z}=e^zD(z)\\
D(z)=\cfrac{1}{1-z}e^{-z}\\
D(z)=(\sum_{k\geq 0}z^k)(\sum_{k\geq 0}(-1)^k\cfrac{z^k}{k!})\\
[z^n]D(z)=\sum_{k=0}^n\cfrac{(-1)^k}{k!}</script><p>于是$g_n=n!\sum_{k=0}^n\cfrac{(-1)^k}{k!}\\$.</p>
<h4><span id="example2qoj5169-夹娃娃">Example2([QOJ5169] 夹娃娃)</span></h4><p>首先设$F_i(x)$为第$i$家的生成函数,这个是显然可以快速预处理出来的.令$M=520$.</p>
<p>问题在于每次询问的时候求出答案呢?</p>
<p>这里有一个套路:我们在一开始就暴力做点值,最后拿拉格朗日插值求答案.中间大概把能预处理的都预处理一下.最后的问题在于:</p>
<p>第一,预处理点值的时候,一共有$n$个多项式,最高次数是$M$,因此一共要插入$nM$个值,又要处理每个后缀,复杂度来到$O(n^2M^3)$.这个问题是好解决的.我们只需要在带入点值的时候做一个后缀继承一类的东西,复杂度就可以来到$O(n^2M^2)$.</p>
<p>第二,询问的时候需要找到所有对应的点值并暴力乘起来,复杂度来到$O(n^2Mq)$.但$n$如此小,我们可以用指数级别的复杂度来优化,我们考虑预处理一下$2^n$的答案,复杂度来到$O(nM2^nq)$.但是这个更不太行.那怎么办呢?我们把这个指数级别的东西分块一下.预处理复杂度来到$O(\frac{n}{B}B2^BMnM)$,单次询问复杂度来到$O(\frac{n}{B}Mnq)$.但这个预处理复杂度好像还是有点艰难.不过注意到如果做一个剪枝优化:如果总共的喜欢的店的个数乘以$k$要大于$m$,就直接输出$0$.预处理的时候块内部也做一个剪枝,然后发现就能过了(牛逼).</p>
<p>第三,拉格朗日插值的时候需要$O((nM)^2q)$的复杂度,不过由于点值可以自己控制,这个复杂度可以轻松降到$O(nMq)$.</p>
<h4><span id="example3十二省联考-2019-皮配">Example3([十二省联考 2019] 皮配)</span></h4><p>首先注意到题目等价于规定一个阵营和一个排序的人数上下界.</p>
<p>我们可以将这四位导师分别记为$xy,y,x,1$,这样最后判断幂在一个区间内的$x$和$y$前面的系数就行.</p>
<p>注意到如果没有学校有偏好,将生成函数卷起来后得到的答案就是$\prod (x^{s_i}y^{s_i}+x^{s_i})+\prod(y^{s_i}+1)=(\prod (x^{s_i}+1))(\prod(y^{s_i}+1))$.也就是$x$和$y$是互相独立的,我们可以分开算.</p>
<p>对于那些有偏好的学校,我们暴力算就行.复杂度不会高于$O(mk^2s)$.最后两部分合并一下.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%9B%BE%E8%AE%BA/" rel="prev" title="图论">
                  <i class="fa fa-angle-left"></i> 图论
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="next" title="字符串">
                  字符串 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
