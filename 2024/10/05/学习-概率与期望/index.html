<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="离散概率  基本定义 期望的简单运算 方差的简单运算 随机抽样调查 条件概率  贝叶斯公式  概率生成函数  Example1 Example2(Penney游戏) Example3([SDOI2017] 硬币游戏)  二项式分布 模型  树上随机游走  Example1 Example2  计数与期望的转换  Example(Code">
<meta property="og:type" content="article">
<meta property="og:title" content="概率与期望">
<meta property="og:url" content="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="离散概率  基本定义 期望的简单运算 方差的简单运算 随机抽样调查 条件概率  贝叶斯公式  概率生成函数  Example1 Example2(Penney游戏) Example3([SDOI2017] 硬币游戏)  二项式分布 模型  树上随机游走  Example1 Example2  计数与期望的转换  Example(Code">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-04T16:04:37.200Z">
<meta property="article:modified_time" content="2025-04-14T16:41:12.733Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/","path":"2024/10/05/学习-概率与期望/","title":"概率与期望"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>概率与期望 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我永远喜欢言和和！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">离散概率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">基本定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">期望的简单运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">方差的简单运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">随机抽样调查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">条件概率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.5.1.</span> <span class="nav-text">贝叶斯公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">概率生成函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.6.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.6.2.</span> <span class="nav-text">Example2(Penney游戏)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.6.3.</span> <span class="nav-text">Example3([SDOI2017] 硬币游戏)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">二项式分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.8.</span> <span class="nav-text">模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.8.1.</span> <span class="nav-text">树上随机游走</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.8.2.</span> <span class="nav-text">计数与期望的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">Example(CodeChef Secplayer)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.8.3.</span> <span class="nav-text">一些小技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">Example1(CF865C)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">Example2(猎人杀)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">Example3(AGC019F)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">数据随机下的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">随机化算法的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.1.</span> <span class="nav-text">数值概率算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.</span> <span class="nav-text">Monte Carlo算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">求解最优化问题的Monte
Carlo算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">求解判定性问题的Monte
Carlo算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.3.</span> <span class="nav-text">正确率与复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.4.</span> <span class="nav-text">算法设计思路1</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.4.1.</span> <span class="nav-text">设计一个能解决问题的确定性算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.4.2.</span> <span class="nav-text">向算法引入随机化优化复杂度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.5.</span> <span class="nav-text">算法设计思路2</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.5.1.</span> <span class="nav-text">设计一个能解决问题的确定性算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.5.2.</span> <span class="nav-text">向算法引入随机化优化复杂度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.6.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.6.1.</span> <span class="nav-text">Example 1(Millar-Rabin算法)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.6.2.</span> <span class="nav-text">Example2(CodeChef MSTONE)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.6.3.</span> <span class="nav-text">Example3(CF364D Ghd)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.2.0.6.4.</span> <span class="nav-text">Example4([POI2014]Couriers)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.0.7.</span> <span class="nav-text">Example5([NOI2013] 向量内积)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.3.</span> <span class="nav-text">Las Vegas算法(Sherwood算法)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">算法设计思路</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.1.1.</span> <span class="nav-text">设计一个能解决问题的确定性算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.1.2.</span> <span class="nav-text">向算法引入随机化优化复杂度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.3.0.2.</span> <span class="nav-text">Example</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.2.1.</span> <span class="nav-text">快速排序算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.2.2.</span> <span class="nav-text">一类由Monte
Carlo算法改造而成的算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.2.3.</span> <span class="nav-text">Example3(CF329C Graph
Reconstruction)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">3.3.0.2.4.</span> <span class="nav-text">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text">爬山与模拟退火</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.4.1.</span> <span class="nav-text">爬山</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.4.2.</span> <span class="nav-text">模拟退火</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm神仙的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://wminus.github.io/" title="https:&#x2F;&#x2F;wminus.github.io" rel="noopener" target="_blank">麦麦的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="概率与期望 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          概率与期望
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-05 00:04:37" itemprop="dateCreated datePublished" datetime="2024-10-05T00:04:37+08:00">2024-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-15 00:41:12" itemprop="dateModified" datetime="2025-04-15T00:41:12+08:00">2025-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- toc -->
<ul>
<li><a href="#离散概率">离散概率</a>
<ul>
<li><a href="#基本定义">基本定义</a></li>
<li><a href="#期望的简单运算">期望的简单运算</a></li>
<li><a href="#方差的简单运算">方差的简单运算</a></li>
<li><a href="#随机抽样调查">随机抽样调查</a></li>
<li><a href="#条件概率">条件概率</a>
<ul>
<li><a href="#贝叶斯公式">贝叶斯公式</a></li>
</ul></li>
<li><a href="#概率生成函数">概率生成函数</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2penney游戏">Example2(Penney游戏)</a></li>
<li><a href="#example3sdoi2017-硬币游戏">Example3([SDOI2017]
硬币游戏)</a></li>
</ul></li>
<li><a href="#二项式分布">二项式分布</a></li>
<li><a href="#模型">模型</a>
<ul>
<li><a href="#树上随机游走">树上随机游走</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#计数与期望的转换">计数与期望的转换</a>
<ul>
<li><a href="#examplecodechef-secplayer">Example(CodeChef
Secplayer)</a></li>
</ul></li>
<li><a href="#一些小技巧">一些小技巧</a>
<ul>
<li><a href="#example1cf865c">Example1(CF865C)</a></li>
<li><a href="#example2猎人杀">Example2(猎人杀)</a></li>
<li><a href="#example3agc019f">Example3(AGC019F)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#数据随机下的性质">数据随机下的性质</a>
<ul>
<li><a href="#树">树</a></li>
<li><a href="#数">数</a></li>
<li><a href="#序列">序列</a></li>
</ul></li>
<li><a href="#随机化算法的分类">随机化算法的分类</a>
<ul>
<li><a href="#数值概率算法">数值概率算法</a></li>
<li><a href="#monte-carlo算法">Monte Carlo算法</a>
<ul>
<li><a href="#求解最优化问题的monte-carlo算法">求解最优化问题的Monte
Carlo算法</a></li>
<li><a href="#求解判定性问题的monte-carlo算法">求解判定性问题的Monte
Carlo算法</a></li>
<li><a href="#正确率与复杂度">正确率与复杂度</a></li>
<li><a href="#算法设计思路1">算法设计思路1</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#算法设计思路2">算法设计思路2</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-1">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-1">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example">Example</a>
<ul>
<li><a href="#example-1millar-rabin算法">Example
1(Millar-Rabin算法)</a></li>
<li><a href="#example2codechef-mstone">Example2(CodeChef
MSTONE)</a></li>
<li><a href="#example3cf364d-ghd">Example3(CF364D Ghd)</a></li>
<li><a href="#example4poi2014couriers">Example4([POI2014]Couriers)</a></li>
</ul></li>
<li><a href="#example5noi2013-向量内积">Example5([NOI2013]
向量内积)</a></li>
</ul></li>
<li><a href="#las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</a>
<ul>
<li><a href="#算法设计思路">算法设计思路</a>
<ul>
<li><a href="#设计一个能解决问题的确定性算法-2">设计一个能解决问题的确定性算法</a></li>
<li><a href="#向算法引入随机化优化复杂度-2">向算法引入随机化优化复杂度</a></li>
</ul></li>
<li><a href="#example-1">Example</a>
<ul>
<li><a href="#快速排序算法">快速排序算法</a></li>
<li><a href="#一类由monte-carlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</a></li>
<li><a href="#example3cf329c-graph-reconstruction">Example3(CF329C Graph
Reconstruction)</a></li>
<li><a href="#example4petrozavodsk-summer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</a></li>
</ul></li>
</ul></li>
<li><a href="#爬山与模拟退火">爬山与模拟退火</a>
<ul>
<li><a href="#爬山">爬山</a></li>
<li><a href="#模拟退火">模拟退火</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="离散概率">离散概率</span></h2>
<h3><span id="基本定义">基本定义</span></h3>
<p>概率空间<span class="math inline">\(\Omega\)</span>:在一个给定问题中可能发生的所有情况.</p>
<p>事件:<span class="math inline">\(\Omega\)</span>的一个子集.</p>
<p>基本事件<span class="math inline">\(\omega\)</span>:<span class="math inline">\(\Omega\)</span>中的单个元素,也可以看作集合大小为<span class="math inline">\(1\)</span>的事件.</p>
<p>概率:若<span class="math inline">\(\omega\in
\Omega\)</span>,我们称它发生的概率为<span class="math inline">\(\Pr(\omega)\)</span>,有<span class="math inline">\(\Pr(\omega)\geq 0\)</span>且<span class="math inline">\(\sum_{\omega\in\Omega}\Pr(\omega)=1\)</span>.</p>
<p>随机变量:在概率空间的基本事件上定义的函数.</p>
<p>联合分布:如果两个随机变量<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>定义在同一个概率空间<span class="math inline">\(\Omega\)</span>上,对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,我们称<span class="math inline">\(\Pr(X=x\and Y=y)\)</span>为它们的联合分布.</p>
<p>独立:如果对于每一个在<span class="math inline">\(X\)</span>取值范围内的<span class="math inline">\(x\)</span>以及在<span class="math inline">\(Y\)</span>取值范围内的<span class="math inline">\(y\)</span>,<span class="math inline">\(\Pr(X=x\and
Y=y)=\Pr(X=x)\times \Pr(Y=y)\)</span>,我们称<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是独立的.</p>
<p>期望(均值)<span class="math inline">\(E
X\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的期望<span class="math inline">\(EX=\sum_{x\in X(\Omega)}x\times
\Pr(X=x)=\sum_{w\in\Omega}X(\omega)\Pr(\omega)\)</span>.</p>
<p>中位数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的中位数为满足<span class="math inline">\(\Pr(X\leq x)\geq 0.5\and \Pr(X\geq x)\geq
0.5\)</span>的<span class="math inline">\(x\in
X(\Omega)\)</span>所组成的集合.</p>
<p>众数:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的众数为满足<span class="math inline">\(\Pr(X= x)\geq \Pr(X=x&#39;),\forall x&#39;\in
X(\Omega)\)</span>的<span class="math inline">\(x\in
X(\Omega)\)</span>所组成的集合.</p>
<p>方差<span class="math inline">\(VX\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的方差<span class="math inline">\(VX=E((X-EX)^2)\)</span>.</p>
<p>标准差<span class="math inline">\(\sigma\)</span>:我们设概率空间上的随机变量<span class="math inline">\(X\)</span>的标准差<span class="math inline">\(\sigma=\sqrt{VX}\)</span>.</p>
<h3><span id="期望的简单运算">期望的简单运算</span></h3>
<p>如果<span class="math inline">\(X,Y\)</span>是定义在同一个概率空间上的两个随机变量,那么:</p>
<ol type="1">
<li><span class="math inline">\(E(X+Y)=EX+EY\)</span>.</li>
<li><span class="math inline">\(E(\alpha X)=\alpha EX\)</span>.</li>
<li>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>互相独立,那么<span class="math inline">\(E(XY)=(EX)(EY)\)</span>.</li>
</ol>
<p>上述法则都可以通过期望的定义简单证明.</p>
<h3><span id="方差的简单运算">方差的简单运算</span></h3>
<p>我们考虑方差的定义式: <span class="math display">\[
E((X-EX)^2)=E(X^2-2X(EX)+(EX)^2)\\
=E(X^2)-2(EX)(EX)+(EX)^2\\
=E(X^2)-(EX)^2
\]</span> 也即:方差等于随机变量平方的均值减均值的平方.</p>
<p>当<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>为独立的随机变量时,我们有: <span class="math display">\[
V(X+Y)=E((X+Y)^2)-(EX+EY)^2\\
=E((X+Y)^2)-(EX)^2-2(EX)(EY)-(EY)^2
\]</span> 而又有: <span class="math display">\[
E((X+Y)^2)=E(X^2+2XY+Y^2)\\
=E(X^2)+2(EX)(EY)+E(Y^2)
\]</span> 则: <span class="math display">\[
V(X+Y)=E(X^2)+2(EX)(EY)+E(Y^2)-(EX)^2-2(EX)(EY)-(EY)^2
\\=VX+VY
\]</span> 即:独立随机变量之和的方差等于它们的方差之和.</p>
<p>接下来,我们可以得到切比雪夫不等式: <span class="math display">\[
\Pr((X-EX)^2\geq \alpha)\leq \cfrac{VX}{\alpha},\alpha&gt;0
\]</span> 证明如下: <span class="math display">\[
VX=\sum_{\omega\in \Omega}(X(\omega)-EX)^2\Pr(\omega)\\
\geq
\sum_{\omega\in\Omega}(X(\omega)-EX)^2\Pr(\omega)[(X(\omega)-EX)^2\geq
\alpha]\\
\geq \sum_{\omega\in\Omega}\alpha\Pr(\omega)[(X(\omega)-EX)^2\geq
\alpha]\\=\alpha \Pr((X-EX)^2\geq \alpha)
\]</span> 如果我们用<span class="math inline">\(c^2VX\)</span>代替<span class="math inline">\(\alpha\)</span>,我们就有:</p>
<p><span class="math inline">\(\Pr(|X-EX|\geq c\sigma)\leq
\cfrac{1}{c^2}\)</span>.</p>
<p>简单来说,这个不等式说明:<span class="math inline">\(X\)</span>落在<span class="math inline">\((EX-c\sigma,EX+c\sigma)\)</span>之外的概率至多为<span class="math inline">\(\cfrac{1}{c^2}\)</span>.</p>
<p>另外,如果我们取<span class="math inline">\(n\)</span>个独立的样本<span class="math inline">\(X_1,X_2,...,X_n\)</span>,令<span class="math inline">\(S=\sum_{i=1}^nX_i\)</span>,那么它的均值是<span class="math inline">\(nEX\)</span>,标准差是<span class="math inline">\(\sqrt n\sigma\)</span>,也就是说,<span class="math inline">\(\cfrac{S}{n}\)</span>落在<span class="math inline">\((EX-\cfrac{c\sigma}{\sqrt
n},EX+\cfrac{c\sigma}{\sqrt n})\)</span>之外的概率小于等于<span class="math inline">\(\cfrac{1}{c^2}\)</span>.</p>
<h3><span id="随机抽样调查">随机抽样调查</span></h3>
<p>如果我们随机取得了<span class="math inline">\(n\)</span>个值<span class="math inline">\(X_1,X_2,...,X_n\)</span>,那么我们可以通过这些值来估计概率空间的期望和方差.</p>
<p><span class="math inline">\(\hat
EX=\cfrac{\sum_{i=1}^nX_i}{n}\)</span>.</p>
<p><span class="math inline">\(\hat
VX=\cfrac{\sum_{i=1}^nX_i^2}{n-1}-\cfrac{(\sum_{i=1}^nX_i)^2}{n(n-1)}\)</span>.</p>
<p>这里的<span class="math inline">\(\hat
VX\)</span>似乎与定义不是那么相符.但是它拥有更好的性质:<span class="math inline">\(E(\hat VX)=VX\)</span>.</p>
<p>证明如下: <span class="math display">\[
E(\hat
VX)=\cfrac{1}{n-1}E(\sum_{i=1}^nX_i^2-\cfrac{1}{n}\sum_{j=1}^n\sum_{k=1}^nX_jX_k)\\
=\cfrac{1}{n-1}(\sum_{i=1}^nE(X_i^2)-\cfrac{1}{n}\sum_{i=1}^n\sum_{j=1}^nE(X_iX_j))\\
=\cfrac{1}{n-1}(\sum_{i=1}^nE(X^2)-\cfrac{1}{n}\sum_{i=1}^n\sum_{j=1}^n((EX)^2[j\ne
k]+E(X^2)[j=k]))\\
=\cfrac{1}{n-1}(nE(X^2)-\cfrac{1}{n}(nE(X^2)+n(n-1)(EX)^2))\\
=E(X^2)-(EX)^2\\
=VX
\]</span></p>
<h3><span id="条件概率">条件概率</span></h3>
<p>已知事件B发生时事件A发生的概率为<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\\\)</span>.</p>
<h4><span id="贝叶斯公式">贝叶斯公式</span></h4>
<p>贝叶斯公式:如果有<span class="math inline">\(\{B_i\}\)</span>是样本空间的一个划分,即<span class="math inline">\(\forall i,j\)</span>,有<span class="math inline">\(B_i\cap B_j=\empty\)</span>,并且有<span class="math inline">\(\bigcup_{i=1}^nB_i=\Omega\)</span>.则有<span class="math inline">\(P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(AB_i)}{P(A)\sum
P(B_j)}=\frac{P(A B_i)}{\sum_{j=1}^n P(A
B_j)}=\frac{P(A|B_i)P(B_i)}{\sum_{j=1}^n P(A|B_j)P(B_j)}\\\)</span>.</p>
<p>简化形式:<span class="math inline">\(P(B|A)=\frac{P(A|B)P(B)}{P(A)}\\\)</span>.</p>
<p>另外,我们考虑设<span class="math inline">\(O(B)=\cfrac{P(B)}{P(\lnot
B)}\)</span>,称<span class="math inline">\(\cfrac{P(B|E)}{P(\lnot
B|E)}\)</span>为贝叶斯算子,则同理可得: <span class="math display">\[
O(B|E)=O(B)\cfrac{P(B|E)}{P(\lnot B|E)}
\]</span>
这个公式更加精准地分开了先验概率和后验概率,也表现了贝叶斯算子对先验概率的改变.</p>
<h3><span id="概率生成函数">概率生成函数</span></h3>
<p>如果<span class="math inline">\(X\)</span>是定义在概率空间<span class="math inline">\(\Omega\)</span>上的随机变量,那么它的概率生成函数为<span class="math inline">\(G_X(z)=\sum_{k\geq
0}\Pr(X=k)z^k=E(z^X)\)</span>.</p>
<p>不难发现<span class="math inline">\(G_X(z)\)</span>需要满足的条件:所有系数都非负并且<span class="math inline">\(G_X(1)=1\)</span>.</p>
<p>我们发现,当我们定义了概率生成函数后,期望和方差都可以使用它来表示:
<span class="math display">\[
EX=G_X&#39;(1)\\
E(X^2)=G&#39;&#39;_X(1)+G_X&#39;(1)\\
VX=G_X&#39;&#39;(1)+G_X&#39;(1)-(G_X&#39;(1))^2
\]</span>
通常,我们也可以将方差和均值的定义扩展到任意函数上,于是我们定义: <span class="math display">\[
Mean(G)=G&#39;(1)\\
Var(G)=G&#39;&#39;(1)+G&#39;(1)-(G&#39;(1))^2
\]</span> 不过,求导的过程可能会有些麻烦,但我们可以直接使用泰勒定理:
<span class="math display">\[
G(1+t)=\sum_{i\geq 0}\cfrac{G^{(i)}(1)}{i!}t^i
\]</span> 另外,我们不难发现:<span class="math inline">\(G_{X+Y}(z)=G_X(z)G_Y(z)\)</span>.</p>
<p>根据前面的推导,我们有: <span class="math display">\[
Mean(G_{X+Y})=Mean(G_X)+Mean(G_Y)\\
Var(G_{X+Y})=Var(G_X)+Var(G_Y)
\]</span> 换句话说,若<span class="math inline">\(G_X(1)=1,G_Y(1)=1\)</span>,那么这个式子与直接对<span class="math inline">\(G_{X+Y}\)</span>使用求导的那个公式是等价的.注意,这里并没有要求这些生成函数的系数是非负的.</p>
<p>于是我们有了另一个法则: <span class="math display">\[
Mean(G_X)=Mean(G_{X+Y})-Mean(G_Y)\\
Var(G_X)=Var(G_{X+Y})-Var(G_Y)
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>一枚硬币正面向上的概率为<span class="math inline">\(p\)</span>,反面向上的概率为<span class="math inline">\(q\)</span>,设硬币正面向上为H,反面向上为T,不断抛掷硬币直到抛掷出连续的THTTH为止,求期望次数.</p>
<p>考虑设<span class="math inline">\(N\)</span>为所有不包含THTTH的硬币序列的生成函数,<span class="math inline">\(S\)</span>为所有只有结尾为THTTH的硬币序列的生成函数,令<span class="math inline">\(H=pz,T=qz\)</span>,<span class="math inline">\(1\)</span>为空集,我们显然有: <span class="math display">\[
1+N\times (H+T)=N+S\\
N\times THTTH=S+S\times TTH
\]</span> 解方程即可.</p>
<p>另外不难发现,这种方法取决于字符串的所有border,显然是通用方法.</p>
<p>我们考虑扩展这个方法,设<span class="math inline">\(A\)</span>是我们要找到的字符串,<span class="math inline">\(m\)</span>是它的长度,令<span class="math inline">\(A^{(k)}\)</span>表示<span class="math inline">\(A\)</span>字符串的前<span class="math inline">\(k\)</span>个字符所组成的字符串,<span class="math inline">\(A_{(k)}\)</span>表示<span class="math inline">\(A\)</span>字符串的后<span class="math inline">\(k\)</span>个字符所组成的字符串.这样的形式与<span class="math inline">\(k\)</span>阶导的形式可能会起冲突,但至少在接下来我们的式子中不会出现导数<del>(好吧其实是因为《具体数学》上就这么写的我也懒得改了)</del>.</p>
<p>我们的方程将会变为: <span class="math display">\[
1+N(H+T)=N+S\\
N\times A=S(\sum_{k=0}^{m-1}A^{(k)}[A^{(m-k)}=A_{(m-k)}])
\]</span> 如果我们设<span class="math inline">\(\tilde
A\)</span>为将字符串<span class="math inline">\(A\)</span>中的H替换成<span class="math inline">\(\cfrac{1}{p}z\)</span>,T替换成<span class="math inline">\(\cfrac{1}{q}z\)</span>之后的值,那么显然有: <span class="math display">\[
N\times A=A\times S\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}])\\
N=S\times (\sum_{k=1}^{m}\tilde A_{(k)}[A^{(k)}=A_{(k)}])\\
\cfrac{S-1}{H+T-1}=S\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}])\\
S\times(1+(1-H-T)\times (\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}]))=1
\]</span> 这显然是一个卷积的形式.</p>
<p>令<span class="math inline">\(w=\sum_{k=1}^{m}\tilde
A_{(k)}[A^{(k)}=A_{(k)}]\)</span>.</p>
<p>令<span class="math inline">\(H(z)=1\)</span>,<span class="math inline">\(F(z)=(1+(1-z)\times w)\)</span>,<span class="math inline">\(G(z)=S\)</span>.</p>
<p>那么我们显然可以直接求<span class="math inline">\(G(z)\)</span>的期望和方差,事实上: <span class="math display">\[
EX=\sum_{k=1}^{m}\tilde A_{(k)}[A^{(k)}=A_{(k)}]\\
VX=(EX)^2-\sum_{k=1}^m(2k-1)\tilde A_{(k)}[A^{(k)}=A_{(k)}]
\]</span> 如果硬币是均匀的(<span class="math inline">\(p=q=\cfrac 1
2\)</span>)我们引入另一个符号:我们设<span class="math inline">\(A:A=\sum_{k=1}^m2^{k}[A^{(k)}=A_{(k)}]\)</span>.那么显然期望需要的抛硬币次数就是<span class="math inline">\((A:A)\)</span>.</p>
<h4><span id="example2penney游戏">Example2(Penney游戏)</span></h4>
<p>一枚均匀硬币,设硬币正面向上为H,反面向上为T.不断扔硬币直到扔出连续的HHT或HTT为止,求最后以HHT结尾的概率.</p>
<p>我们设<span class="math inline">\(S_A\)</span>为所有以HHT结尾的硬币序列的生成函数,设<span class="math inline">\(S_B\)</span>为所有以HTT结尾的硬币序列的生成函数.<span class="math inline">\(N\)</span>为其它的硬币序列的生成函数,令<span class="math inline">\(H=T=0.5z\)</span>.</p>
<p>我们显然有: <span class="math display">\[
1+N(H+T)=N+S_A+S_B\\
N\times HHT=S_A\\
N\times HTT=S_A\times T+S_B
\]</span> 解方程并带入<span class="math inline">\(z=1\)</span>,可以有得知以HHT结尾的概率为<span class="math inline">\(\cfrac{2}3\)</span>.</p>
<p>事实上,我们使用类似Example1的方法,设这两个硬币序列分别为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,那么可以求出: <span class="math display">\[
\cfrac{S_A}{S_B}=\cfrac{B:B-B:A}{A:A-A:B}
\]</span></p>
<h4><span id="example3sdoi2017-硬币游戏">Example3([SDOI2017] 硬币游戏)</span></h4>
<p>是Example2的超级加强版.</p>
<p>把上面的东西给形式化一下,不妨设<span class="math inline">\(g_i\)</span>表示进行了<span class="math inline">\(i\)</span>步还未结束的概率,<span class="math inline">\(f_{k,i}\)</span>为进行了<span class="math inline">\(i\)</span>步恰好第<span class="math inline">\(k\)</span>个人胜利的概率,<span class="math inline">\(F,G\)</span>是它们的生成函数,我们自然有:</p>
<ol type="1">
<li><span class="math inline">\(1+xG(x)=\sum_kF_k(x)+G(x)\)</span>.</li>
<li><span class="math inline">\((\frac{1}{2}x)^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^i[A_k^{(L-i)}={A_j}_{(L-i)}]\)</span>.</li>
</ol>
<p>第一个式子的用处在于带入<span class="math inline">\(x=1\)</span>,发现<span class="math inline">\(\sum_{k}F_k(1)=1\)</span>.</p>
<p>把(2)化简一下,有: <span class="math display">\[
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=0}^{L-1}(\frac{1}{2}x)^{i-L}[A_k^{(L-i)}={A_j}_{(L-i)}]\\
x^LG(x)=\sum_{j=1}^nF_j(x)\sum_{i=1}^{L}(\frac{1}{2}x)^{-i}[A_k^{(i)}={A_j}_{(i)}]
\]</span> 带入<span class="math inline">\(x=1\)</span>,有: <span class="math display">\[
G(1)=\sum_{j=1}^nF_j(1)\sum_{i=1}^{L}2^i[A_k^{(i)}={A_j}_{(i)}]
\]</span> 不难发现对于不同的<span class="math inline">\(k\)</span>,(2)的右边不同,而左边一定相同,这样就给出了<span class="math inline">\(n\)</span>个等式,算上(1)一共有<span class="math inline">\(n+1\)</span>个等式,可以算出<span class="math inline">\(G(1),F_{1\cdots n}(1)\)</span>这<span class="math inline">\(n+1\)</span>个未知数.</p>
<h3><span id="二项式分布">二项式分布</span></h3>
<p>现在有一个大小为<span class="math inline">\(n+1\)</span>的概率空间,其中<span class="math inline">\(\Pr(\omega_k)=\binom{n}{k}p^kq^{n-k}\\\)</span>,我们把这样的概率序列称为二项式分布.</p>
<p>如果我们令<span class="math inline">\(H(z)=q+pz\)</span>,不难发现二项式分布的生成函数为<span class="math inline">\(H(z)^n\)</span>.</p>
<p>不难发现,满足二项式分布的随机变量的均值是<span class="math inline">\(np\)</span>,方差是<span class="math inline">\(npq\)</span>.</p>
<p>与二项式分布相对应的还有负二项式分布,它的生成函数形如:<span class="math inline">\(G(z)^n=(\cfrac{p}{1-qz})^n=\sum_{k}\binom{n+k-1}{k}p^nq^kz^k\)</span>.</p>
<p>我们考虑如何求<span class="math inline">\(G(z)\)</span>的方差和均值,不妨设<span class="math inline">\(F(z)=\cfrac{1-qz}{p}=\cfrac{1}{p}-\cfrac{q}{p}z\)</span>,则<span class="math inline">\(G(z)^n=F(z)^{-n}\)</span>.</p>
<p>不难发现<span class="math inline">\(F(z)\)</span>满足二项式分布.也就是说,以<span class="math inline">\((n,p,q)\)</span>为参数的负二项式分布也就是以<span class="math inline">\((-n,-\cfrac{q}{p},\cfrac{1}{p})\)</span>为参数的二项式分布.</p>
<h3><span id="模型">模型</span></h3>
<h4><span id="树上随机游走">树上随机游走</span></h4>
<p>随机游走指每次从相邻的点中随机选一个走过去，
重复这样的过程若干次.</p>
<h5><span id="example1">Example1</span></h5>
<p>给一棵所有边长都为<span class="math inline">\(1\)</span>的<span class="math inline">\(n\)</span>个点的树,问所有点对<span class="math inline">\((i,j)(1\leq i,j\leq n)\)</span>中,从<span class="math inline">\(i\)</span>走到<span class="math inline">\(j\)</span>的期望距离的最大值是多少.</p>
<p>由于树上简单路径唯一,我们考虑设<span class="math inline">\(f_u\)</span>表示<span class="math inline">\(u\)</span>随机走到它父亲的期望,<span class="math inline">\(g_v\)</span>表示<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的期望.</p>
<p>对于<span class="math inline">\(f_u\)</span>,我们有: <span class="math display">\[
f_u=\cfrac{\sum_{u\rightarrow v}(f_v+f_u)}{\deg_u}+1\\
f_u=\deg_u+\sum_{u\rightarrow v}f_v
\]</span> 对于<span class="math inline">\(g_v\)</span>,我们有: <span class="math display">\[
g_v=\cfrac{g_u+g_v+\sum_{u\rightarrow w,w\ne v}(g_v+f_w)}{\deg_u}+1\\
g_v=g_u+\sum_{u\rightarrow w,w\ne v}f_w+\deg_u
\]</span></p>
<h5><span id="example2">Example2</span></h5>
<p>给出一棵<span class="math inline">\(n\)</span>个节点的树,每个点有可能是黑白两种颜色的一种.</p>
<p>现在从<span class="math inline">\(1\)</span>号点开始随机游走(即走这个点的每条出边的概率是相同的),每到一个点,如果这个点是黑点,或者这是白点并且这个点第一次经过,那么答案<span class="math inline">\(+1\)</span>.当走到度数为<span class="math inline">\(1\)</span>的节点时游走停止.</p>
<p>注意到黑白点对答案的贡献是互相独立的,所以分开讨论:</p>
<p>如果只有黑点,那么显然答案就是路径的期望长度,我们设<span class="math inline">\(f_u\)</span>表示以<span class="math inline">\(u\)</span>为起点的路径的期望长度,不难注意到<span class="math inline">\(f_{leaf}=1\)</span>且<span class="math inline">\(f_u=1+\cfrac{1}{\deg_u}\sum_{u\rightarrow v\or
v\rightarrow
u}f_v\)</span>.这个dp转移显然是有后效性的,可以使用高斯消元做,但有一个经典做法:我们求得<span class="math inline">\(f_u=k_uf_{fa}+b_u\)</span>,然后就可以采取带入化简的方法做了.</p>
<p>如果只有白点,考虑每个点只会贡献一次,所以我们要求出的就是每个点被走到的概率.注意到一个点被走到一定是从它父亲走来的,于是我们需要求出<span class="math inline">\(g_v\)</span>表示从<span class="math inline">\(v\)</span>的父亲(假设是<span class="math inline">\(u\)</span>)走到<span class="math inline">\(v\)</span>的概率,再令<span class="math inline">\(f_u\)</span>表示从<span class="math inline">\(u\)</span>走到父亲的概率,类似Example1,我们有:
<span class="math display">\[
f_u=\cfrac{1}{\deg_u}(1+\sum_{u\rightarrow v} f_vf_u)\\
g_v=\cfrac{1}{\deg_u}(1+g_vg_u+\sum_{u\rightarrow w,w\ne v}f_wg_v)
\]</span> 最后把两部分答案合起来就好.</p>
<h4><span id="计数与期望的转换">计数与期望的转换</span></h4>
<h5><span id="examplecodechef-secplayer">Example(CodeChef Secplayer)</span></h5>
<p>冷静一下,如果我们直接计数的话会发现巨大难做,因为项太多了,直接乘起来也太麻烦了.</p>
<p>这启发我们:当我们注意到一个计数题的各种情况相乘很麻烦的时候,我们不妨只考虑一种情况并计算期望,然后拿期望和总数反推计数.注意到权值最小的人最危险,他不能和其他任何一个人匹配到,不然就死了.那不难求得此时他作为次大值存活的概率为<span class="math inline">\(\frac{1}{\binom{n}{2}}\)</span>.</p>
<p>把所有人权值从大到小排序,设<span class="math inline">\(f_i\)</span>表示只考虑前<span class="math inline">\(i\)</span>个人的时候的期望,不难发现:<span class="math inline">\(f_{i}=\frac{1}{\binom{i}{2}}v_i+(1-\frac{1}{\binom{i}{2}})f_{i-1}\)</span>.</p>
<h4><span id="一些小技巧">一些小技巧</span></h4>
<h5><span id="example1cf865c">Example1(CF865C)</span></h5>
<p>首先写出转移式子,但是存在后效性.如果我们设<span class="math inline">\(f_{i,j}\)</span>表示过了<span class="math inline">\(i\)</span>关,花费为<span class="math inline">\(j\)</span>的期望,不难发现所有的<span class="math inline">\(f\)</span>都需要与<span class="math inline">\(f_{0,0}\)</span>取<span class="math inline">\(\min\)</span>,这咋办?</p>
<p>我们考虑二分这个<span class="math inline">\(f_{0,0}\)</span>,做的时候直接取<span class="math inline">\(\min\)</span>,这样最后还会求出一个<span class="math inline">\(f_{0,0}\)</span>,比较一下大小然后继续做二分.</p>
<p>等一下,为撒子这样是收敛的呢?</p>
<p>首先,根据这个题,期望肯定是存在的.</p>
<p>我们注意到我们一开始二分的<span class="math inline">\(f_{0,0}\)</span>越大,最后的答案就越大,但是增长的一定会变慢.换句话说,最后的答案关于我们二分的值的关系应该是一个上凸的函数(增长的时候会被取<span class="math inline">\(\min\)</span>的另一项限制住,但原本应该是没被限制的),于是这个时候得到的答案如果比二分的答案更小,那我们就应该调小一点.</p>
<p>换句话说,当我们二分答案的时候,应该判断函数凸性.wqs二分也是这个道理:二分答案并判断答案是否满足条件.</p>
<h5><span id="example2猎人杀">Example2(猎人杀)</span></h5>
<p>先做一步转化:如果做期望的时候,会有一些操作变得不能做,那我们改为:先随便选,如果选到不合法的操作就跳过,概率和期望都不会变.</p>
<p>offline</p>
<h5><span id="example3agc019f">Example3(AGC019F)</span></h5>
<p>人类智慧题…</p>
<p>首先注意到策略显然是每次选剩下最多的答案.</p>
<p>我们画一张<span class="math inline">\(n\times
m\)</span>的图(假设<span class="math inline">\(n\geq
m\)</span>),其中格点<span class="math inline">\((a,b)\)</span>表示现在还剩<span class="math inline">\(a\)</span>个Yes,<span class="math inline">\(b\)</span>个No.我们再把我们的策略用图上的有向边表示.我们先考虑转化为计数问题,那答案显然就是所有从<span class="math inline">\((n,m)\)</span>走到<span class="math inline">\((0,0)\)</span>的路径与我们图上有向边的交的大小总和.</p>
<p>然后咧?</p>
<p>我们注意到这张图长得太规律了,换句话说,如果我们把图的左半部分沿着直线<span class="math inline">\(y=x\)</span>翻折(路径也跟着翻折),注意到对着这张图做仍然是一样的!</p>
<p>所以呢?由于从<span class="math inline">\((n,m)\)</span>走到<span class="math inline">\((0,0)\)</span>一定会经过<span class="math inline">\(n\)</span>条有向边,所以期望贡献一定要加上一个<span class="math inline">\(n\)</span>.而如果我走到了直线<span class="math inline">\(y=x\)</span>上,那接下来的贡献是<span class="math inline">\(\frac{1}{2}\)</span>.我们只需要枚举一下走到了多少次即可.</p>
<h2><span id="数据随机下的性质">数据随机下的性质</span></h2>
<h3><span id="树">树</span></h3>
<ol type="1">
<li>随机树树高为<span class="math inline">\(\sqrt n\)</span>.</li>
<li>点的度数期望为<span class="math inline">\(\log n\)</span>.</li>
</ol>
<h3><span id="数">数</span></h3>
<ol type="1">
<li>数字的期望因数个数为<span class="math inline">\(\log
V\)</span>.</li>
</ol>
<h3><span id="序列">序列</span></h3>
<ol type="1">
<li>随机序列的LIS长度期望为<span class="math inline">\(O(\sqrt
n)\)</span>.</li>
</ol>
<h2><span id="随机化算法的分类">随机化算法的分类</span></h2>
<h3><span id="数值概率算法">数值概率算法</span></h3>
<p>即通过随机选取元素从而求得在数值上的近似解.较之于传统算法,其运行速度更快,而且随着运行时间的增加,近似解的精度也会提高.在不可能或不必要求出问题的精确解时,可以使用其得到相当满意的近似解,如随机撒点法(近似求难以计算的图形面积).</p>
<h3><span id="monte-carlo算法">Monte Carlo算法</span></h3>
<p>总是能在确定的运行时间内出解,但是得到的解有一定概率是错的.通常出错的概率比较小,因此可以通过反复运行算法来得到可以接受的正确率.</p>
<h5><span id="求解最优化问题的montecarlo算法">求解最优化问题的Monte
Carlo算法</span></h5>
<p>事实上,大部分最优化问题都可以转化为判定性问题:也就是判定一个解是否是最优解,因此我们接下来基本都是讨论的求解判定性问题的Monte
Carlo算法.</p>
<h5><span id="求解判定性问题的montecarlo算法">求解判定性问题的Monte
Carlo算法</span></h5>
<ol type="1">
<li>假倾向的Monte
Carlo算法:当这类算法的返回值为假的时候,结果一定正确,但返回值为真的时候则有一定概率错误.</li>
<li>真倾向的Monte
Carlo算法:当这类算法的返回值为真的时候,结果一定正确,但返回值为假的时候则有一定概率错误.</li>
<li>产生双侧错误的Monte
Carlo算法:无论返回值为什么都有概率出错.基本不会使用.</li>
</ol>
<p>以下讨论的Monte Carlo算法均为产生单侧错误的Monte Carlo算法.</p>
<h5><span id="正确率与复杂度">正确率与复杂度</span></h5>
<p>显然,如果我们有一个单词正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的算法,我们运行其<span class="math inline">\(k\)</span>次,则正确率为<span class="math inline">\(1-(1-p)^k\)</span>,时间复杂度为<span class="math inline">\(O(kf(n))\)</span>.</p>
<h5><span id="算法设计思路1">算法设计思路1</span></h5>
<p>我们来总结一下通常的Monte Carlo算法的设计思路:</p>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举一些元素.</li>
<li>设这个算法的复杂度为<span class="math inline">\(O(f(n)g(n))\)</span>,其中<span class="math inline">\(f(n)\)</span>为枚举部分的复杂度,<span class="math inline">\(g(n)\)</span>为单词枚举中计算所需的复杂度.大部分情况下应保证<span class="math inline">\(g(n)\)</span>不会很大.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找元素来降低复杂度.</li>
<li>计算随机化情况下的正确率以及复杂度.</li>
</ol>
<h5><span id="算法设计思路2">算法设计思路2</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要用到一个或多个传入的元素.</li>
<li>这个元素的值不应该依赖于输入数据.</li>
<li>我们可以通过check这个元素来得到与答案有关的信息.</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机这个元素.</li>
<li>计算随机化情况下的正确率以及复杂度</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="example-1millar-rabin算法">Example 1(Millar-Rabin算法)</span></h6>
<p>略</p>
<h6><span id="example2codechef-mstone">Example2(CodeChef MSTONE)</span></h6>
<p>平面上有<span class="math inline">\(n\)</span>个互不重合的点,已知存在不超过<span class="math inline">\(7\)</span>条直线可以覆盖全部的点,问在平面上作一条直线,最多能覆盖多少个点.<span class="math inline">\(n\leq 10000\)</span>.</p>
<p>考虑一个朴素的暴力:枚举两个点,确定一条直线,然后判断多少个点在这条直线上.但是这样复杂度是<span class="math inline">\(O(n^3)\)</span>的.</p>
<p>考虑加入随机化.我们不妨每次随机两个点,注意到存在七条直线覆盖全部的点,那覆盖点最多的直线覆盖的点数一定不少于<span class="math inline">\(\lceil\frac{n}{7}\rceil\)</span>个点.换句话说,我们随机一个点,这个点在这条直线上的概率是<span class="math inline">\(\frac{1}{7}\)</span>,因此随机两个点确定这条直线的概率为<span class="math inline">\(\frac{1}{49}\)</span>.随机<span class="math inline">\(1000\)</span>次,错误概率为<span class="math inline">\(1-(\frac{48}{49})^{1000}\)</span>,是很小的.</p>
<h6><span id="example3cf364d-ghd">Example3(CF364D Ghd)</span></h6>
<p>给定一个长度为<span class="math inline">\(n\)</span>的序列,要求找出一个长度大于等于<span class="math inline">\(\frac{n}{2}\)</span>的子序列,使这个子序列中所有数的<span class="math inline">\(\gcd\)</span>最大,求最大的<span class="math inline">\(\gcd\)</span>.<span class="math inline">\(n\leq
10^6\)</span>,<span class="math inline">\(a_i\leq 10^{12}\)</span>.</p>
<p>注意到我们随机一个数,这个数在最终答案中的概率是<span class="math inline">\(\frac{1}{2}\)</span>.我们不妨直接随机这个数,然后枚举它的因子,判断每个因子在序列中的出现次数即可.但是这样单次复杂度<span class="math inline">\(O(n\sqrt a)\)</span>,好像不太能过.</p>
<p>冷静一下,我们不妨将这<span class="math inline">\(\sqrt
a\)</span>个质因子全都存下来,然后将<span class="math inline">\(n\)</span>个数也全都存下来,做狄利克雷后缀和即可.不过直接做可能还需要离散化/map,我们考虑先把所有数与我们随机到的那个数取一个<span class="math inline">\(\gcd\)</span>,这样所有数就都是这个数的因子,可以使用大小因子分别编号来实现.</p>
<h6><span id="example4poi2014couriers">Example4([POI2014]Couriers)</span></h6>
<p>给定长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,有<span class="math inline">\(m\)</span>次询问,每次给定一个区间<span class="math inline">\([l,r]\)</span>,问<span class="math inline">\(a[l,r]\)</span>中是否存在出现次数严格大于其它所有数出现次数之和的数,如果存在请输出.<span class="math inline">\((n,m\leq 500000,1\leq a_i\leq n)\)</span>.</p>
<p>先存下来每个位置的数是第几次出现,我们就可以利用二分快速找到一个区间内某个数出现次数.接下来只需要随机化找这个区间内某个数并判断是否满足条件即可.</p>
<h5><span id="example5noi2013-向量内积">Example5([NOI2013] 向量内积)</span></h5>
<p>先考虑<span class="math inline">\(k=2\)</span>的情况:</p>
<p>首先,我们自然可以枚举一个向量<span class="math inline">\(A\)</span>并判断它与其它向量的内积,这样复杂度为<span class="math inline">\(O(n^2d)\)</span>.</p>
<p>冷静一下,这个过程其实就是一个矩阵乘法的过程:我们设<span class="math inline">\(A=\begin{bmatrix}\vec{a_1},\vec{a_2},...,\vec{a_n}\end{bmatrix}\)</span>,那我们要验证的无非是<span class="math inline">\(B=AA^T\)</span>中是否存在一个不在主对角线上的元素<span class="math inline">\(B_{i,j}\)</span>在<span class="math inline">\(\mod
2\)</span>意义下为<span class="math inline">\(0\)</span>.</p>
<p>这咋做啊?我们冷静一下,构造一个矩阵<span class="math inline">\(C\)</span>,其中<span class="math inline">\(C\)</span>的主对角线元素与<span class="math inline">\(B\)</span>相同,而其他元素全是<span class="math inline">\(1\)</span>.接下来我们要做的无非是找到<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>不同的地方.</p>
<p>这咋办呢?我们考虑这么一点:如果<span class="math inline">\(B=C\)</span>,那么对于任意一个<span class="math inline">\(X_{m\times n}\)</span>都应该满足<span class="math inline">\(XB=XC\)</span>,取<span class="math inline">\(m=1\)</span>,我们的问题就转化为:是否能找到一个<span class="math inline">\(X\)</span>,使得<span class="math inline">\(XB\ne
XC\)</span>?这显然可以随机化.计算前者的复杂度为<span class="math inline">\(O(nd)\)</span>,后者由于<span class="math inline">\(C\)</span>很特殊,可以在<span class="math inline">\(O(n)\)</span>的时间内求出.这样我们就保证了算法复杂度上的合理性.</p>
<p>接下来,我们要证明其正确率上的合理性.这个算法显然是单侧错误的Monte
Carlo算法.问题在于正确率:</p>
<p>令<span class="math inline">\(D=B-C\)</span>,若返回相等但实际上不相等,则<span class="math inline">\(D\)</span>中至少存在一个不为<span class="math inline">\(0\)</span>的数字,假设<span class="math inline">\(D_{i,j}\ne 0\)</span>.我们令<span class="math inline">\(E=X\times D\)</span>,那么只有当<span class="math inline">\(E\)</span>是零向量时才会错误.而<span class="math inline">\(E_j=\sum_{k}X_kD_{k,j}\)</span>,不难解得:<span class="math inline">\(E_i=-\frac{1}{D_{i,j}}\sum_{k\ne
i}X_kD_{k,j}\)</span>,也就是说如果<span class="math inline">\(X\)</span>的其它位置都确定了,那么<span class="math inline">\(E\)</span>只有一种取值会返回错误.由于<span class="math inline">\(k\)</span>一共就俩取值,所以正确率至少<span class="math inline">\(\frac{1}2\)</span>.</p>
<p>至于找到答案:我们找到一个不为<span class="math inline">\(0\)</span>的<span class="math inline">\(E_i\)</span>,那么一定存在一组解包含了第<span class="math inline">\(i\)</span>个向量,只需枚举另一个向量检验就行,复杂度<span class="math inline">\(O(nd)\)</span>.</p>
<p><span class="math inline">\(k=3\)</span>的话,我们注意到<span class="math inline">\(\mod 3\)</span>意义下,<span class="math inline">\(1\)</span>和<span class="math inline">\(2\)</span>的平方都是<span class="math inline">\(1\)</span>.考虑<span class="math inline">\(\sum_{j}B_{i,j}^2X_j=\sum_{j}B_{i,j}X_jB_{h,i}^T\)</span>,大概做做.</p>
<h3><span id="las-vegas算法sherwood算法">Las Vegas算法(Sherwood算法)</span></h3>
<p>总是能返回正确的结果,但是其运行时间不确定.对于一些平均时间复杂度优秀,但是最坏情况下复杂度较高的确定性算法,通过引入随机函数,尝试减小最坏情况的可能性,以在期望意义下达到优秀的时间复杂度.</p>
<h5><span id="算法设计思路">算法设计思路</span></h5>
<h6><span id="设计一个能解决问题的确定性算法">设计一个能解决问题的确定性算法</span></h6>
<ol type="1">
<li>这个算法需要枚举全排列.</li>
<li>通常,问题问的是要么只是可行解而不是最优解,要么最优方案特别多,总之要保证有用的排列个数不会太少</li>
</ol>
<h6><span id="向算法引入随机化优化复杂度">向算法引入随机化优化复杂度</span></h6>
<ol type="1">
<li>随机化寻找排列来降低复杂度.</li>
<li>通常证明复杂度和正确率巨大麻烦,这里建议直接实践证明.</li>
</ol>
<h5><span id="example">Example</span></h5>
<h6><span id="快速排序算法">快速排序算法</span></h6>
<p>我们试图计算它的期望时间复杂度:</p>
<p>不妨设<span class="math inline">\(T(n)\)</span>表示对长度为<span class="math inline">\(n\)</span>的序列运行快速排序算法所需的期望时间,我们有:
<span class="math display">\[
T(0)=0\\
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})
\]</span> 做放缩(可能有些地方需要<span class="math inline">\(+1\)</span>或者<span class="math inline">\(-1\)</span>或者加取整,但是问题不大,反正是期望):
<span class="math display">\[
T(n)=n+\frac{1}{n}\sum_{i=0}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{n-1}(T_i+T_{n-i-1})\\
=n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(i)+T(n-i-1))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(i)+T(n-i-1))
\]</span> 由于<span class="math inline">\(T(n)\geq
n\)</span>,所以对于<span class="math inline">\(\frac{n}2\leq i\leq
j\)</span>,我们显然有:<span class="math inline">\(T(i)+T(n-i)\leq
T(j)+T(n-j)\)</span>.</p>
<p>因此: <span class="math display">\[
T(n)\leq
n+\frac{2}{n}\sum_{i=\frac{n}{2}}^{\frac{3n}{4}}(T(\frac{3n}{4})+T(\frac{n}{4}))+\frac{2}{n}\sum_{i=\frac{3n}{4}}^{n}(T(n-1)+T(0))\\
\leq n+\frac{1}{2}(T(\frac{3n}{4})+T(\frac{n}{4})+T(n-1))
\]</span> 我们要证明<span class="math inline">\(\exists c\)</span>,<span class="math inline">\(T(n)\leq cn\log n\)</span>,考虑使用数学归纳法,则:
<span class="math display">\[
T(n)\leq
n+\frac{1}2(\frac{3cn}4\log(\frac{3n}{4})+\frac{cn}4\log(\frac{n}{4})+c(n-1)\log(n-1))\\
\leq n+c(\frac{3n}{8}\log n-\frac{3n}{8}\log\frac{4}{3}+\frac{n}{8}\log
n-\frac{n}{4}+\frac{n}{2}\log n)\\
=cn\log n+n(1-\frac{3c}{8}\log(\frac{4}{3})-\frac{c}{4})
\]</span> 于是显然存在,假设成立.</p>
<h6><span id="一类由montecarlo算法改造而成的算法">一类由Monte
Carlo算法改造而成的算法</span></h6>
<p>对于一类一定有解的构造性问题,假设我们有一个正确率为<span class="math inline">\(p\)</span>,时间复杂度为<span class="math inline">\(O(f(n))\)</span>的产生单侧错误的Monte
Carlo算法,我们时图将其改造为Las
Vegas算法,我们现在想知道它的期望复杂度.</p>
<p>设其期望运行<span class="math inline">\(k\)</span>次,则: <span class="math display">\[
k=\sum_{i=1}^{\infty}p(1-p)^{i-1}i\\
(1-p)k=\sum_{i=1}^{\infty}p(1-p)^ii\\
pk=\sum_{i=2}^{\infty}p(1-p)^{i-1}=p\sum_{i=0}^{\infty}(1-p)^i\\
k=\frac 1 p
\]</span> 则期望复杂度为<span class="math inline">\(O(\frac{f(n)}{p})\)</span>.</p>
<h6><span id="example3cf329c-graphreconstruction">Example3(CF329C Graph
Reconstruction)</span></h6>
<h6><span id="example4petrozavodsksummer-2015-moscow-ipt-contest-bgame-with-a-fairy">Example4([Petrozavodsk
Summer-2015. Moscow IPT Contest B]Game With A Fairy)</span></h6>
<p>首先注意到一个问题:操作能得到的信息太少了,应该是没有什么确定性算法.因此考虑随机化,那就肯定要先将整个序列random_shuffle一下.</p>
<p>然后呢?我们考虑之后随机选取新序列的一个前缀询问,只要有大致的正确性/复杂性估计应该就是很正确的.</p>
<p>这里有一种方式:考虑这个前缀中第一个有宝藏的位置<span class="math inline">\(x_1\)</span>和第二个位置<span class="math inline">\(x_2\)</span>,显然只要问到<span class="math inline">\([x_1,x_2)\)</span>是正确的.</p>
<p>考虑因为是随机,所以<span class="math inline">\(x_1\times 2\leq
x_2\)</span>的概率应当是不低的(事实上约为<span class="math inline">\(\frac{1}{2}\)</span>),而此时的<span class="math inline">\([x_1,x_2)\)</span>中必有一个位置是二的整数幂,因此我们查询一个等比数列:<span class="math inline">\(1,2,4,...\)</span>.每次random_shuffle后就查一次,就可以得到一个正确性较高的Las
Vegas算法.</p>
<h3><span id="爬山与模拟退火">爬山与模拟退火</span></h3>
<h4><span id="爬山">爬山</span></h4>
<p>也就是随机一个起始的解,然后走向与其相邻的较大的解.</p>
<p>但是这样会卡在一个局部最优解上而得不到全局最优解.</p>
<p>于是我们就有了模拟退火算法.</p>
<h4><span id="模拟退火">模拟退火</span></h4>
<p>简而言之,模拟退火就是以一定的概率跳到随机的不优秀的点,这样就避免卡在了局部最优解上.不妨设我们想找到最大解,如果要最小解那就稍微改改.</p>
<p>下面给出这个概率的公式: <span class="math display">\[
P=\begin{cases}1&amp;E_{t+1}&gt;E_t\\e^{\frac{E_{t+1}-E_t}{T}}&amp;E_{t+1}\leq
E_t\end{cases}
\]</span> 具体流程是,先设定一个初始温度<span class="math inline">\(T_0\)</span>,降温速度<span class="math inline">\(k\in(0,1)\)</span>,以及终止温度<span class="math inline">\(T_k\)</span>,每次操作后让<span class="math inline">\(T=kT\)</span>,直到其小于终止温度.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" rel="prev" title="文化课数学导论">
                  <i class="fa fa-angle-left"></i> 文化课数学导论
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" rel="next" title="组合数学">
                  组合数学 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
