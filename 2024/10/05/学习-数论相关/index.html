<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="整除性及相关  欧几里得算法 一些性质  Example1([CF1656H]Equal LCM Subsets)  基于值域预处理的快速 GCD 裴蜀定理 扩展欧几里得算法  Example1([XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain contest">
<meta property="og:type" content="article">
<meta property="og:title" content="数论相关">
<meta property="og:url" content="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="整除性及相关  欧几里得算法 一些性质  Example1([CF1656H]Equal LCM Subsets)  基于值域预处理的快速 GCD 裴蜀定理 扩展欧几里得算法  Example1([XVII Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain contest">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-04T16:04:37.030Z">
<meta property="article:modified_time" content="2025-04-14T16:43:07.031Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/","path":"2024/10/05/学习-数论相关/","title":"数论相关"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数论相关 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我们曾在这坐过</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">整除性及相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">欧几里得算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">一些性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.1.</span> <span class="nav-text">Example1([CF1656H]Equal LCM
Subsets)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">基于值域预处理的快速 GCD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">裴蜀定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">扩展欧几里得算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.5.1.</span> <span class="nav-text">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">素数及相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.1.1.</span> <span class="nav-text">Example1(《具体数学》4.22)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">唯一分解定理(算数基本定理)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.1.</span> <span class="nav-text">Example1([CF986F]Oppa
Funcan Style Remastered)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">素数的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.1.</span> <span class="nav-text">Example1(《具体数学》4.20)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.</span> <span class="nav-text">欧几里得数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.</span> <span class="nav-text">费马数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.1.</span> <span class="nav-text">Example1(《具体数学》4.17)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.2.</span> <span class="nav-text">Example2(《具体数学》4.18)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.</span> <span class="nav-text">Miller-Rabin算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.</span> <span class="nav-text">Pollard-Rho算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.</span> <span class="nav-text">狄利克雷前缀和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">阶乘</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.0.1.</span> <span class="nav-text">Example(《具体数学》4.55)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">互素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">4.0.1.</span> <span class="nav-text">Example1(《具体数学》4.42)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">4.0.2.</span> <span class="nav-text">Example2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">4.0.3.</span> <span class="nav-text">Example3(《具体数学》4.63)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.1.</span> <span class="nav-text">Stern-Brocot 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">4.2.</span> <span class="nav-text">升幂引理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">4.2.1.</span> <span class="nav-text">形式一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">4.2.2.</span> <span class="nav-text">形式二</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">同余</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.0.1.</span> <span class="nav-text">Example(《具体数学》4.31)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.1.</span> <span class="nav-text">威尔逊定理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.1.1.</span> <span class="nav-text">Example1(《具体数学》4.48)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.1.2.</span> <span class="nav-text">Example2(《具体数学》4.40)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.1.3.</span> <span class="nav-text">Example3(《具体数学》4.53)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.2.</span> <span class="nav-text">费马小定理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.2.1.</span> <span class="nav-text">Example1(《具体数学》4.41)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.2.2.</span> <span class="nav-text">Example2(《具体数学》4.46)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.3.</span> <span class="nav-text">中国剩余定理(crt)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.4.</span> <span class="nav-text">扩展中国剩余定理(excrt)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.4.1.</span> <span class="nav-text">Example1([NOI2018]屠龙勇士)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.4.2.</span> <span class="nav-text">Example2([CF571E]Geometric
Progressions)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.5.</span> <span class="nav-text">二次剩余</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.5.1.</span> <span class="nav-text">Example1([CF1091G]New
Year and the Factorisation Collaboration)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.5.2.</span> <span class="nav-text">Example2(qoj5021)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.5.3.</span> <span class="nav-text">Example3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.6.</span> <span class="nav-text">BSGS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.7.</span> <span class="nav-text">exBSGS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.8.</span> <span class="nav-text">原根和阶</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.8.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">5.8.2.</span> <span class="nav-text">Example2(《具体数学》4.47)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">积性函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.0.1.</span> <span class="nav-text">Example(《具体数学》4.58)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.1.</span> <span class="nav-text">狄利克雷卷积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.2.</span> <span class="nav-text">欧拉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.1.</span> <span class="nav-text">和法里级数的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.2.</span> <span class="nav-text">麦克马洪和式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.3.</span> <span class="nav-text">Burnside定理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">6.2.3.1.</span> <span class="nav-text">Example1([HNOI2009]图的同构计数)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.4.</span> <span class="nav-text">欧拉定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.5.</span> <span class="nav-text">扩展欧拉定理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">6.2.5.1.</span> <span class="nav-text">Example2([六省联考 2017]
相逢是问候)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">6.2.5.2.</span> <span class="nav-text">Example3(《具体数学》4.54)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.6.</span> <span class="nav-text">Example1(《具体数学》4.57)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.2.7.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.3.</span> <span class="nav-text">莫比乌斯函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.3.1.</span> <span class="nav-text">莫比乌斯反演</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.4.</span> <span class="nav-text">min25筛</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.4.1.</span> <span class="nav-text">Example1([uoj188]Sanrd)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.5.</span> <span class="nav-text">杜教筛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.6.</span> <span class="nav-text">Powerful Number筛</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">6.6.1.</span> <span class="nav-text">Example1([SP20174]DIVCNT3)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">整值函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">整值函数的基本性值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">整值函数的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.1.</span> <span class="nav-text">一类函数与整值函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.2.</span> <span class="nav-text">迪利克雷抽屉原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.2.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.</span> <span class="nav-text">计算区间内整数个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text">谱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.4.1.</span> <span class="nav-text">Example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.5.</span> <span class="nav-text">整值函数的递归式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.5.1.</span> <span class="nav-text">Example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.6.</span> <span class="nav-text">整值函数的恒等式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.7.</span> <span class="nav-text">整值函数的和式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.7.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.7.2.</span> <span class="nav-text">Example2(类欧几里得算法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.7.3.</span> <span class="nav-text">Example4([uoj42]Sum)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">3.7.4.</span> <span class="nav-text">Example5([loj6440]万能欧几里得算法)</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数论相关 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数论相关
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-05 00:04:37" itemprop="dateCreated datePublished" datetime="2024-10-05T00:04:37+08:00">2024-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-15 00:43:07" itemprop="dateModified" datetime="2025-04-15T00:43:07+08:00">2025-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- toc -->
<ul>
<li><a href="#整除性及相关">整除性及相关</a>
<ul>
<li><a href="#欧几里得算法">欧几里得算法</a></li>
<li><a href="#一些性质">一些性质</a>
<ul>
<li><a href="#example1cf1656hequal-lcm-subsets">Example1([CF1656H]Equal
LCM Subsets)</a></li>
</ul></li>
<li><a href="#基于值域预处理的快速-gcd">基于值域预处理的快速
GCD</a></li>
<li><a href="#裴蜀定理">裴蜀定理</a></li>
<li><a href="#扩展欧几里得算法">扩展欧几里得算法</a>
<ul>
<li><a href="#example1xvii-open-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstrain-contest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</a></li>
</ul></li>
</ul></li>
<li><a href="#素数及相关">素数及相关</a>
<ul>
<li><a href="#定义">定义</a>
<ul>
<li><a href="#example1具体数学422">Example1(《具体数学》4.22)</a></li>
</ul></li>
<li><a href="#唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</a>
<ul>
<li><a href="#example1cf986foppa-funcan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</a></li>
</ul></li>
<li><a href="#素数的个数">素数的个数</a>
<ul>
<li><a href="#example1具体数学420">Example1(《具体数学》4.20)</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#欧几里得数">欧几里得数</a></li>
<li><a href="#费马数">费马数</a>
<ul>
<li><a href="#example1具体数学417">Example1(《具体数学》4.17)</a></li>
<li><a href="#example2具体数学418">Example2(《具体数学》4.18)</a></li>
</ul></li>
<li><a href="#miller-rabin算法">Miller-Rabin算法</a></li>
<li><a href="#pollard-rho算法">Pollard-Rho算法</a></li>
<li><a href="#狄利克雷前缀和">狄利克雷前缀和</a></li>
</ul></li>
<li><a href="#阶乘">阶乘</a>
<ul>
<li><a href="#example具体数学455">Example(《具体数学》4.55)</a></li>
</ul></li>
<li><a href="#互素">互素</a>
<ul>
<li><a href="#example1具体数学442">Example1(《具体数学》4.42)</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3具体数学463">Example3(《具体数学》4.63)</a></li>
<li><a href="#stern-brocot-树">Stern-Brocot 树</a></li>
<li><a href="#升幂引理">升幂引理</a>
<ul>
<li><a href="#形式一">形式一</a></li>
<li><a href="#形式二">形式二</a></li>
</ul></li>
</ul></li>
<li><a href="#同余">同余</a>
<ul>
<li><a href="#example具体数学431">Example(《具体数学》4.31)</a></li>
<li><a href="#威尔逊定理">威尔逊定理</a>
<ul>
<li><a href="#example1具体数学448">Example1(《具体数学》4.48)</a></li>
<li><a href="#example2具体数学440">Example2(《具体数学》4.40)</a></li>
<li><a href="#example3具体数学453">Example3(《具体数学》4.53)</a></li>
</ul></li>
<li><a href="#费马小定理">费马小定理</a>
<ul>
<li><a href="#example1具体数学441">Example1(《具体数学》4.41)</a></li>
<li><a href="#example2具体数学446">Example2(《具体数学》4.46)</a></li>
</ul></li>
<li><a href="#中国剩余定理crt">中国剩余定理(crt)</a></li>
<li><a href="#扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</a>
<ul>
<li><a href="#example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</a></li>
<li><a href="#example2cf571egeometric-progressions">Example2([CF571E]Geometric
Progressions)</a></li>
</ul></li>
<li><a href="#二次剩余">二次剩余</a>
<ul>
<li><a href="#example1cf1091gnew-year-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</a></li>
<li><a href="#example2qoj5021">Example2(qoj5021)</a></li>
<li><a href="#example3">Example3</a></li>
</ul></li>
<li><a href="#bsgs">BSGS</a></li>
<li><a href="#exbsgs">exBSGS</a></li>
<li><a href="#原根和阶">原根和阶</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2具体数学447">Example2(《具体数学》4.47)</a></li>
</ul></li>
</ul></li>
<li><a href="#积性函数">积性函数</a>
<ul>
<li><a href="#example具体数学458">Example(《具体数学》4.58)</a></li>
<li><a href="#狄利克雷卷积">狄利克雷卷积</a></li>
<li><a href="#欧拉函数">欧拉函数</a>
<ul>
<li><a href="#和法里级数的关系">和法里级数的关系</a></li>
<li><a href="#麦克马洪和式">麦克马洪和式</a></li>
<li><a href="#burnside定理">Burnside定理</a>
<ul>
<li><a href="#example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</a></li>
</ul></li>
<li><a href="#欧拉定理">欧拉定理</a></li>
<li><a href="#扩展欧拉定理">扩展欧拉定理</a>
<ul>
<li><a href="#example2六省联考-2017-相逢是问候">Example2([六省联考 2017]
相逢是问候)</a></li>
<li><a href="#example3具体数学454">Example3(《具体数学》4.54)</a></li>
</ul></li>
<li><a href="#example1具体数学457">Example1(《具体数学》4.57)</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#莫比乌斯函数">莫比乌斯函数</a>
<ul>
<li><a href="#莫比乌斯反演">莫比乌斯反演</a></li>
</ul></li>
<li><a href="#min25筛">min25筛</a>
<ul>
<li><a href="#example1uoj188sanrd">Example1([uoj188]Sanrd)</a></li>
</ul></li>
<li><a href="#杜教筛">杜教筛</a></li>
<li><a href="#powerful-number筛">Powerful Number筛</a>
<ul>
<li><a href="#example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</a></li>
</ul></li>
</ul></li>
<li><a href="#整值函数">整值函数</a>
<ul>
<li><a href="#定义-1">定义</a></li>
<li><a href="#整值函数的基本性值">整值函数的基本性值</a></li>
<li><a href="#整值函数的应用">整值函数的应用</a>
<ul>
<li><a href="#一类函数与整值函数">一类函数与整值函数</a></li>
<li><a href="#迪利克雷抽屉原理">迪利克雷抽屉原理</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul></li>
<li><a href="#计算区间内整数个数">计算区间内整数个数</a></li>
<li><a href="#谱">谱</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#整值函数的递归式">整值函数的递归式</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
<li><a href="#整值函数的恒等式">整值函数的恒等式</a></li>
<li><a href="#整值函数的和式">整值函数的和式</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
<li><a href="#example2类欧几里得算法">Example2(类欧几里得算法)</a></li>
<li><a href="#example4uoj42sum">Example4([uoj42]Sum)</a></li>
<li><a href="#example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p>本文除特殊说明,所涉及数均为整数.</p>
<h3><span id="整除性及相关">整除性及相关</span></h3>
<p>如果<span class="math inline">\(m&gt;0\)</span>且<span class="math inline">\(\cfrac{n}{m}\)</span>是一个整数,我们就说<span class="math inline">\(m\)</span>整除<span class="math inline">\(n\)</span>,记作<span class="math inline">\(m|n\)</span>.</p>
<p>能同时整除两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的数称为<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子,所有公因子中最大的那个称为最大公因子,记作<span class="math inline">\(\gcd(n,m)\)</span>.而最小的能同时被<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>整除的非零数被称为他们的最小公倍数,记作<span class="math inline">\(lcm(n,m)\)</span>.不难发现<span class="math inline">\(lcm(n,m)\gcd(n,m)=nm\)</span>.</p>
<h4><span id="欧几里得算法">欧几里得算法</span></h4>
<p>欧几里得算法基于以下定理:</p>
<p><span class="math inline">\(\gcd(0,n)=n\)</span>且<span class="math inline">\(\gcd(n,m)=\gcd(n\mod m,m),m&gt;0\)</span>.</p>
<p>考虑证明,首先,<span class="math inline">\(\forall
k\in\mathbb{Z}\)</span>,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(n\)</span>和<span class="math inline">\(m+kn\)</span>的公因子,这是显然的.因此,<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>的公因子一定是<span class="math inline">\(m\)</span>和<span class="math inline">\(n-m\lfloor\cfrac{n}{m}\rfloor\)</span>的公因子,而反之亦然.</p>
<p>另外有如下性质:</p>
<ol type="1">
<li><span class="math inline">\(\gcd(kn,km)=k\gcd(n,m)\)</span>以及<span class="math inline">\(lcm(kn,km)=k\ lcm(n,m)\)</span>.</li>
<li>若<span class="math inline">\(a\bot b\)</span>,则<span class="math inline">\(\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(n,m)}-b^{\gcd(n,m)}\)</span>.</li>
<li>如果<span class="math inline">\(n^a\equiv 1\pmod m\and n^b\equiv
1\pmod m\)</span>,则<span class="math inline">\(n^{\gcd(a,b)}\equiv
1\pmod m\)</span>.</li>
</ol>
<p>(1)的证明较为显然,我们考虑(2)的证明.</p>
<p>不妨假设<span class="math inline">\(n\leq m\)</span>,当<span class="math inline">\(n=m\)</span>时显然成立.</p>
<p>当<span class="math inline">\(n&lt;m\)</span>时:</p>
<p>假设<span class="math inline">\(a&gt;b\)</span>,考虑<span class="math inline">\(\gcd(a^m-b^m,a^n-b^n)=\gcd(a^m-b^m-k(a^n-b^n),a^n-b^n)\)</span>.</p>
<p>取<span class="math inline">\(k=b^{m-n}\)</span>,则: <span class="math display">\[
\gcd(a^m-b^m,a^n-b^n)=\gcd(a^m-b^{m-n}a^n,a^n-b^n)\\
=\gcd(a^n(a^{m-n}-b^{m-n}),a^n-b^n)
\]</span> 由于<span class="math inline">\(a\bot b\)</span>,所以显然<span class="math inline">\(a^n-b^n\bot a^n\)</span>,于是: <span class="math display">\[
\gcd(a^m-b^m,a^n-b^n)=\gcd(a^{m-n}-b^{m-n},a^n-b^n)
\]</span> 自然得证.</p>
<p>接下来考虑(3)的证明:</p>
<p>如果<span class="math inline">\(a=b\)</span>,显然得证.不然,不妨设<span class="math inline">\(a&gt;b\)</span>注意到: <span class="math display">\[
n^a\equiv 1\pmod m\\
n^a-n^{a-b}n^b\equiv 1-n^{a-b}\pmod m\\
n^{a-b}\equiv 1\pmod m
\]</span> 自然得证.</p>
<h4><span id="一些性质">一些性质</span></h4>
<p>令<span class="math inline">\(n,m\in\mathbb{N_+}\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(k|n\and k|m\Leftrightarrow
k|\gcd(n,m)\)</span>.</li>
<li><span class="math inline">\(\sum_{m|n}a_m=\sum_{m|n}a_{\frac{n}{m}}\)</span>.</li>
<li><span class="math inline">\(\sum_{m|n}\sum_{k|m}a_{k,m}=\sum_{k|n}\sum_{l|(\frac{n}{k})}a_{k,kl}\)</span>.</li>
</ol>
<p>另外,<span class="math inline">\(\gcd\)</span>有一个很著名的性质:对于数字<span class="math inline">\(n,m\)</span>,找到最小的正整数<span class="math inline">\(x\)</span>满足<span class="math inline">\(\exists
y\in \mathbb N\)</span>,<span class="math inline">\(xn=ym\)</span>.</p>
<p>首先令<span class="math inline">\(g=\gcd(n,m)\)</span>,我们自然有<span class="math inline">\(x\frac{n}{g}=y\frac{m}{g}\)</span>,也就相当于<span class="math inline">\(x\frac{n}{g}\equiv
0\pmod{\frac{m}{g}}\)</span>,由于<span class="math inline">\(\gcd(\frac{n}{g},\frac{m}{g})=1\)</span>,所以左边的<span class="math inline">\(\frac{n}{g}\)</span>可以用逆元消掉,显然最小正整数解为<span class="math inline">\(x=\frac{m}{g}\)</span>.</p>
<h5><span id="example1cf1656hequal-lcmsubsets">Example1([CF1656H]Equal LCM
Subsets)</span></h5>
<p>注意到插入可能有点小困难,我们考虑从全集中删除:注意到如果对于一个数字的某一个质因子,如果它的指数大于了对方集合中相同质因子的最大指数,那这个数一定不可能存在,直接删掉.不难发现删完后就是合法的了.</p>
<p>首先,数据范围不允许我们判断质因子,那么怎么做呢?</p>
<p>显然合法的条件等价于<span class="math inline">\(a_i|lcm(b),\forall
1\leq i\leq
n\)</span>(当然这个还要反过来再写一遍,两个式子一起才是充要条件,这里为了方便只写一个),这个条件等价于<span class="math inline">\(\gcd_{j=1}^n(\frac{a_i}{\gcd(b_j,a_i)})=1\)</span>.后者是方便做的.</p>
<p>然后上线段树处理一下,好像先random_shuffle一下再暴力删除也是对的.</p>
<h4><span id="基于值域预处理的快速-gcd">基于值域预处理的快速 GCD</span></h4>
<p>存在一种<span class="math inline">\(O(n)\)</span>预处理,<span class="math inline">\(O(1)\)</span>求任意两个小于等于<span class="math inline">\(n\)</span>的数的<span class="math inline">\(\gcd\)</span>的方法:</p>
<p>引理:</p>
<p>对于任意整数<span class="math inline">\(n\)</span>,存在一种划分方式<span class="math inline">\(n=abc\)</span>,<span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>,<span class="math inline">\(c\)</span>三个数要么是质数,要么<span class="math inline">\(\leq \sqrt n\)</span>.</p>
<p>证明:</p>
<p>如果<span class="math inline">\(n\)</span>存在一个大于等于<span class="math inline">\(\sqrt n\)</span>的质因子,显然成立.</p>
<p>否则,使用数学归纳,我们考虑<span class="math inline">\(n\)</span>的最小质因子为<span class="math inline">\(p\)</span>,设<span class="math inline">\(\frac n
p=xyz\)</span>,不妨设<span class="math inline">\(x\leq y\leq
z\)</span>.</p>
<p>如果<span class="math inline">\(x=1\)</span>,显然成立.</p>
<p>不然有<span class="math inline">\(p\leq x\leq y\leq
z\)</span>,而<span class="math inline">\(pxyz=n\)</span>,那么<span class="math inline">\(p^4\leq n\)</span>,<span class="math inline">\(p\leq n^{\frac 1 4}\)</span>.</p>
<p>现在我们想要证明不存在<span class="math inline">\(xp&gt;\sqrt
n\)</span>,<span class="math inline">\(yp&gt;\sqrt n\)</span>,<span class="math inline">\(zp&gt;\sqrt n\)</span>.</p>
<p>如果存在,我们有: <span class="math display">\[
xyzp^3&gt;n^{\frac 3 2}\\
np^2&gt;n^{\frac 3 2}\\
p^2&gt;\sqrt n\\
p&gt;n^{\frac 1 4}
\]</span> 与我们前面的结论不符合.</p>
<p>因而该引理成立,并且给出了<span class="math inline">\(O(n)\)</span>预处理所有数<span class="math inline">\(abc\)</span>的方法.</p>
<p>接下来，设<span class="math inline">\(m=\sqrt
n\)</span>,考虑使用<span class="math inline">\(O(n)\)</span>的时间求出每个小于等于<span class="math inline">\(m\)</span>的数对的<span class="math inline">\(\gcd\)</span>,如果我们要求<span class="math inline">\(\gcd(x,y)\)</span>,设<span class="math inline">\(x=abc\)</span>,显然<span class="math inline">\(\gcd(x,y)=\gcd(a,y)\times\gcd(b,\frac{y}{\gcd(a,y)})\times\gcd(c,\frac{y}{\gcd(ab,y)})\)</span>.</p>
<p>如果<span class="math inline">\(a\)</span>是质数，只需要判断<span class="math inline">\(a\)</span>是否整除<span class="math inline">\(y\)</span>.</p>
<p>否则<span class="math inline">\(\gcd(a,y)=\gcd(y\mod
a,a)\)</span>,因为<span class="math inline">\(a\leq \sqrt
n\)</span>,因而可以直接查表.</p>
<h4><span id="裴蜀定理">裴蜀定理</span></h4>
<p><span class="math inline">\(\forall
a,b,m\in\mathbb{Z}\)</span>,则<span class="math inline">\(\exists x,y\in
\mathbb{Z}\)</span>满足<span class="math inline">\(ax+by=m\)</span>,当且仅当<span class="math inline">\(\gcd(a,b)|m\)</span>.</p>
<p>证明如下:</p>
<p>若<span class="math inline">\(a=0\)</span>或<span class="math inline">\(b=0\)</span>,显然成立.</p>
<p>不然,设集合<span class="math inline">\(A=\{xa+yb|x,y\in\mathbb{Z}\}\)</span>中的最小正元素<span class="math inline">\(d_0=x_0a+y_0b\)</span>,该集合中显然一定有正元素.</p>
<p>考虑取该集合中另一个正整数<span class="math inline">\(d_1=x_1a+y_1b&gt;d_0\)</span>,注意到<span class="math inline">\(d_1-d_0=(x_1-x_0)a+(y_1-y_0)b\in
A\)</span>,所以<span class="math inline">\(\gcd (d_1,d_0)\in
A\)</span>,如果<span class="math inline">\(d_0\nmid
d_1\)</span>,那么<span class="math inline">\(0&lt;\gcd
(d_1,d_0)&lt;d_0\)</span>,与假设不符.所以这个集合里的所有数一定都是<span class="math inline">\(d_0\)</span>的倍数.</p>
<p>事实上还有另一种证明方式:</p>
<p>如果我们定义一个非空集合<span class="math inline">\(I\subseteq
\Z\)</span>,满足其对加法和数乘(<span class="math inline">\(\forall a\in
\Z,x\in I,ax\in
I\)</span>)均封闭,那么我们可以证明其中存在一个唯一的数字<span class="math inline">\(g\)</span>满足所有数都是<span class="math inline">\(g\)</span>的倍数.</p>
<p>如果<span class="math inline">\(I=\{0\}\)</span>,可以取<span class="math inline">\(g=0\)</span>.</p>
<p>反之,显然其中有正有负(因为可以取<span class="math inline">\(a=-1\)</span>),我们设<span class="math inline">\(I_+=\{k\in I|k\geq 1\}\)</span>取<span class="math inline">\(g=\min I_+\)</span>.<span class="math inline">\(\forall a\in I\)</span>,不妨设<span class="math inline">\(a=gq+r,r\in [0,g)\)</span>,那么<span class="math inline">\(r=a+(-q)g\in I\)</span>,由于<span class="math inline">\(r&lt;g\)</span>,所以<span class="math inline">\(r\notin I_+\)</span>,所以<span class="math inline">\(r=0\)</span>,<span class="math inline">\(a\)</span>是<span class="math inline">\(g\)</span>的倍数,且显然<span class="math inline">\(g\)</span>唯一.</p>
<h4><span id="扩展欧几里得算法">扩展欧几里得算法</span></h4>
<p>考虑求方程<span class="math inline">\(ax+by=\gcd(a,b)\)</span>的一组解.</p>
<p>首先,如果<span class="math inline">\(b=0\)</span>,那这组解显然就是<span class="math inline">\(\begin{cases}x=1\\y=0\end{cases}\)</span>.</p>
<p>反之,我们令<span class="math inline">\(c=a\mod
b\)</span>,考虑求方程<span class="math inline">\(cz+bw=\gcd(c,b)\)</span>的一组解.</p>
<p>接下来呢,考虑带入<span class="math inline">\(c\)</span>,则我们求出来的即方程<span class="math inline">\((a-b\lfloor\cfrac a
b\rfloor)z+bw=\gcd(a,b)\)</span>的一组解.不难发现这也就是方程<span class="math inline">\(az+(w-\lfloor\cfrac a b\rfloor
z)b=\gcd(a,b)\)</span>的一组解,所以原本的方程的解也就是<span class="math inline">\(\begin{cases}x=z\\y=(w-\lfloor\cfrac a b\rfloor
z)\end{cases}\)</span>.</p>
<p>另外,这个算法也可以使用矩阵形式:</p>
<p>首先有<span class="math inline">\(\left[\begin{matrix}
a\\
b
\end{matrix}\right]
=\left[\begin{matrix}
a\\
b
\end{matrix}\right]\)</span>,令<span class="math inline">\(q=\lfloor\frac a b\rfloor\)</span>,那么我们有<span class="math inline">\(\left[\begin{matrix}
0&amp;1\\
1&amp;-q
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
b\\
a\mod b
\end{matrix}\right]\)</span>.</p>
<p>同样我们可以得到:<span class="math inline">\(\left[\begin{matrix}
x_1&amp;y_1\\
x_2&amp;y_2
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
\gcd(a,b)\\
0
\end{matrix}\right]\)</span>,即<span class="math inline">\(ax_1+by_1=\gcd(a,b)\)</span>,<span class="math inline">\((x_1,y_1)\)</span>就是一组特解.</p>
<h5><span id="example1xviiopen-cup-named-after-ev-pankratiev-grand-prix-of-japanopenstraincontest-1489eeel-and-grid">Example1([XVII
Open Cup named after E.V. Pankratiev. Grand Prix of Japan(openstrain
contest 1489)E]Eel and Grid)</span></h5>
<p>题意:<span class="math inline">\(h\times w(h,w\leq
10^6)\)</span>的格子图,只能往下往右走,走到边界会循环,问从<span class="math inline">\((0,0)\)</span>开始走遍历走一个哈密顿回路的方案数.</p>
<p>这题最重要的地方其实在于观察到,由于每个点只会被走到一次(除了<span class="math inline">\((0,0)\)</span>,它会被走到两次,但只会由其它格子走来一次),因此如果抽象成图,每个格子只会有一个出边和一个入边.这意味着每个格子上面的和左边的格子必定只有一个指向它,进一步地,这意味着这两个格子的状态必然相同.</p>
<p>由此我们发现,每条副对角线(取膜意义下)的状态必然相同,而取膜意义下的副对角线有多少条呢?不难注意到是<span class="math inline">\(d=\frac{hw}{\text
{lcm}(h,w)}=\gcd(h,w)\)</span>条.也就是说,我们只需要确定这<span class="math inline">\(d\)</span>条对角线的值,就可以确定整个矩阵的答案.假设<span class="math inline">\(R\)</span>表示向右走,<span class="math inline">\(D\)</span>表示向下走,<span class="math inline">\(a_i\)</span>表示第<span class="math inline">\(i\)</span>条副对角线的状态,最后的操作序列自然是<span class="math inline">\(a_0a_1...a_{d-1}a_0a_1...\)</span>.</p>
<p>那么我们接下来要做的就是给这<span class="math inline">\(d\)</span>条副对角线定向,并判断一个方案是否合法.注意到一个方案不合法当且仅当出现了多于<span class="math inline">\(1\)</span>个环.那这又意味着什么呢?意味着存在一个点,它可以通过少于<span class="math inline">\(hw\)</span>次走动走回自己.这显然是不被我们允许的.另一件不难发现的事是,第一个走回自己的点一定是<span class="math inline">\((0,0)\)</span>.再不难发现的是,走回自己的时候一定是经过了若干个周期:<span class="math inline">\(a_0a_1...a_{d-1}a_0...a_{d-1}\)</span>,因为每次向下或者向右走都会走到下一条副对角线,而且最后要回到自己.这就注意到每一个循环<span class="math inline">\(a_0a_1...a_{d-1}\)</span>内部具体什么情况是不在乎的,只在乎经历过这个过程之后会发生什么样的变化.</p>
<p>我们不妨假设序列<span class="math inline">\(\{a\}\)</span>中有<span class="math inline">\(k\)</span>个<span class="math inline">\(R\)</span>,<span class="math inline">\(d-k\)</span>个<span class="math inline">\(D\)</span>,那会产生这种情况当且仅当<span class="math inline">\(\exists x\in \mathbb{N_+},x&lt;
\frac{hw}{d}\)</span>,<span class="math inline">\(\begin{cases}h|x(d-k)\\w|xk\end{cases}\)</span>.注意到这等价于寻找最小的<span class="math inline">\(x\)</span>,判断其是否小于<span class="math inline">\(\frac{hw}{d}\)</span>,于是条件等价于自然有<span class="math inline">\(x=lcm(\frac{h}{\gcd(d-k,h)},\frac{w}{\gcd(w,k)})\)</span>,枚举<span class="math inline">\(k\)</span>并判断即可.</p>
<h3><span id="素数及相关">素数及相关</span></h3>
<h4><span id="定义">定义</span></h4>
<p>可以利用裴蜀定理证明素数的定义等价于<span class="math inline">\(\forall a,b,p|ab\Rightarrow p|a\or
p|b\)</span>.</p>
<p>考虑先用最基础的定义得到这个命题,考虑<span class="math inline">\(p|ab,p\nmid a\)</span>,则<span class="math inline">\(1=px+ay\)</span>有解,则<span class="math inline">\(b=pxb+(ab)y\)</span>,右边都是<span class="math inline">\(p\)</span>的倍数,所以<span class="math inline">\(p|b\)</span>.</p>
<p>这个命题反推的话,考虑设<span class="math inline">\(p=ab,a,b\ne
1\)</span>,则<span class="math inline">\(p|ab\)</span>且<span class="math inline">\(p\nmid a,p\nmid b\)</span>,不符.</p>
<h5><span id="example1具体数学422">Example1(《具体数学》4.22)</span></h5>
<p>证明:在<span class="math inline">\(n\)</span>进制下,若<span class="math inline">\((11...1)_n\)</span>的<span class="math inline">\(1\)</span>的个数不是质数则其一定不是质数..</p>
<p>设<span class="math inline">\(1\)</span>的个数为<span class="math inline">\(m\)</span>,则<span class="math inline">\((11...1)_n=\sum_{i=0}^{m-1}n^i\)</span>.</p>
<p>如果<span class="math inline">\(m\notin prime\)</span>,不妨设则<span class="math inline">\(m=cd,c\ne 1\and d\ne 1\)</span>.</p>
<p>则 <span class="math display">\[
\sum_{i=0}^{m-1}n^i=\sum_{i=0}^{c-1}n^{di}\sum_{j=0}^{d-1}n^{j}\\=(\sum_{i=0}^{c-1}n^{di})(\sum_{j=0}^{d-1}n^j)
\]</span> 显然不是质数.</p>
<h4><span id="唯一分解定理算数基本定理">唯一分解定理(算数基本定理)</span></h4>
<p>任何正整数都只有一种方式以素数非减的次序写成素数的乘积.</p>
<p>证明:</p>
<p>考虑数学归纳法,设小于<span class="math inline">\(n\)</span>的数全部满足.</p>
<p>则对于<span class="math inline">\(n\)</span>,如果它不满足条件,一定存在两种分解方式<span class="math inline">\(n=\prod_{i=1}^mp_i=\prod_{i=1}^kq_i\)</span>.</p>
<p>首先,如果<span class="math inline">\(p_1=q_1\)</span>,根据归纳假设,显然不成立.</p>
<p>不失一般性,设<span class="math inline">\(p_1&lt;q_1\)</span>.则<span class="math inline">\(q_1|p_1\prod_{i=2}^mp_i\)</span>,显然<span class="math inline">\(q_1\nmid p_1\)</span>,所以<span class="math inline">\(q_1|\prod_{i=2}^mp_i\)</span>,设<span class="math inline">\(s=\prod_{i=2}^mp_i\)</span>,但这是不可能的,因为<span class="math inline">\(s&lt;n\)</span>,根据归纳假设,它只有一种分解方式,这种方式中显然不可能存在<span class="math inline">\(p_1\)</span>.</p>
<p>那么根据上述证明,我们可以将一个数表示为以下形式:<span class="math inline">\(n=\prod_p p^{n_p},n_p\geq 0\)</span>.</p>
<p>另外不难证明的一点是,假设<span class="math inline">\(\sum
n_p=k\)</span>,那么最小质因子一定不大于<span class="math inline">\(\sqrt[k]{n}\)</span>.</p>
<h5><span id="example1cf986foppafuncan-style-remastered">Example1([CF986F]Oppa
Funcan Style Remastered)</span></h5>
<p>首先对<span class="math inline">\(k\)</span>做pollard-Rho算法.注意到我们可以默认<span class="math inline">\(q_i\)</span>是质因子,这显然不会影响答案.</p>
<p>然后,如果只有一个质因子,显然直接判断.</p>
<p>如果有两个质因子,是经典的二元不定方程.</p>
<p>如果有三个质因子,此时最小质因子的大小就不大于<span class="math inline">\(\sqrt[3]{k}\)</span>,做同余最短路即可.</p>
<h4><span id="素数的个数">素数的个数</span></h4>
<p>首先,欧几里得证明了素数有无穷多个:</p>
<p>假设素数有有限个,分别为<span class="math inline">\(p_1,p_2,...p_m\)</span>,则<span class="math inline">\(\prod_{i=1}^mp_i+1\)</span>无法被其中任何素数整除,则假设不成立.</p>
<p>在此基础上,我们可以定义欧几里得数:</p>
<p><span class="math inline">\(e_1=2,e_n=1+\prod_{i=1}^{n-1}e_i\)</span>.</p>
<p>令<span class="math inline">\(\pi(n)\)</span>表示小于等于<span class="math inline">\(n\)</span>的素数个数,有<span class="math inline">\({\lim_{n\rightarrow+\infty}\cfrac{\pi(n)\times \ln
n}{n}}=1\)</span>.</p>
<p>有切比雪夫定理(又称贝特朗假设):若<span class="math inline">\(n&gt;1,\exist p\in prime,p\in(n,2n)\)</span>.</p>
<p>又有狄利克雷定理:若<span class="math inline">\(\gcd(a,b)=1,\{an+b\}\)</span>中包含了无穷个素数.</p>
<p>(顺便一提,当<span class="math inline">\(a=4\)</span>或者<span class="math inline">\(a=6\)</span>,<span class="math inline">\(b=-1\)</span>的时候是好证明的,由于素数要么形如<span class="math inline">\(6n-1\)</span>要么形如<span class="math inline">\(6n+1\)</span>,或者要么形如<span class="math inline">\(4n-1\)</span>要么形如<span class="math inline">\(4n+1\)</span>,只需要类似证明素数无限那样乘一乘)</p>
<p>同时,我们还有以下结论:<span class="math inline">\(\sum_{1\leq p\leq
n\and p\in prime}\cfrac{1}{p}\approx \log\log n\)</span>.</p>
<p>证明如下: <span class="math display">\[
\sum_{1\leq p\leq n\and p\in
prime}\cfrac{1}{p}=\sum^n_{k=1}\cfrac{\pi(k)-\pi(k-1)}{k}=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^n_{k=1}\cfrac{\pi(k-1)}{k}\\
=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^{n-1}_{k=0}\cfrac{\pi(k)}{k+1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k}+\cfrac{\pi(n)}{n}-\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k+1}-\cfrac{\pi(0)}{1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k(k+1)}+\cfrac{\pi(n)}{n}\\
= \sum^{n-1}_{k=1}{(\cfrac{1}{k\log k})}+O(\frac{1}{\log n})= O(\log
\log n)+O(\frac1{\log n})
\]</span></p>
<h5><span id="example1具体数学420">Example1(《具体数学》4.20)</span></h5>
<p>证明:存在一个常数<span class="math inline">\(b\)</span>满足<span class="math inline">\(\lfloor2^b\rfloor,\lfloor2^{2^b}\rfloor,\lfloor2^{2^{2^b}}\rfloor.,..\)</span>都是质数.</p>
<p>如此构造数列:设<span class="math inline">\(p_1=2\)</span>,且<span class="math inline">\(p_n\)</span>为满足<span class="math inline">\(2^{p_{n-1}}&lt;p_n&lt;2^{p_{n-1}+1}\)</span>的最小质数.</p>
<p>通过构造不难发现:<span class="math inline">\(p_{n-1}=\lfloor\log_2
p_n\rfloor\)</span>.</p>
<p>根据整值函数的性质,我们有<span class="math inline">\(\lfloor\log_2
x\rfloor=\lfloor\log_2\lfloor
x\rfloor\rfloor\)</span>.考虑反向数学归纳,考虑当<span class="math inline">\(n\rightarrow
+\infty\)</span>时构造满足题目条件,那么<span class="math inline">\(p^{n-1}=\lfloor
\log_2\lfloor2^{2^{2^{...^{b}}}}\rfloor\rfloor=\lfloor2^{2^{...^{b}}}\rfloor\)</span>,自然也满足条件.所以如果设<span class="math inline">\(\log_2^{(n)}x\)</span>为不断对<span class="math inline">\(x\)</span>迭代求<span class="math inline">\(\log_2\)</span>做<span class="math inline">\(n\)</span>次后的答案,只需构造<span class="math inline">\(b=\lim_{n\rightarrow
+\infty}\log_2^{(n)}p_n\)</span>即可.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证: <span class="math display">\[
\mu(\gcd(a,b))=0\Leftrightarrow \forall n&gt;0,\mu(an+b)=0
\]</span> 左推右是简单的.接下来考虑右推左.</p>
<p>考虑狄利克雷定理,数列<span class="math inline">\(\{\frac{an+b}{\gcd(a,b)}\}\)</span>.不妨反证,假设<span class="math inline">\(\mu(\gcd(a,b))\ne 0\)</span>,不妨设<span class="math inline">\(p=\frac{an+b}{\gcd(a,b)}\)</span>,<span class="math inline">\(p\gcd(a,b)=ax+b\)</span>,也就是<span class="math inline">\(\mu(p\gcd(a,b))=0\)</span>,注意到<span class="math inline">\(\mu(\gcd(a,b))\ne 0\)</span>,此时必有<span class="math inline">\(p|\gcd(a,b)\)</span>,而<span class="math inline">\(p\)</span>无限,<span class="math inline">\(\gcd(a,b)\)</span>的素因子有限,这就导出了矛盾.</p>
<h4><span id="欧几里得数">欧几里得数</span></h4>
<p>定义欧几里得数:<span class="math inline">\(e_1=2,e_n=1+\prod_{i=1}^{n-1}e_i\)</span>.不难发现<span class="math inline">\(e_n=e_{n-1}(e_{n-1}-1)\)</span>.</p>
<h4><span id="费马数">费马数</span></h4>
<p>定义费马数<span class="math inline">\(f_n=2^{2^n}+1\)</span>.不难发现<span class="math inline">\(f_n=(f_{n-1}-1)^2+1\)</span>.</p>
<p>另外,费马数还满足<span class="math inline">\(f_n=\prod_{i=0}^{n-1}f_i+2\)</span>,我们考虑这个式子的证明:显然后面那一个连乘会得到若干项<span class="math inline">\(2\)</span>的次幂,并且这些项两两不同,根据几何级数,我们有<span class="math inline">\(\prod _{i=0}^{n-1}f_i+1\)</span>=<span class="math inline">\(2^{2^{n}}\)</span>,于是显然得证.</p>
<h5><span id="example1具体数学417">Example1(《具体数学》4.17)</span></h5>
<p>求证:如果<span class="math inline">\(m\ne n\)</span>,则<span class="math inline">\(f_m\bot f_n\)</span>.</p>
<p>不妨假设<span class="math inline">\(m&lt;n\)</span>,有:<span class="math inline">\(\gcd(f_m,f_n)=\gcd(f_m,2)=1\)</span>.</p>
<h5><span id="example2具体数学418">Example2(《具体数学》4.18)</span></h5>
<p>求证:若<span class="math inline">\(2^n+1\)</span>是质数,则<span class="math inline">\(n\)</span>是<span class="math inline">\(2\)</span>的整数幂.</p>
<p>如果<span class="math inline">\(n=qm\)</span>且<span class="math inline">\(q\)</span>是奇数,我们有:<span class="math inline">\(2^n+1=(2^m+1)(2^{n-m}-2^{n-2m}+2^{n-3m}...-2^m+1)\)</span>.</p>
<h4><span id="miller-rabin算法">Miller-Rabin算法</span></h4>
<p>如果判断<span class="math inline">\(n\)</span>是否是质数,取<span class="math inline">\(a&lt;n\)</span>,设<span class="math inline">\(n-1=d\times2^r\)</span>.</p>
<p>则要么<span class="math inline">\(a^d\equiv 1(\mod n)\)</span>.</p>
<p>要么<span class="math inline">\(\exists i\)</span>,使得<span class="math inline">\(0\leq i&lt;r\)</span>,<span class="math inline">\(a^{d\times 2^i}\equiv -1(\mod n)\)</span>.</p>
<p>若一个都不满足,则n一定不是质数,不然可能是质数.</p>
<p>但是若取足够多的不同的<span class="math inline">\(a\)</span>(如果选<span class="math inline">\(m\)</span>个),那么<span class="math inline">\(n\)</span>是质数的可能性更大.</p>
<p>此为Miller-Rabin算法,复杂度<span class="math inline">\(O(m\times
log_2n)\)</span>.不保证正确性.</p>
<p>其中a通常取质数,原因不详.（事实上，如果a取前八个小质数，在<span class="math inline">\(2^{64}\)</span>内是不会出错的）</p>
<h4><span id="pollard-rho算法">Pollard-Rho算法</span></h4>
<p>对<span class="math inline">\(n\)</span>做质因数分解,若能找到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a|n\)</span>,则考虑对<span class="math inline">\(\cfrac{n}{a}\)</span>和<span class="math inline">\(a\)</span>分别进行质因数分解.</p>
<p>考虑随机<span class="math inline">\(a\)</span>,若<span class="math inline">\(n\)</span>有<span class="math inline">\(m\)</span>个因数,那么显然随机到<span class="math inline">\(a\)</span>使得<span class="math inline">\(a|n\)</span>的概率为<span class="math inline">\(\cfrac{m}{n}\)</span>,显然不太优秀.</p>
<p>考虑改变随机策略,我们考虑随机一个<span class="math inline">\(a\)</span>使得<span class="math inline">\(\gcd(a,n)\ne 1\)</span>,那么<span class="math inline">\(\gcd(a,n)\)</span>就是<span class="math inline">\(n\)</span>的一个因子.</p>
<p>这种情况下,随机的概率是<span class="math inline">\(\cfrac{\varphi(n)}{n}\)</span>,仍然很不优秀.</p>
<p>考虑使用生日悖论优化,随机<span class="math inline">\(k\)</span>个数<span class="math inline">\(a\)</span>.两两匹配得到<span class="math inline">\(k^2\)</span>个值,这些值全都不整除<span class="math inline">\(n\)</span>的概率可以用生日悖论来计算.</p>
<p>当<span class="math inline">\(k=10\sqrt{n}\)</span>时,错误的概率会很小,但是复杂度仍然很高,无法接受.</p>
<p>考虑构造<span class="math inline">\(a_i=[(a_{i-1})^2+b]\mod
n\)</span>.</p>
<p>考虑该数列的性质,当<span class="math inline">\(b\)</span>确定时,<span class="math inline">\(a\)</span>一定有循环节.</p>
<p>显然当<span class="math inline">\(x|(a_i-a_j)\)</span>,则<span class="math inline">\(x|[(a_i-a_j)\times(a_i+a_j)-b+b]\)</span>,<span class="math inline">\(x|(a_{i+1}-a_{j+1})\)</span>.</p>
<p>因此,我们可以利用floyd判环法(双指针法)找出循环节.</p>
<p>并且在这个过程中,我们可以预处理出大量的<span class="math inline">\(a_{i+len}-a_i\)</span>.</p>
<p>复杂度极其玄学,但是实际应用中不差.</p>
<h4><span id="狄利克雷前缀和">狄利克雷前缀和</span></h4>
<p>已知数列<span class="math inline">\(a\)</span>,求数列<span class="math inline">\(b\)</span>满足<span class="math inline">\(b_n=\sum_{d|n}a_d\)</span>.</p>
<p>我们将一个数的质因数分解看作它的向量表示.更直接地,如果<span class="math inline">\(n=\prod_{i=1}^kp_i^{q_i}\)</span>,其中<span class="math inline">\(p_i\)</span>是第<span class="math inline">\(i\)</span>大的质数.我们将其写作向量<span class="math inline">\((q_1,q_2,...,q_k)\)</span>的形式,并做高位前缀和.</p>
<p>可以用<span class="math inline">\(O(n\log\log
n)\)</span>的时间复杂度解决问题.</p>
<h3><span id="阶乘">阶乘</span></h3>
<p>我们定义<span class="math inline">\(n!=\prod_{i=1}^ni\)</span>,特别地,<span class="math inline">\(0!=1\)</span>.</p>
<p>考虑估计<span class="math inline">\(n!\)</span>的大小,不难发现<span class="math inline">\((n!)^2=\prod_{i=1}^ni(n+1-i)\)</span>.</p>
<p>而函数<span class="math inline">\(y=i(n+1-i),i\in[1,n]\)</span>显然在<span class="math inline">\(i=1\)</span>和<span class="math inline">\(i=n\)</span>时取最小值,而在<span class="math inline">\(i=\cfrac{n+1}2\)</span>时取最大值.</p>
<p>那么我们有<span class="math inline">\(\prod_{i=1}^nn\leq (n!)^2\leq
\prod _{i=1}^n\cfrac{(n+1)^2}{4}\)</span>.</p>
<p>于是<span class="math inline">\(n^{\frac{n}2}\leq n!\leq
\cfrac{(n+1)^n}{2^n}\)</span>.</p>
<p>还有一种估计方式是考虑<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{n}{\sqrt[n]
n!}\)</span>,由Stolz定理及其推论,我们知道若<span class="math inline">\(a_n&gt;0,\frac{a_{n+1}}{a_n}=a\)</span>,那么<span class="math inline">\(\lim_{n\rightarrow
\infty}\sqrt[n]{a_n}=a\)</span>.而我们令<span class="math inline">\(a_n=\frac{n^n}{n!}\)</span>,<span class="math inline">\(\frac{a_{n+1}}{a_n}=(1+\frac{1}{n})^n\)</span>,所以<span class="math inline">\(\lim_{n\rightarrow
\infty}\frac{n}{\sqrt[n]{n!}}=e\)</span>,于是我们可以估计<span class="math inline">\(n!\sim (\frac{n}{e})^n\)</span>.</p>
<p>事实上有一种更准确的估计方法:<span class="math inline">\(n!\sim
\sqrt{2\pi n}(\cfrac{n}e)^n\)</span>.</p>
<p>考虑设<span class="math inline">\(\varepsilon_p(n!)\)</span>为<span class="math inline">\(n!\)</span>中质因子<span class="math inline">\(p\)</span>的个数,我们分析一下这个函数:</p>
<p>首先显然有:<span class="math inline">\(\varepsilon_p(n!)=\sum_{k\geq
1}\lfloor\cfrac{n}{p^k}\rfloor\leq\frac{n}{p-1}\)</span>.</p>
<p>我们考虑以<span class="math inline">\(v_p(n)\)</span>表示<span class="math inline">\(n\)</span>在<span class="math inline">\(p\)</span>进制下各位数字之和,不妨设第<span class="math inline">\(k\)</span>位数字为<span class="math inline">\(w\)</span>.那么这个数字对于最后的答案的贡献为<span class="math inline">\(w(p^{k-1}+p^{k-2}+...+1)=w\cfrac{p^k-1}{p-1}=\cfrac{wp^k-w}{p-1}\)</span>.求和得到<span class="math inline">\(\varepsilon_p(n!)=\cfrac{n-v_p(n)}{p-1}\)</span>.</p>
<h5><span id="example具体数学455">Example(《具体数学》4.55)</span></h5>
<p>令<span class="math inline">\(P_n=\prod
_{i=1}^ni!\)</span>,求证:<span class="math inline">\(P_n^4(n+1)\mid
P_{2n}\)</span>.</p>
<p>考虑对于每个质因子,分开考虑它在前者和后者内出现的次数.</p>
<p>我们不妨将<span class="math inline">\(p\)</span>和<span class="math inline">\(p^k\)</span>分开考虑,于是显然下面的式子是上面的式子成立的充分条件:
<span class="math display">\[
\sum_{m\geq
1}\sum_{i=1}^{2n}\lfloor\cfrac{i}{p^m}\rfloor\geq4\sum_{m\geq 1}
\sum_{i=1}^n\lfloor\cfrac{i}{p^m}\rfloor+[p^m\mid (n+1)]
\]</span> 我们不妨对上面这个式子使用数学归纳,也就是说它的充分条件是:
<span class="math display">\[
\lfloor\cfrac{2n-1}{p^m}\rfloor+\lfloor\cfrac{2n}{p^m}\rfloor\geq
4\lfloor\cfrac{n}{p^m}\rfloor+[n\equiv -1\pmod {p^m}]-[n\equiv 0\pmod
{p^m}]
\]</span> 这个式子,当<span class="math inline">\(1\leq n\leq
p^m\)</span>时显然成立.而当<span class="math inline">\(n\)</span>每增大<span class="math inline">\(p^m\)</span>的时候,左右两边同时增大<span class="math inline">\(4\)</span>,于是也是成立的,由此可以数学归纳.</p>
<h3><span id="互素">互素</span></h3>
<p>如果两个数<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>满足<span class="math inline">\(\gcd(n,m)=1\)</span>,我们称他们互素,记作<span class="math inline">\(n\bot m\)</span>.</p>
<p>我们显然有这样两条性质:</p>
<ol type="1">
<li><span class="math inline">\(\cfrac{n}{\gcd(n,m)}\bot
\cfrac{m}{\gcd(n,m)}\)</span>.</li>
<li><span class="math inline">\(k\bot n\and k\bot m\Leftrightarrow k\bot
nm\)</span>.</li>
</ol>
<h5><span id="example1具体数学442">Example1(《具体数学》4.42)</span></h5>
<p>证明:如果两个分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>满足<span class="math inline">\(n\bot m\)</span>且<span class="math inline">\(n&#39;\bot m&#39;\)</span>,则<span class="math inline">\((mn&#39;+m&#39;n)\bot(nn&#39;)\)</span>的充分必要条件是<span class="math inline">\(n\bot n&#39;\)</span>.</p>
<p>首先,如果<span class="math inline">\(\gcd(n,n&#39;)\ne
1\)</span>,显然不可能满足条件,必要性得证.</p>
<p>考虑充分性,如果<span class="math inline">\(n\bot
n&#39;\)</span>,则只需证明<span class="math inline">\(n\bot
(mn&#39;+m&#39;n)\and n&#39;\bot (mn&#39;+m&#39;n)\)</span>即可.</p>
<p>而<span class="math inline">\(\gcd(n,mn&#39;+m&#39;n)=\gcd(n,mn&#39;)=1\)</span>,另一个式子同理,于是得证.</p>
<h5><span id="example2">Example2</span></h5>
<p>证明:<span class="math inline">\(\sum_{0\leq
k&lt;m}f(k)=\sum_{d|m}\sum_{0\leq k&lt;d}f(\frac{km}{d})[k\bot
d]\\\)</span>.</p>
<p>考虑: <span class="math display">\[
\sum_{0\leq k&lt;m}f(k)=\sum_{d|m}\sum_{0\leq
k&lt;m,d|k}f(k)[\gcd(k,m)=d]\\
=\sum_{d|m}\sum_{0\leq k&lt;m,d|k}f(k)[\frac{k}{d}\bot \frac{m}{d}]\\
=\sum_{d|m}\sum_{0\leq k&lt;\frac{m}d}f(kd)[k\bot \frac{m}{d}]\\
=\sum_{d|m}\sum_{0\leq k&lt;d}f(\frac{km}{d})[k\bot d]
\]</span></p>
<h5><span id="example3具体数学463">Example3(《具体数学》4.63)</span></h5>
<p>证明:满足<span class="math inline">\(a^n+b^n=
c^n(n\in\mathbb{N_+},n&gt;2)\)</span>的最小的(<span class="math inline">\(n\)</span>为第一关键字,<span class="math inline">\(c\)</span>为第二关键字)一组正整数解(即费马大定理最小的反例)一定满足以下性质:(另外,<span class="math inline">\(n=4\)</span>的情况早被证明了无解)</p>
<ol type="1">
<li><span class="math inline">\(n\in prime\)</span>.</li>
<li><span class="math inline">\(\exists m\in
\mathbb{N_+},a+b=\begin{cases}m^n &amp; n\nmid c\\n^{n-1}m^n&amp;n\mid
c\end{cases}\)</span>.</li>
</ol>
<p>首先证明(1),如果<span class="math inline">\(n\)</span>是最小的满足条件的数但并不是质数,我们不妨设<span class="math inline">\(n=xy,x&gt;2\)</span>,则<span class="math inline">\((a^y)^x+(b^y)^x=(c^y)^x\)</span>,显然这是更小的一组反例,于是(1)得证.</p>
<p>接下来考虑性质(2),注意到<span class="math inline">\(a,b,c\)</span>必然两两互质,不然可以两边同时除以一个数构造出更小的解,又注意到:
<span class="math display">\[
\gcd(a+b,\cfrac{a^n+b^n}{a+b})=\gcd(a+b,(a^{n-1}-a^{n-2}b+...+b^{n-1}))\\
\gcd(a+b,\cfrac{c^n}{a+b})=\gcd(a+b,na^{n-1})\\
\gcd(a+b,\cfrac{c^n}{a+b})=\gcd(a+b,n)
\]</span> 如果<span class="math inline">\(\gcd(a+b,n)=1\)</span>,那么我们有<span class="math inline">\((a+b)\bot
\cfrac{c^n}{a+b}\)</span>.接下来考虑每一个质因子<span class="math inline">\(p\)</span>,如果<span class="math inline">\((a+b)\)</span>中有<span class="math inline">\(x\)</span>个<span class="math inline">\(p\)</span>,<span class="math inline">\(c\)</span>中有<span class="math inline">\(y\)</span>个<span class="math inline">\(p\)</span>,于是<span class="math inline">\(c^n\)</span>中有<span class="math inline">\(ny\)</span>个<span class="math inline">\(p\)</span>,我们自然有:<span class="math inline">\(x=ny\)</span>,于是<span class="math inline">\(\exists m\in \mathbb{N_+}\)</span>满足<span class="math inline">\(a+b=m^n\)</span>.</p>
<p>如果<span class="math inline">\(n\mid (a+b)\)</span>,我们就有:<span class="math inline">\(\gcd(a+b,\cfrac{c^n}{a+b})=n\)</span>,此时必有<span class="math inline">\(n\mid c\)</span>,<span class="math inline">\(n^n\mid c^n\)</span>,并且不难发现:<span class="math inline">\(n^k\mid \cfrac{c^n}{a+b}\Leftrightarrow
n^{n-k}\mid (a+b)\)</span>,由于上面提到的<span class="math inline">\(\gcd\)</span>的原因,<span class="math inline">\(\min\{k,n-k\}=1\)</span>,显然<span class="math inline">\(k=1\)</span>或者<span class="math inline">\(k=n-1\)</span>.下面只需要证明<span class="math inline">\(k\ne n-1\)</span>.</p>
<p>冷静一下,如果<span class="math inline">\(n|(a+b),n^2\nmid
(a+b)\)</span>,令<span class="math inline">\(m=a+b\)</span>,此时必有:
<span class="math display">\[
c^n=a^n+(m-a)^n\\
=a^n+(-a)^n+nm(-a)^{n-1}+\frac{n(n-1)}{2}m^2(-a)^{n-2}+\cdots
\]</span> 注意到<span class="math inline">\(n\)</span>是奇数,<span class="math inline">\(a^n+(-a)^n=0\)</span>,而<span class="math inline">\(n^n|c^n\Rightarrow n^3|c^n\)</span>,又注意到<span class="math inline">\(n^3|nm^2\)</span>,我们把两边对<span class="math inline">\(n^3\)</span>取模: <span class="math display">\[
0\equiv nx(-a)^{n-1}\pmod {n^3}
\]</span> 注意到若<span class="math inline">\(n^2\nmid
m\)</span>,则该式子必不成立.</p>
<h4><span id="stern-brocot-树">Stern-Brocot 树</span></h4>
<p>Stern-Brocot树是一种可以不重不漏列举有理数的方式,它的构造如下:</p>
<p>一开始,序列中有两个分数:<span class="math inline">\(\cfrac{0}{1}\)</span>和<span class="math inline">\(\cfrac{1}{0}\)</span>,这里使用了<span class="math inline">\(0\)</span>作分母,但我们暂且认为它是正确的,因为这样会出现很多方便的性质.</p>
<p>接下来,不断地对这个序列进行以下操作:在两个相邻的分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>之间插入一个新分数<span class="math inline">\(\cfrac{m+m&#39;}{n+n&#39;}\)</span>.</p>
<p>这么无限构造下去得到的序列满足两个性质:</p>
<ol type="1">
<li>所得到的分数全都是最简分数.</li>
<li>所得到的分数不重不漏,换句话说,任意非负有理数都在这个序列中出现恰好一次.</li>
</ol>
<p>我们不妨认为<span class="math inline">\(\cfrac{1}{0}=+\infty\)</span>,那么不难发现这么构造序列,所得到的序列一定是单调递增的.</p>
<p>这是因为如果我们有<span class="math inline">\(\cfrac{m}{n}&lt;\cfrac{m&#39;}{n&#39;}\)</span>,那么我们一定有:<span class="math inline">\(\cfrac{m}{n}&lt;\cfrac{m+m&#39;}{n+n&#39;}&lt;\cfrac{m&#39;}{n&#39;}\)</span>,其中<span class="math inline">\(n,n&#39;,m,m&#39;\geq0\)</span>,这一点不难验证.</p>
<p>而正因为如此,我们可以证明所得到的所有分数不重.</p>
<p>然后,如果当前所得到的序列中有两个数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>相邻,则<span class="math inline">\(m&#39;n-mn&#39;=1\)</span>,这一点不难通过数学归纳证明.而根据裴蜀定理,显然<span class="math inline">\(m\bot n\)</span>且<span class="math inline">\(m&#39;\bot n&#39;\)</span>.</p>
<p>我们最后需要证明任意非负有理数都可以通过这个序列构造出来,考虑类似二分的方法构造.换句话说,我们有两个序列中的分数<span class="math inline">\(\cfrac{m}{n}\)</span>和<span class="math inline">\(\cfrac{m&#39;}{n&#39;}\)</span>,要构造的有理数为<span class="math inline">\(\cfrac ab\)</span>且满足<span class="math inline">\(\cfrac{m}n&lt;\cfrac a b&lt;\cfrac
{m&#39;}{n&#39;}\)</span>.</p>
<p>我们考虑判断<span class="math inline">\(\cfrac{m+m&#39;}{n+n&#39;}\)</span>与<span class="math inline">\(\cfrac{a}{b}\)</span>的大小关系,这样就可以类似二分的方法一直往下找下去.</p>
<p>问题在于为什么我们最后一定可以找到这个数呢?如果我们一直找不到这个数,意味着无论我们怎么做,都有<span class="math inline">\(\cfrac{m}n&lt;\cfrac a b&lt;\cfrac
{m&#39;}{n&#39;}\)</span>成立,而这也就意味着<span class="math inline">\(an-bm\geq 1\and bm&#39;-an&#39;\geq
1\)</span>,处理一下不等式并合并,我们有<span class="math inline">\((m&#39;+n&#39;)(an-bm)+(n+m)(bm&#39;-an&#39;)\geq
n+m+n&#39;+m&#39;\)</span>.</p>
<p>化简这个式子得到<span class="math inline">\(a+b\geq
m&#39;+n&#39;+m+n\)</span>,而我们在操作过程中<span class="math inline">\(m,n,m&#39;,n&#39;\)</span>显然会有两个数不变,另外两个数变大,因此迟早会大于<span class="math inline">\(a+b\)</span>,也就意味着这个数迟早会被找到.</p>
<p>之所以称其为”树”,则是因为我们如果每次都在任意两个数之间插入一个数,然后将进行若干次操作得到的序列放到二叉搜索树上,会得到一些很好的性质,譬如一个数是由它所有祖先中最大的小于它的数和最小的大于它的数生成的,以及关于根中心对称的两点互为倒数.</p>
<p>另外,如果我们定义法里级数<span class="math inline">\(\mathcal{F}_n\)</span>表示所有在<span class="math inline">\([0,1]\)</span>范围内且分母小于等于<span class="math inline">\(n\)</span>的最简分数的集合.不难发现,<span class="math inline">\(\mathcal{F}_n\)</span>对应着整棵树的一棵子树的一部分.而<span class="math inline">\(\mathcal{F}_n\)</span>可以由<span class="math inline">\(\mathcal{F}_{n-1}\)</span>得到,只需要判断<span class="math inline">\(\mathcal
F_{n-1}\)</span>中每两个相邻数能否生成一个满足条件的数即可.</p>
<p>我们回到它的树形态上,如果我们定义<span class="math inline">\(\cfrac 1
1\)</span>为这棵二叉搜索树的根,那么每个有理数显然都可以表示为从根到它的一个<span class="math inline">\(LR\)</span>序列,表示从根向下搜索时每一步向左走还是向右走.特别地,我们定义根的序列为<span class="math inline">\(I\)</span>.</p>
<p>不难发现,通过这样的操作,我们将每一个非负有理数都对应到了一个<span class="math inline">\(LR\)</span>序列.</p>
<p>那么我们来考虑第一个问题:已知<span class="math inline">\(LR\)</span>序列如何求这个数.</p>
<p>我们可以设当前点是<span class="math inline">\(x\)</span>,且它由<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>生成,其中<span class="math inline">\(y&lt;x&lt;z\)</span>,那么不难发现它的右儿子由<span class="math inline">\(x\)</span>和<span class="math inline">\(z\)</span>生成,左儿子由<span class="math inline">\(y\)</span>和<span class="math inline">\(x\)</span>生成.</p>
<p>那么我们显然可以使用记录<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>的方式,反复迭代求得答案.注意<span class="math inline">\(x\)</span>是可以通过<span class="math inline">\(y\)</span>和<span class="math inline">\(z\)</span>求得的,因此没有必要存储.</p>
<p>而这一过程可以简化为矩阵运算:</p>
<p>我们令<span class="math inline">\(y=\cfrac{m}n\)</span>,<span class="math inline">\(z=\cfrac{m&#39;}{n&#39;}\)</span>,<span class="math inline">\(S=\begin{bmatrix}n&amp;n&#39;\\m&amp;m&#39;\end{bmatrix}\)</span>,<span class="math inline">\(f(S)=\cfrac{m+m&#39;}{n+n&#39;}\)</span>.</p>
<p>那么不难发现它的每一次操作只需右乘一个变换矩阵即可.</p>
<p>其中:<span class="math inline">\(L=\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix},R=\begin{bmatrix}1
&amp;0\\1&amp;1\end{bmatrix}\)</span>.</p>
<p>使用数学归纳不难证明:</p>
<p><span class="math inline">\(L^k=\begin{bmatrix}1&amp;k\\0&amp;1\end{bmatrix},R^k=\begin{bmatrix}1
&amp;0\\k&amp;1\end{bmatrix}\)</span>.</p>
<p>至于已知数字求它的序列表示,首先可以直接在树上搜索.</p>
<p>而如果要脱离树,我们仍然可以回到矩阵上,意识到<span class="math inline">\(f(RS)=f(S)+1\)</span>,再加上关于根中心对称两点互为倒数的性质,我们可以推导出以下法则:</p>
<p>如果<span class="math inline">\(m&gt;n\)</span>,那么<span class="math inline">\(f(RS)=\cfrac{m}{n}\Leftrightarrow
f(S)=\cfrac{m-n}{n}\)</span>.</p>
<p>如果<span class="math inline">\(m&lt;n\)</span>,那么<span class="math inline">\(f(LS)=\cfrac{m}n\Leftrightarrow
f(S)=\cfrac{m}{n-m}\)</span>.</p>
<p>借助这一点,我们就可以求一个数的<span class="math inline">\(LR\)</span>序列表示了.</p>
<p>在某些情形下,这种表示可以解决二进制下某些分数无法精确表示的问题.</p>
<h4><span id="升幂引理">升幂引理</span></h4>
<h5><span id="形式一">形式一</span></h5>
<p>对于素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p\nmid x,p\nmid y\)</span>,对于满足<span class="math inline">\(\gcd(n,p)=1\)</span>的<span class="math inline">\(n\)</span>:</p>
<ol type="1">
<li>若<span class="math inline">\(p|(x-y)\)</span>,则<span class="math inline">\(v_p(x^n-y^n)=v_p(x-y)\)</span>.</li>
<li>若<span class="math inline">\(p|(x+y)\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p(x^n+y^n)=v_p(x+y)\)</span>.</li>
</ol>
<p>考虑(1)的证明,由于<span class="math inline">\(p|(x-y),x\equiv y\pmod
p\)</span>,因此<span class="math inline">\(\sum_{k=0}^{n-1}x^ky^{n-1-k}\equiv nx^{n-1}\ne
0\pmod p\)</span>.有次方差公式,显然.</p>
<p>(2)类似.</p>
<h5><span id="形式二">形式二</span></h5>
<p>对于奇素数<span class="math inline">\(p\)</span>,<span class="math inline">\(p\nmid x,p\nmid y\)</span>:</p>
<ol type="1">
<li>若<span class="math inline">\(p|(x-y)\)</span>,则<span class="math inline">\(v_p(x^n-y^n)=v_p(x-y)+v_p(n)\)</span>.</li>
<li>若<span class="math inline">\(p|(x+y)\)</span>,<span class="math inline">\(n\)</span>是奇数,则<span class="math inline">\(v_p(x^n+y^n)=v_p(x+y)+v_p(n)\)</span>.</li>
</ol>
<p>和形式一的证明完全类似.</p>
<h3><span id="同余">同余</span></h3>
<p>如果<span class="math inline">\(a\mod m=b\mod m\)</span>,我们称<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>关于模<span class="math inline">\(m\)</span>同余,记作<span class="math inline">\(a\equiv b(\mod m)\)</span>.</p>
<p>根据同余的定义,若<span class="math inline">\(a,b,c,d,k\in
\mathbb{Z}\)</span>,<span class="math inline">\(n,m\in\mathbb{N_+}\)</span>,我们有以下性质:</p>
<ol type="1">
<li><span class="math inline">\(a\equiv b\pmod m\Leftrightarrow
a-b=km\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and c\equiv d\pmod
m\Rightarrow a+c\equiv b+d\pmod m\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and c\equiv d\pmod
m\Rightarrow ac\equiv bd\pmod m\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\Rightarrow a^k\equiv
b^k\pmod m\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod m\Leftrightarrow
a\equiv b\pmod m,m\bot d\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod {md}\Leftrightarrow
a\equiv b\pmod m,d\ne 0\)</span>.</li>
<li><span class="math inline">\(ad\equiv bd\pmod m\Leftrightarrow
a\equiv b\pmod {\cfrac{m}{\gcd(m,d)}}\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod {md}\Rightarrow a\equiv
b\pmod m,d\ne 0\)</span>.</li>
<li><span class="math inline">\(a\equiv b\pmod m\and a\equiv b\pmod
n\Leftrightarrow a\equiv b\pmod {lcm(n,m)}\)</span>.</li>
</ol>
<p>我们考虑第五条的证明:由于<span class="math inline">\(m\bot
d\)</span>,则根据扩展欧几里得算法,可以求得一个数<span class="math inline">\(d&#39;\)</span>满足<span class="math inline">\(dd&#39;+mm&#39;=1\)</span>,也就是<span class="math inline">\(dd&#39;\equiv 1(\mod
m)\)</span>,那么如果我们有<span class="math inline">\(ad\equiv bd(\mod
m)\)</span>,只需要两边同时乘以<span class="math inline">\(d&#39;\)</span>就可以得到右边.值得一提的是,我们通常称<span class="math inline">\(d&#39;\)</span>是<span class="math inline">\(d\)</span>在模<span class="math inline">\(m\)</span>意义下的逆元,记作<span class="math inline">\(inv(d,m)\)</span>或<span class="math inline">\(d^{-1}\)</span>.</p>
<p>逆元有一种线性预处理的求法:</p>
<p>考虑<span class="math inline">\(1\leq i\leq n\)</span>,设<span class="math inline">\(p=ki+r\)</span>,则有<span class="math inline">\(ki+r\equiv 0(\mod p)\)</span>,则有<span class="math inline">\(kr^{-1}+i^{-1}\equiv 0(\mod p)\)</span>.</p>
<p>于是有<span class="math inline">\(i^{-1}\equiv -kr^{-1}(\mod
p)\)</span>,即<span class="math inline">\(i^{-1}\equiv
-\lfloor\cfrac{p}{i}\rfloor\times r^{-1}(\mod p)\)</span>.</p>
<p>现在,我们给出一个结论:数列<span class="math inline">\(0\mod m,n\mod
m,2n\mod m,...,(m-1)n\mod m\)</span>在排序去重后恰好为数列<span class="math inline">\(0,d,2d,...,m-d\)</span>,<span class="math inline">\(d=\gcd(n,m)\)</span>,而且其中每个数字在原数列中恰好出现了<span class="math inline">\(d\)</span>次.</p>
<p>恰好出现<span class="math inline">\(d\)</span>次是好证明的:考虑<span class="math inline">\(jn\equiv kn(\mod m)\)</span>可以推导出<span class="math inline">\(j\equiv k(\mod
\cfrac{m}d),d=\gcd(n,m)\)</span>,则显然这些数是一个序列复制<span class="math inline">\(d\)</span>次得到的.</p>
<p>由上,我们要证明<span class="math inline">\(kn\mod
m\)</span>一定是<span class="math inline">\(d\)</span>的倍数.不难发现<span class="math inline">\(kn\mod m=dk\cfrac{n}d(\mod \cfrac m d
d)=d(\cfrac{kn}d\mod \cfrac{m}d)\)</span>.</p>
<p>接下来,不妨假设<span class="math inline">\(n\bot
m\)</span>,并在此条件下证明<span class="math inline">\(0\mod m,n\mod
m,2n\mod m,...,(m-1)n\mod m\)</span>两两不同即可.而由于<span class="math inline">\(n\bot m\)</span>,则<span class="math inline">\(kn\equiv jn(\mod m)\)</span>的充分必要条件是<span class="math inline">\(k\equiv j(\mod
m)\)</span>,因此它们显然两两不同.</p>
<h5><span id="example具体数学431">Example(《具体数学》4.31)</span></h5>
<p><span class="math inline">\(n\)</span>进制下,各位数字之和是<span class="math inline">\(m\)</span>的倍数,则这个数是<span class="math inline">\(m\)</span>的倍数的充分必要条件是?</p>
<p>令<span class="math inline">\(a_i\)</span>表示这个数字在<span class="math inline">\(n\)</span>进制下的第<span class="math inline">\(i\)</span>位,则这条性质也就是: <span class="math display">\[
\sum_{i=0}a_in^i\equiv 0\pmod m\Leftrightarrow\sum_{i=0}a_i\equiv 0\pmod
m
\]</span> 不难发现,当<span class="math inline">\(n\equiv 1\pmod
m\)</span>时,满足该性质.</p>
<h4><span id="威尔逊定理">威尔逊定理</span></h4>
<p><span class="math inline">\((p-1)!\equiv \begin{cases}
-1(\mod p)&amp;p\in prime\\
2(\mod p)&amp;p=4\\
0(\mod p)&amp;other
\end{cases}\)</span></p>
<p>证明:</p>
<p>当<span class="math inline">\(p\)</span>为质数时，考虑对于<span class="math inline">\(a\)</span>和<span class="math inline">\(b=a^{-1}(\mod p)\)</span>,若<span class="math inline">\(a=b\)</span>,此时可证明<span class="math inline">\(a=1\)</span>或<span class="math inline">\(a=p-1\)</span>(需要用到下面独立剩余知识).</p>
<p>如果<span class="math inline">\(a\ne b\)</span>那么一定可以在<span class="math inline">\([1,p-1]\)</span>找到一对数,它们相乘为<span class="math inline">\(1\)</span>.原因是若<span class="math inline">\(a_1\ne a_2\)</span>,那么<span class="math inline">\(a_1^{-1}\ne a_2^{-1}\)</span>.</p>
<p>若<span class="math inline">\(p\)</span>不是质数,则设<span class="math inline">\(p=ab\)</span>,当<span class="math inline">\(a\ne
b\)</span>时,由于<span class="math inline">\(a,b\leq
p\)</span>,因此<span class="math inline">\((p-1)!\)</span>一定是<span class="math inline">\(p\)</span>的倍数.</p>
<p>若<span class="math inline">\(a=b\)</span>,除非<span class="math inline">\(p=4\)</span>,不然一定能在<span class="math inline">\([1,p-1]\)</span>里找到<span class="math inline">\(a\)</span>和<span class="math inline">\(2a\)</span>,此时<span class="math inline">\((p-1)!\)</span>也是<span class="math inline">\(p\)</span>的倍数.</p>
<p>另外,当<span class="math inline">\(p\)</span>是奇质数的时候,威尔逊定理可以写成如下形式:
<span class="math display">\[
\prod_{k=1}^{\frac{p-1}{2}}k(p-k)\equiv -1\pmod p\\
\prod_{k=1}^{\frac{p-1}2}-k^2\equiv -1\pmod p\\
(-1)^{\frac{p-1}{2}}((\cfrac{p-1}{2})!)^2\equiv -1\pmod p
\]</span></p>
<p>另外,通过以上推导过程,不难发现威尔逊定理还可以写成: <span class="math display">\[
(p-2)!\equiv \begin{cases}
1(\mod p)&amp;p\in prime\\
2(\mod p)&amp;p=4\\
0(\mod p)&amp;other
\end{cases}
\]</span></p>
<h5><span id="example1具体数学448">Example1(《具体数学》4.48)</span></h5>
<p>求<span class="math inline">\(\prod_{1\leq n&lt;m,n\bot m}n\pmod
m\\\)</span>.</p>
<p>首先,类似威尔逊定理的推导,不难注意到这个式子也就等价于: <span class="math display">\[
\prod_{1\leq n&lt;m,n^2\equiv 1\pmod m}n\pmod m
\]</span> 首先考虑满足<span class="math inline">\(n^2\equiv 1\pmod
m\)</span>的<span class="math inline">\(n\)</span>满足什么性质,根据我们在二次剩余的推导,先考虑<span class="math inline">\(2\nmid m\)</span>的情况,此时我们将<span class="math inline">\(m\)</span>分解为了若干个形如<span class="math inline">\(p^k\)</span>的质因数的乘积,对于每个<span class="math inline">\(p^k\)</span>作为模数时,<span class="math inline">\(n\)</span>有两个解:<span class="math inline">\(1\)</span>和<span class="math inline">\(p^k-1\)</span>.</p>
<p>当<span class="math inline">\(m=p^k\)</span>的时候,显然答案就是<span class="math inline">\(-1\)</span>.</p>
<p>不然,由于此时有很多解,我们考虑设答案为<span class="math inline">\(ans\)</span>并对于每个<span class="math inline">\(p^k\)</span>求出$ans <span class="math inline">\(的答案,再使用中国剩余定理合并.不难发现只要\)</span>m<span class="math inline">\(有多个不同的质因子,那么中国剩余定理合并的时候,一定会有偶数个\)</span>n<span class="math inline">\((事实上,假设\)</span>m<span class="math inline">\(有\)</span>a$个质因子,那么有<span class="math inline">\(2^{a-1}\)</span>个这样的<span class="math inline">\(n\)</span>)满足<span class="math inline">\(n\equiv
-1\pmod {p^k}\)</span>,也有同样数目的<span class="math inline">\(n\)</span>满足<span class="math inline">\(n\equiv
1\pmod {p^k}\)</span>.那么此时的<span class="math inline">\(ans\equiv
1\pmod {p^k}\)</span>.多次合并后的<span class="math inline">\(ans\)</span>显然还是<span class="math inline">\(1\)</span>.</p>
<p>至于<span class="math inline">\(2\mid
m\)</span>的情况并没有麻烦很多,当<span class="math inline">\(2\mid m\and
4\nmid m\)</span>,显然有没有这个<span class="math inline">\(2\)</span>作为质因子都一样.当<span class="math inline">\(4\mid m\and 8\nmid
m\)</span>,这个质因子和其它质因子并没有多少区别.</p>
<p>于是我们最后得到结论: <span class="math display">\[
\prod_{1\leq n&lt;m,n\bot m}n\equiv \begin{cases}
-1\pmod m&amp;m=p^k\or m=2p^k\or m=4,p\in prime\and p\ne 2\\
1\pmod m&amp;other\\
\end{cases}
\]</span></p>
<h5><span id="example2具体数学440">Example2(《具体数学》4.40)</span></h5>
<p>如果我们设<span class="math inline">\(n=\sum_{k\geq
0}a_kp^k\)</span>,求证:<span class="math inline">\(\cfrac{n!}{p^{\varepsilon_p(n!)}}=(-1)^{\varepsilon_p(n!)}\prod_{k\geq
0}a_k!\pmod p\)</span>.</p>
<p>证明考虑数学归纳:如果<span class="math inline">\(n\rightarrow
n+1\)</span>的过程中没有发生进位,那么该公式显然成立.</p>
<p>如果发生进位了,假设进到了第<span class="math inline">\(k\)</span>位,第<span class="math inline">\(k\)</span>位原本是<span class="math inline">\(w\)</span>,现在是<span class="math inline">\(w+1\)</span>,那么要证其对于<span class="math inline">\(n+1\)</span>成立,即证明下式成立: <span class="math display">\[
\cfrac{n!(n+1)}{p^{\varepsilon_p(n!)+k}}=(-1)^{\varepsilon_p(n!)+k}(w+1)!\prod_{i\geq
k+1}a_i!\pmod p
\]</span> 考虑<span class="math inline">\((p-1)\equiv -1\pmod
p\)</span>,于是上式也即: <span class="math display">\[
\cfrac{n!(n+1)}{p^{\varepsilon_p(n!)+k}}=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p\\
\cfrac{n!}{p^{\varepsilon_p(n!)}}\cfrac{n+1}{p^k}=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p\\
\cfrac{n!}{p^{\varepsilon_p(n!)}}(w+1)=(-1)^{\varepsilon_p(n!)}(w+1)\prod_{i\geq
0}a_i!\pmod p
\]</span> 于是化到<span class="math inline">\(n\)</span>的情况,于是<span class="math inline">\(n+1\)</span>时该式子成立.</p>
<h5><span id="example3具体数学453">Example3(《具体数学》4.53)</span></h5>
<p>求所有满足<span class="math inline">\(n|\lceil\cfrac{(n-1)!}{n+1}\rceil\)</span>的整数<span class="math inline">\(n\)</span>.</p>
<p>首先这个形式看上去就是威尔逊定理的形式,所以第一步我们先暴力验证<span class="math inline">\(n\in[1,4]\)</span>的答案,注意到此时当且仅当<span class="math inline">\(n=1\)</span>时成立.接下来我们尝试找到<span class="math inline">\(n\geq 5\)</span>时的解.</p>
<p>考虑当<span class="math inline">\(n+1\in
prime\)</span>时,根据威尔逊定理,要求化为:<span class="math inline">\(n\mid\cfrac{(n-1)!+n}{n+1}\)</span>.注意到此时<span class="math inline">\(n\)</span>一定不是质数,又因为<span class="math inline">\(n\bot (n+1)\)</span>,于是要求化为<span class="math inline">\(n\mid {(n-1)!+n}\)</span>,显然成立.</p>
<p>当<span class="math inline">\(n+1\notin
prime\)</span>时,要求则化为<span class="math inline">\(n\mid
\cfrac{(n-1)!}{n+1}\)</span>.当<span class="math inline">\(n\in
prime\)</span>时,显然不成立.反之显然成立.</p>
<p>于是要么<span class="math inline">\(n=1\)</span>,要么<span class="math inline">\(n\geq 5\and n\notin prime\)</span>.</p>
<h4><span id="费马小定理">费马小定理</span></h4>
<p><span class="math inline">\(n^{p-1}\equiv 1(\mod p),n\bot p,p\in
prime\)</span>.</p>
<p>我们有: <span class="math display">\[
\prod _{k=1}^{p-1}kn\equiv \prod _{k=1}^{p-1}(kn\mod p)(\mod p)\\
n^{p-1}(p-1)!\equiv (p-1)!(\mod p)
\]</span> 根据威尔逊定理,显然可以推得费马小定理.</p>
<p>根据费马小定理,我们可以考虑证明一个结论:<span class="math inline">\(n^{p^k}\equiv n^{p^{k-1}}(\mod p^k)\)</span>.</p>
<p>由于<span class="math inline">\(n^{p-1}\equiv 1(\mod
p)\)</span>,那么我们有<span class="math inline">\(n^p\equiv n(\mod
p)\)</span>,也即<span class="math inline">\(\exist
q\in\mathbb{Z}\)</span>满足<span class="math inline">\(n^p=n+pq\)</span>,不断两边取<span class="math inline">\(p\)</span>次方即可得到上述结论.</p>
<p>另外,费马小定理还可以如下证明:</p>
<p>考虑证明<span class="math inline">\(n^p\equiv n\pmod
p\)</span>,也就是要证明<span class="math inline">\((\sum_{i=1}^n1)^p\equiv n\pmod p\)</span>.</p>
<p>注意到根据多项式定理,<span class="math inline">\((\sum_{i=1}^n1)^p=\sum_{\sum
a=p}\cfrac{p!}{a_1!...a_n!}\)</span>.而如果<span class="math inline">\(\max\{a\}\ne p\)</span>,则后面的式子在<span class="math inline">\(\mod p\)</span>意义下显然为<span class="math inline">\(0\)</span>,不然,考虑<span class="math inline">\(\max\{a\}=p\)</span>的序列一共会出现<span class="math inline">\(n\)</span>次且每次对答案的贡献都是<span class="math inline">\(1\)</span>,自然有<span class="math inline">\(n^p\equiv n(\mod p)\)</span>.</p>
<h5><span id="example1具体数学441">Example1(《具体数学》4.41)</span></h5>
<p>求证:如果质数<span class="math inline">\(p\)</span>满足<span class="math inline">\(p\equiv 3\pmod 4\)</span>,则不存在整数<span class="math inline">\(n\)</span>满足<span class="math inline">\(p|(n^2+1)\)</span>;如果其满足<span class="math inline">\(p\equiv 1\pmod 4\)</span>,则一定存在一个整数<span class="math inline">\(n\)</span>满足条件.</p>
<p>先考虑证明前半部分,如果存在这样一个整数<span class="math inline">\(n\)</span>,考虑<span class="math inline">\(p|(n^2+1)\)</span>也就等价于<span class="math inline">\(n^2\equiv -1\pmod p\)</span>,则<span class="math inline">\(n^4\equiv 1\pmod p\)</span>.显然<span class="math inline">\(p\bot n\)</span>,根据费马小定理,我们有<span class="math inline">\(n^{p-1}\equiv 1\pmod p\)</span>,也就有<span class="math inline">\(n^{p+1}\equiv -1\pmod p\)</span>.</p>
<p>而由于<span class="math inline">\(p\equiv 3\pmod 4\)</span>,所以<span class="math inline">\(4|(p+1)\)</span>,所以<span class="math inline">\(n^{p+1}\equiv 1\pmod
p\)</span>,不符,因此一定不存在.</p>
<p>反之,考虑威尔逊定理的变形<span class="math inline">\(\prod_{k=1}^{\frac{p-1}2}-k^2\equiv -1\pmod
p\\\)</span>.由于<span class="math inline">\(p-1\equiv 0\pmod
4\)</span>,所以这个式子也就等价于<span class="math inline">\(\prod
_{k=1}^{\frac{p-1}2}k^2\equiv -1\pmod p\)</span>,也就是<span class="math inline">\(((\cfrac{p-1}{2})!)^2\equiv -1\pmod
p\)</span>,这就是一个解.</p>
<h5><span id="example2具体数学446">Example2(《具体数学》4.46)</span></h5>
<p>求证:如果<span class="math inline">\(n&gt;1\)</span>,则<span class="math inline">\(2^n\ne 1\pmod n\)</span>.</p>
<p>如果<span class="math inline">\(n\)</span>是质数,根据费马小定理,显然得证.</p>
<p>不然,设<span class="math inline">\(n=pq\)</span>,且<span class="math inline">\(p\)</span>是<span class="math inline">\(n\)</span>的最小质因子,若<span class="math inline">\(2^{n}\equiv 1\pmod n\)</span>,则<span class="math inline">\(2^n\equiv 1\pmod p\)</span>.</p>
<p>若<span class="math inline">\(p=2\)</span>,显然不成立.不然,有<span class="math inline">\(2^{p-1}\equiv 1\pmod p\)</span>,由于<span class="math inline">\((p-1)\bot n\)</span>,则<span class="math inline">\(2^{\gcd(p-1,n)}\equiv 2\equiv 1\pmod
p\)</span>,显然不成立.</p>
<p>另外,上面的过程显然可以推广为:</p>
<p>如果<span class="math inline">\(n&gt;1\)</span>,则对于任意质数<span class="math inline">\(p\)</span>,<span class="math inline">\(p^n\ne
1\pmod n\)</span>.</p>
<h4><span id="中国剩余定理crt">中国剩余定理(crt)</span></h4>
<p>对于方程组<span class="math inline">\(x\equiv a_i(\mod
m_i)\)</span>,其中<span class="math inline">\(m_i\)</span>两两互质,求<span class="math inline">\(x\)</span>.</p>
<p>令<span class="math inline">\(m=\prod^k_{i=1}m_i\)</span>,设<span class="math inline">\(M_i=\cfrac{m}{m_i}\)</span>,<span class="math inline">\(N_i\)</span>是<span class="math inline">\(M_i\)</span>在<span class="math inline">\(\mod
m_i\)</span>意义下逆元.</p>
<p>则<span class="math inline">\(x\equiv \sum^k_{i=1}M_iN_ia_i(\mod
m)\)</span>.</p>
<p>中国剩余定理的证明类似拉格朗日插值:</p>
<p>由于<span class="math inline">\(x\)</span>在<span class="math inline">\(\mod m_i\)</span>意义下,<span class="math inline">\(\sum\)</span>中枚举的所有不等于<span class="math inline">\(i\)</span>的项都会成<span class="math inline">\(0\)</span>，等于<span class="math inline">\(i\)</span>的项会成<span class="math inline">\(a_i\)</span>.</p>
<p>考虑每次合并两项，显然有:<span class="math inline">\(a=a_1+(a_2-a_1)\times m_1\times
inv(m_1,m_2)\)</span>,<span class="math inline">\(m=m_1m_2\)</span>.</p>
<p>中国剩余定理的本质是一个环同构<span class="math inline">\(\varphi:\Z/m_1m_2\Z\rightarrow (\Z/m_1\Z)\times
(\Z/m_2\Z)\)</span>,当<span class="math inline">\(m_1\bot
m_2\)</span>.</p>
<p>由于映射两边都是大小相同的有限环,所以只需证明它是单射就行.而容易发现<span class="math inline">\(\ker \varphi=\{[1]\}\)</span>.</p>
<p>下面的扩展中国剩余定理亦然同理,用一下裴蜀定理证明映射两边的有限环大小相等,再注意到<span class="math inline">\(|\ker \varphi|=1\)</span>.</p>
<h4><span id="扩展中国剩余定理excrt">扩展中国剩余定理(excrt)</span></h4>
<p>对于方程组<span class="math inline">\(x\equiv a_i(\mod
m_i)\)</span>,若<span class="math inline">\(m_i\)</span>两两不互质.</p>
<p>我们考虑每次合并两个方程:<span class="math inline">\(\begin{cases}
x\equiv a_1(\mod m_1)\\
x\equiv a_2(\mod m_2)
\end{cases}\)</span> 那这个方程组等价于:<span class="math inline">\(\begin{cases}
x=k_1m_1+a_1\\
x=k_2m_2+a_2
\end{cases}\)</span> 合并上下方程,有: <span class="math display">\[
k_1m_1+a_1=k_2m_2+a_2\\
a_2-a_1=k_1m_1-k_2m_2
\]</span> 设<span class="math inline">\(g=\gcd(m_1,m_2)\)</span>,显然若<span class="math inline">\(g\nmid (a_2-a_1)\)</span>,方程无解.</p>
<p>不然,有: <span class="math display">\[
\frac {a_2-a_1}g=k_1\frac {m_1}{g}-k_2\frac{m_2}{g}\\
k_1\frac{m_1}{g}=k_2\frac {m_2}g+\frac {a_2-a_1}g\\
k_1\frac{m_1}g\equiv \frac {a_2-a_1}{g}(\mod \frac {m_2}g)\\
\]</span> 令<span class="math inline">\(inv(a,p)\)</span>表示<span class="math inline">\(a\)</span>在<span class="math inline">\(\mod
p\)</span>意义下的逆元,有: <span class="math display">\[
k_1\equiv inv(\frac {m_1}{g},\frac {m_2}g)\frac{a_2-a_1}{g}(\mod \frac
{m_2}g)\\
k_1=inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g\\
\]</span> 带回第一个方程: <span class="math display">\[
x=m_1(inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g)+a_1\\
x\equiv m_1inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+a_1(\mod
\frac{m_1m_2}g)
\]</span></p>
<h5><span id="example1noi2018屠龙勇士">Example1([NOI2018]屠龙勇士)</span></h5>
<p>考虑拿个set之类的维护,然后问题转化为求: <span class="math display">\[
\begin{cases}
b_1x\equiv a_1(\mod m_1)\\
b_2x\equiv a_2(\mod m_2)\\
...\\
b_nx\equiv a_n(\mod m_n)
\end{cases}
\]</span> 的一个<span class="math inline">\(x\)</span>的最小解.</p>
<p>对于一个式子<span class="math inline">\(b_ix\equiv a_i\pmod
{m_i}\)</span>,设<span class="math inline">\(g=\gcd(b_i,m_i)\)</span>,那么若<span class="math inline">\(g\nmid a_i\)</span>,显然无解;不然,我们有:<span class="math inline">\(\cfrac{b_i}{g}x\equiv \cfrac{a_i}g\pmod
{\cfrac{m_i}{g}}\)</span>,而<span class="math inline">\(\cfrac{b_i}{g}\bot
\cfrac{m_i}{g}\)</span>,可以求逆元.</p>
<h5><span id="example2cf571egeometricprogressions">Example2([CF571E]Geometric
Progressions)</span></h5>
<p>首先分解质因子,这样问题转化为判断等差数列中是否出现.我们随便挑一个数列,假设这个数列中第<span class="math inline">\(x\)</span>个数字是答案,显然最小化<span class="math inline">\(x\)</span>即可.</p>
<p>但是直接对所有质因子做excrt复杂度不可接受.我们考虑如果对于质因子<span class="math inline">\(p\)</span>,<span class="math inline">\(\exists
i,j\in[1,n],i\ne j\)</span>有<span class="math inline">\(p|b_j,p\nmid
a_i,p\nmid b_i\)</span>,显然无解.如果有<span class="math inline">\(p|b_j,p|a_i,p\nmid
b_i\)</span>,显然要么无解,要么有唯一解,而且可以快速求出唯一解是谁,直接验证就行.</p>
<p>这样,我们就保证了所有需要做excrt的质因子必然全部出现,容易发现这样的质因子数量很少.</p>
<h4><span id="二次剩余">二次剩余</span></h4>
<p>求方程<span class="math inline">\(x^2=k(\mod m)\)</span>的解.</p>
<p>我们先考虑一个特殊情况:<span class="math inline">\(k=1\)</span>,<span class="math inline">\(m=p^k,p\in prime\)</span>.</p>
<p>那么也就相当于求方程<span class="math inline">\((x-1)(x+1)\equiv
0(\mod p^k)\)</span>.</p>
<p>如果<span class="math inline">\(p&gt;2\)</span>,那么显然<span class="math inline">\(x-1\)</span>和<span class="math inline">\(x+1\)</span>只有一个能被<span class="math inline">\(p^k\)</span>整除,所以有<span class="math inline">\(x=\pm 1\)</span>.</p>
<p>如果<span class="math inline">\(p=2\)</span>,那么显然<span class="math inline">\(x-1\)</span>和<span class="math inline">\(x+1\)</span>有一个能被<span class="math inline">\(2\)</span>整除但不能被<span class="math inline">\(4\)</span>整除,另一个能被<span class="math inline">\(2^{k-1}\)</span>整除,如果<span class="math inline">\(k=1\)</span>时,显然只有一个解.当<span class="math inline">\(k=2\)</span>时,同上.反之,有<span class="math inline">\(x=\pm 1\)</span>或<span class="math inline">\(x=2^{k-1}\pm 1\)</span>.考虑一个性质:<span class="math inline">\((2k+1)^2\equiv 1(\mod 8)\)</span>.</p>
<p>那么如果:<span class="math inline">\(k=1,m\in\mathbb{N_+}\)</span>,也是一样的.先把<span class="math inline">\(m\)</span>作质因数分解,然后再用中国剩余定理合并,那么显然不同质数的解会累乘到总的解上,若<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同大于<span class="math inline">\(2\)</span>的质因子,总的解的个数是<span class="math inline">\(2^r\)</span>.而如果考虑<span class="math inline">\(p=2\)</span>的情况,<span class="math inline">\(m\)</span>有<span class="math inline">\(r\)</span>个不同的质因子,则解的个数为<span class="math inline">\(2^{r+[8|m]+[4|m]-[2|m]}\)</span>.</p>
<p>下面开始讲正经的二次剩余.</p>
<p>我们称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的二次剩余,当且仅当<span class="math inline">\(\exists b,b^2\equiv a\pmod p\)</span>并且<span class="math inline">\(a\ne 0\pmod p\)</span>,这里的<span class="math inline">\(p\)</span>是奇素数,如果<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的倍数且<span class="math inline">\(\nexists b,b^2\equiv a\pmod
p\)</span>,则称为二次非剩余.我们引入勒让德符号来表示这个东西: <span class="math display">\[
\left(\frac{a}{p}\right)=\begin{cases}1&amp;a是二次剩余\\0&amp;a\equiv
0\pmod p\\-1&amp;a为二次非剩余\end{cases}
\]</span> 那么这玩意怎么求呢?我们有欧拉判别准则: <span class="math display">\[
\left(\frac{a}{p}\right)\equiv a^{\frac{p-1}{2}}\pmod p
\]</span> 先证明个引理:若<span class="math inline">\(g\)</span>为<span class="math inline">\(\bmod p\)</span>意义下的原根,且<span class="math inline">\(a\equiv g^k\)</span>,那么<span class="math inline">\(x^2\equiv a\pmod p\)</span>有解的充要条件是<span class="math inline">\(k\)</span>是偶数.</p>
<p>充分性显然,而必要性,我们考虑费马小定理:<span class="math inline">\(g^{p-1}\equiv 1\pmod p\)</span>,而<span class="math inline">\(p-1\)</span>是偶数,因此无论如何奇偶性都不会变.</p>
<p>接下来证明欧拉判别准则: <span class="math display">\[
g^{p-1}\equiv 1\pmod p\\
g^{p-1}-1\equiv 0\pmod p\\
(g^{\frac{p-1}{2}}+1)(g^{\frac{p-1}{2}}-1)\equiv 0\pmod p\\
g^{\frac{p-1}{2}}\equiv -1\pmod p\\
a^{\frac{p-1}{2}}=(g^k)^{\frac{p-1}{2}}=(g^{p-1})^{\frac{k}{2}}
\]</span> 于是得证.另外通过这个证明过程,我们可以发现<span class="math inline">\([1,p-1]\)</span>中有正好一半的数是二次剩余,我们还能得知<span class="math inline">\(x^2\equiv a\pmod p\)</span>的解的数量是<span class="math inline">\(\left(\frac{a}{p}\right)+1\\\)</span>.</p>
<h5><span id="example1cf1091gnewyear-and-the-factorisation-collaboration">Example1([CF1091G]New
Year and the Factorisation Collaboration)</span></h5>
<p>考虑随机一个<span class="math inline">\(x\)</span>,令<span class="math inline">\(x&#39;=\sqrt{x^2}\pmod n\)</span>,如果<span class="math inline">\(x&#39;=x\)</span>则放弃这次询问,不然自然有<span class="math inline">\((x&#39;-x)(x&#39;+x)\equiv 0\pmod n\)</span>.</p>
<p><span class="math inline">\(\forall p|n,p\in
prime\)</span>,注意到一定满足<span class="math inline">\(p|(x&#39;-x)\)</span>或<span class="math inline">\(p|(x&#39;+x)\)</span>,我们可以多做几次,可以理解为这样将<span class="math inline">\(n\)</span>随机分割了.</p>
<h5><span id="example2qoj5021">Example2(qoj5021)</span></h5>
<p>整个题就强调一个字:双射!</p>
<p>先把模数质因数分解.</p>
<p>从头开始看,这种多元组计数肯定要一点一点确定,我们考虑固定<span class="math inline">\((a,a&#39;)\)</span>求解<span class="math inline">\((b,b&#39;)\)</span>,这个时候发现只要<span class="math inline">\((a,a&#39;)\)</span>不全为<span class="math inline">\(0\)</span>,那么就有<span class="math inline">\(p\)</span>组<span class="math inline">\((b,b&#39;)\)</span>满足条件,这个可以通过移项求逆元发现.发现这个全为<span class="math inline">\(0\)</span>的条件很烦,我们先把它处理掉.</p>
<p>显然只有<span class="math inline">\(r=0\)</span>会出现这种情况,讨论一下<span class="math inline">\((a,a&#39;)\)</span>全为<span class="math inline">\(0\)</span>或<span class="math inline">\((b,b&#39;)\)</span>全为<span class="math inline">\(0\)</span>的情况,简单分类讨论可以得到共有<span class="math inline">\(2p^3+p^2-2p\)</span>种方案.</p>
<p>好了,困难的部分被我们解决了,不过这样我们需要多讨论一下<span class="math inline">\(r\)</span>是否等于<span class="math inline">\(0\)</span>,不过问题不大.</p>
<p>先考虑<span class="math inline">\(r=0\)</span>的情况:</p>
<p>注意到此时固定<span class="math inline">\((a,a&#39;)\)</span>会有<span class="math inline">\(p-1\)</span>组(有一组全<span class="math inline">\(0\)</span>)<span class="math inline">\((b,b&#39;)\)</span>满足条件,此时有方程<span class="math inline">\(\begin{cases}ac+a&#39;c&#39;\equiv 0\pmod
p\\bc+b&#39;c&#39;\equiv 0\pmod p\end{cases}\)</span>.显然若<span class="math inline">\((b,b&#39;)\equiv
k(a,a&#39;)\)</span>,那么该方程有<span class="math inline">\(p\)</span>组解,不然只有一组解.而前者相当于<span class="math inline">\((a,a&#39;)\)</span>满足<span class="math inline">\(ka^2+ka&#39;^2\equiv 0\)</span>,我们设<span class="math inline">\(C_k\)</span>是方程<span class="math inline">\(a^2+a&#39;^2\equiv k\pmod
p\)</span>的解的数量,把上面的全部加起来,答案是: <span class="math display">\[
(C_0-1)(p-1)p+((p^2-1)(p-1)-(C_0-1)(p-1))
\]</span> 化简一下得到:<span class="math inline">\((C_0-1)(p-1)^2+p^3-p^2-p+1\)</span>.</p>
<p>再考虑<span class="math inline">\(r\ne 0\)</span>的情况:</p>
<p>注意到此时不可能有全为<span class="math inline">\(0\)</span>的二元组了.所以固定<span class="math inline">\((a,a&#39;)\)</span>的话,<span class="math inline">\((b,b&#39;)\)</span>共有<span class="math inline">\(p\)</span>组解,此时有方程<span class="math inline">\(\begin{cases}ac+a&#39;c&#39;\equiv r\pmod
p\\bc+b&#39;c&#39;\equiv r\pmod p\end{cases}\)</span>.</p>
<p>若<span class="math inline">\((b,b&#39;)\equiv
k(a,a&#39;)\)</span>,显然当<span class="math inline">\(k=1\)</span>时有<span class="math inline">\(p\)</span>组解,否则无解,此时<span class="math inline">\(a^2+a&#39;^2\equiv r\pmod p\)</span>.</p>
<p>不然有唯一解.</p>
<p>而<span class="math inline">\((b,b&#39;)=k(a,a&#39;)\)</span>的方案有多少呢,显然是<span class="math inline">\(\sum_{k=1}^{p-1}C_{\frac{r}{k}}=\sum_{k=1}^{p-1}C_k=p^2-C_0\)</span>,这里用到了这篇题解的第一个双射,<span class="math inline">\([1,p-1]/k\mapsto [1,p-1]\)</span>.</p>
<p>于是这里的答案就是: <span class="math display">\[
C_rp+((p^2-1)p-(p^2-C_0))
\]</span> 化简一下得到<span class="math inline">\(p^3-p^2-p+C_0+C_rp\)</span>.</p>
<p>现在的问题是如何求<span class="math inline">\(C_0,C_r\)</span>.</p>
<p>先来技术总结一下,这种多元组计数通常要确定一些数字,然后对另一些数字进行计数,如果确定的那些数字不能进行枚举,那就得进行一些别的操作来在不同的情况下判断数量.</p>
<p>那么<span class="math inline">\(C_r\)</span>怎么求呢?考虑<span class="math inline">\(x^2\equiv a\pmod p\)</span>的解数为<span class="math inline">\(\left(\frac{a}{p}\right)+1\)</span>,我们有: <span class="math display">\[
C_r=\sum_{i=0}^{p-1}(\left(\frac{i}{p}\right)+1)(\left(\frac{r-i}{p}\right)+1)\\
=\sum_{i=0}^{p-1}\left(\frac{i(r-i)}{p}\right)+2\sum_{i=0}^{p-1}\left(\frac{i}{p}\right)+p\\
=\sum_{i=1}^{p-1}\left(\frac{\frac{r}{i}-1}{p}\right)+p
\]</span> <del>(这是干啥啊)</del></p>
<p>我们来一步一步分析这个式子是怎么得到的:</p>
<p>首先,第一步仍然是枚举其中一个,然后求另一个.然后将整个式子乘开,做一个双射<span class="math inline">\(r-[0,p-1]\mapsto
[0,p-1]\)</span>就可以合并其中两项,而至于前两项则是根据欧拉判别准则直接将上指标乘起来合并.然后我们发现<span class="math inline">\(\sum_{i=0}^{p-1}\left(\frac{i}{p}\right)=0\)</span>,因为<span class="math inline">\([0,p-1]\)</span>中一半是<span class="math inline">\(1\)</span>一半是<span class="math inline">\(-1\)</span>,又可以发现<span class="math inline">\(i=0\)</span>时显然为<span class="math inline">\(0\)</span>,<span class="math inline">\(x^2=i(r-i)\Leftrightarrow
(\frac{x}{i})^2=\frac{r}{i}-1\)</span>,做双射<span class="math inline">\([1,p-1]\times i^{-1}\mapsto [1,p-1]\)</span>.</p>
<p>做到这一步,自然有<span class="math inline">\(C_0=(p-1)\left(\frac{-1}{p}\right)+p\)</span>.</p>
<p>而对于<span class="math inline">\(r\ne
0\)</span>的时候,我们再做双射<span class="math inline">\(r/[1,p-1]\mapsto [1,p-1]\)</span>,于是<span class="math inline">\(C_r=\sum_{i=0}^{p-2}\left(\frac{i}{p}\right)+p=p-\left(\frac{-1}{p}\right)\)</span>.</p>
<p>只能说模质数意义下的加法乘法减法以及不含<span class="math inline">\(0\)</span>的乘法都是群,而且所有运算都是双射,很牛逼,计数题直接起飞.</p>
<p>不过这题需要特别判断一下<span class="math inline">\(p=2\)</span>的情况,也容易,暴力就行.</p>
<h5><span id="example3">Example3</span></h5>
<p>求<span class="math inline">\(2^a=3^b+1\)</span>和<span class="math inline">\(3^a=2^b+1\)</span>的所有解.</p>
<p>先看<span class="math inline">\(2^a=3^b+1\)</span>,显然<span class="math inline">\((2,1)\)</span>是一组解.当<span class="math inline">\(y\geq 3\)</span>的时候,显然有<span class="math inline">\(3^a+1\equiv 0\pmod 8\)</span>,而考虑<span class="math inline">\(3^{2k}\equiv 1\pmod 8\)</span>,这自然不可能.</p>
<p>再看<span class="math inline">\(3^a=2^b+1\)</span>.显然<span class="math inline">\((1,1)\)</span>和<span class="math inline">\((2,3)\)</span>是两组解.当<span class="math inline">\(b\geq 2\)</span>的时候<span class="math inline">\(3^a\equiv 1\pmod 4\)</span>,根据欧拉定理知道<span class="math inline">\(a\in \text {even}\)</span>,令<span class="math inline">\(a=2k\)</span>.自然有<span class="math inline">\((3^k-1)(3^k+1)=2^b\)</span>,这是形如<span class="math inline">\(t(t+2)=2^b\)</span>的形式,只有<span class="math inline">\(t=2\)</span>是一个解.</p>
<h4><span id="bsgs">BSGS</span></h4>
<p>求<span class="math inline">\(a^x\equiv b(\mod
p)\)</span>的一组解,其中<span class="math inline">\(p\in
prime\)</span>且<span class="math inline">\(1\leq p\leq
10^9\)</span>.</p>
<p>直接枚举显然是<span class="math inline">\(O(p)\)</span>的,非常不合理,考虑如何优化.</p>
<p>求出<span class="math inline">\(s=\lfloor\sqrt{p}\rfloor\)</span>,并求出所有<span class="math inline">\(a^i\)</span>,其中<span class="math inline">\(i\in
[0,s-1]\)</span>.</p>
<p>若<span class="math inline">\(x\leq
s-1\)</span>.则可以直接判断是否被求出来过.</p>
<p>否则,则将<span class="math inline">\(x=x\mod
(s-1)\)</span>,一直操作直到<span class="math inline">\(x\leq
s-1\)</span>.</p>
<h4><span id="exbsgs">exBSGS</span></h4>
<p>求<span class="math inline">\(a^x\equiv b(\mod
p)\)</span>的一组解,其中<span class="math inline">\(1\leq p\leq
10^9\)</span>.</p>
<p>设<span class="math inline">\(g=\gcd(a,p)\)</span>,那么根据膜的性质,原方程即<span class="math inline">\(\frac {a^x} g\equiv \frac b g (\mod \frac p
g)\)</span>.</p>
<p>显然若<span class="math inline">\(g\nmid b\)</span>并且<span class="math inline">\(b\ne 1\)</span>,方程定无解.(若<span class="math inline">\(b=1\)</span>,那么<span class="math inline">\(x=0\)</span>就是一个解)</p>
<p>那么现在的方程就是<span class="math inline">\(a^{x-1}\frac a g\equiv
\frac b g(\mod \frac p g)\)</span>.</p>
<p>继续进行这个过程,不断求<span class="math inline">\(a\)</span>和当前模数的<span class="math inline">\(\gcd\)</span>.并将当前模数除以该<span class="math inline">\(\gcd\)</span>,这样最后我们得到了方程:</p>
<p><span class="math inline">\(a^{x-k}\prod_{i=1}^k \frac a {g_i}\equiv
\frac b {\prod_{i=1}^k g_i}(\mod \frac p {\prod_{i=1}^k
g_i})\\\)</span></p>
<p>不妨设<span class="math inline">\(A=\prod_{i=1}^k \frac a
{g_i},B=\frac b {\prod_{i=1}^k g_i},P=\frac p {\prod_{i=1}^k
g_i}\\\)</span></p>
<p>那么现在方程就是<span class="math inline">\(a^{x-k}\equiv \frac B
A\pmod P\)</span>,可以使用BSGS求解.</p>
<p>ps：<span class="math inline">\(p=1\)</span>的时候要特判.</p>
<h4><span id="原根和阶">原根和阶</span></h4>
<p>阶:找到一个最小的<span class="math inline">\(k\)</span>使得<span class="math inline">\(a^k\equiv1(\mod p)\)</span>,则称<span class="math inline">\(k\)</span>是<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶.</p>
<p>原根:如果<span class="math inline">\(a\)</span>在膜<span class="math inline">\(p\)</span>意义下的阶是<span class="math inline">\(\varphi(p)\)</span>且<span class="math inline">\(a&lt;p\)</span>,则称<span class="math inline">\(a\)</span>是<span class="math inline">\(p\)</span>的一个原根.</p>
<p>若<span class="math inline">\(m\)</span>有原根,则<span class="math inline">\(m\)</span>一定是<span class="math inline">\(2\)</span>,<span class="math inline">\(4\)</span>或是<span class="math inline">\(p^a,2p^a\)</span>,其中<span class="math inline">\(p\in prime\)</span>且<span class="math inline">\(2\nmid p\)</span>.</p>
<p>由于对于大部分<span class="math inline">\(m\)</span>来说,都存在一个很小的原根,所以在实际应用中只需要暴力找就可以了.</p>
<p>根据阶的定义,我们如果要判断一个<span class="math inline">\(a\)</span>不是<span class="math inline">\(p\)</span>的原根,只需判断是否<span class="math inline">\(\exists i\)</span>使得<span class="math inline">\(a^i\equiv 1(\mod p)\)</span>.</p>
<p>而由于<span class="math inline">\(a^{\varphi(p)}\equiv 1(\mod
p)\)</span>,因此一定有<span class="math inline">\(i|\varphi(p)\)</span>,因此只需判断<span class="math inline">\(\varphi(p)\)</span>的所有因数,复杂度<span class="math inline">\(O(\sqrt{\varphi(p)})\)</span>.</p>
<p>事实上,只需要判断对于<span class="math inline">\(\varphi(p)\)</span>的所有质因子<span class="math inline">\(w\)</span>,是否有<span class="math inline">\(a^{\frac {\varphi(p)} w}\equiv 1(\mod
p)\)</span>即可,复杂度<span class="math inline">\(O(\omega
(p))\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>给定<span class="math inline">\(k\)</span>,<span class="math inline">\(p\)</span>,<span class="math inline">\(a\)</span>,求<span class="math inline">\(x^k\equiv
a(\mod p)\)</span>的所有解,其中<span class="math inline">\(p\in
prime\)</span>,<span class="math inline">\(1\leq k \leq
10^5\)</span>.</p>
<p>考虑求出<span class="math inline">\(p\)</span>的原根<span class="math inline">\(g\)</span>,得到<span class="math inline">\(g^r\equiv a(\mod p)\)</span>,同时由于<span class="math inline">\(x\equiv g^y(\mod p)\)</span>,因此原方程变为:<span class="math inline">\(g^{yk}\equiv g^r(\mod p)\)</span>.</p>
<p>于是有:<span class="math inline">\(yk\equiv r(\mod
p-1)\)</span>,即可求解.</p>
<h5><span id="example2具体数学447">Example2(《具体数学》4.47)</span></h5>
<p>证明:如果<span class="math inline">\(\exist n,n^{m-1}\equiv 1\pmod
m\)</span>,且对于所有满足<span class="math inline">\(p|(m-1)\)</span>的<span class="math inline">\(p\)</span>都满足<span class="math inline">\(n^{\frac{m-1}{p}}\ne 1\pmod m\)</span>,那么<span class="math inline">\(m\)</span>是素数.</p>
<p>首先不难发现,<span class="math inline">\(m\in\ prime\Leftrightarrow
\varphi(m)=m-1\)</span>.</p>
<p>考虑上面的过程中,不可能存在一个数<span class="math inline">\(k\)</span>满足<span class="math inline">\(0\leq
k&lt;m-1,n^k\equiv 1\pmod m\)</span>.因此<span class="math inline">\(\nexists 0\leq i,j&lt;m,i\ne j,n^i\equiv n^j\pmod
m\)</span>.</p>
<p>根据欧拉定理,<span class="math inline">\(m-1=\varphi(m)\)</span>,因此得证.</p>
<h3><span id="积性函数">积性函数</span></h3>
<p>若函数<span class="math inline">\(f(x)\)</span>满足<span class="math inline">\(\forall n,m\in \mathbb{N_+},n\bot
m\)</span>,有<span class="math inline">\(f(1)=1,f(nm)=f(n)f(m)\)</span>,则称其为积性函数.若<span class="math inline">\(\forall n,m\in \mathbb{N_+}\)</span>,有<span class="math inline">\(f(1)=1,f(nm)=f(n)f(m)\)</span>,则称其为完全积性函数.</p>
<p>若函数<span class="math inline">\(g(x)\)</span>是积性函数并且有<span class="math inline">\(g(m)=\sum_{d|m}f(d)\)</span>,则<span class="math inline">\(f(x)\)</span>也是积性函数,证明如下:</p>
<p>不妨考虑数学归纳,首先<span class="math inline">\(g(1)=f(1)=1\)</span>.</p>
<p>令<span class="math inline">\(m=m_1m_2,m_1\bot m_2\)</span>,则<span class="math inline">\(g(m)=\sum_{d|m}f(d)=\sum_{d_1|m_1}\sum_{d_2|m_2}f(d_1d_2)\)</span>.由于归纳假设,此时只有<span class="math inline">\(d_1=m_1\and d_2=m_2\)</span>的时候,<span class="math inline">\(f(d_1d_2)\)</span>可能不等于<span class="math inline">\(f(d_1)f(d_2)\)</span>.</p>
<p>于是有 <span class="math display">\[
g(m)=\sum_{d_1|m_1}\sum_{d_2|m_2}f(d_1)f(d_2)-f(m_1)f(m_2)+f(m_1m_2)\\=g(m_1m_2)-f(m_1)f(m_2)+f(m_1m_2)
\]</span> 于是<span class="math inline">\(f(m_1)f(m_2)=f(m_1m_2)\)</span>.</p>
<p>该命题的逆命题也是同样成立的.有一些常见的积性函数,比如:<span class="math inline">\(id(x)=x\)</span>,<span class="math inline">\(I(x)=1\)</span>,<span class="math inline">\(\varepsilon(x)=[x=1]\)</span>.</p>
<h5><span id="example具体数学458">Example(《具体数学》4.58)</span></h5>
<p>求:<span class="math inline">\(f(m)=\sum_{d|m}d\)</span>是<span class="math inline">\(2\)</span>的整数次幂的充分必要条件.</p>
<p>不难发现<span class="math inline">\(f\)</span>是一个积性函数,于是考虑<span class="math inline">\(f(p^k)=1+p+p^2+...+p^k\)</span>.</p>
<p>当<span class="math inline">\(p=2\)</span>的时候,显然不满足条件.</p>
<p>不然,只有<span class="math inline">\(k\)</span>是奇数的时候,<span class="math inline">\(f(p^k)\)</span>才是一个偶数.</p>
<p>而此时<span class="math inline">\(f(p^k)=(1+p)(1+p^2+p^4+...+p^{k-1})=(1+p)(1+p^2)(1+p^4+...+p^{k-3})\)</span>.其是<span class="math inline">\(2\)</span>的整数次幂的一个必要条件是<span class="math inline">\(p\)</span>是一个梅森素数,而且不难发现只有当<span class="math inline">\(k=1\)</span>的时候才满足条件.</p>
<p>于是充分必要条件是:<span class="math inline">\(m\)</span>是若干个不同的梅森素数的乘积.</p>
<h4><span id="狄利克雷卷积">狄利克雷卷积</span></h4>
<p><span class="math inline">\(f*g=\sum_{d|n}{f(d)g(\cfrac n
d)}\)</span>.</p>
<p>不难证明狄利克雷卷积满足:</p>
<ol type="1">
<li>交换律:<span class="math inline">\(f*g=g*f\)</span>.</li>
<li>结合律:<span class="math inline">\(f*(g*h)=(f*g)*h\)</span>.</li>
<li>分配律:<span class="math inline">\(f*(g+h)=f*g+f*h\)</span>.</li>
<li>若<span class="math inline">\(f,g\)</span>是积性函数,则<span class="math inline">\(f*g\)</span>也是积性函数.</li>
</ol>
<p>考虑第四条的证明: <span class="math display">\[
f*g(nm)=\sum_{d|(nm)}f(d)g(\cfrac{n}d)\\
=\sum_{c|n}\sum_{d|m}f(cd)g(\cfrac{nm}{cd})\\
=\sum_{c|n}\sum_{d|m}f(c)f(d)g(\cfrac{n}{c})g(\cfrac{m}{d})\\
=(f*g(n))\times (f*g(m))
\]</span></p>
<ol start="5" type="1">
<li><span class="math inline">\(\forall f,f(1)\ne 0\)</span>,<span class="math inline">\(\exists f^{-1}\)</span>,<span class="math inline">\(f*f^{-1}=\epsilon\)</span>.</li>
</ol>
<p>构造<span class="math inline">\(g(x)\)</span>满足<span class="math inline">\(f(1)g(x)=\epsilon(x)-\sum_{d|x,d\ne
1}f(d)g(\frac{x}{d})\)</span>显然就是满足条件的.</p>
<ol start="6" type="1">
<li>积性函数的逆元也是积性函数.</li>
</ol>
<h4><span id="欧拉函数">欧拉函数</span></h4>
<p>定义欧拉函数<span class="math inline">\(\varphi(m)\)</span>为所有满足<span class="math inline">\(1\leq n\leq m\land n\perp m\)</span>的<span class="math inline">\(n\)</span>的个数.</p>
<p>令<span class="math inline">\(m=m_1m_2\)</span>,其中<span class="math inline">\(m_1\bot m_2\)</span>.由于若<span class="math inline">\(n\bot m_1,n\bot m_2\)</span>,显然有<span class="math inline">\((n\mod m_1)\bot m_1\)</span>且<span class="math inline">\((n\mod m_2)\bot
m_2\)</span>,则根据中国剩余定理,不难有<span class="math inline">\(\varphi(m)=\varphi(m_1)\varphi(m_2)\)</span>,也即<span class="math inline">\(\varphi(x)\)</span>是积性函数.</p>
<p>若<span class="math inline">\(n=\prod^{k}_{i=1}p_i^{a_i}\)</span>,则:</p>
<p><span class="math inline">\(\varphi(n)=\prod^k_{i=1}\varphi(p_i^{a_i})=\prod^k_{i=1}{p_i^{a_i}-p_i^{a_i-1}}=\prod^k_{i=1}{p^{a_i-1}(p_i-1)}\)</span>.</p>
<p>考虑改变枚举方式,因为<span class="math inline">\(n=\prod_{p|n}p^{a_p}\)</span>,则:<span class="math inline">\(\varphi(n)=\prod_{p|n}{p^{a_p-1}(p-1)}=\prod_{p|n}{(p^{a_p}\times
\cfrac{p-1}{p})}=n\times\prod_{p|n}\cfrac{p-1}{p}\)</span>.</p>
<p>我们考虑一个事实:现在有<span class="math inline">\(m\)</span>个不同的分数<span class="math inline">\(\cfrac{k}m,k\in[1,m]\)</span>,这些分数进行约分后,它们的分母即<span class="math inline">\(m\)</span>的若干因数,而它们的分子就是与这些因数互质的数,同时这些数的个数总共是<span class="math inline">\(m\)</span>个,我们可以得到:<span class="math inline">\(\sum_{d|m}\varphi(d)=m\)</span>.</p>
<p>上面这个结论还有另一种证明方法:</p>
<p>由于<span class="math inline">\(\varphi\)</span>是积性函数,若<span class="math inline">\(n\ne1\)</span>,设<span class="math inline">\(n=\prod_{i=1}^kp_i^{q_i}\)</span>,则<span class="math inline">\(\varphi(n)=\prod_{i=1}^k\varphi(p_i^{q_i})\)</span>,则有:
<span class="math display">\[
\sum_{d|n}\varphi(d)=\sum_{w_1=0}^{q_1}\sum_{w_2=0}^{q_2}......\sum_{w_k=0}^{q_k}{\varphi(p_1^{w_1})\varphi(p_2^{w_2})......\varphi(p_k^{w_k})}\\
\]</span> 而<span class="math inline">\(\varphi(p^q)=p^q-p^{q-1}\)</span>,于是有<span class="math inline">\(\sum_{i=1}^{q_i}{(p_x^i-p_x^{i-1})}=(p_x^{q_x}-1)\)</span>,则有<span class="math inline">\(\sum_{i=0}^{q_x}\varphi(p_x^{i})=p_x^{q_x}\)</span>.</p>
<p>则原式等于<span class="math inline">\(\prod_{i=1}^kp_i^{q_i}=n\)</span>.</p>
<h5><span id="和法里级数的关系">和法里级数的关系</span></h5>
<p>我们考虑之前提到的法里级数<span class="math inline">\(\mathcal{F}_n\)</span>,令<span class="math inline">\(\Phi(x)=\sum_{1\leq k\leq
x}\varphi(k)\)</span>,那么<span class="math inline">\(\mathcal{F}_n\)</span>的个数显然是<span class="math inline">\(\Phi(x)+1\)</span>.</p>
<p>接下来我们思考如何计算<span class="math inline">\(\Phi(x)\)</span>.事实上,我们有<span class="math inline">\(\sum_{d=1}^n\Phi(\lfloor\cfrac{n}d\rfloor)=\cfrac{1}2(n+1)n\)</span>.这里的证明是:考虑满足<span class="math inline">\(0\leq a&lt;b\leq n\)</span>的分数<span class="math inline">\(\cfrac{a}{b}\)</span>共有<span class="math inline">\(\cfrac{1}2n(n+1)\)</span>个,而如果我们枚举<span class="math inline">\(d=\gcd(a,b)\)</span>,那么显然右边也等于这些分数个数,于是得证.</p>
<p>而事实上,如果我们用<span class="math inline">\(n=\lfloor
x\rfloor\)</span>来带入上面的式子,可以得到<span class="math inline">\(\sum_{d=1}\Phi(\cfrac{x}d)=\cfrac{1}2\lfloor
x\rfloor\lfloor1+x\rfloor\)</span>.</p>
<p>根据第三种莫比乌斯反演的形式,我们有:<span class="math inline">\(\Phi(x)=\cfrac1 2\sum_{1\leq
d}\mu(d)\lfloor\cfrac{x }d\rfloor\lfloor\cfrac x
d+1\rfloor\)</span>.</p>
<h5><span id="麦克马洪和式">麦克马洪和式</span></h5>
<p>考虑这个问题:我们现在有<span class="math inline">\(m\)</span>种颜色,要对一个长度为<span class="math inline">\(n\)</span>的圆环进行染色,旋转后相同算一种方案,求方案数.</p>
<p>我们先设答案为<span class="math inline">\(N(n,m)\)</span>,并将这些答案全部列举出来,然后将它们进行旋转,进行<span class="math inline">\(n-1\)</span>次.这样我们就得到了<span class="math inline">\(nN(n,m)\)</span>个圆环,但是这些圆环是有重复的.</p>
<p>那么我们显然有: <span class="math display">\[
nN(n,m)=\sum_{a_0a_1...a_{n-1}}\sum_{0\leq
k&lt;n}[a_0a_1...a_{n-1}=a_k...a_{n-1}a_0...a_{k-1}]\\
=\sum_{0\leq
k&lt;n}\sum_{a_0a_1...a_{n-1}}[a_0a_1...a_{n-1}=a_k...a_{n-1}a_0...a_{k-1}]
\]</span> 接下来我们只需要知道,当已知<span class="math inline">\(k\)</span>的时候,右边和式的贡献是多少.显然此时有<span class="math inline">\(a_i=a_{(i+k)\mod n}\)</span>,也就是<span class="math inline">\(a_i=a_{(i+kl)\mod n}\)</span>,此时答案为<span class="math inline">\(m^{\gcd({n,k})}\)</span>.</p>
<p>为啥答案为<span class="math inline">\(m^{\gcd(n,k)}\)</span>呢?我们考虑这一定会不断在<span class="math inline">\(a\)</span>中取数,那么会取多少数呢?显然会取<span class="math inline">\(x-1\)</span>个数,其中<span class="math inline">\(i+xk=i+yn\)</span>,不难解得此时<span class="math inline">\(x=\frac{n}{\gcd(k,n)}\)</span>,因此一共有<span class="math inline">\(\gcd(n,k)\)</span>个轨道.</p>
<p>也就是说:<span class="math inline">\(nN(n,m)=\sum_{0\leq
k&lt;n}m^{\gcd(n,k)},N(n,m)=\cfrac{1}n\sum_{0\leq
k&lt;n}m^{\gcd(n,k)}\\\)</span>.</p>
<p>如果我们对这个式子进行化简: <span class="math display">\[
N(n,m)=\cfrac{1}{n}\sum_{d|n}m^d\sum_{0\leq k&lt;n}[d=\gcd(n,k)]\\
=\cfrac{1}{n}\sum_{d|n}m^d\sum_{d|k,k&lt;n}[\cfrac{k}{d}\bot
\cfrac{n}{d}]\\
=\cfrac{1}{n}\sum_{d|n}m^d\sum_{0\leq k&lt;\frac{n}d}[k\bot
\cfrac{n}d]\\
=\cfrac{1}{n}\sum_{d|n}\varphi(d)m^{\frac{n}{d}}.
\]</span> 这个式子被称为麦克马洪公式.</p>
<p>另外,如果我们考虑<span class="math inline">\(n|(\sum_{d|n}\varphi(d)n^{\frac{n}{d}})\)</span>这件事的证明,考虑如果<span class="math inline">\(n=p^k\)</span>,那么根据费马小定理,显然可证明.</p>
<p>而由于<span class="math inline">\(\varphi(x)\)</span>是积性函数,令<span class="math inline">\(n=n_1n_2,n_1\bot n_2\)</span>,有: <span class="math display">\[
\sum_{d|n}\varphi(d)n^{\frac{n}d}=\sum_{d_1|n_1,d_2|n_2}\varphi(d_1d_2)n^{\frac{n_1n_2}{d_1d_2}}\\
=\sum_{d_1|n_1}\varphi(d_1)(\sum_{d_2|n_2}\varphi(d_2)(n^{\frac{n_1}{d_1}})^{\frac{n_2}{d_2}})
\]</span> 我们可以通过数学归纳来证明.</p>
<h5><span id="burnside定理">Burnside定理</span></h5>
<p>现在让我们来进行一些抽象代数的计算.</p>
<p>置换群:运算<span class="math inline">\((a_1,a_2,...,a_k)\)</span>表示将<span class="math inline">\(a_1\)</span>放到<span class="math inline">\(a_2\)</span>位置…把<span class="math inline">\(a_i\)</span>放到<span class="math inline">\(a_{i+1}\)</span>的位置…把<span class="math inline">\(a_k\)</span>放到<span class="math inline">\(a_1\)</span>的位置,而幺元<span class="math inline">\(e=(1)(2)(3)...(n)\)</span>.</p>
<p>由麦克马洪和式的证明,我们不难推导出Polya定理:设要对<span class="math inline">\(n\)</span>个元素用<span class="math inline">\(m\)</span>种颜色染色,若通过某种旋转得到的染色方案算同一种,考虑旋转一定是一种置换,则本质不同的染色方案数<span class="math inline">\(=\cfrac{\sum_{s\in
S}m^{\eta(s)}}{|S|}\)</span>,其中<span class="math inline">\(\eta(s)\)</span>表示<span class="math inline">\(s\)</span>的轨道数,即有多少组置换.</p>
<h6><span id="example1hnoi2009图的同构计数">Example1([HNOI2009]图的同构计数)</span></h6>
<p>首先看到循环同构,第一反应就是Burnside定理.考虑将每条边的状态设为两种:选或不选,那么我们就对点的编号进行置换,然后找到不动边的数量.</p>
<p>我们先考虑对于一个置换,该如何求得它的不动边的数量.考虑置换是一个排列,对它做置换环分解.</p>
<p>现在问题在于置换环内和置换环间要分别求不动点的数量.</p>
<p>先来考虑置换环内:由于是一个置换环,我们假设它的大小是<span class="math inline">\(b\)</span>,将这<span class="math inline">\(b\)</span>个点排成一个正<span class="math inline">\(b\)</span>边形(<span class="math inline">\(b\)</span>个点的完全图),考虑一个一条边转多少次才能转回来,如果不是<span class="math inline">\(b\)</span>是偶数并且这条边正好平分整个多边形的话,显然需要转<span class="math inline">\(n\)</span>次,简单判掉特殊情况,发现轨道数量<span class="math inline">\(\lfloor\frac{b}{2}\rfloor\)</span>.</p>
<p>接下来考虑置换环外:对于两个置换环间,对于一条边,我们考虑不断做置换,做多少次才能使这条边回归原位置.注意到需要做<span class="math inline">\(lcm(b_1,b_2)\)</span>次.而总共有<span class="math inline">\(b_1b_2\)</span>条边,于是轨道数量<span class="math inline">\(\frac{b_1b_2}{lcm(b_1,b_2)}=\gcd(b_1,b_2)\)</span>.</p>
<p>这样对于一个<span class="math inline">\(k\)</span>个环的置换,它的答案就是<span class="math inline">\(\sum_{i=1}^k\lfloor\frac{b_i}{2}\rfloor+\sum_{i=1}^k\sum_{j=i+1}^k\gcd(b_i,b_j)\)</span>.</p>
<p>接下来发现本质不同的置换不多,搜出来每个置换环的大小,暴力判断.</p>
<h5><span id="欧拉定理">欧拉定理</span></h5>
<p>当<span class="math inline">\(a\perp m\)</span>时,<span class="math inline">\(a^{\varphi(m)}\equiv 1(\mod m)\)</span>.</p>
<p>证明考虑取出<span class="math inline">\([1,m]\)</span>中所有和<span class="math inline">\(m\)</span>互质的数,设它们为<span class="math inline">\(b_1,b_2,\cdots,b_{\varphi(m)}\)</span>.我们有:
<span class="math display">\[
\prod _{k=1}^{\varphi(m)}ab_k\equiv \prod _{k=1}^{\varphi(m)}(ab_k\bmod
p)(\mod p)\\
a^{\varphi(m)}\prod _{k=1}^{\varphi(m)}b_k\equiv \prod
_{k=1}^{\varphi(m)}b_k(\mod p)
\]</span></p>
<p>欧拉定理可以用来求逆元:<span class="math inline">\(a^{\varphi(p)}\equiv 1(\mod p)\)</span>,则有<span class="math inline">\(a^{-1}\equiv a^{\varphi(p)-1}(\mod
p)\)</span>.</p>
<h5><span id="扩展欧拉定理">扩展欧拉定理</span></h5>
<p><span class="math inline">\(a^b\equiv a^c(\mod m)\)</span>,其中<span class="math inline">\(c=
\begin{cases}
b\bmod \varphi(m) &amp;a\perp m\\
b &amp;b&lt;\varphi(m)\\
(b\bmod \varphi(m))+\varphi(m) &amp;other
\end{cases}\)</span></p>
<p>证明如下:</p>
<p>设<span class="math inline">\(m=\prod^k_{i=1}p_i^{e_i}\)</span>,则要证<span class="math inline">\(a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod
m)\)</span>,即证<span class="math inline">\(\forall i\)</span>都有<span class="math inline">\(a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod
p_i^{e_i})\)</span>.</p>
<p>分情况讨论:</p>
<p>若<span class="math inline">\(p_i^{e_i}\perp
a\)</span>,则为普通欧拉定理情况,即证明<span class="math inline">\(\varphi(p_i^{e_i})\)</span>是<span class="math inline">\(b-c\)</span>的因数.由于<span class="math inline">\(\varphi(p_i^{e_i})\)</span>是<span class="math inline">\(\varphi(m)\)</span>的因数,而<span class="math inline">\(\varphi(m)\)</span>是<span class="math inline">\(b-c\)</span>的因数,显然得证.</p>
<p>不然,发现<span class="math inline">\(e_i\leq\varphi(p_i^{e_i})\leq\varphi(m)\leq
b\)</span>且<span class="math inline">\(\varphi(m)\leq
c\)</span>,又发现<span class="math inline">\(p_i^{e_i}|a^{e_i}\)</span>,所以<span class="math inline">\(p_i^{e_i}|a^b\)</span>,<span class="math inline">\(p_i^{e_i}|a^c\)</span>,左右两边均为<span class="math inline">\(0\)</span>,得证.</p>
<p>######Example1(CF906D Power Tower)</p>
<p>考虑每次暴力做扩展欧拉定理,注意到每次会把<span class="math inline">\(p\)</span>变成<span class="math inline">\(\varphi(p)\)</span>,如果<span class="math inline">\(p\)</span>是奇数,那它下一步会变为偶数,如果<span class="math inline">\(p\)</span>是偶数,则下一步至少减半,于是迭代次数是<span class="math inline">\(\log n\)</span>级别的.</p>
<h6><span id="example2六省联考-2017相逢是问候">Example2([六省联考 2017]
相逢是问候)</span></h6>
<p>同上.</p>
<h6><span id="example3具体数学454">Example3(《具体数学》4.54)</span></h6>
<p>求<span class="math inline">\(1000!\pmod {10^{250}}\)</span>.</p>
<p>首先,根据前面的例题,不难发现<span class="math inline">\(5^{249}\times
2^{994}\mid (1000!)\)</span>.</p>
<p>我们有: <span class="math display">\[
1000!\equiv ans \pmod {10^{250}}\\
\cfrac{1000!}{10^{249}}\equiv \cfrac{ans}{10^{249}}\pmod {10}
\]</span> 由于模数现在变成了<span class="math inline">\(10\)</span>,考虑<span class="math inline">\(1\times 3\times 3\times 7\times 9\mod
{10}=7\)</span>,于是我们有: <span class="math display">\[
\cfrac{ans}{10^{249}}\equiv 2^{745}\times 7^{100}\pmod {10}\\
\]</span> 而<span class="math inline">\(\varphi(10)=4\)</span>,根据扩展欧拉定理: <span class="math display">\[
\cfrac{ans}{10^{249}}\equiv 2^{5}\pmod {10}\\
ans\equiv 2\times 10^{249}\pmod {10^{250}}
\]</span></p>
<h5><span id="example1具体数学457">Example1(《具体数学》4.57)</span></h5>
<p>求证:<span class="math inline">\(\sum_{1\leq k\leq
n+m}\varphi(k)[(m\mod k)+(n\mod k)\geq k]=nm\\\)</span>.</p>
<p>先考虑将条件改为一个更好处理的式子,不难发现: <span class="math display">\[
[m\bmod k+n\bmod k\geq
k]=\lfloor\cfrac{n+m}{k}\rfloor-\lfloor\cfrac{n}{k}\rfloor-\lfloor\cfrac{m}{k}\rfloor
\]</span> 于是接下来我们要处理的式子形如<span class="math inline">\(\sum_{1\leq k\leq
n}\varphi(k)\lfloor\cfrac{n}{k}\rfloor\\\)</span>.</p>
<p>对其增加枚举量: <span class="math display">\[
\sum_{1\leq k\leq n}\varphi(k)\lfloor\cfrac{n}{k}\rfloor=\sum_{1\leq
k\leq n}\varphi(k)\sum_{d=1}^{\lfloor \frac{n}{k}\rfloor}1\\
=\sum_{k=1}^n\sum_{d|k}\varphi(d)\\
=\sum_{k=1}^nk=\cfrac{(n+1)n}{2}
\]</span> 带入即可证明.</p>
<h5><span id="example2">Example2</span></h5>
<p>求<span class="math inline">\(\sum_{1\leq a,b\leq p(p-1)}[a^b\equiv
b^a(\mod p)],p\in prime\)</span>.</p>
<p>考虑<span class="math inline">\(p\bot
(p-1)\)</span>,使用中国剩余定理,我们有: <span class="math display">\[
\sum_{1\leq a,b\leq p(p-1)}[a^b\equiv b^a(\mod p)]\\
=\sum_{0\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv b^d(\mod p)]\\
=(p-1)^2+\sum_{1\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv
b^d(\mod p)]
\]</span> 后面那部分的答案是: <span class="math display">\[
\sum_{1\leq a,b&lt; p}\sum_{0\leq c,d&lt;p-1}[a^c\equiv b^d(\mod p)]\\
=\sum_{1\leq x&lt; p}\sum_{0\leq a,b&lt; p}\sum_{1\leq
c,d&lt;p-1}[a^c\equiv x(\mod p)][b^d\equiv x(\mod p)]\\
=\sum_{1\leq x&lt;p}(\sum_{1\leq a&lt;p,0\leq c&lt;p-1}[a^c\equiv x(\mod
p)])^2
\]</span> 令<span class="math inline">\(g\)</span>为<span class="math inline">\(p\)</span>的原根,令<span class="math inline">\(a=g^b\)</span>,<span class="math inline">\(x=g^{x&#39;}\)</span>有: <span class="math display">\[
\sum_{1\leq x&lt;p}(\sum_{1\leq a&lt;p,0\leq c&lt;p-1}[a^c\equiv x(\mod
p)])^2\\
=\sum_{0\leq x&#39;&lt;p-1}(\sum_{0\leq b&lt; p-1,0\leq
c&lt;p-1}[bc\equiv x&#39;(\mod p-1)])^2\\
=\sum_{0\leq x&lt;p-1}(\sum_{0\leq a,b&lt;p-1}[ab\equiv x(\mod
p-1)])^2\\
\]</span> 考虑前面那个式子,如果我们令<span class="math inline">\(x=x_0x_1,x_0\bot x_1\)</span>,<span class="math inline">\(p-1=p_0p_1,p_0\bot p_1\)</span>,其中<span class="math inline">\(0\leq x_0&lt;p_0,0\leq
x_1&lt;p_1\)</span>,后面那个式子为<span class="math inline">\(f(p-1,x)\)</span>,由于中国剩余定理,有<span class="math inline">\(f(p-1,x)=f(p_0,x_0)f(p_1,x_1)\)</span>.</p>
<p>于是令<span class="math inline">\(p-1=\prod_{i=1}^kp_i^{q_i}\)</span>上面的式子可以改为:
<span class="math display">\[
\prod_{i=1}^k(\sum_{0\leq x_i&lt;p_i^{q_i}}(\sum_{0\leq
a,b&lt;p_i^{q_i}}[ab\equiv x_i(\mod p_i^{q_i})])^2)
\]</span> 我们只考虑其中一项,形如: <span class="math display">\[
\sum_{0\leq x&lt;p^{q}}(\sum_{0\leq a,b&lt;p^q}[ab\equiv x(\mod
p^{q})])^2
\]</span> 我们不妨用<span class="math inline">\(ap^{\alpha}\)</span>代替<span class="math inline">\(a\)</span>,<span class="math inline">\(bp^\beta\)</span>代替<span class="math inline">\(b\)</span>,<span class="math inline">\(xp^t\)</span>代替<span class="math inline">\(x\)</span>,其中<span class="math inline">\(a,b,x\bot p\)</span>那么有: <span class="math display">\[
\sum_{0\leq x&lt;p^{q-t}}(\sum_{0\leq a&lt; p^{q-\alpha},0\leq
b&lt;p^{q-\beta}}[abp^{\alpha+\beta}\equiv xp^t(\mod p^{q})])^2
\]</span> 则我们要做的即对四元组<span class="math inline">\((a,b,\alpha,\beta)\)</span>计数.由于<span class="math inline">\(a,b,x\bot p\)</span>,我们有: <span class="math display">\[
\alpha+\beta=t,\alpha,\beta\in\mathbb{N}\\
ab\equiv x\pmod {p^{q-t}},0\leq a&lt;p^{q-\alpha},0\leq b&lt;p^{q-\beta}
\]</span> 第一个式子对四元组的贡献显然是<span class="math inline">\(t+1\)</span>,而第二个式子,由于<span class="math inline">\([1,p^{q-t})\in[1,p^{q-\alpha})\)</span>,所以我们可以先求出<span class="math inline">\(1\leq a&lt;p^{q-t}\)</span>的答案,然后乘以<span class="math inline">\(p^{t-\alpha}\)</span>得到答案,<span class="math inline">\(b\)</span>是类似的,于是: <span class="math display">\[
ans=\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t-\alpha}p^{t-\beta}\sum_{1\leq
a,b&lt; p^{q-t}}[ab\equiv x\pmod {p^{q-t}}])^2+(\sum_{1\leq a,b\leq
p^q}[ab\equiv 0\pmod {p^{q}}])^2\\
=\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t-\alpha}p^{t-\beta}\sum_{1\leq
a,b&lt; p^{q-t}}[ab\equiv x\pmod {p^{q-t}}])^2+q(p-1)p^{q-1}+p^q
\]</span> 后面,由于<span class="math inline">\(a\bot
p\)</span>,显然一个<span class="math inline">\(a\)</span>唯一对应一个<span class="math inline">\(b\)</span>.于是我们得到了答案为: <span class="math display">\[
\sum_{1\leq x&lt;p^{q-t}}((t+1)p^{t}\varphi(p^{q-t}))^2
\]</span> 而后面的式子显然跟<span class="math inline">\(x\)</span>无关,所以有: <span class="math display">\[
\sum_{0&lt; x&lt;p^{q-t}}((t+1)p^{t}\varphi(p^{q-t}))^2\\
=\sum_{0\leq t&lt; q}(\varphi(p^{q-t}))((t+1)p^{t}\varphi(p^{q-t}))^2\\
=\sum_{0\leq t&lt;q}(t+1)^2p^{2t}(p-1)^3p^{3q-3t-3}\\
=\sum_{0\leq t&lt;q}(t+1)^2(p-1)^3p^{3q-t-3}
\]</span> 其实到这一步,由于<span class="math inline">\(\sum
t\)</span>是<span class="math inline">\(O(\log
n)\)</span>级别的,这题已经可以做了.</p>
<h4><span id="莫比乌斯函数">莫比乌斯函数</span></h4>
<p>莫比乌斯函数<span class="math inline">\(\mu(x)\)</span>是一个满足<span class="math inline">\(\sum_{d|n}\mu(n)=1\)</span>的函数,根据定义其显然是积性函数.根据定义可以求出它的封闭形式:</p>
<p><span class="math inline">\(\mu(m)=\begin{cases}0&amp;\exist m_i\geq
2\\(-1)^k&amp;\forall m_i\leq
1\end{cases},m=\prod_{i=1}^kp_i^{m_i}\)</span>.</p>
<h5><span id="莫比乌斯反演">莫比乌斯反演</span></h5>
<p>见”反演.md”.</p>
<p>另外,值得一提的是,根据莫比乌斯反演,我们可以发现<span class="math inline">\(\mu*id=\varphi\)</span>.</p>
<p>有公式:<span class="math inline">\(\mu^2(x)=\sum_{i^2|x}\mu(i)\)</span>.原因很简单,我们设<span class="math inline">\(x&#39;\)</span>为<span class="math inline">\(x\)</span>中所有的质因子的幂先除二下取整再乘二后变成的答案,显然<span class="math inline">\(\mu^2(x)=\mu^2(x&#39;)\)</span>,我们有<span class="math inline">\(\sum_{i|\sqrt {x&#39;}}\mu(y)=[\sqrt
{x&#39;}=1],\sum_{i^2|x&#39;}\mu(y)=[x&#39;=1]\)</span>.</p>
<h4><span id="min25筛">min25筛</span></h4>
<p>如果我们考虑积性函数的值,理论上来说,设<span class="math inline">\(S(n,k)\)</span>表示最小质因子大于等于<span class="math inline">\(p_k\)</span>的所有<span class="math inline">\(f\)</span>的和加上<span class="math inline">\(f(1)\)</span>,其实我们自然有: <span class="math display">\[
S(n,k)=\sum_{e\geq 0}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)
\]</span> 问题在于这么做需要枚举<span class="math inline">\([1,n]\)</span>中的全部质数,这是根本无法接受的.</p>
<p>我们考虑一些很大的质数,换言之,最小质因子大于<span class="math inline">\(\sqrt n\)</span>的数在<span class="math inline">\([1,n]\)</span>中只有可能是质数本身.</p>
<p>因此你会发现,这个过程只需要把质数单独拿出来做,复杂度就可以得到相当的飞跃.</p>
<p>考虑: <span class="math display">\[
\sum_{i=1}^nf(i)=\sum_{p\in prime}f(p)+\sum_{p\notin prime\and p\ne
1}f(p)+f(1)
\]</span></p>
<p>令<span class="math inline">\(g(N,i)=\sum_{j=1}^N[j\in prime \or
Min_j&gt;p_i]F(j)\\\)</span>,其中<span class="math inline">\(Min_j\)</span>表示<span class="math inline">\(j\)</span>最小的质因数,<span class="math inline">\(p_i\)</span>表示第<span class="math inline">\(i\)</span>个质数.</p>
<p>注意到<span class="math inline">\(g(N,i)\)</span>实际上就是<span class="math inline">\(N\)</span>以内的数在第<span class="math inline">\(i\)</span>轮埃氏筛后剩余的数的<span class="math inline">\(F\)</span>的和.</p>
<p><span class="math inline">\(F(i)\)</span>表示若干完全积性函数之和且当<span class="math inline">\(p\in prime\)</span> 时,<span class="math inline">\(F(p)=f(p)\)</span>,下文为了方便书写,直接认为<span class="math inline">\(F\)</span>是完全积性函数.</p>
<p>而<span class="math inline">\(g(N,\sqrt N)\)</span>实际上就是<span class="math inline">\(N\)</span>以内的质数的<span class="math inline">\(F\)</span>之和,那么有: <span class="math display">\[
g(n,0)=\sum_{i=2}^nF(i)\\
g(i,j)=g(i,j-1)-F(p_j)(\ g(\lfloor\frac{i}{p_j}\rfloor,j-1)-\sum_{2\leq
p\leq p_{j-1},p\in prime}F(p)\ )\\
\]</span> ps1:</p>
<p>第<span class="math inline">\(j\)</span>个质数会比第<span class="math inline">\(j-1\)</span>个多筛若干个数,即最小质因数是<span class="math inline">\(p_j\)</span>的数.这些数形如<span class="math inline">\(\{p_j,2p_j,3p_j...\}\)</span>,同时除以<span class="math inline">\(p_j\)</span>得到<span class="math inline">\(\{1,2,3...\}\)</span>.</p>
<p>我们要的就是其中最小质因数大于等于<span class="math inline">\(p_j\)</span>的数,也就是最小质因数大于<span class="math inline">\(p_{j-1}\)</span>的数,因而就是<span class="math inline">\(g(\lfloor\frac{i}{p_j}\rfloor,j-1)\)</span>.</p>
<p>但还有一些质数会被重复计算,我们把他删掉就可以了.</p>
<p>考虑到<span class="math inline">\(g\)</span>后面的维度最多走到<span class="math inline">\(\sqrt
n\)</span>,所以我们所枚举的最小质因子一定小于等于<span class="math inline">\(\sqrt n\)</span>,所以一定有<span class="math inline">\(p_{j-1}&lt;\lfloor\frac{i}{p_j}\rfloor\)</span>,所以直接删去一定不会多删.</p>
<p>ps2:</p>
<p>注意到以下事实:<span class="math inline">\(\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor=\lfloor\frac{a}{bc}\rfloor\\\)</span>.</p>
<p>因而,如果我们有以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[n])<span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">else</span> f[n]=......;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">solve</span>(n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码复杂度为<span class="math inline">\(O(\sqrt
n)\)</span>.原因在于,根据整数分块,<span class="math inline">\(\lfloor\frac{n}{i}\rfloor\)</span>有<span class="math inline">\(\sqrt n\)</span>种取值.</p>
<p>而如果递归下去,继续枚举<span class="math inline">\(j\)</span>,并往下递归到<span class="math inline">\(\lfloor\frac{\lfloor\frac{n}{i}\rfloor}{j}\rfloor\)</span>,那他就相当于枚举<span class="math inline">\(k=ij\)</span>,并递归到<span class="math inline">\(\lfloor\frac{n}{k}\rfloor\)</span>,因而复杂度得到保证.</p>
<p>由此可知,求<span class="math inline">\(g\)</span>的复杂度为<span class="math inline">\(O(\sqrt n\times \sqrt {\sqrt n})=O(n^{\frac3
4})\)</span>.</p>
<p>令<span class="math inline">\(S(n,m)\)</span>表示前<span class="math inline">\(n\)</span>个数中,最小质因数大于等于<span class="math inline">\(p_m\)</span>的数的<span class="math inline">\(f\)</span>之和,可知: <span class="math display">\[
S(n,m)=g(n,+\infty)-\sum_{k=1}^{m-1}f(p_k)+\sum_{k\geq m,e\geq
1,p_k^{e+1}\leq
n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+\sum_{k\geq
m,e=2,p_k^e\leq n}f(p_k^e)\\
=g(n,+\infty)-\sum_{k=1}^{m-1}f(p_k)+\sum_{k\geq m,e\geq 1,p_k^{e+1}\leq
n}[f(p_k^e) S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+f(p_k^{e+1})]\\
\]</span> ps1:</p>
<p>前半段求出质数部分的和,后半段开始枚举最小质因子.</p>
<p>由于<span class="math inline">\(p_k\)</span>是当前数的最小质因子,<span class="math inline">\(e\)</span>是他的幂.则这个数其他的质因子应该均大于<span class="math inline">\(p_k\)</span>,因而大于等于<span class="math inline">\(p_{k+1}\)</span>.</p>
<p>注意到由于<span class="math inline">\(S\)</span>中不包含<span class="math inline">\(1\)</span>,所以应特殊处理只含有<span class="math inline">\(p_k\)</span>一个质因子的情况.</p>
<p>又注意到,如果<span class="math inline">\(p_k^e&lt;
n&lt;p_k^{e+1}\)</span>,那么此时<span class="math inline">\(\lfloor\frac{n}{p_k^e}\rfloor\)</span>一定小于<span class="math inline">\(p_k\)</span>,则不可能拥有比<span class="math inline">\(p_k\)</span>更大的质因子.</p>
<p>该形式与上面一致,因而复杂度同样为<span class="math inline">\(O(n^{\frac 3
4})\)</span>.我们最终要求的答案即<span class="math inline">\(S(n,1)+f(1)\)</span>.</p>
<p>一些后记:</p>
<ol type="1">
<li>事实上,复杂度的计算只是上限,实际上应该约为<span class="math inline">\(O(\frac{n^{\frac3 4}}{\log_2 n})\)</span>.</li>
<li>如果使用map会导致复杂度较差,考虑如下事实: (1).<span class="math inline">\(\forall 1\leq x\leq n\)</span>,则要么<span class="math inline">\(x\leq \sqrt n\)</span>,要么<span class="math inline">\(\lfloor\frac{n}{x}\rfloor\leq \sqrt n\\\)</span>.
(2).<span class="math inline">\(\forall a\)</span>形如<span class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span>,则<span class="math inline">\(\lfloor\frac{n}{a}\rfloor\)</span>应为<span class="math inline">\(x_{max}\)</span>,互不相同.
因而可以分别特判,从而做到比map或离散化都优秀的复杂度.</li>
<li>我们在代码中所求出的<span class="math inline">\(w\)</span>是倒序的,而我们转移的过程也是倒序的,因而枚举的时候可以直接正序枚举.</li>
<li>考虑做的时候由于进行了滚动数组,因而继承操作可以直接使用,为了方便可以直接判掉可以直接继承的情况.</li>
<li>求<span class="math inline">\(S\)</span>的过程可以使用递归,因为我们只关心一个<span class="math inline">\(S\)</span>的量.</li>
</ol>
<h5><span id="example1uoj188sanrd">Example1([uoj188]Sanrd)</span></h5>
<p>注意到这题显然可以写埃筛的暴力.考虑使用类似min15筛的方式,定义<span class="math inline">\(f(n)\)</span>为<span class="math inline">\(n\)</span>的次大质因子(若<span class="math inline">\(n=1\or n\in prime\)</span>则<span class="math inline">\(f(n)=0\)</span>),<span class="math inline">\(S(n,k)=\sum_{i=1}^n[Min_i\geq
p_k]f(i)\)</span>.不难发现我们要求的就是<span class="math inline">\(S(n,1)\)</span>,而显然<span class="math inline">\(S(n,\sqrt n)=0\)</span>.</p>
<p>注意到: <span class="math display">\[
S(n,m)=\sum_{i\geq m,e\geq 1,p_i^{e+1}\leq
n}S(\lfloor\frac{n}{p_i^e}\rfloor,i+1)+p_i\sum_{i=p_i+1}^{\lfloor\frac{n}{p_i^e}\rfloor}[i\in
prime]
\]</span> 区间素数个数可以拿min25筛的前半部分做.</p>
<h4><span id="杜教筛">杜教筛</span></h4>
<p>令<span class="math inline">\(F(n)=\sum_{i=1}^nf(i)\\\)</span>,我们考虑构造两个函数<span class="math inline">\(g\)</span>和<span class="math inline">\(s\)</span>.使得<span class="math inline">\(f*g=s\)</span>.</p>
<p>令<span class="math inline">\(G(n)=\sum_{i=1}^ng(i),S(n)=\sum_{i=1}^ns(i)\\\)</span>.若<span class="math inline">\(G(i)\)</span>和<span class="math inline">\(S(i)\)</span>都很方便求,<span class="math inline">\(g(1)=1\)</span>,我们就可以求出<span class="math inline">\(F(n)\)</span>. <span class="math display">\[
f*g=s\\
\sum_{j|i}f(j)g(\frac i j)=s(i)\\
\]</span> 由于<span class="math inline">\(g(1)=1\)</span>,我们有<span class="math inline">\(f(i)=s(i)-\sum_{j|i,j\ne i}f(j)g(\frac i
j)\\\)</span>.</p>
<p>那么: <span class="math display">\[
F(n)=\sum_{i=1}^nf(i)\\=\sum_{i=1}^n(s(i)-\sum_{j|i,j\ne i}f(j)g(\frac i
j))\\
=S(n)-\sum_{j=1}^n\sum_{k=2}^{\lfloor\frac n
j\rfloor}g(k)f(j)\\=S(n)-\sum_{k=2}^ng(k)\sum_{j=1}^{\lfloor\frac n
k\rfloor}f(j)\\
=S(n)-\sum_{k=2}^ng(k)F(\lfloor\frac n k\rfloor)\\
\]</span> 复杂度证明和min25筛是一样的,不同点在于我们可以预处理<span class="math inline">\(n^{\frac 2 3}\)</span>以内的<span class="math inline">\(F\)</span>,这样复杂度可以降到<span class="math inline">\(O(n^{\frac 2 3})\)</span>.</p>
<p>#####Example1</p>
<p>求<span class="math inline">\(\sum_{i=1}^N\mu(i)\\\)</span>.</p>
<p>由于<span class="math inline">\(\mu*I=\epsilon\)</span>,于是考虑<span class="math inline">\(g=I\)</span>.</p>
<p>#####Example2</p>
<p>求<span class="math inline">\(\sum_{i=1}^N\varphi(i)\\\)</span>.</p>
<p>由于<span class="math inline">\(\varphi*I=id\)</span>,于是考虑<span class="math inline">\(g=I\)</span>.</p>
<p>#####Example3</p>
<p>求<span class="math inline">\(\sum_{i=1}^N{\varphi(i)\times
i}\\\)</span> 由于<span class="math inline">\(\sum^N_{i=1}(f*g)(i)=\sum_{d|N}{f(i)\times
g(\cfrac n d)}=\sum_{d|N}{\varphi(d)\times d\times g(\cfrac n
d)}\\\)</span> 由于中间过程中乘出来的<span class="math inline">\(d\)</span>很难处理,需要消掉它,于是考虑<span class="math inline">\(g=id\)</span>.</p>
<p>#####Example4</p>
<p><span class="math inline">\(\sum_{i=1}^N{\varphi(i)\times
i^2}\\\)</span>. 由Example3,于是考虑<span class="math inline">\(g=id^2\)</span>.</p>
<h4><span id="powerful-number筛">Powerful Number筛</span></h4>
<p>定义Powerful Number为满足所有质因子的指数都<span class="math inline">\(&gt;1\)</span>的数,不难证明这样的数在<span class="math inline">\([1,n]\)</span>中最多只有<span class="math inline">\(O(\sqrt
n)\)</span>个(使用积分).同时对于质因子的幂分奇偶讨论:奇数分成一个<span class="math inline">\(3\)</span>加上一个偶数,那么不难证明这个数一定有:<span class="math inline">\(a^2b^3\)</span>的形式.找到这些数字可以直接dfs搜指数.</p>
<p>现在我们要求积性函数<span class="math inline">\(f(n)\)</span>的前缀和.假设<span class="math inline">\(f=h*g\)</span>,其中<span class="math inline">\(h(1)=1,g(p)=f(p),\forall p\in
prime\)</span>且<span class="math inline">\(g(n)\)</span>的前缀和容易计算.</p>
<p>接下来我们证明:<span class="math inline">\(h(n)\ne0\Rightarrow n\ is\
Powerful\ Number\)</span>.</p>
<p><span class="math inline">\(\forall p\in prime\)</span>,<span class="math inline">\(f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)\)</span>,于是<span class="math inline">\(h(p)=0\)</span>.根据积性函数的性质有<span class="math inline">\(\forall x\notin \text{PN},h(x)=0\)</span>.</p>
<p>注意到: <span class="math display">\[
F(n)=\sum_{i=1}^nf(i)\\
=\sum_{i=1}^n\sum_{j|i}h(j)g(\frac{i}j)\\
=\sum_{j=1}^nh(j)G(\lfloor\frac{n}{j}\rfloor)
\]</span> 于是可以快速求,复杂度<span class="math inline">\(O(\sqrt
n)\)</span>.</p>
<h5><span id="example1sp20174divcnt3">Example1([SP20174]DIVCNT3)</span></h5>
<p>首先我们需要构造<span class="math inline">\(g(p)=f(p),p\in
prime\)</span>.注意到<span class="math inline">\(f(p)=d(p^3)=4\)</span>,我们构造<span class="math inline">\(g(p)=(d*d)(p)\)</span>.这样问题在于求<span class="math inline">\(G(n)\)</span>.我们有: <span class="math display">\[
G(n)=\sum_{i=1}^n(d*d)(i)\\
=\sum_{ij\leq n}d(i)d(j)\\
=\sum_{i=1}^nd(i)D(\lfloor\frac{n}{i}\rfloor)
\]</span> 而<span class="math inline">\(D(n)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor\)</span>,自然可以做.复杂度算一算是<span class="math inline">\(O(n^{\frac{2}{3}})\)</span>.</p>
<p>感觉Powerful Number筛的关键在于构造.</p>
<h2><span id="整值函数">整值函数</span></h2>
<h3><span id="定义">定义</span></h3>
<p>若<span class="math inline">\(x\in\mathbb{R}\)</span>,则:</p>
<p><span class="math inline">\(\lfloor
x\rfloor=\)</span>小于等于x的最大的整数.</p>
<p><span class="math inline">\(\lceil
x\rceil=\)</span>大于等于x的最小的整数.</p>
<p>我们有时称<span class="math inline">\(\lfloor
x\rfloor\)</span>为<span class="math inline">\(x\)</span>的整数部分,并定义<span class="math inline">\(x-\lfloor
x\rfloor\)</span>为分数部分,有时记作<span class="math inline">\(\{x\}\)</span>.</p>
<p>我们定义<span class="math inline">\(x\mod
y=x-y\lfloor\cfrac{x}{y}\rfloor\)</span>,<span class="math inline">\(x\
mumble\ y=y\lceil\cfrac{x}{y}\rceil-x\)</span>,其中<span class="math inline">\(x,y\in \mathbb{N_+}\)</span>.</p>
<p>当然,我们也可以使用上述定义将<span class="math inline">\(mod\)</span>和<span class="math inline">\(mumble\)</span>的定义扩展到实数域,不过<span class="math inline">\(y=0\)</span>的时候需要特殊处理.</p>
<h3><span id="整值函数的基本性值">整值函数的基本性值</span></h3>
<p>若<span class="math inline">\(x\in \mathbb{R},n\in
\mathbb{Z}\)</span>,则有:</p>
<ol type="1">
<li><span class="math inline">\(\lfloor x\rfloor=x \Leftrightarrow
\lceil x\rceil=x\Leftrightarrow x\in \mathbb{Z}\)</span>.</li>
<li><span class="math inline">\(\lceil x\rceil-\lfloor x\rfloor=[x\notin
\mathbb{Z}]\)</span>.</li>
<li><span class="math inline">\(x-1&lt;\lfloor x\rfloor\leq x\leq \lceil
x\rceil&lt;x+1\)</span>.</li>
<li><span class="math inline">\(\lfloor-x\rfloor=-\lceil x\rceil,\lceil
-x\rceil=-\lfloor x\rfloor\)</span>.</li>
<li><span class="math inline">\(\lfloor x \rfloor=n\Leftrightarrow n\leq
x&lt;n+1 \Leftrightarrow x-1&lt;n\leq x\)</span>.</li>
<li><span class="math inline">\(\lceil x\rceil =n\Leftrightarrow
n-1&lt;x\leq n\Leftrightarrow x\leq n&lt;x+1\)</span>.</li>
<li><span class="math inline">\(x&lt;n\Leftrightarrow \lfloor
x\rfloor&lt;n\)</span>.</li>
<li><span class="math inline">\(x\leq n\Leftrightarrow \lceil
x\rceil\leq n\)</span>.</li>
<li><span class="math inline">\(x&gt;n\Leftrightarrow \lceil
x\rceil&gt;n\)</span>.</li>
<li><span class="math inline">\(x\geq n\Leftrightarrow \lfloor
x\rfloor\geq n\)</span>.</li>
<li><span class="math inline">\(\lfloor x+n\rfloor=\lfloor
x\rfloor+n\)</span>.</li>
<li><span class="math inline">\(\lceil x+n\rceil=\lceil
x\rceil+n\)</span>.</li>
<li><span class="math inline">\(\lfloor nx\rfloor=n\lfloor
x\rfloor\Leftrightarrow n=0\or x-\lfloor x\rfloor&lt;
\cfrac{1}n\)</span>.</li>
<li><span class="math inline">\(\lceil nx\rceil=n\lceil
x\rceil\Leftrightarrow n=0\or x-\lceil x\rceil&lt;
\cfrac{1}n\)</span>.</li>
<li><span class="math inline">\(\lceil\cfrac{n}{m}\rceil=\lfloor\cfrac{n-1}{m}\rfloor+1,m\in\mathbb{N_+}\)</span>.</li>
<li><span class="math inline">\(m\lceil x\rceil-\lceil m(\lceil
x\rceil-x)\rceil=\lfloor mx\rfloor\)</span>.</li>
<li><span class="math inline">\((x\mod ny)\mod y=x\mod
y,n\in\mathbb{N_+}\)</span>.</li>
<li>分配律:<span class="math inline">\(c(x\mod y)=(cx)\mod
(cy)\)</span>.</li>
</ol>
<h3><span id="整值函数的应用">整值函数的应用</span></h3>
<h4><span id="一类函数与整值函数">一类函数与整值函数</span></h4>
<p>设<span class="math inline">\(f(x)\)</span>是一个有以下性质且在一个实数区间连续的单调递增函数:</p>
<p><span class="math inline">\(f(x)\in \mathbb{Z}\Rightarrow x\in
\mathbb{Z}\)</span>.</p>
<p>那么,只要<span class="math inline">\(f(x),f(\lfloor
x\rfloor),f(\lceil x\rceil)\)</span>都有定义,我们有:</p>
<p><span class="math inline">\(\lfloor f(x)\rfloor=\lfloor f(\lfloor
x\rfloor) \rfloor\)</span>和<span class="math inline">\(\lceil
f(x)\rceil=\lceil f(\lceil x\rceil) \rceil\)</span>.</p>
<p>由于底和顶是类似的,我们考虑先对顶进行证明,这样也可以类似证明底:</p>
<p>若<span class="math inline">\(x=\lceil x\rceil\)</span>,显然得证;</p>
<p>不然,有<span class="math inline">\(x&lt;\lceil
x\rceil\)</span>,那么有<span class="math inline">\(f(x)&lt;f(\lceil
x\rceil)\)</span>,也就有<span class="math inline">\(\lceil
f(x)\rceil\leq \lceil f(\lceil x\rceil) \rceil\)</span>.</p>
<p>考虑反证法,不妨令<span class="math inline">\(\lceil
f(x)\rceil&lt;\lceil f(\lceil x\rceil)
\rceil\)</span>.则一定存在一个整数<span class="math inline">\(y\)</span>使得<span class="math inline">\(\lceil
f(x)\rceil=y&lt;\lceil f(\lceil x\rceil) \rceil\)</span>,此时必有<span class="math inline">\(x\leq y&lt;\lceil x\rceil\)</span>.由于<span class="math inline">\(f\)</span>的性值,显然有<span class="math inline">\(y\)</span>是整数,但根据整值函数的性值,不可能存在这样一个整数<span class="math inline">\(y\)</span>满足<span class="math inline">\(x\leq
y&lt;\lceil x\rceil\)</span>,因此得证.</p>
<p>另外,我们考虑函数<span class="math inline">\(f(x)=\cfrac{x+m}{n}\)</span>,显然这是一个满足条件的函数,因此显然满足上述的条件.再考虑<span class="math inline">\(m=0\)</span>的特殊情况:<span class="math inline">\(\lfloor
\cfrac{\lfloor\cfrac{x}{n}\rfloor}{m}\rfloor=\lfloor\cfrac{x}{nm}\rfloor\)</span>.</p>
<p>而单调递减函数可以取相反数转化为单调递增函数.</p>
<h4><span id="迪利克雷抽屉原理">迪利克雷抽屉原理</span></h4>
<p><span class="math inline">\(n\)</span>个物体放进<span class="math inline">\(m\)</span>个盒子里,那么必定有一个盒子中放入了大于等于<span class="math inline">\(\lceil\cfrac n
m\rceil\)</span>个物品,有一个盒子放入了小于等于<span class="math inline">\(\lfloor\cfrac n m\rfloor\)</span>个物体.</p>
<h5><span id="example1">Example1</span></h5>
<p>求证:每个由<span class="math inline">\(n^2+1\)</span>个不同实数构成的序列都包含一个长为<span class="math inline">\(n+1\)</span>的严格递增子序列或严格递减子序列.</p>
<p>设<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个实数,<span class="math inline">\(c_i\)</span>为以这个数为开头的最长的递增子序列,<span class="math inline">\(d_i\)</span>表示以这个数为开头的最长的递减子序列.考虑反证法,如果不成立,那么<span class="math inline">\(\forall 1\leq i\leq n^2+1\)</span>,<span class="math inline">\(1\leq c_i\leq n\and 1\leq d_i\leq
n\)</span>.那么一共有<span class="math inline">\(n^2\)</span>种不同的有序对.</p>
<p>根据抽屉原理,一共有<span class="math inline">\(n^2+1\)</span>个有序对,所以一定有两个有序对相等.由于这些数字两两不同,所以一定可以把其中一个数字加到另一个数字的递增或递减子序列的后面,这样那个数字的<span class="math inline">\(c_i\)</span>或者<span class="math inline">\(d_i\)</span>就要<span class="math inline">\(+1\)</span>,与我们的假设不符,因此该定理成立.</p>
<h5><span id="example2">Example2</span></h5>
<p>求证:若任意两个人间只有两种关系:朋友或敌人.那么对于六个人而言,一定有三个人两两都是朋友或者两两都是敌人.</p>
<p>令<span class="math inline">\(A\)</span>是这六个人中其中一个,根据抽屉原理,一定有大于等于<span class="math inline">\(3\)</span>个人都是<span class="math inline">\(A\)</span>的敌人或者都是<span class="math inline">\(A\)</span>的朋友,不妨假设这三个人都是<span class="math inline">\(A\)</span>的朋友.</p>
<p>如果这三个人中有两个人是朋友,那么它们和A就一起构成了一组人.不然,他们三个人就构成了一组人.</p>
<h4><span id="计算区间内整数个数">计算区间内整数个数</span></h4>
<p>整值函数的另一个应用是计算区间内整数个数:</p>
<p>考虑基本性值<span class="math inline">\(7,8,9,10\)</span>,不难发现:</p>
<ol type="1">
<li><span class="math inline">\([\alpha,\beta]\)</span>包含<span class="math inline">\(\lfloor\beta\rfloor-\lceil\alpha\rceil+1\)</span>个整数.</li>
<li><span class="math inline">\((\alpha,\beta)\)</span>包含<span class="math inline">\(\lceil\beta\rceil-\lfloor\alpha\rfloor-1\)</span>个整数.</li>
<li><span class="math inline">\((\alpha,\beta]\)</span>包含<span class="math inline">\(\lfloor\beta\rfloor-\lfloor\alpha\rfloor\)</span>个整数.</li>
<li><span class="math inline">\([\alpha,\beta)\)</span>包含<span class="math inline">\(\lceil\beta\rceil-\lceil\alpha\rceil\)</span>个整数.</li>
</ol>
<h4><span id="谱">谱</span></h4>
<p>我们定义一个实数<span class="math inline">\(\alpha\)</span>的<strong>谱</strong>是以下集合:</p>
<p><span class="math inline">\(Spec(\alpha)=\{\lfloor\alpha\rfloor,\lfloor2\alpha\rfloor,\lfloor3\alpha\rfloor...\}\)</span>.</p>
<p>不难发现,只要<span class="math inline">\(\alpha\ne\beta\)</span>,则<span class="math inline">\(Spec(\alpha)\ne Spec(\beta)\)</span>.</p>
<h5><span id="example">Example</span></h5>
<p>求证:<span class="math inline">\(Spec(\sqrt2)\cup
Spec(2+\sqrt2)=\mathbb{N_+}\)</span>且<span class="math inline">\(Spec(\sqrt2)\cap
Spec(2+\sqrt2)=\phi\)</span>,即这两个集合构成了正整数集的一个划分.</p>
<p>我们考虑这样一个事实:对于任意正整数<span class="math inline">\(n\)</span>,如果我们能求出来<span class="math inline">\(Spec(\sqrt2)\)</span>中有<span class="math inline">\(a\)</span>个元素<span class="math inline">\(\leq
n\)</span>,<span class="math inline">\(Spec(2+\sqrt2)\)</span>中有<span class="math inline">\(b\)</span>个元素<span class="math inline">\(\leq
n\)</span>,并且<span class="math inline">\(a+b=n\)</span>,则结论显然成立.</p>
<p>不妨令函数<span class="math inline">\(N(\alpha,n)\)</span>表示<span class="math inline">\(Spec(\alpha)\)</span>中有多少个元素<span class="math inline">\(\leq n\)</span>,其中<span class="math inline">\(\alpha\)</span>是正数,我们有: <span class="math display">\[
N(\alpha,n)=\sum_{k\in\mathbb{N_+}}[\lfloor k\alpha\rfloor\leq n]\\
=\sum_{k\in\mathbb{N_+}}[\lfloor k\alpha\rfloor&lt; n+1]\\
=\sum_{k\in\mathbb{N_+}}[k\alpha&lt; n+1]\\
=\sum_k[0&lt;k&lt;(n+1)/\alpha]\\
=\lceil(n+1)/\alpha\rceil-1
\]</span> 则我们要证明的就是: <span class="math display">\[
\lceil\cfrac{n+1}{\sqrt2}\rceil-1+\lceil\cfrac{n+1}{2+\sqrt2}\rceil-1=n\\
\lfloor\cfrac{n+1}{\sqrt2}\rfloor+\lfloor\cfrac{n+1}{2+\sqrt2}\rfloor=n\\
\cfrac{n+1}{\sqrt2}-\{\cfrac{n+1}{\sqrt2}\}+\cfrac{n+1}{2+\sqrt2}-\{\cfrac{n+1}{2+\sqrt2}\}=n
\]</span> 而由于我们有恒等式:<span class="math inline">\(\cfrac1{\sqrt2}+\cfrac{1}{2+\sqrt2}=1\)</span>,且两个相加为整数的数的分数部分相加显然为<span class="math inline">\(1\)</span>,原式得证.</p>
<p>事实上,如果两个集合<span class="math inline">\(Spec(\alpha)\)</span>和<span class="math inline">\(Spac(\beta)\)</span>构成正整数集一个划分,可以同上证明<span class="math inline">\(\cfrac1\alpha+\cfrac1\beta=1\)</span>且<span class="math inline">\(\alpha\)</span>和<span class="math inline">\(\beta\)</span>都是无理数.</p>
<h4><span id="整值函数的递归式">整值函数的递归式</span></h4>
<p>得到递归式的封闭形式的确很有用,它可以让我们在很快的时间内求出答案,但大部分时候是很麻烦的.</p>
<p>而如果我们对时间的要求没有那么紧,我们不妨考虑一种较慢但更容易的方法:</p>
<h5><span id="example">Example</span></h5>
<p>约瑟夫问题,但是每隔两个人处死一个人,求最后存活者的编号.</p>
<p>我们不妨这样考虑:我们每略过两个人,就将他们重新编号.</p>
<p>例如,我们杀掉了三号,就将一号和二号重新编号为<span class="math inline">\(n+1\)</span>号和<span class="math inline">\(n+2\)</span>号,杀掉了六号,就将四号和五号重新编号为<span class="math inline">\(n+3\)</span>号和<span class="math inline">\(n+4\)</span>号,这样,我们在做游戏的时候,场上人员的编号一定是连续的.</p>
<p>我们把最后存活者改为最后死亡者,这样它的最后编号就是<span class="math inline">\(3n\)</span>.</p>
<p>并且不难发现,第<span class="math inline">\(k\)</span>个死亡的人的最后编号就是<span class="math inline">\(3k\)</span>.</p>
<p>我们考虑已知新编号如何求旧编号,设新编号为<span class="math inline">\(N\)</span>:</p>
<p>如果<span class="math inline">\(N\leq n\)</span>,则<span class="math inline">\(N\)</span>是初始编号,反之,我们考虑在编号<span class="math inline">\(N\)</span>的时候被杀死的人的编号.</p>
<p>假设现在进行完了<span class="math inline">\(k+1\)</span>轮,令<span class="math inline">\(N=n+2k+w\)</span>,其中<span class="math inline">\(w\in\{1,2\}\)</span>,则编号<span class="math inline">\(N\)</span>的时候被杀死的即是<span class="math inline">\(3(k+1)\)</span>,那么<span class="math inline">\(N\)</span>之前的编号就是<span class="math inline">\(3k+w=N-(n-k)=N-n+k\)</span>.</p>
<p>而<span class="math inline">\(k=\lfloor\cfrac
{(N-n-1)}{2}\rfloor\)</span>,我们可以不断进行迭代.</p>
<p>如果我们令<span class="math inline">\(D=3n+1-N\)</span>,换句话说即改变编号的顺序,我们可以有以下的赋值操作:</p>
<p><span class="math inline">\(3n+1-D&#39;=3n+1-D-n+\lfloor\cfrac
{(3n+1-D-n-1)}{2}\rfloor\)</span>.</p>
<p>化简这个式子,我们有:<span class="math inline">\(D&#39;=D+n-\lfloor\cfrac
{(2n-D)}{2}\rfloor=D+\lceil\cfrac{D}{2}\rceil=\lceil\cfrac{3D}2\rceil\)</span>.</p>
<p>事实上,我们可以证明:如果我们每隔<span class="math inline">\(q\)</span>个人就杀掉一个人的话,那么<span class="math inline">\(D&#39;=\lceil\cfrac{(q+1)D}{q}\rceil\)</span>,一直迭代到<span class="math inline">\(D&#39;&gt;qn\)</span>时.</p>
<p>而最后的答案就是<span class="math inline">\((q+1)n+1-D\)</span>.</p>
<h4><span id="整值函数的恒等式">整值函数的恒等式</span></h4>
<p>考虑公式<span class="math inline">\(\lceil\cfrac{n-k+1}{m}\rceil\)</span>,不难发现它在<span class="math inline">\(1\leq k\leq n\mod m\)</span>时的值为<span class="math inline">\(\lceil\cfrac{n}{m}\rceil\)</span>,而在<span class="math inline">\(n\mod m&lt;k\leq m\)</span>的值为<span class="math inline">\(\lfloor\cfrac n m\rfloor\)</span>.</p>
<p>那么我们可以得到以下恒等式:</p>
<p><span class="math inline">\(n=\sum_{k=1}^m\lceil\cfrac{n-k+1}{m}\rceil\)</span>.</p>
<p>类似地,有:</p>
<p><span class="math inline">\(n=\sum_{k=1}^m\lfloor\cfrac{n+k-1}{m}\rfloor\)</span>.</p>
<p>用<span class="math inline">\(\lfloor
mx\rfloor\)</span>替换上面的<span class="math inline">\(n\)</span>有<span class="math inline">\(\lfloor
mx\rfloor=\sum_{k=1}^m\lfloor x+\cfrac{k-1}{m}\rfloor\)</span>.</p>
<p>同样的,有<span class="math inline">\(\lceil
mx\rceil=\sum_{k=1}^m\lceil x-\cfrac{k-1}{m}\rceil\)</span>.</p>
<h4><span id="整值函数的和式">整值函数的和式</span></h4>
<p>通常情况下,处理含整值函数的和式时,通过引入新变量进行代替以及通过转化为区间进行化简.</p>
<p>如果遇到难以处理的情况,我们不妨考虑直接处理其中一段的和,使得剩下部分求和更为简单.</p>
<p>处理整值函数的另一个方法是:考虑将整值函数内的东西移出,并且让里面的东西形如等差序列,这样我们就可以尝试使用恒等式来化简.</p>
<h5><span id="example1">Example1</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^{n-1}\lfloor\sqrt
k\rfloor\)</span>.</p>
<p>我们有: <span class="math display">\[
\sum_{k=0}^{n-1}\lfloor\sqrt k\rfloor=\sum_{0\leq
k,m}[k&lt;n][m=\lfloor\sqrt k\rfloor]m\\
=\sum_{0\leq k,m}[k&lt;n][m^2\leq k&lt;(m+1)^2]m\\
=\sum_{0\leq k,m}m[m^2\leq k&lt;n&lt;(m+1)^2]+\sum_{0\leq k,m}m[m^2\leq
k&lt;(m+1)^2\leq n]
\]</span> 考虑<span class="math inline">\(n=a^2\)</span>的特殊情况,则前面那一项显然是<span class="math inline">\(0\)</span>,那么: <span class="math display">\[
ans=\sum_{0\leq k,m}m[m^2\leq k&lt;(m+1)^2\leq n]\\
=\sum_{0\leq m}m(2m+1)[m&lt;a]\\
=\sum_{m=0}^{a-1}(2m^2+m)\\
=\cfrac{(a-1)a(2a-1)}{3}+\cfrac{a(a-1)}{2}\\
=\cfrac{(4a+1)a(a-1)}{6}
\]</span> 而如果<span class="math inline">\(n\ne
a^2\)</span>,我们令<span class="math inline">\(a=\lfloor\sqrt
n\rfloor\)</span>,而当<span class="math inline">\(k\in
[a^2,n)\)</span>的部分的贡献显然是<span class="math inline">\(a(n-a^2)\)</span>.</p>
<p>于是最后的结果就是:<span class="math inline">\(\cfrac{(4a+1)a(a-1)}{6}+a(n-a^2),a=\lfloor\sqrt
n\rfloor\)</span>.</p>
<p>另一个做法是,我们考虑增加枚举量,有: <span class="math display">\[
\sum_{k=0}^{n-1}\lfloor\sqrt k\rfloor=\sum_{j,k}[1\leq j\leq \sqrt
k][0\leq k&lt;a^2]\\
=\sum_{1\leq j&lt;a}\sum_{k}[j^2\leq k&lt;a^2]\\
=\sum_{1\leq j&lt;a}a^2-j^2=a^3-\cfrac{a(2a+1)(a+1)}{6}
\]</span></p>
<h5><span id="example2类欧几里得算法">Example2(类欧几里得算法)</span></h5>
<p>求<span class="math inline">\(\sum_{k=0}^{m-1}\lfloor\cfrac{nk+x}{m}\rfloor,m\in\mathbb{N_+},n\in
\mathbb{Z}\)</span>.</p>
<p>由于<span class="math inline">\(kn-(kn\mod
m)=m\lfloor\cfrac{kn}{m}\rfloor\)</span>,我们有:</p>
<p><span class="math display">\[
\lfloor\cfrac{x+kn}{m}\rfloor=\lfloor\cfrac{x+(kn\mod
m)}{m}\rfloor+\cfrac{kn}{m}-\cfrac{kn\mod m}{m}
\]</span>
这样,我们将整个式子的求和分为了三部分,第二项显然是等差数列求和,而如果我们令<span class="math inline">\(g=\gcd(n,m)\)</span>,不难发现第三项的分子是一个等差数列<span class="math inline">\(0,g,2g,...m-g\)</span>重复了<span class="math inline">\(g\)</span>次,而且正因为这,第一项里面的数也就自然组成了等差数列,由于我们有恒等式,那么这一项也就自然可以计算了.</p>
<p>分别求和后加起来,得到答案为<span class="math inline">\(g\lfloor\cfrac{x}{g}\rfloor+\cfrac{(m-1)n}{2}+\cfrac{g-m}{2}\)</span>.</p>
<p>另外,对这个式子进行化简,我们可以得到:<span class="math inline">\(g\lfloor\cfrac{x}{g}\rfloor+\cfrac{(m-1)(n-1)}{2}+\cfrac{g-1}2\)</span>,而这个式子关于<span class="math inline">\(n\)</span>和<span class="math inline">\(m\)</span>是对称的.</p>
<p>也就是说:<span class="math inline">\(\sum_{k=0}^{m-1}\lfloor\cfrac{nk+x}{m}\rfloor=\sum_{k=0}^{n-1}\lfloor\cfrac{mk+x}{n}\rfloor,m,n\in\mathbb{N_+}\)</span>.</p>
<p>另外,如果要求<span class="math inline">\(\sum^n_{i=0}\lfloor\cfrac{ai+b}{c}\rfloor\)</span>,我们也有一种<span class="math inline">\(O(\log n)\)</span>的做法(类欧几里得算法):</p>
<p>若<span class="math inline">\(c\leq a\)</span>,原式化为<span class="math inline">\(\sum^n_{i=0}{(i\times\lfloor\frac{a}{c}\rfloor+\lfloor\cfrac{(a\mod
c)i+b}{c}\rfloor)}\)</span>.</p>
<p>若<span class="math inline">\(c\leq b\)</span>,原式化为<span class="math inline">\(\sum^n_{i=0}{\lfloor\cfrac{b}{c}\rfloor+\lfloor\cfrac{ai+(b\mod
c)}{c}\rfloor}\)</span>.</p>
<p>考虑<span class="math inline">\(a,b&lt;c\)</span>的情况,设<span class="math inline">\(m=\lfloor\cfrac{an+b}{c}\rfloor\)</span>,原式化为
<span class="math display">\[
\sum^n_{i=0}\sum^m_{j=1}[j\leq
\lfloor\cfrac{ai+b}{c}\rfloor]\\=\sum^n_{i=0}\sum^m_{j=1}[cj\leq
ai+b]\\=nm-\sum^n_{i=0}\sum^m_{j=1}[ai\leq
cj-b-1]\\=nm-\sum^m_{i=1}\lfloor\cfrac{ci-b-1}{a}\rfloor
\]</span></p>
<p>#####Example3</p>
<p>求<span class="math inline">\(\sum_{n=1}^{1000}[\lfloor\sqrt[3]n\rfloor|n]\)</span>.
<span class="math display">\[
ans=\sum_{n,k}[k=\lfloor\sqrt[3]n\rfloor][k|n][1\leq n\leq 1000]\\
=\sum_{k,m,n}[k^3\leq n&lt;(k+1)^3][n=km][1\leq n\leq 1000]\\
=1+\sum_{k,m}[k^3\leq km&lt;(k+1)^3][1\leq k&lt; 10]\\
=1+\sum_{k,m}[k^2\leq m&lt;\frac{(k+1)^3}k][1\leq k&lt;10]\\
=1+\sum_{k=1}^9(\lceil k^2+3k+3+\frac1 k\rceil-\lceil k^2\rceil)\\
=1+\sum_{k=1}^9(3k+4)=172
\]</span> 上述推理过程将<span class="math inline">\(n=1000\)</span>的情况特殊讨论了一下,不难发现,如果我们要求的式子是<span class="math inline">\(\sum_{n=1}^{N}[\lfloor\sqrt[3]n\rfloor|n]\)</span>,也仍然可以使用将<span class="math inline">\([K^3,N],K=\lfloor\sqrt[3]N\rfloor\)</span>中的数特殊处理的方式做掉,因为这些数的三次根下取整一定是<span class="math inline">\(K\)</span>,式子就不难化简了.</p>
<h5><span id="example4uoj42sum">Example4([uoj42]Sum)</span></h5>
<p>这题的重点在于将幂通过<span class="math inline">\(-1\)</span>的性质拿下来.</p>
<p>我们有<span class="math inline">\((-1)^a=1-2(a\mod
2)=1-2(a-2\lfloor\frac{a}{2}\rfloor)\)</span>.</p>
<p>于是我们有: <span class="math display">\[
\sum_{d=1}^n(-1)^{\lfloor d\sqrt r\rfloor}\\=n-2\sum_{d=1}^n\lfloor
d\sqrt r\rfloor+4\sum_{d=1}^n\lfloor\frac{\lfloor d\sqrt
r\rfloor}{2}\rfloor\\
\]</span> 令<span class="math inline">\(f(x)=\frac{x}2\)</span>,根据整值函数的性质,不难发现<span class="math inline">\(\lfloor\frac{\lfloor d\sqrt
r\rfloor}{2}\rfloor=\lfloor\frac{d\sqrt r}{2}\rfloor\)</span>.</p>
<p>于是我们有: <span class="math display">\[
ans=n-2\sum_{d=1}^n\lfloor d\sqrt
r\rfloor+4\sum_{d=1}^n\lfloor\frac{d\sqrt r}{2}\rfloor\\
\]</span> 记<span class="math inline">\(t=\sqrt
r\)</span>,我们所要解决的问题是<span class="math inline">\(\sum_{d=1}^n\lfloor
d\frac{Pt+R}{Q}\rfloor\)</span>.如果<span class="math inline">\(\frac{Pt+R}{Q}\geq
1\)</span>,我们可以把整数部分取出来单独算.于是接下来我们只讨论<span class="math inline">\(0\leq
\frac{Pt+R}{Q}&lt;1\)</span>的情况.相当于求一条斜率小于<span class="math inline">\(1\)</span>的直线下方的整点个数.我们可以反转坐标系,这样就变成了斜率大于<span class="math inline">\(1\)</span>的直线,继续做上面的操作.</p>
<p>这个问题引出万能欧几里得算法.</p>
<h5><span id="example5loj6440万能欧几里得算法">Example5([loj6440]万能欧几里得算法)</span></h5>
<p>解决形如<span class="math inline">\(\sum_{x=1}^{L}A^xB^{\lfloor\frac{Px+R}{Q}\rfloor}\)</span>的问题,其中<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是<span class="math inline">\(n\times
n\)</span>的矩阵.默认<span class="math inline">\(P,Q,R\geq
0\)</span>.</p>
<p>我们将问题抽象为下面的模型:</p>
<p>首先将坐标系中所有经过整数点的与坐标轴平行的直线全都标记出来.</p>
<p>考虑将问题转化为:有一条<span class="math inline">\(y=\frac{Px+R}{Q}\)</span>的直线,我们从<span class="math inline">\((0,\frac{R}{Q})\)</span>(不包含这个点)处开始沿直线向右走.每遇到一条横线,就进行<span class="math inline">\(U_w\)</span>操作;每遇到一条竖线,就进行<span class="math inline">\(R_w\)</span>操作.如果遇到了整数格点,就先进行<span class="math inline">\(U_w\)</span>操作,再进行<span class="math inline">\(R_w\)</span>操作.</p>
<p>例如上面那个例子就是:现在有一个矩阵二元组<span class="math inline">\((X,Y)\)</span>,初始为<span class="math inline">\((A,B^{\lfloor\frac{R}{Q}\rfloor})\)</span>,<span class="math inline">\(R_w\)</span>操作是:<span class="math inline">\((X,Y)\rightarrow (AX,Y+X)\)</span>,<span class="math inline">\(U_w\)</span>操作是:<span class="math inline">\((X,Y)\rightarrow(XB,Y)\)</span>.一直走到<span class="math inline">\(x=L\)</span>的点为止,最后矩阵<span class="math inline">\(Y\)</span>就是答案.不过这个形式不好写成矩阵,我们可以记录<span class="math inline">\((A^a,B^b,Y)\)</span>.这样最后就可以带入操作,不难发现这个操作是个环.</p>
<p>操作要满足可合并性,也就是我可以将<span class="math inline">\(U_wR_w\)</span>变成一个操作进行.</p>
<p>接下来我们分情况讨论一下:</p>
<p>当<span class="math inline">\(P\geq Q\)</span>时,注意到<span class="math inline">\(y=\frac{Px+R}{Q}=\lfloor\frac{P}{Q}\rfloor
x+\frac{(P\mod Q)x+R}{Q}\)</span>,此时任意一个<span class="math inline">\(R_w\)</span>操作前必然有至少<span class="math inline">\(\lfloor\frac{P}{Q}\rfloor\)</span>个<span class="math inline">\(U_w\)</span>,我们令<span class="math inline">\(R_w&#39;=U_w^{\lfloor\frac{P}{Q}\rfloor}R_w\)</span>,不难发现:<span class="math inline">\(solve(P,Q,R,L,U_w,R_w)=solve(P\mod
Q,Q,R,L,U_w,R_w&#39;)\)</span>.</p>
<p>当<span class="math inline">\(P&lt;Q\and P\ne
0\)</span>时,我们想要让<span class="math inline">\(P\)</span>与<span class="math inline">\(Q\)</span>互换,假设第<span class="math inline">\(a\)</span>个<span class="math inline">\(R_w\)</span>在第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>之前,考虑这个<span class="math inline">\(R_w\)</span>前会有<span class="math inline">\(\lfloor\frac{Pa+R}{Q}\rfloor-\lfloor\frac{R}{Q}\rfloor\)</span>个<span class="math inline">\(U_w\)</span>,而对于后者,变换坐标系得到<span class="math inline">\(x=\frac{yQ-R}{P}\)</span>,由于遇到整点时,先<span class="math inline">\(U_w\)</span>再进行<span class="math inline">\(R_w\)</span>,也就是说,第<span class="math inline">\(b\)</span>个<span class="math inline">\(U_w\)</span>前会有<span class="math inline">\(\lfloor\frac{Qb-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>(这个并没有忽略初始位置).我们考虑如何让这个数和上面的<span class="math inline">\(\lfloor\frac{Pa+R}{Q}\rfloor\)</span>的差分写成一样的形式.注意到<span class="math inline">\(b=1\)</span>需要特殊处理!</p>
<p>显然操作序列一共有<span class="math inline">\(cntU=\lfloor\frac{PL+R}{Q}\rfloor-\lfloor\frac{R}{Q}\rfloor\)</span>,将二者对应一下,这里的答案就是<span class="math inline">\(solve(Q,P,(Q-R-1)\bmod
P,cntU-1,R_w,U_w)\)</span>.</p>
<p>然后是开头部分,开头部分一共有<span class="math inline">\(\lfloor\frac{Q-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>和一个<span class="math inline">\(U_w\)</span>.</p>
<p>但是注意到末尾部分同样是不规整的,注意到末尾一共有<span class="math inline">\(L-\lfloor\frac{QcntU-R-1}{P}\rfloor\)</span>个<span class="math inline">\(R_w\)</span>,拼到末尾即可.</p>
<p>最后<span class="math inline">\(P=0\)</span>的时候直接返回<span class="math inline">\(R_w^{L}\)</span>即可.</p>
<p>假设合并的复杂度是<span class="math inline">\(c\)</span>,注意到每层的复杂度是<span class="math inline">\(O(c\log(\frac{Q}{P}))=O(c(\log Q-\log
P))\)</span>,但是每两层会抵消,因此复杂度<span class="math inline">\(O(C\log(P+Q))\)</span>.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_telegram"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="数据结构相关">
                  <i class="fa fa-angle-left"></i> 数据结构相关
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/05/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" rel="next" title="文化课数学导论">
                  文化课数学导论 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2024/10/05/%E5%AD%A6%E4%B9%A0-%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
