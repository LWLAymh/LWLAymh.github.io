<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="抽象代数  群  定义 基本概念和事实  Example1 Example2  子群  Example1 Example2 Example3 Example4 Example5 Example6 Example7 Example8  同态和同构 群的实例  全变换群,对称群与交错群 一般线性群 克莱因四元群 循环群  相反群">
<meta property="og:type" content="article">
<meta property="og:title" content="高等代数">
<meta property="og:url" content="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="抽象代数  群  定义 基本概念和事实  Example1 Example2  子群  Example1 Example2 Example3 Example4 Example5 Example6 Example7 Example8  同态和同构 群的实例  全变换群,对称群与交错群 一般线性群 克莱因四元群 循环群  相反群">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-22T16:00:25.492Z">
<meta property="article:modified_time" content="2025-06-22T16:00:25.492Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/","path":"2025/06/23/学习-高等代数/","title":"高等代数"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>高等代数 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">抽象代数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.</span> <span class="nav-text">基本概念和事实</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.3.</span> <span class="nav-text">子群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Example2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Example3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Example4</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">Example5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">Example6</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">Example7</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">Example8</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.4.</span> <span class="nav-text">同态和同构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.5.</span> <span class="nav-text">群的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">全变换群,对称群与交错群</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">一般线性群</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">克莱因四元群</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">循环群</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.6.</span> <span class="nav-text">相反群</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.6.0.1.</span> <span class="nav-text">Example1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.7.</span> <span class="nav-text">陪集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.8.</span> <span class="nav-text">群作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">Cayley定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">Burnside引理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">\(p\)-群</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.8.3.1.</span> <span class="nav-text">Example1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.9.</span> <span class="nav-text">正规子群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">正规子群的判定定理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.9.1.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.9.1.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">正规子群与同态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">同态基本定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">第一同构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.5.</span> <span class="nav-text">第二同构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.9.6.</span> <span class="nav-text">交换化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.9.6.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.9.6.2.</span> <span class="nav-text">Example2(岩泽健吉(Iwasawa)判准)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.9.6.3.</span> <span class="nav-text">Example3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.10.</span> <span class="nav-text">群的直和与直积</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">直和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">半直积</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.10.2.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.1.10.2.2.</span> <span class="nav-text">Example2(二面体群)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.1.</span> <span class="nav-text">子环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.2.</span> <span class="nav-text">理想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.3.</span> <span class="nav-text">同态和同构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">同态基本定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">第一同构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">第二同构定理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.2.4.</span> <span class="nav-text">整环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">整除性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">唯一分解整环(UFD)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">主理想整环(PID)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">多项式环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.1.</span> <span class="nav-text">一元多项式环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.2.</span> <span class="nav-text">多元多项式环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.3.</span> <span class="nav-text">不可约多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">本原多项式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">一个判定不可约的算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">不可约多项式上的扩域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.4.</span> <span class="nav-text">对称多项式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">牛顿公式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.5.</span> <span class="nav-text">结式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.3.6.</span> <span class="nav-text">判别式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.1.</span> <span class="nav-text">分式域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.2.</span> <span class="nav-text">子域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">线性代数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">矩阵引入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.1.</span> <span class="nav-text">矩阵运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.1.2.</span> <span class="nav-text">分块矩阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">线性方程组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.1.</span> <span class="nav-text">系数矩阵和增广矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.2.</span> <span class="nav-text">矩阵的初等行变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.3.</span> <span class="nav-text">阶梯形矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">简化阶梯形矩阵的唯一性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.4.</span> <span class="nav-text">解线性方程组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">存在与唯一性定理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.5.</span> <span class="nav-text">矩阵方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.2.6.</span> <span class="nav-text">齐次线性方程组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">线性空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.1.</span> <span class="nav-text">相关运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">直积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">直和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">叉乘</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.2.</span> <span class="nav-text">线性无关与线性相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.3.</span> <span class="nav-text">子空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">向量的线性组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">线性映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">基和维数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.4.</span> <span class="nav-text">可逆矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">初等矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">求解逆矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">Example1(LU分解)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.5.</span> <span class="nav-text">核与像与秩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">Sylvester秩不等式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">Frobenius秩不等式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.6.</span> <span class="nav-text">对偶空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.7.</span> <span class="nav-text">直和分解与分块矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.8.</span> <span class="nav-text">基的变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.8.1.</span> <span class="nav-text">矩阵的共轭(相似)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.8.2.</span> <span class="nav-text">矩阵的相抵</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.3.9.</span> <span class="nav-text">商空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.9.1.</span> <span class="nav-text">同态基本定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.9.2.</span> <span class="nav-text">第一同构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.9.3.</span> <span class="nav-text">第二同构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.9.4.</span> <span class="nav-text">旗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.3.9.5.</span> <span class="nav-text">不变子空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.4.</span> <span class="nav-text">行列式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.1.</span> <span class="nav-text">置换(排列)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.2.</span> <span class="nav-text">交错形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.3.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.4.</span> <span class="nav-text">余子式与代数余子式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.5.</span> <span class="nav-text">行列式定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.6.</span> <span class="nav-text">克拉默(Cramer)法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.7.</span> <span class="nav-text">一些特殊行列式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">置换矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.4.7.2.</span> <span class="nav-text">上三角矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.4.7.3.</span> <span class="nav-text">分块上三角矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.4.7.4.</span> <span class="nav-text">范德蒙德(Vandermonde)行列式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.4.7.5.</span> <span class="nav-text">一类分块矩阵</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.8.</span> <span class="nav-text">特征多项式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.9.</span> <span class="nav-text">Cayley-Hamilton定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.10.</span> <span class="nav-text">矩阵的迹</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.4.10.0.1.</span> <span class="nav-text">Example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.11.</span> <span class="nav-text">Binet-Cauchy定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.12.</span> <span class="nav-text">特征值与特征向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.13.</span> <span class="nav-text">极小多项式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.14.</span> <span class="nav-text">同步对角化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.15.</span> <span class="nav-text">上三角化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.16.</span> <span class="nav-text">广义特征子空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.4.17.</span> <span class="nav-text">特殊矩阵的特征值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.4.17.0.1.</span> <span class="nav-text">Example</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.5.</span> <span class="nav-text">双线性形式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.1.</span> <span class="nav-text">线性映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.2.</span> <span class="nav-text">非退化形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.3.</span> <span class="nav-text">伴随映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.4.</span> <span class="nav-text">分类问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.5.</span> <span class="nav-text">二次型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">实二次型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">惯性(Sylvester)定理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.6.</span> <span class="nav-text">辛空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.6.1.</span> <span class="nav-text">达布定理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.5.7.</span> <span class="nav-text">回看对偶空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.7.1.</span> <span class="nav-text">双重对偶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.7.2.</span> <span class="nav-text">核,余核与对偶映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.5.7.3.</span> <span class="nav-text">像自对偶</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.6.</span> <span class="nav-text">实内积空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.1.</span> <span class="nav-text">勾股定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.2.</span> <span class="nav-text">柯西不等式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.3.</span> <span class="nav-text">三角不等式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.4.</span> <span class="nav-text">距离相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.5.</span> <span class="nav-text">正交向量族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.6.</span> <span class="nav-text">Gram-Schmidt 正交化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.6.6.0.1.</span> <span class="nav-text">Example1(RU分解)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.6.6.0.2.</span> <span class="nav-text">Example2(Legendre多项式)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.7.</span> <span class="nav-text">正交算子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.8.</span> <span class="nav-text">正交补空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.9.</span> <span class="nav-text">投影矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.10.</span> <span class="nav-text">自伴算子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.10.1.</span> <span class="nav-text">(实)Sylvester 判准</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.10.2.</span> <span class="nav-text">(实)正定矩阵的二次根</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.6.10.2.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.6.10.2.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.10.3.</span> <span class="nav-text">极分解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.10.4.</span> <span class="nav-text">最小二乘法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.11.</span> <span class="nav-text">奇异值分解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.12.</span> <span class="nav-text">Moore-Penrose 广义逆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.13.</span> <span class="nav-text">极大化极小原理(Courant-Fischer定理)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.14.</span> <span class="nav-text">Perron-Frobenius定理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.14.1.</span> <span class="nav-text">Collatz-Wielandt公式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.14.2.</span> <span class="nav-text">Perron定理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.6.15.</span> <span class="nav-text">实正交变换的标准型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.15.1.</span> <span class="nav-text">欧拉角</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.6.15.2.</span> <span class="nav-text">四元数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.7.</span> <span class="nav-text">复内积空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.1.</span> <span class="nav-text">共轭空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.2.</span> <span class="nav-text">(复)半双线性形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.3.</span> <span class="nav-text">伴随映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.4.</span> <span class="nav-text">Hermite形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">正规线性映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">二次型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.7.5.</span> <span class="nav-text">复内积空间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.5.1.</span> <span class="nav-text">酉变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.5.2.</span> <span class="nav-text">正规算子的酉对角化(谱定理)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.5.3.</span> <span class="nav-text">相关实内积空间定理推广</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.7.5.4.</span> <span class="nav-text">复矩阵范数实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.8.</span> <span class="nav-text">模</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.1.</span> <span class="nav-text">自由模</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.8.1.0.1.</span> <span class="nav-text">Example1(非自由模)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.2.</span> <span class="nav-text">线性映射和模结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.3.</span> <span class="nav-text">主理想环上的有限生成模</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">自由模与其子模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">Smith标准型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">结构定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.3.4.</span> <span class="nav-text">有限生成交换群的分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.4.</span> <span class="nav-text">有理标准型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.8.4.0.1.</span> <span class="nav-text">Example1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.8.5.</span> <span class="nav-text">Jordan标准型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.5.1.</span> <span class="nav-text">加性Jordan-Chevalley分解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.8.5.2.</span> <span class="nav-text">乘性Jordan-Chevalley分解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.9.</span> <span class="nav-text">张量积</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.1.</span> <span class="nav-text">张量积与直和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.2.</span> <span class="nav-text">Kronecker积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.3.</span> <span class="nav-text">张量积与对偶空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.4.</span> <span class="nav-text">张量代数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">另一种构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.9.4.2.</span> <span class="nav-text">又看对偶空间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.9.4.2.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">2.9.4.2.2.</span> <span class="nav-text">Example2</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.9.4.3.</span> <span class="nav-text">简单应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.9.5.</span> <span class="nav-text">域的变换</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="高等代数 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高等代数
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-23 00:00:25" itemprop="dateCreated datePublished" datetime="2025-06-23T00:00:25+08:00">2025-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">大学课程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- toc -->
<ul>
<li><a href="#抽象代数">抽象代数</a>
<ul>
<li><a href="#群">群</a>
<ul>
<li><a href="#定义">定义</a></li>
<li><a href="#基本概念和事实">基本概念和事实</a>
<ul>
<li><a href="#example1">Example1</a></li>
<li><a href="#example2">Example2</a></li>
</ul></li>
<li><a href="#子群">子群</a>
<ul>
<li><a href="#example1-1">Example1</a></li>
<li><a href="#example2-1">Example2</a></li>
<li><a href="#example3">Example3</a></li>
<li><a href="#example4">Example4</a></li>
<li><a href="#example5">Example5</a></li>
<li><a href="#example6">Example6</a></li>
<li><a href="#example7">Example7</a></li>
<li><a href="#example8">Example8</a></li>
</ul></li>
<li><a href="#同态和同构">同态和同构</a></li>
<li><a href="#群的实例">群的实例</a>
<ul>
<li><a href="#全变换群对称群与交错群">全变换群,对称群与交错群</a></li>
<li><a href="#一般线性群">一般线性群</a></li>
<li><a href="#克莱因四元群">克莱因四元群</a></li>
<li><a href="#循环群">循环群</a></li>
</ul></li>
<li><a href="#相反群">相反群</a>
<ul>
<li><a href="#example1-2">Example1</a></li>
</ul></li>
<li><a href="#陪集">陪集</a></li>
<li><a href="#群作用">群作用</a>
<ul>
<li><a href="#cayley定理">Cayley定理</a></li>
<li><a href="#burnside引理">Burnside引理</a></li>
<li><a href="#p-群"><span class="math inline">\(p\)</span>-群</a>
<ul>
<li><a href="#example1-3">Example1</a></li>
</ul></li>
</ul></li>
<li><a href="#正规子群">正规子群</a>
<ul>
<li><a href="#正规子群的判定定理">正规子群的判定定理</a>
<ul>
<li><a href="#example1-4">Example1</a></li>
<li><a href="#example2-2">Example2</a></li>
</ul></li>
<li><a href="#正规子群与同态">正规子群与同态</a></li>
<li><a href="#同态基本定理">同态基本定理</a></li>
<li><a href="#第一同构定理">第一同构定理</a></li>
<li><a href="#第二同构定理">第二同构定理</a></li>
<li><a href="#交换化">交换化</a>
<ul>
<li><a href="#example1-5">Example1</a></li>
<li><a href="#example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</a></li>
<li><a href="#example3-1">Example3</a></li>
</ul></li>
</ul></li>
<li><a href="#群的直和与直积">群的直和与直积</a>
<ul>
<li><a href="#直和">直和</a></li>
<li><a href="#半直积">半直积</a>
<ul>
<li><a href="#example1-6">Example1</a></li>
<li><a href="#example2二面体群">Example2(二面体群)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#环">环</a>
<ul>
<li><a href="#子环">子环</a></li>
<li><a href="#理想">理想</a></li>
<li><a href="#同态和同构-1">同态和同构</a>
<ul>
<li><a href="#同态基本定理-1">同态基本定理</a></li>
<li><a href="#第一同构定理-1">第一同构定理</a></li>
<li><a href="#第二同构定理-1">第二同构定理</a></li>
</ul></li>
<li><a href="#整环">整环</a>
<ul>
<li><a href="#特征">特征</a></li>
<li><a href="#整除性">整除性</a></li>
<li><a href="#唯一分解整环ufd">唯一分解整环(UFD)</a></li>
<li><a href="#主理想整环pid">主理想整环(PID)</a></li>
</ul></li>
</ul></li>
<li><a href="#多项式环">多项式环</a>
<ul>
<li><a href="#一元多项式环">一元多项式环</a></li>
<li><a href="#多元多项式环">多元多项式环</a></li>
<li><a href="#不可约多项式">不可约多项式</a>
<ul>
<li><a href="#本原多项式">本原多项式</a></li>
<li><a href="#一个判定不可约的算法">一个判定不可约的算法</a></li>
<li><a href="#不可约多项式上的扩域">不可约多项式上的扩域</a></li>
</ul></li>
<li><a href="#对称多项式">对称多项式</a>
<ul>
<li><a href="#牛顿公式">牛顿公式</a></li>
</ul></li>
<li><a href="#结式">结式</a></li>
<li><a href="#判别式">判别式</a></li>
</ul></li>
<li><a href="#域">域</a>
<ul>
<li><a href="#分式域">分式域</a></li>
<li><a href="#子域">子域</a></li>
</ul></li>
</ul></li>
<li><a href="#线性代数">线性代数</a>
<ul>
<li><a href="#矩阵引入">矩阵引入</a>
<ul>
<li><a href="#矩阵运算">矩阵运算</a></li>
<li><a href="#分块矩阵">分块矩阵</a></li>
</ul></li>
<li><a href="#线性方程组">线性方程组</a>
<ul>
<li><a href="#系数矩阵和增广矩阵">系数矩阵和增广矩阵</a></li>
<li><a href="#矩阵的初等行变换">矩阵的初等行变换</a></li>
<li><a href="#阶梯形矩阵">阶梯形矩阵</a>
<ul>
<li><a href="#简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</a></li>
</ul></li>
<li><a href="#解线性方程组">解线性方程组</a>
<ul>
<li><a href="#存在与唯一性定理">存在与唯一性定理</a></li>
</ul></li>
<li><a href="#矩阵方程">矩阵方程</a></li>
<li><a href="#齐次线性方程组">齐次线性方程组</a></li>
</ul></li>
<li><a href="#线性空间">线性空间</a>
<ul>
<li><a href="#相关运算">相关运算</a>
<ul>
<li><a href="#直积">直积</a></li>
<li><a href="#直和-1">直和</a></li>
<li><a href="#叉乘">叉乘</a></li>
</ul></li>
<li><a href="#线性无关与线性相关">线性无关与线性相关</a></li>
<li><a href="#子空间">子空间</a>
<ul>
<li><a href="#向量的线性组合">向量的线性组合</a></li>
<li><a href="#线性映射">线性映射</a></li>
<li><a href="#基和维数">基和维数</a></li>
</ul></li>
<li><a href="#可逆矩阵">可逆矩阵</a>
<ul>
<li><a href="#初等矩阵">初等矩阵</a></li>
<li><a href="#求解逆矩阵">求解逆矩阵</a>
<ul>
<li><a href="#example1lu分解">Example1(LU分解)</a></li>
</ul></li>
</ul></li>
<li><a href="#核与像与秩">核与像与秩</a>
<ul>
<li><a href="#sylvester秩不等式">Sylvester秩不等式</a></li>
<li><a href="#frobenius秩不等式">Frobenius秩不等式</a></li>
</ul></li>
<li><a href="#对偶空间">对偶空间</a></li>
<li><a href="#直和分解与分块矩阵">直和分解与分块矩阵</a></li>
<li><a href="#基的变换">基的变换</a>
<ul>
<li><a href="#矩阵的共轭相似">矩阵的共轭(相似)</a></li>
<li><a href="#矩阵的相抵">矩阵的相抵</a></li>
</ul></li>
<li><a href="#商空间">商空间</a>
<ul>
<li><a href="#同态基本定理-2">同态基本定理</a></li>
<li><a href="#第一同构定理-2">第一同构定理</a></li>
<li><a href="#第二同构定理-2">第二同构定理</a></li>
<li><a href="#旗">旗</a></li>
<li><a href="#不变子空间">不变子空间</a></li>
</ul></li>
</ul></li>
<li><a href="#行列式">行列式</a>
<ul>
<li><a href="#置换排列">置换(排列)</a></li>
<li><a href="#交错形式">交错形式</a></li>
<li><a href="#定义-1">定义</a></li>
<li><a href="#余子式与代数余子式">余子式与代数余子式</a></li>
<li><a href="#行列式定向">行列式定向</a></li>
<li><a href="#克拉默cramer法则">克拉默(Cramer)法则</a></li>
<li><a href="#一些特殊行列式">一些特殊行列式</a>
<ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#上三角矩阵">上三角矩阵</a></li>
<li><a href="#分块上三角矩阵">分块上三角矩阵</a></li>
<li><a href="#范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</a></li>
<li><a href="#一类分块矩阵">一类分块矩阵</a></li>
</ul></li>
<li><a href="#特征多项式">特征多项式</a></li>
<li><a href="#cayley-hamilton定理">Cayley-Hamilton定理</a></li>
<li><a href="#矩阵的迹">矩阵的迹</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#binet-cauchy定理">Binet-Cauchy定理</a></li>
<li><a href="#特征值与特征向量">特征值与特征向量</a></li>
<li><a href="#极小多项式">极小多项式</a></li>
<li><a href="#同步对角化">同步对角化</a></li>
<li><a href="#上三角化">上三角化</a></li>
<li><a href="#广义特征子空间">广义特征子空间</a></li>
<li><a href="#特殊矩阵的特征值">特殊矩阵的特征值</a>
<ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
</ul></li>
<li><a href="#双线性形式">双线性形式</a>
<ul>
<li><a href="#线性映射-1">线性映射</a></li>
<li><a href="#非退化形式">非退化形式</a></li>
<li><a href="#伴随映射">伴随映射</a></li>
<li><a href="#分类问题">分类问题</a></li>
<li><a href="#二次型">二次型</a>
<ul>
<li><a href="#实二次型">实二次型</a></li>
<li><a href="#惯性sylvester定理">惯性(Sylvester)定理</a></li>
</ul></li>
<li><a href="#辛空间">辛空间</a>
<ul>
<li><a href="#达布定理">达布定理</a></li>
</ul></li>
<li><a href="#回看对偶空间">回看对偶空间</a>
<ul>
<li><a href="#双重对偶">双重对偶</a></li>
<li><a href="#核余核与对偶映射">核,余核与对偶映射</a></li>
<li><a href="#像自对偶">像自对偶</a></li>
</ul></li>
</ul></li>
<li><a href="#实内积空间">实内积空间</a>
<ul>
<li><a href="#勾股定理">勾股定理</a></li>
<li><a href="#柯西不等式">柯西不等式</a></li>
<li><a href="#三角不等式">三角不等式</a></li>
<li><a href="#距离相关">距离相关</a></li>
<li><a href="#正交向量族">正交向量族</a></li>
<li><a href="#gram-schmidt-正交化">Gram-Schmidt 正交化</a>
<ul>
<li><a href="#example1ru分解">Example1(RU分解)</a></li>
<li><a href="#example2legendre多项式">Example2(Legendre多项式)</a></li>
</ul></li>
<li><a href="#正交算子">正交算子</a></li>
<li><a href="#正交补空间">正交补空间</a></li>
<li><a href="#投影矩阵">投影矩阵</a></li>
<li><a href="#自伴算子">自伴算子</a>
<ul>
<li><a href="#实sylvester-判准">(实)Sylvester 判准</a></li>
<li><a href="#实正定矩阵的二次根">(实)正定矩阵的二次根</a>
<ul>
<li><a href="#example1-7">Example1</a></li>
<li><a href="#example2-3">Example2</a></li>
</ul></li>
<li><a href="#极分解">极分解</a></li>
<li><a href="#最小二乘法">最小二乘法</a></li>
</ul></li>
<li><a href="#奇异值分解">奇异值分解</a></li>
<li><a href="#moore-penrose-广义逆">Moore-Penrose 广义逆</a></li>
<li><a href="#极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</a></li>
<li><a href="#perron-frobenius定理">Perron-Frobenius定理</a>
<ul>
<li><a href="#collatz-wielandt公式">Collatz-Wielandt公式</a></li>
<li><a href="#perron定理">Perron定理</a></li>
</ul></li>
<li><a href="#实正交变换的标准型">实正交变换的标准型</a>
<ul>
<li><a href="#欧拉角">欧拉角</a></li>
<li><a href="#四元数">四元数</a></li>
</ul></li>
</ul></li>
<li><a href="#复内积空间">复内积空间</a>
<ul>
<li><a href="#共轭空间">共轭空间</a></li>
<li><a href="#复半双线性形式">(复)半双线性形式</a></li>
<li><a href="#伴随映射-1">伴随映射</a></li>
<li><a href="#hermite形式">Hermite形式</a>
<ul>
<li><a href="#正规线性映射">正规线性映射</a></li>
<li><a href="#二次型-1">二次型</a></li>
</ul></li>
<li><a href="#复内积空间-1">复内积空间</a>
<ul>
<li><a href="#酉变换">酉变换</a></li>
<li><a href="#正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</a></li>
<li><a href="#相关实内积空间定理推广">相关实内积空间定理推广</a></li>
<li><a href="#复矩阵范数实例">复矩阵范数实例</a></li>
</ul></li>
</ul></li>
<li><a href="#模">模</a>
<ul>
<li><a href="#自由模">自由模</a>
<ul>
<li><a href="#example1非自由模">Example1(非自由模)</a></li>
</ul></li>
<li><a href="#线性映射和模结构">线性映射和模结构</a></li>
<li><a href="#主理想环上的有限生成模">主理想环上的有限生成模</a>
<ul>
<li><a href="#自由模与其子模">自由模与其子模</a></li>
<li><a href="#smith标准型">Smith标准型</a></li>
<li><a href="#结构定理">结构定理</a></li>
<li><a href="#有限生成交换群的分类">有限生成交换群的分类</a></li>
</ul></li>
<li><a href="#有理标准型">有理标准型</a>
<ul>
<li><a href="#example1-8">Example1</a></li>
</ul></li>
<li><a href="#jordan标准型">Jordan标准型</a>
<ul>
<li><a href="#加性jordan-chevalley分解">加性Jordan-Chevalley分解</a></li>
<li><a href="#乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</a></li>
</ul></li>
</ul></li>
<li><a href="#张量积">张量积</a>
<ul>
<li><a href="#张量积与直和">张量积与直和</a></li>
<li><a href="#kronecker积">Kronecker积</a></li>
<li><a href="#张量积与对偶空间">张量积与对偶空间</a></li>
<li><a href="#张量代数">张量代数</a>
<ul>
<li><a href="#另一种构造">另一种构造</a></li>
<li><a href="#又看对偶空间">又看对偶空间</a>
<ul>
<li><a href="#example1-9">Example1</a></li>
<li><a href="#example2-4">Example2</a></li>
</ul></li>
<li><a href="#简单应用">简单应用</a></li>
</ul></li>
<li><a href="#域的变换">域的变换</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="抽象代数">抽象代数</span></h2>
<h3><span id="群">群</span></h3>
<h4><span id="定义">定义</span></h4>
<p>如果一个非空集合<span class="math inline">\(G\)</span>上定义了一个二元运算<span class="math inline">\(\circ : G \times G \to
G\)</span>(不引起混淆的前提下,通常省略不写,例如<span class="math inline">\(a \circ b\)</span>记作<span class="math inline">\(ab\)</span>),满足:</p>
<ol start="0" type="1">
<li><p>封闭性:<span class="math inline">\(a \circ b \in
G\)</span>.</p></li>
<li><p>结合律:<span class="math inline">\(( a \circ b ) \circ c = a
\circ ( b \circ c )\)</span>.</p></li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>半群</strong>.</p>
<p>如果它还满足:</p>
<ol start="2" type="1">
<li>存在幺元:<span class="math inline">\(\exists e \in
G\)</span>,使得<span class="math inline">\(\forall a , e \circ a = a
\circ e = a\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>幺半群(monoid)</strong>.</p>
<p>如果它还满足:</p>
<ol start="3" type="1">
<li>存在逆元:对任意的<span class="math inline">\(a \in
G\)</span>,存在<span class="math inline">\(b \in G\)</span>,使得<span class="math inline">\(a \circ b = e\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>群</strong>.</p>
<p>如果它还满足:</p>
<ol start="4" type="1">
<li>交换律:<span class="math inline">\(\forall a , b , a \circ b = b
\circ a\)</span>.</li>
</ol>
<p>那么称作<span class="math inline">\(G\)</span>是一个<strong>交换群</strong>或<strong>阿贝尔群</strong>.特别地,一般而言在交换群里,我们的运算使用加法符号(有时也直接叫它加法群),这只是一个惯例.</p>
<p>下面主要研究群.</p>
<h4><span id="基本概念和事实">基本概念和事实</span></h4>
<p>定义群的<strong>阶</strong>为群中元素个数,记作<span class="math inline">\(| G |\)</span>,如果<span class="math inline">\(| G
| &lt;
\infty\)</span>称为<strong>有限群</strong>,否则为<strong>无限群</strong>.</p>
<ol type="1">
<li>群的幺元唯一.</li>
</ol>
<p>设<span class="math inline">\(e , e &#39;\)</span>都是幺元,有<span class="math inline">\(e = ee &#39; = e &#39;\)</span>.</p>
<ol start="2" type="1">
<li>群中任一元素的逆元唯一.</li>
</ol>
<p>设<span class="math inline">\(b , b &#39;\)</span>都是<span class="math inline">\(a\)</span>的逆元,有<span class="math inline">\(b =
bab &#39; = b &#39;\)</span>.</p>
<p>这同样说明了虽然群上的二元运算有可能不满足交换律,但是仍然不存在左逆和右逆这种东西(或者说无意义),它俩都等价于逆.</p>
<ol start="3" type="1">
<li>群中有消去律,即<span class="math inline">\(ax = ay \Leftrightarrow x
= y\)</span>(左消去律),<span class="math inline">\(xa = ya
\Leftrightarrow x = y\)</span>(右消去律).</li>
</ol>
<p>显然.</p>
<p>于是可以定义乘方,并定义<span class="math inline">\(a^{ 0 } = e , a^{
- 1 } = inv ( a )\)</span>.一切的指数的常规操作在这里都可以照常进行.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明:对于有限集合<span class="math inline">\(G\)</span>和满足结合律的二元运算<span class="math inline">\(\circ\)</span>来说,如果其有左右消去律,那么该二元运算在该集合上构成群.</p>
<p>考虑是有限集合,所以单射<span class="math inline">\(f_a : b
\rightarrow ab\)</span>同时也是满射,这意味着<span class="math inline">\(\forall a , b \in G , xa = b\)</span>和<span class="math inline">\(ay = b\)</span>一定有解,令<span class="math inline">\(b = a\)</span>可以拿到幺元,令<span class="math inline">\(b = e\)</span>可以拿到逆元,自然可以推出其是群.</p>
<h5><span id="example2">Example2</span></h5>
<p>设<span class="math inline">\(G\)</span>是群,且<span class="math inline">\(\exists a , b , aba^{ - 1 } =
b^r\)</span>,求证:<span class="math inline">\(a^i ba^{ - i } = b^{ r^i
}\)</span>.</p>
<p>显然<span class="math inline">\(b^{ rk } = ( b^k )^r = ab^k a^{ - 1
}\)</span>,使用数学归纳,注意到<span class="math inline">\(b^{ r^i } =
ab^{ r^{ i - 1 } } a^{ - 1 } = a^i ba^{ - i }\)</span>.</p>
<h4><span id="子群">子群</span></h4>
<p>设<span class="math inline">\(H\)</span>为群<span class="math inline">\(G\)</span>的非空子集,如果<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>的运算下构成群,则称<span class="math inline">\(H\)</span>为<span class="math inline">\(G\)</span>的<strong>子群</strong>,记作<span class="math inline">\(H \leq G\)</span>.</p>
<p><strong>子群的判定定理</strong>:</p>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H \subseteq G , H \ne
\emptyset\)</span>,下列命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(H \leq G\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in H , ab \in H , a^{
- 1 } \in H\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in H\)</span>,有<span class="math inline">\(ab^{ - 1 } \in H\)</span>.</p></li>
</ol>
<p>显然(1)<span class="math inline">\(\Rightarrow\)</span>(2),(2)<span class="math inline">\(\Rightarrow\)</span>(3),下面证明(3)<span class="math inline">\(\Rightarrow\)</span>(1):</p>
<p>满足(3),有<span class="math inline">\(e = aa^{ - 1 } \in
H\)</span>,于是存在幺元.有<span class="math inline">\(ea^{ - 1 } \in
H\)</span>,于是存在逆元.因为<span class="math inline">\(a ( b^{ - 1 }
)^{ - 1 } = ab \in
H\)</span>,于是对运算封闭.同样的运算显然满足结合律.于是证毕.</p>
<p>如果<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H , K \subseteq
G\)</span>,类似闵可夫斯基和,我们定义<span class="math inline">\(HK = \{
hk \mid h \in H , k \in K \}\)</span>.如果<span class="math inline">\(H
= \{ a \}\)</span>,可以写作<span class="math inline">\(aK\)</span>.类似记<span class="math inline">\(H^{
- 1 } = \{ h^{ - 1 } \mid h \in H \}\)</span>,注意<span class="math inline">\(HH^{ - 1 } \ne \{ e \}\)</span>.</p>
<p>再定义<span class="math inline">\(H^n = \{ h_1 h_2 \cdots h_n \mid
h_1 , h_2 , \cdots , h_n \in H \}\)</span>.</p>
<p>于是子群的判定定理可以改写成:</p>
<p>下列命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(H \leq G\)</span>.</p></li>
<li><p><span class="math inline">\(H^2 \subseteq H \land H^{ - 1 }
\subseteq H\)</span>.</p></li>
<li><p><span class="math inline">\(HH^{ - 1 } \subseteq
H\)</span>.</p></li>
</ol>
<p>显然,任意群<span class="math inline">\(G\)</span>,<span class="math inline">\(G\)</span>和<span class="math inline">\(\{ e
\}\)</span>都是它的子群,我们称为<strong>平凡子群</strong>,如果<span class="math inline">\(H \ne
G\)</span>,称为<strong>真子群</strong>,记作<span class="math inline">\(H
&lt; G\)</span>.</p>
<p>若干个群的交仍然是子群,但是若干个群的并不一定.我们可以证明一下若干个群的交仍然是子群:考虑<span class="math inline">\(h \in A , h \in B , w \in A , w \in
B\)</span>,那么<span class="math inline">\(hw^{ - 1 } \in A \cap
B\)</span>.</p>
<p>设集合<span class="math inline">\(M \subseteq G\)</span>,则称<span class="math inline">\(G\)</span>的所有包含<span class="math inline">\(M\)</span>的子群的交为由<span class="math inline">\(M\)</span><strong>生成的子群</strong>,记作<span class="math inline">\(\langle M \rangle\)</span>.这显然是包含<span class="math inline">\(M\)</span>的最小的子群.</p>
<p>如果<span class="math inline">\(\langle M \rangle =
G\)</span>,则称<span class="math inline">\(M\)</span>是<span class="math inline">\(G\)</span>的一个<strong>生成系</strong>.可由有限多个元素生成的群叫做<strong>有限生成群</strong>,若<span class="math inline">\(\exists M , | M | = 1 , \langle M \rangle =
G\)</span>,则称<span class="math inline">\(G\)</span>是<strong>循环群</strong>.</p>
<p>对于<span class="math inline">\(a \in G\)</span>,我们称<span class="math inline">\(o ( a ) = | \langle a \rangle |\)</span>为<span class="math inline">\(a\)</span>的<strong>阶</strong>,不难发现<span class="math inline">\(o ( a )\)</span>是满足<span class="math inline">\(a^n = e\)</span>的最小的正整数<span class="math inline">\(n\)</span>.如果这样的<span class="math inline">\(n\)</span>不存在,记<span class="math inline">\(o (
a ) = \infty\)</span>.群中所有元素的阶的<span class="math inline">\(lcm\)</span>称作群的<strong>方次数</strong>(如果不存在,则记为<span class="math inline">\(\infty\)</span>),记作<span class="math inline">\(\exp ( G )\)</span>.</p>
<p>另一个不平凡的例子是群<span class="math inline">\(G\)</span>的<strong>中心</strong>定义为<span class="math inline">\(Z_G = \{ z \in G \mid \forall g \in G , zg = gz
\}\)</span>,这显然也是一个子群.</p>
<h5><span id="example1">Example1</span></h5>
<p>证明不存在恰有两个二阶元素的群.</p>
<p>不妨设这两个二阶元素分别为<span class="math inline">\(a \ne b , a , b
\ne e\)</span>,则注意到<span class="math inline">\(aba\)</span>也是一个二阶元素.</p>
<p>如果<span class="math inline">\(aba = a\)</span>,则<span class="math inline">\(ba = e\)</span>,说明<span class="math inline">\(a
= b\)</span>.</p>
<p>如果<span class="math inline">\(aba = b\)</span>,则<span class="math inline">\(ba = ab\)</span>,说明<span class="math inline">\(ab\)</span>是第三个二阶元素.</p>
<p>类似还可以证明如果<span class="math inline">\(\exp ( G ) =
2\)</span>,则<span class="math inline">\(G\)</span>一定是交换群(一定满足<span class="math inline">\(\forall a , b \in G , ab =
ba\)</span>).原因是假设<span class="math inline">\(ab = c\)</span>,<span class="math inline">\(ba = d\)</span>,则<span class="math inline">\(cd =
e\)</span>.</p>
<h5><span id="example2">Example2</span></h5>
<p>对于一个群<span class="math inline">\(G\)</span>,如果<span class="math inline">\(\forall a , b \in G\)</span>,<span class="math inline">\(\exists i \in \mathbb{ N_+ } , ( ab )^i = a^i b^i
, ( ab )^{ i + 1 } = a^{ i + 1 } b^{ i + 1 } , ( ab )^{ i + 2 } = a^{ i
+ 2 } b^{ i + 2 }\)</span>,求证其是交换群.</p>
<p>考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( ab )^{ i + 1 } &amp; = a^{ i + 1 } b^{ i + 1 } = a ( ab )^i b \\
( ab )^i &amp; = a ( ab )^i a^{ - 1 }
\end{aligned}
\]</span></p>
<p>同理有<span class="math inline">\(( ab )^{ i + 1 } = a ( ab )^{ i + 1
} a^{ - 1 }\)</span>.两式合并一下有<span class="math inline">\(a ( ab
)^i a^{ - 1 } ab = a ( ab )^{ i + 1 } a^{ - 1 } \Rightarrow b = aba^{ -
1 }\)</span>.</p>
<h5><span id="example3">Example3</span></h5>
<p>证明若<span class="math inline">\(\exp ( G ) \in \text{ even
}\)</span>,则存在阶为<span class="math inline">\(2\)</span>的元素.</p>
<p>一定存在一个阶为<span class="math inline">\(2 k\)</span>的元素<span class="math inline">\(a\)</span>,显然<span class="math inline">\(o ( a^k
) = 2\)</span>.</p>
<h5><span id="example4">Example4</span></h5>
<p>当<span class="math inline">\(n &gt;
2\)</span>的时候,证明在有限群<span class="math inline">\(G\)</span>中阶为<span class="math inline">\(n\)</span>的元素个数是偶数.</p>
<p>显然构造双射<span class="math inline">\(a \mapsto a^{ n - 1
}\)</span>即可.</p>
<h5><span id="example5">Example5</span></h5>
<p>对于群<span class="math inline">\(G\)</span>,证明<span class="math inline">\(o ( ab ) = o ( ba )\)</span>.</p>
<p>考虑反证,不妨设<span class="math inline">\(o ( ab ) = n &lt; o ( ba )
= m\)</span>.</p>
<p>则<span class="math inline">\(e = ( ba )^m = ( ba )^{ m - n } b ( ab
)^{ n - 1 } a = ( ba )^{ m - n }\)</span>,说明<span class="math inline">\(o ( ba ) \leq m - n &lt; m\)</span>,不符题意.</p>
<h5><span id="example6">Example6</span></h5>
<p>证明:如果<span class="math inline">\(H , K \leq G\)</span>,那么<span class="math inline">\(HK \leq G \Leftrightarrow HK = KH\)</span>.</p>
<p>如果<span class="math inline">\(HK = KH\)</span>,那么<span class="math inline">\(HK \leq G \Leftrightarrow HK ( HK )^{ - 1 } =
HK\)</span>.考虑:</p>
<p><span class="math display">\[
HK ( HK )^{ - 1 } = HKK^{ - 1 } H^{ - 1 } = HKH^{ - 1 } = KHH^{ - 1 } =
HK
\]</span></p>
<p>如果<span class="math inline">\(HK \leq G\)</span>,那么<span class="math inline">\(HK = ( HK )^{ - 1 } = K^{ - 1 } H^{ - 1 } =
KH\)</span>.</p>
<h5><span id="example7">Example7</span></h5>
<p>设<span class="math inline">\(G\)</span>是交换群,证明<span class="math inline">\(G\)</span>中的全体有限阶元素构成<span class="math inline">\(G\)</span>的一个子群.</p>
<p>等价于证明如果<span class="math inline">\(a ,
b\)</span>的阶有限,那么<span class="math inline">\(ab^{ - 1
}\)</span>的阶有限.这对交换群来说是显然的.</p>
<h5><span id="example8">Example8</span></h5>
<p>如果<span class="math inline">\(G\)</span>只有有限多个子群,证明<span class="math inline">\(G\)</span>是有限群.</p>
<p>考虑若其有无限阶元素<span class="math inline">\(a\)</span>,则<span class="math inline">\(\langle a
\rangle\)</span>已经有无限个子群(取幂次为<span class="math inline">\(k\)</span>的倍数).反之则每个元素都可以生成一个循环群,也有无限个子群.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>考虑在两个群<span class="math inline">\(G\)</span>和<span class="math inline">\(G_1\)</span>之间构造映射<span class="math inline">\(\varphi\)</span>,如果<span class="math inline">\(\varphi\)</span>保持群运算,即对于所有的<span class="math inline">\(a , b \in G\)</span>,都有<span class="math inline">\(\varphi ( ab ) = \varphi ( a ) \varphi ( b
)\)</span>,则称其为由<span class="math inline">\(G\)</span>到<span class="math inline">\(G_1\)</span>的一个<strong>群同态</strong>.如果同时<span class="math inline">\(\varphi\)</span>又是单(满)射,则称其为<strong>单(满)同态</strong>,又单又满的同态称为<strong>同构</strong>.如果存在一个映射<span class="math inline">\(\varphi\)</span>,使得<span class="math inline">\(G
, G_1\)</span>同构,则称这两个群<strong>同构</strong>,记作<span class="math inline">\(G \cong G_1\)</span>.</p>
<p>容易见到,同构等价于两方都有<span class="math inline">\(f : G \to
G_1\)</span>和<span class="math inline">\(g : G_1 \to
G\)</span>,并且二者的合成<span class="math inline">\(fg = gf = \text{ id
}\)</span>.而且同构的合成仍是同构.</p>
<p>我们以<span class="math inline">\(End ( G )\)</span>表示<span class="math inline">\(G\)</span>的全体<strong>自同态</strong>组成的集合,<span class="math inline">\(Aut ( G
)\)</span>表示全体<strong>自同构</strong>组成的集合.不难发现,<span class="math inline">\(End ( G )\)</span>组成一个幺半群,而<span class="math inline">\(Aut ( G )\)</span>组成一个群.</p>
<p>我们可以搞一个伴随映射:<span class="math inline">\(G \to Aut ( G ) ,
g \mapsto Ad_g\)</span>,其中<span class="math inline">\(Ad_g ( x ) =
gxg^{ - 1 }\)</span>.容易见到<span class="math inline">\(Ad_g =
id\)</span>的充要条件是<span class="math inline">\(g \in Z ( G
)\)</span>也就是群的中心.</p>
<p>群同态<span class="math inline">\(\varphi : G \rightarrow
G_1\)</span>把<span class="math inline">\(G\)</span>的幺元映为<span class="math inline">\(G_1\)</span>的幺元.原因是:</p>
<p><span class="math display">\[
\varphi ( e )^2 = \varphi ( e^2 ) = \varphi ( e ) e_1
\]</span></p>
<p>然而应当说明,这里保持单位元对幺半群未必成立,因此如果要将群同态的定义挪到幺半群上,需要额外添加<span class="math inline">\(\varphi ( e ) = e_1\)</span>的条件.</p>
<p>我们还有:</p>
<p><span class="math display">\[
e_1 = \varphi ( e ) = \varphi ( aa^{ - 1 } ) = \varphi ( a ) \varphi (
a^{ - 1 } )
\]</span></p>
<p>所以<span class="math inline">\(\varphi ( a^{ - 1 } ) = ( \varphi ( a
) )^{ - 1 }\)</span>.</p>
<p>我们将<span class="math inline">\(\varphi ( G )\)</span>称为<span class="math inline">\(G\)</span>的<strong>像</strong>,记为<span class="math inline">\(\text{ im } \ \varphi\)</span>.又将<span class="math inline">\(e_1\)</span>的原像的集合称为<span class="math inline">\(\varphi\)</span>的<strong>核</strong>,记为<span class="math inline">\(\ker \ \varphi\)</span>.</p>
<p>注意到<span class="math inline">\(\varphi\)</span>不是单射等价于:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \Leftrightarrow \exists a , b \in G , a \ne b , \varphi ( a ) =
\varphi ( b ) \\
&amp; \Leftrightarrow \varphi ( ab^{ - 1 } ) = \varphi ( a ) \varphi ( b
)^{ - 1 } = e_1 \\
&amp; \Leftrightarrow \ker \ \varphi \ne \{ e \}
\end{aligned}
\]</span></p>
<h4><span id="群的实例">群的实例</span></h4>
<h5><span id="全变换群对称群与交错群">全变换群,对称群与交错群</span></h5>
<p>设<span class="math inline">\(M\)</span>是一个非空集合,<span class="math inline">\(M\)</span>到自身的双射的全体对于映射的复合构成一个群,称作<span class="math inline">\(M\)</span>的<strong>全变换群</strong>,记作<span class="math inline">\(S ( M )\)</span>.</p>
<p>设<span class="math inline">\(M\)</span>是含有<span class="math inline">\(n\)</span>个元素的集合,<span class="math inline">\(M\)</span>的全变换群<span class="math inline">\(S
( M )\)</span>称为<strong>n级对称群</strong>,记作<span class="math inline">\(S_n\)</span>.不失一般性,我们可以设<span class="math inline">\(M = \{ 1 , 2 , \cdots , n \}\)</span>,<span class="math inline">\(S_n\)</span>的元素称为<strong>n元置换</strong>,任一置换可以用列表的方法表示,即如果<span class="math inline">\(\sigma\)</span>是一个映射,我们将其写作:</p>
<p><span class="math display">\[
\sigma = \left ( \begin{array}
{ c } 1 &amp; 2 &amp; \cdots &amp; n \\
\sigma_1 &amp; \sigma_2 &amp; \cdots &amp; \sigma_n
\end{array} \right )
\]</span></p>
<p>显然<span class="math inline">\(| S_n | = n !\)</span>.</p>
<p>设<span class="math inline">\(\sigma \in S_n\)</span>,<span class="math inline">\(\{ i_1 , i_2 , \cdots , i_t \} \subseteq \{ 1 , 2
, \cdots , n \}\)</span>,有<span class="math inline">\(\sigma ( i_t ) =
i_1 , \forall 1 \leq k &lt; t , \sigma ( i_k ) = i_{ k + 1
}\)</span>,我们称这样的置换是对于<span class="math inline">\(\{ i_1 ,
i_2 , \cdots , i_t \}\)</span>的<strong>轮换</strong>,记作<span class="math inline">\(\left ( \begin{array}{ c } i_1 &amp; i_2 &amp;
\cdots &amp; i_t\end{array} \right )\)</span>,<span class="math inline">\(t\)</span>为轮换的<strong>长度</strong>,长度为<span class="math inline">\(2\)</span>的轮换称作<strong>对换</strong>.显然,一个置换可以被分解成若干两两无交轮换(注意到如果两个轮换无交,则它们可交换)的乘积.又显然,一个轮换可以被分解成若干对换的乘积,原因是总有:</p>
<p><span class="math display">\[
( a_1 , \cdots , a_l ) = ( a_1 , a_l ) ( a_1 , \cdots , a_{ l - 1 } )
\]</span></p>
<p>另外轮换的性质给出任何一个置换<span class="math inline">\(\sigma\)</span>的<span class="math inline">\(o (
\sigma )\)</span>就是其拆出的所有轮换的<span class="math inline">\(\text{ lcm }\)</span>.</p>
<p>根据逆序对相关,我们知道一个置换的逆序对数量的奇偶性等于其分解成的对换的数量.我们将逆序对数量是奇数的置换称为<strong>奇置换</strong>,是偶数的称之为<strong>偶置换</strong>,<span class="math inline">\(S_n\)</span>中的所有偶置换也构成一个群,称之为<strong>n级交错群</strong>,记为<span class="math inline">\(A_n\)</span>.<span class="math inline">\(A_n\)</span>实际上是<span class="math inline">\(S_n\)</span>的一个子群.</p>
<h5><span id="一般线性群">一般线性群</span></h5>
<p>对于定义在域<span class="math inline">\(F\)</span>上的线性空间<span class="math inline">\(V\)</span>,它上面的所有自同构构成一个<strong>一般线性群</strong><span class="math inline">\(GL ( V ) = \{ T \in \text{ End } ( V ) \mid \det T
\ne 0 \}\)</span>.特别地,当<span class="math inline">\(\dim V &lt;
\infty\)</span>的时候,其有一个子群<strong>特殊线性群</strong><span class="math inline">\(SL ( V ) = \{ T \in \text{ End } ( V ) \mid \det T
= 1 \}\)</span>.</p>
<p>在配套的内积空间上还可以把正交变换组成的群一块拿到,称为<strong>正交群</strong>或者<strong>酉群</strong><span class="math inline">\(O ( V )\)</span>,还可以定义<span class="math inline">\(SO ( V ) = O ( V ) \cap SL ( V )\)</span>.</p>
<p>当然上面的版本都可以用矩阵来表示,这里略去不表.然而对于矩阵来代替上面的情形,我们疑似需要引入群同构的概念,这会在下面提出.</p>
<h5><span id="克莱因四元群">克莱因四元群</span></h5>
<p>取<span class="math inline">\(V = \{ \text{ id } , \sigma , \tau ,
\sigma \tau \}\)</span>,其中:</p>
$$
<span class="math display">\[\begin{aligned}
\sigma &amp; = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
2 &amp; 1 &amp; 4 &amp; 3
\end{matrix} \right ) \\
\tau &amp; = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
3 &amp; 4 &amp; 1 &amp; 2
\end{matrix} \right ) \\
\sigma \tau &amp; = \tau \sigma = \left ( \begin{matrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
4 &amp; 3 &amp; 2 &amp; 1
\end{matrix} \right ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>见到这确实是一个群,而且任何一个元素的逆元都是它本身,而且两个不同的非<span class="math inline">\(1\)</span>元的乘积会得到另一个非<span class="math inline">\(1\)</span>元.</p>
<p>克莱因群的实例非常多,例如<span class="math inline">\(\{ 1 , 3 , 5 , 7
\}\)</span>在<span class="math inline">\(\mod
8\)</span>意义下对乘法构成克莱因群,<span class="math inline">\(\{ 0 , 1
, 2 , 3 \}\)</span>对异或构成克莱因群.以及:</p>
<p><span class="math display">\[
\left \{ \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} , \begin{bmatrix}
1 &amp; 0 \\
0 &amp; - 1
\end{bmatrix} , \begin{bmatrix}
- 1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} , \begin{bmatrix}
- 1 &amp; 0 \\
0 &amp; - 1
\end{bmatrix} \right \}
\]</span></p>
<p>对矩阵乘法也构成群.</p>
<h5><span id="循环群">循环群</span></h5>
<p>如果对于一个群<span class="math inline">\(G\)</span>,它可以由其中的某个元素<span class="math inline">\(\sigma\)</span>生成,记作<span class="math inline">\(G = \langle \sigma \rangle\)</span>,当<span class="math inline">\(\forall g \in G , \exists k \in \mathbb{ Z } , g =
\sigma^k\)</span>.</p>
<p>显然<span class="math inline">\(\mathbb{ Z } / n \mathbb{ Z
}\)</span>对加法就是一个循环群,其中<span class="math inline">\(\sigma =
1 + n \mathbb{ Z }\)</span>.</p>
<p>特别地,容易见到对于任意循环群,如果<span class="math inline">\(| G | =
\infty\)</span>,则<span class="math inline">\(G \cong \mathbb{ Z
}\)</span>;反之则<span class="math inline">\(G \cong \mathbb{ Z } / | G
| \mathbb{ Z }\)</span>.</p>
<h4><span id="相反群">相反群</span></h4>
<p>群中的左右区别如此之大,是否说对于任何一个左的版本都存在一个与之对应的右的版本呢?</p>
<p>留神到我们其实可以定义<strong>相反群</strong><span class="math inline">\(G^{ op } = ( G , \odot
)\)</span>,其中的运算满足<span class="math inline">\(g \odot g &#39; = g
&#39; g\)</span>,也就是在<span class="math inline">\(G\)</span>中使得乘法倒置.容易检验其保留了幺元和逆元等性质,而且<span class="math inline">\(( G^{ op } )^{ op } = G\)</span>.另外只需观察<span class="math inline">\(G \to G^{ op } , g \mapsto g^{ - 1
}\)</span>就可构造双射.有时干脆将相反群记作<span class="math inline">\(G^{ - 1 }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:群<span class="math inline">\(G\)</span>是交换群当且仅当<span class="math inline">\(x \mapsto x^{ - 1 }\)</span>是群同构.</p>
<p>显然是单射且是双射,只需证明是群同态即可.此时就需要证明<span class="math inline">\(y^{ - 1 } x^{ - 1 } = ( xy )^{ - 1 } = ( yx )^{ -
1 }\)</span>,那就搞定了.</p>
<h4><span id="陪集">陪集</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个群,<span class="math inline">\(H \leq G\)</span>,定义等价关系<span class="math inline">\(a \sim b \Leftrightarrow \exists h \in H , a =
bh\)</span>,容易检查其满足等价类的三条性质.不难发现对于元素<span class="math inline">\(a\)</span>,其所在的等价类就是<span class="math inline">\(aH\)</span>.类似可以定义<span class="math inline">\(Ha\)</span>.我们定义形如<span class="math inline">\(aH\)</span>的子集为<span class="math inline">\(H\)</span>的一个<strong>右陪集</strong>,形如<span class="math inline">\(Ha\)</span>的称作<strong>左陪集</strong>.由于左陪集是一个等价类,因此会将原集合划分为若干个等价类.这种划分用商集刻画,记作<span class="math inline">\(G /
H\)</span>.需要强调的是这个符号需要区分左右,有的人会盗用反斜杠来表述此关系,但这种符号容易与差集相混淆.因此,我们在下面会直接不加区分(或者说根据上下文判断)来一律统一使用<span class="math inline">\(G / H\)</span>.如若的确需要区分,则采用<span class="math inline">\(( G / H )_L , ( G / H )_R\)</span>的写法.</p>
<p>一个自然的想法是<span class="math inline">\(G /
H\)</span>是否构成一个群.先看取逆,容易发现<span class="math inline">\((
aH )^{ - 1 } = Ha^{ - 1
}\)</span>,这给出左陪集和右陪集之间一个自然的同构:</p>
<p><span class="math display">\[
Hg \mapsto g^{ - 1 } H = ( Hg )^{ - 1 }
\]</span></p>
<p>所以不同的左右陪集个数相等.</p>
<p>我们将<span class="math inline">\(H\)</span>的不同左陪集的个数(不一定有限)称为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的<strong>指数</strong>,记为<span class="math inline">\(| G : H |\)</span>,用消去律注意到<span class="math inline">\(| H | = | aH | = | Ha
|\)</span>,因此其实右陪集个数也是这个指数.既然是等价类,就完成了对原群的一个划分,而且容易见到每个划出的等价类大小都是<span class="math inline">\(| H |\)</span>.</p>
<p>对于有限群,这引出重要的<strong>拉格朗日定理</strong>:</p>
<p><span class="math display">\[
| G | = | G : H | \times | H |
\]</span></p>
<p>对于每一个陪集<span class="math inline">\(C \in G /
H\)</span>,我们可以选定其一个代表元<span class="math inline">\(x_c\)</span>使得<span class="math inline">\(x_C H
= C\)</span>.考虑映射<span class="math inline">\(H \times ( G / H ) \to
G , ( h , C ) \mapsto x_C h\)</span>.下面证明这的确是个同构.</p>
<p>由于这里在映射前就钦定了代表元(需要使用选择公理),所以无需验证良定性.</p>
<p>接下来检查其单射,由于<span class="math inline">\(x_C h \in
C\)</span>,所以如果<span class="math inline">\(x_{ C &#39; } h &#39; =
x_C h\)</span>,意味着<span class="math inline">\(C &#39; \cap C \ne
\emptyset\)</span>,这是不符合的,因为陪集肯定两两不交.</p>
<p>而满射性只需要找到自己所在的那个等价类即可.</p>
<p>该定理有以下推论(以下默认有限群):</p>
<ol type="1">
<li><p>任何一个子群的大小都一定整除原群大小.</p></li>
<li><p>若<span class="math inline">\(H , K \subseteq
G\)</span>,如果<span class="math inline">\(| H | , | K
|\)</span>的大小互素,则<span class="math inline">\(H \cap K = \{ 1
\}\)</span></p></li>
<li><p><span class="math inline">\(\forall \sigma \in G , o ( \sigma )
\mid ( | G | )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall \sigma \in G , \sigma^{ | G |
} = e\)</span>.</p></li>
<li><p>如果<span class="math inline">\(p = | G | \in \mathrm{ prime
}\)</span>,则<span class="math inline">\(G\)</span>是一个循环群.</p></li>
<li><p><span class="math inline">\(K \leq H \leq G\)</span>,则<span class="math inline">\([ G : K ] = [ G : H ] \times [ H : K
]\)</span>.</p></li>
</ol>
<p>(1)显然.</p>
<p>(2)的原因是<span class="math inline">\(H \cap
K\)</span>一定是一个子群,则它的大小要整除<span class="math inline">\(\gcd ( | H | , | K | ) = 1\)</span>.</p>
<p>(3)是因为<span class="math inline">\(\langle \sigma \rangle \leq
G\)</span>,而<span class="math inline">\(o ( \sigma ) = | \langle \sigma
\rangle |\)</span>.</p>
<p>(4)根据(3)显然.这其实就是费马小定理和欧拉定理在群上的体现.</p>
<p>(5)是因为任取一个<span class="math inline">\(\sigma \ne
1\)</span>,则<span class="math inline">\(1 \ne o ( \sigma ) |
p\)</span>,所以<span class="math inline">\(o ( \sigma ) =
p\)</span>,这是循环群.</p>
<p>(6)的话仍是取代表元,不妨设<span class="math inline">\(C \in G /
H\)</span>的代表元是<span class="math inline">\(x_C\)</span>,<span class="math inline">\(D \in H / K\)</span>的代表元是<span class="math inline">\(y_D\)</span>.则<span class="math inline">\(G =
\bigsqcup x_C H = \bigsqcup x_C y_D
K\)</span>,容易检验两边是一一对应的.它的另一个证明策略是取道第一同构定理.</p>
<h4><span id="群作用">群作用</span></h4>
<p>我们早应看出群往往是由一类双射组成的集合,而并非应该将其看作单一运算的环.因此,考虑群在一个集合上的作用是很有意义的.</p>
<p>我们称群<span class="math inline">\(G\)</span>的一个<strong>左作用</strong>是<span class="math inline">\(\varphi : G \times X \to X\)</span>,使得:</p>
<ol type="1">
<li><p><span class="math inline">\(\varphi ( 1_G , x ) =
x\)</span>.</p></li>
<li><p><span class="math inline">\(\varphi ( g , \varphi ( h , x ) ) =
\varphi ( gh , x )\)</span>.</p></li>
</ol>
<p>这种作用看似隔了一层,只是多引入了符号,而并非将<span class="math inline">\(G\)</span>与<span class="math inline">\(X\)</span>直接联系起来.然而回忆到柯里化过程,上述作用也等价于<span class="math inline">\(G \to ( X \to X )\)</span>,设这个映射是<span class="math inline">\(\Phi : G \to \mathrm{ End } ( X
)\)</span>,容易见到上面两条性质等价于:</p>
<ol type="1">
<li><p><span class="math inline">\(\Phi ( 1_G ) = \text{ id
}_X\)</span>.</p></li>
<li><p><span class="math inline">\(\Phi ( g_1 g_2 ) = \Phi ( g_1 ) \Phi
( g_2 )\)</span>.</p></li>
</ol>
<p>容易见到<span class="math inline">\(\Phi\)</span>是群同态.</p>
<p>当然同理可以定义<strong>右作用</strong>.</p>
<p>对于左作用,我们定义<span class="math inline">\(x\)</span>的<span class="math inline">\(G\)</span><strong>轨道</strong>是<span class="math inline">\(Gx = \{ gx | g \in G \} \subseteq
X\)</span>.我们还可以定义其<strong>稳定化子群</strong>是<span class="math inline">\(\mathrm{ Stab }_G ( x ) = \{ g \in G | gx = x
\}\)</span>,容易检验这的确是一个子群,原因是封闭性和逆存在都满足,而且还满足<span class="math inline">\(\mathrm{ Stab }_G ( gx ) = g \mathrm{ Stab }_G ( x
) g^{ - 1 }\)</span>.因此一个轨道中的点的稳定化子群大小相等.</p>
<p>定义<span class="math inline">\(X\)</span>的<span class="math inline">\(G\)</span><strong>不动点</strong>是<span class="math inline">\(X^G = \{ x \in X | \forall g \in G , gx = x
\}\)</span>,容易见到<span class="math inline">\(X^G\)</span>中的每一个点都自己构成一个轨道,还可以对单个<span class="math inline">\(g\)</span>定义不动点集合<span class="math inline">\(X^g = \{ x \in X | gx = x \}\)</span>.对于<span class="math inline">\(\forall g \in G\)</span>.还可以引入以下定义:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\forall x \in X , gx =
x\)</span>当且仅当<span class="math inline">\(g = 1_G\)</span>,或说<span class="math inline">\(\bigcap_{ x \in X } \mathrm{ Stab }_{ G } ( x ) =
\{ 1_G
\}\)</span>,则称这个作用是<strong>忠实的</strong>.此时还会满足<span class="math inline">\(\Phi ( g ) = id_X \Leftrightarrow g =
1_G\)</span>,也就是上述柯里化是单射.</p></li>
<li><p>若<span class="math inline">\(X\)</span>只有一个轨道,换言之<span class="math inline">\(\forall x , y \in X , \exists g \in G , y =
gx\)</span>.则称此群作用<strong>传递</strong>.</p></li>
<li><p>若<span class="math inline">\(\forall x \in X\)</span>,<span class="math inline">\(\mathrm{ Stab }_G ( x ) ={ 1_G
}\)</span>,则称此群作用<strong>自由</strong>.自由性严格强于忠实性.</p></li>
</ol>
<p>对于<span class="math inline">\(x , y \in
X\)</span>,我们定义等价关系<span class="math inline">\(x \sim
y\)</span>当且仅当<span class="math inline">\(y \in
Gx\)</span>.容易见到其满足传递性,自反性,对称性.在此等价关系下的商集也就是分解出的所有轨道,称此为轨道分解,或者盗用陪集符号写作<span class="math inline">\(X / G\)</span>.</p>
<h5><span id="cayley定理">Cayley定理</span></h5>
<p>由上面可以见到,任何一个<span class="math inline">\(G\)</span>都可以用柯里化表为一个集合上的变换.并且如果群作用是忠实的,那么这种表示事实上总是单射.然而<span class="math inline">\(G\)</span>作用于自己本身的时候因为消去律一定能导出自由性.这自然是一个置换.</p>
<p>Cayley定理的一个很重要的作用是理解轨道分解.我们早就用图论手段理解过置换可以拆解成轮换的性质.如今我们可以用群论的手段去理解.对于任何一个置换<span class="math inline">\(\sigma\)</span>,考虑其作用在<span class="math inline">\(X = \{ 1 , \cdots , n
\}\)</span>上.考虑取一个循环群<span class="math inline">\(G = \langle
\sigma \rangle\)</span>,<span class="math inline">\(G\)</span>作用在<span class="math inline">\(X\)</span>上给出了<span class="math inline">\(X\)</span>的一个轨道分解.容易见到这里的轨道分解就是给出了若干个轮换.由轨道分解的唯一性,立刻见到轮换分解的唯一性.</p>
<h5><span id="burnside引理">Burnside引理</span></h5>
<p>下面选定<span class="math inline">\(x \in X\)</span>考虑映射<span class="math inline">\(G \to Gx , g \mapsto gx\)</span>.考虑取<span class="math inline">\(H = \text{ Stab }_G ( x )\)</span>,现在考虑有:</p>
$$
<span class="math display">\[\begin{aligned}
gx &amp; = g &#39; x \\
&amp; \Leftrightarrow g^{ - 1 } g &#39; x = x \\
&amp; \Leftrightarrow g^{ - 1 } g &#39; \in H \\
&amp; \Leftrightarrow g &#39; \in gH \\
&amp; \Leftrightarrow g &#39; H = gH \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以我们可以搞一个同构映射<span class="math inline">\(G / H \to
Gx\)</span>.注意这里未必是群同构,原因是<span class="math inline">\(H\)</span>未必是正规子群,但<span class="math inline">\(G /
H\)</span>这个右陪集总可以定义.对于有限集合的情况,回忆到<span class="math inline">\(X\)</span>可以进行轨道分解,设其不同的轨道分别是<span class="math inline">\(Gx_1 , \cdots , Gx_m\)</span>(回忆到<span class="math inline">\(m = | X / G
|\)</span>),并且对应的稳定化子群分别是<span class="math inline">\(H_1 ,
\cdots , H_m\)</span>,上述命题给出:</p>
<p><span class="math display">\[
| X | = \sum | Gx_k | = \sum [ G : H_k ]
\]</span></p>
<p>另一个结论是<span class="math inline">\(| X / G | \cdot | G | =
\sum_{ g \in G } | X^g |\)</span>,这个结论是染色计数的基础.</p>
<p>为了证明上面这个结论,我们下面证明把<span class="math inline">\(X\)</span>分解为若干轨道后,对于每个轨道<span class="math inline">\(X_i\)</span>都有<span class="math inline">\(\sum_{
g \in G } | X_i^g | = | G
|\)</span>,由于轨道之间互不干扰,下面只需证明<span class="math inline">\(X\)</span>是传递性的单个轨道的情况即可,回忆到单个轨道上的稳定化子群大小均相等,任取<span class="math inline">\(x_0 \in
X\)</span>,由于此时只着眼于单个轨道,因此根据上述结论<span class="math inline">\(| X | = [ G : \mathrm{ Stab }_G ( x_0 )
]\)</span>.此时:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ g \in G } | X^g | &amp; = \sum_{ x \in X } | \mathrm{ Stab }_G (
x ) | \\
&amp; = | X | \cdot | \mathrm{ Stab }_G ( x_0 ) | \\
&amp; = [ G : \mathrm{ Stab }_G ( x_0 ) ] \cdot | \mathrm{ Stab }_G (
x_0 ) | \\
&amp; = | G |
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<h5><span id="p-群"><span class="math inline">\(p\)</span>-群</span></h5>
<p>设<span class="math inline">\(p \in \mathrm{ prime
}\)</span>,如果<span class="math inline">\(| G | = p^m\)</span>(当<span class="math inline">\(m = 0\)</span>的时候称其平凡),则称<span class="math inline">\(G\)</span>为<span class="math inline">\(p\)</span>-<strong>群</strong>.对此我们有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(| X | \equiv | X^G | \pmod{ p
}\)</span>.</p></li>
<li><p>如果<span class="math inline">\(| G |\)</span>非平凡,则<span class="math inline">\(Z_G \ne \{ 1 \}\)</span>.进一步地,<span class="math inline">\(p \mid ( | Z_G | )\)</span>.</p></li>
</ol>
<p>(1)的原因是轨道分解给出:</p>
<p><span class="math display">\[
| X | = | X^G | + \sum_{ H_i \ne G } [ G : H_i ]
\]</span></p>
<p>然而拉格朗日定理给出<span class="math inline">\(| H_i
|\)</span>总是<span class="math inline">\(| G
|\)</span>的因子,也就是说<span class="math inline">\(\frac{ | G | }{ |
H_i | } = p^k\)</span>,于是证毕.</p>
<p>(2)的证明,考虑映射<span class="math inline">\(a : G \times G \to G :
a ( g , x ) = Ad_g ( x ) = gxg^{ - 1 }\)</span>,这本身是<span class="math inline">\(G\)</span>对自身的一个左作用.而容易见到此作用下的不动点集就是<span class="math inline">\(Z_G\)</span>.而<span class="math inline">\(| Z_G |
\equiv | G | \equiv 0 \pmod{ p }\)</span>,于是证毕.</p>
<p>我们知道轨道分解事实上给出了一种划分集合的策略,而这里的映射其实也给出了一种划分集合的策略:按<strong>共轭类</strong>划分.换言之,我们设<span class="math inline">\(a \sim b\)</span>当且仅当<span class="math inline">\(\exists g \in G , a = gbg^{ - 1
}\)</span>,容易见到其满足等价关系的三条性质.因此我们得到一个共轭类的大小总是整除群的大小,以及:</p>
<p><span class="math display">\[
| G | = | Z_G | + \sum_{ H_i \ne G } [ G : H_i ]
\]</span></p>
<p>这个被称为<strong>类方程</strong>.</p>
<h6><span id="example1">Example1</span></h6>
<p>求证:阶为<span class="math inline">\(p^2\)</span>的有限群都是交换的.</p>
<p>考虑其中心<span class="math inline">\(Z_G\)</span>,由于该群非平凡,所以<span class="math inline">\(| Z_G | &gt; 1\)</span>,所以<span class="math inline">\(| Z_G | = p\)</span>或<span class="math inline">\(| Z_G | = p^2\)</span>,后者显然已经证毕.</p>
<p>如果能取出一个元素<span class="math inline">\(c\)</span>使得<span class="math inline">\(\langle c \rangle =
G\)</span>则显然证毕,下面假设所有的非平凡循环子群的阶都是<span class="math inline">\(p\)</span>.</p>
<p>取<span class="math inline">\(a \in Z_G , a \ne 1\)</span>,则<span class="math inline">\(Z_G = \langle a \rangle\)</span>.任取<span class="math inline">\(b \in G \setminus Z_G\)</span>,考虑<span class="math inline">\(\langle b \rangle \cap Z_G = \{ 1
\}\)</span>,原因是如果<span class="math inline">\(\exists i , j , a^i =
b^j\)</span>,则取<span class="math inline">\(j\)</span>在<span class="math inline">\(\bmod p\)</span>下的逆元<span class="math inline">\(k\)</span>,有<span class="math inline">\(a^{ ik }
= b\)</span>,这就不符.</p>
<p>于是有<span class="math inline">\(G / Z_G \cong \langle b
\rangle\)</span>,立刻证毕.</p>
<h4><span id="正规子群">正规子群</span></h4>
<p>设<span class="math inline">\(G\)</span>是一个群,<span class="math inline">\(H \leq G\)</span>,如果<span class="math inline">\(\forall a \in G , aH =
Ha\)</span>或回忆到商群的概念只需检验<span class="math inline">\(a^{ - 1
} Ha \subseteq H\)</span>,我们称<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的<strong>正规子群</strong>,记作<span class="math inline">\(H \trianglelefteq
G\)</span>.当一个子群是正规的时候,它的左右陪集不必区分.</p>
<p>显然,<span class="math inline">\(G\)</span>和<span class="math inline">\(\{ e \}\)</span>都是<span class="math inline">\(G\)</span>的正规子群,如果<span class="math inline">\(G\)</span>除此之外没有别的正规子群,称其为<strong>单群</strong>.</p>
<p>容易发现<span class="math inline">\(Z_G \trianglelefteq
G\)</span>.此外,如果<span class="math inline">\(N \trianglelefteq
G\)</span>,而且<span class="math inline">\(H \leq G\)</span>,则<span class="math inline">\(N \cap H \trianglelefteq
H\)</span>,只需套用定义即可发现.</p>
<p>于此还可以引入两个定义,假设<span class="math inline">\(K \leq
G\)</span>:</p>
<ol type="1">
<li><p>定义<span class="math inline">\(K\)</span>的<strong>中心化子</strong>:<span class="math inline">\(Z_G ( K ) = \{ g \in G | \forall k \in K , gkg^{ -
1 } = k \}\)</span>.</p></li>
<li><p>定义<span class="math inline">\(K\)</span>的<strong>正规化子</strong>:<span class="math inline">\(N_G ( K ) = \{ g \in G | gKg^{ - 1 } = K
\}\)</span>.</p></li>
</ol>
<p>显然<span class="math inline">\(K \trianglelefteq N_G ( K ) \geq Z_G
( K )\)</span>.</p>
<h5><span id="正规子群的判定定理">正规子群的判定定理</span></h5>
<p>当<span class="math inline">\(H \leq G\)</span>时,下列命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(H \trianglelefteq
G\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in G , \exists c \in G
, ( aH ) ( bH ) = cH\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a \in G , a^{ - 1 } Ha =
H\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a \in G , h \in H , a^{ - 1 }
ha \in H\)</span>.</p></li>
</ol>
<p>先证明(2)<span class="math inline">\(\Rightarrow\)</span>(1):</p>
<p>由于<span class="math inline">\(a^2 H \subseteq ( aH
)^2\)</span>,<span class="math inline">\(a^2 \subseteq ( aH
)^2\)</span>并且<span class="math inline">\(( aH )^2 =
cH\)</span>是左陪集,那么由于左陪集是等价类,所以<span class="math inline">\(a^2 H = ( aH )^2\)</span>.两边同时乘以<span class="math inline">\(a^{ - 1 }\)</span>,有<span class="math inline">\(Ha \subseteq HaH =
aH\)</span>.再次两边左右乘以<span class="math inline">\(a^{ - 1
}\)</span>,得到<span class="math inline">\(a^{ - 1 } H \subseteq Ha^{ -
1 } , \forall a \in G\)</span>,也就证毕.</p>
<p>再证明(1)<span class="math inline">\(\Rightarrow\)</span>(2):</p>
<p><span class="math display">\[
( aH ) ( bH ) = aHbH = a ( bH ) H = abH
\]</span></p>
<p>这里还可以进一步说明如果这里干脆在正规子群的陪集上定义二元运算<span class="math inline">\(( aH , bH ) \to
abH\)</span>后其陪集构成群.首先我们要检验良定性质.注意到如果<span class="math inline">\(a &#39; = au , b &#39; = bv\)</span>,其中<span class="math inline">\(u , v \in H\)</span>,则:</p>
<p><span class="math display">\[
a &#39; b &#39; H = aubvH = abb^{ - 1 } ubvH = abH
\]</span></p>
<p>原因是<span class="math inline">\(b^{ - 1 } ub \in H , v \in
H\)</span>.</p>
<p>逆元只需要对<span class="math inline">\(( aH )^{ - 1 } = a^{ - 1 }
H\)</span>即可.至于结合律也可以用上述性质转化,这样就搞定了.</p>
<p>剩下的部分,(1)<span class="math inline">\(\Leftrightarrow\)</span>(3),(3)<span class="math inline">\(\Rightarrow\)</span>(4)都显然,考虑证明(4)<span class="math inline">\(\Rightarrow\)</span>(3).</p>
<p>(4)显然等价于<span class="math inline">\(ha \in
aH\)</span>,于是有<span class="math inline">\(Ha \subseteq
aH\)</span>.而又等价于<span class="math inline">\(a^{ - 1 } h \in Ha^{ -
1 }\)</span>,于是类似证毕.</p>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H \trianglelefteq G\)</span>,则<span class="math inline">\(H\)</span>的陪集在乘法下构成群,这个群称为<span class="math inline">\(G\)</span>关于<span class="math inline">\(H\)</span>的<strong>商群</strong>,记作<span class="math inline">\(G / H\)</span>.</p>
<p>考虑封闭律:<span class="math inline">\(( aH ) ( bH ) = a ( bH ) H =
abH\)</span>,又显然满足结合律.又有<span class="math inline">\(\forall aH
\in G / H , eH ( aH ) = ( aH ) H = aH\)</span>,于是<span class="math inline">\(H\)</span>是幺元.同样知道<span class="math inline">\(a^{ - 1 } H = ( aH )^{ - 1
}\)</span>,于是存在逆元.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明:如果<span class="math inline">\([ G : H ] =
2\)</span>的话则一定有<span class="math inline">\(H \trianglelefteq
G\)</span>.</p>
<p>原因是其可以分解成两个陪集,而其中一个陪集自动是<span class="math inline">\(H\)</span>本身,所以另一个陪集也同样不分左右.</p>
<h6><span id="example2">Example2</span></h6>
<p>求证:如果<span class="math inline">\(G / Z_G\)</span>是循环群,则<span class="math inline">\(G\)</span>交换.</p>
<p>不妨假设<span class="math inline">\(G / Z_G = \{ Z_G , aZ_G , a^2 Z_G
, \cdots \}\)</span>.</p>
<p>对于任意<span class="math inline">\(b , c \in
G\)</span>,都存在一组<span class="math inline">\(i , j , g_1 ,
g_2\)</span>满足<span class="math inline">\(i , j \in \mathbb{ Z
}\)</span>,<span class="math inline">\(g_1 , g_2 \in Z_G\)</span>有<span class="math inline">\(b = a^i g_1 , c = a^j g_2\)</span>,显然<span class="math inline">\(bc = cb\)</span>.</p>
<h5><span id="正规子群与同态">正规子群与同态</span></h5>
<p>事实上有以下命题:</p>
<ol type="1">
<li><p><span class="math inline">\(\text{ im } \ \varphi \leq
G_1\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ ker } \ \varphi
\trianglelefteq G\)</span>.</p></li>
</ol>
<p>先看(1),考虑首先<span class="math inline">\(e_1 \in \text{ im } \
\varphi\)</span>,所以其不为空.其次对于任意<span class="math inline">\(a_1 , b_1 \in \text{ im } \ \varphi\)</span>,<span class="math inline">\(\exists a , b \in G\)</span>,使得<span class="math inline">\(\varphi ( a ) = a_1 , \varphi ( b ) =
b_1\)</span>.于是:</p>
<p><span class="math display">\[
a_1 b_1^{ - 1 } = \varphi ( a ) \varphi ( b^{ - 1 } ) = \varphi ( ab^{ -
1 } ) \in \text{ im } \ \varphi
\]</span></p>
<p>再看(2),同上可知<span class="math inline">\(\text{ ker } \ \varphi
\ne \emptyset\)</span>,对于任意的<span class="math inline">\(a , b \in
\text{ ker } \ \varphi\)</span>,<span class="math inline">\(\varphi (
ab^{ - 1 } ) = \varphi ( a ) \varphi ( b )^{ - 1 } =
e_1\)</span>,所以<span class="math inline">\(ab^{ - 1 } \in \text{ ker }
\ \varphi\)</span>,说明<span class="math inline">\(\text{ ker } \
\varphi \leq G\)</span>.而<span class="math inline">\(\forall g \in
G\)</span>,<span class="math inline">\(\varphi ( gag^{ - 1 } ) = \varphi
( g ) e_1 \varphi ( g )^{ - 1 } = e_1\)</span>,所以<span class="math inline">\(gag^{ - 1 } \in \text{ ker } \
\varphi\)</span>.</p>
<p>我们也可以说正规子群均可以成为某个映射的<span class="math inline">\(\ker\)</span>,方法是构造映射<span class="math inline">\(\pi : G \to G / N , g \mapsto
gN\)</span>.容易检验这的确是一个群同态.</p>
<p>另外如果<span class="math inline">\(f\)</span>是同构,那么<span class="math inline">\(f^{ - 1 }\)</span>也是同态,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
f ( f^{ - 1 } ( x ) f^{ - 1 } ( y ) ) &amp; = f ( f^{ - 1 } ( x ) ) f (
f^{ - 1 } ( y ) ) = xy = f ( f^{ - 1 } ( xy ) ) \\
f^{ - 1 } ( x ) f^{ - 1 } ( y ) &amp; = f^{ - 1 } ( xy )
\end{aligned}
\]</span></p>
<p>以及如果<span class="math inline">\(f , g\)</span>都是同态,那么<span class="math inline">\(f \circ g\)</span>也是同态.</p>
<p>更进一步地,我们实际上可以在这里画交换图表,对于任何一个群同态<span class="math inline">\(f : G \to G &#39;\)</span>,取<span class="math inline">\(\pi : G \to G / \ker
f\)</span>,我们存在唯一的<span class="math inline">\(\bar{ f
}\)</span>使得<span class="math inline">\(f = \bar{ f } \circ
\pi\)</span>,或言使得下述交换图表成立:</p>
<p><span class="math display">\[
\xymatrix{ G \ar[r]^f \ar[d]_\pi &amp; G &#39; \\
G / \ker f \ar[ru]_{ \bar{ f } } &amp; \\
}
\]</span></p>
<p>这被称为商群的泛性质.事实上这也很一眼,原因是要满足<span class="math inline">\(\forall x \in G , \bar{ f } ( xN ) = f ( x
)\)</span>,这其实也就定义了<span class="math inline">\(\bar{ f
}\)</span>,而存在性只需要堆堆语言就行.</p>
<p>进一步地,如果<span class="math inline">\(f : G \to G
&#39;\)</span>,而<span class="math inline">\(N \trianglelefteq G , N
&#39; \trianglelefteq G &#39;\)</span>,并且<span class="math inline">\(f
( N ) \subseteq N &#39;\)</span>,则存在唯一的映射<span class="math inline">\(\bar{ f } : G / N \to G &#39; / N
&#39;\)</span>使得我们可以搞定下面这个图表的交换性:</p>
<p><span class="math display">\[
\xymatrix{ G \ar[r]^f \ar[d] &amp; G &#39; \ar[d] \\
G / N \ar[r]_{ \bar{ f } } &amp; G &#39; / N &#39; }
\]</span></p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>设<span class="math inline">\(\varphi : G \rightarrow
G_1\)</span>是群同态,则<span class="math inline">\(G / \text{ ker } \
\varphi \cong \text{ im } \ \varphi\)</span>.</p>
<p>不妨先设<span class="math inline">\(H = \text{ ker } \
\varphi\)</span>.我们定义映射<span class="math inline">\(\psi : G / H
\rightarrow \text{ im } \ \varphi\)</span>,满足<span class="math inline">\(\psi ( aH ) = \varphi ( a )\)</span>.</p>
<p>不过首先要判断<span class="math inline">\(\psi\)</span>是不是良定义,也就是当<span class="math inline">\(aH = bH\)</span>的时候,我们要判断<span class="math inline">\(\varphi ( a )\)</span>是否等于<span class="math inline">\(\varphi ( b )\)</span>.若<span class="math inline">\(aH = bH\)</span>,说明<span class="math inline">\(\exists h \in H , a = bh\)</span>,那么<span class="math inline">\(\psi ( aH ) = \varphi ( a ) = \varphi ( bh ) =
\varphi ( b ) \varphi ( h ) = \varphi ( b )\)</span>.</p>
<p>然后还要证明其是群同态,注意到<span class="math inline">\(\psi ( ( aH
) ( bH ) ) = \psi ( abH ) = \varphi ( ab ) = \varphi ( a ) \varphi ( b )
= \psi ( aH ) \psi ( bH )\)</span>.</p>
<p>接下来要证明它是单射,显然只有<span class="math inline">\(\psi ( H ) =
e_1\)</span>,<span class="math inline">\(\text{ ker } \ \psi = \{ H
\}\)</span>.</p>
<p>接下来要证明它是满射,<span class="math inline">\(\forall g \in \text{
im } \ \varphi\)</span>,<span class="math inline">\(\exists a , \varphi
( a ) = g\)</span>,则<span class="math inline">\(\psi ( aH ) =
g\)</span>.</p>
<p>这样就证明了同态基本定理.</p>
<p>当<span class="math inline">\(\varphi\)</span>是满射的时候<span class="math inline">\(G_1 = \text{ im } \
\varphi\)</span>,所以此时有<span class="math inline">\(G / \text{ ker }
\ \varphi \cong G_1\)</span>.</p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>我们定义<span class="math inline">\(H \trianglelefteq
G\)</span>时,定义<span class="math inline">\(\pi : G \rightarrow G / H ,
a \mapsto aH\)</span>.显然其是群同态,定义其为由<span class="math inline">\(G\)</span>到<span class="math inline">\(G /
H\)</span>的<strong>典范同态</strong>.</p>
<p>那么我们有第一同构定理,即对于一个<span class="math inline">\(G\)</span>的一个正规子群<span class="math inline">\(H\)</span>,在典范同态<span class="math inline">\(\pi : G \rightarrow G / H\)</span>下,我们有:</p>
<ol type="1">
<li><p><span class="math inline">\(G\)</span>的包含<span class="math inline">\(H\)</span>的子群和<span class="math inline">\(G /
H\)</span>的子群在<span class="math inline">\(\pi\)</span>下是群同构.</p></li>
<li><p>在此对应下,正规子群对应于正规子群.</p></li>
<li><p>若有<span class="math inline">\(H \trianglelefteq K
\trianglelefteq G\)</span>,则<span class="math inline">\(G / K \cong ( G
/ H ) / ( K / H )\)</span>.</p></li>
</ol>
<p>如若考虑满同态的情况,我们有另一种形式的表达.设<span class="math inline">\(f : G \rightarrow G
&#39;\)</span>是群的满同态,根据同态基本定理有<span class="math inline">\(G / \ker f \cong G &#39;\)</span>,立刻有:</p>
<ol type="1">
<li><p><span class="math inline">\(G\)</span>的包含<span class="math inline">\(\ker f\)</span>的子群和<span class="math inline">\(G &#39;\)</span>的子群在<span class="math inline">\(f\)</span>下一一对应.</p></li>
<li><p>在此对应下,正规子群对应正规子群.</p></li>
<li><p>若有<span class="math inline">\(\ker f \leq H \trianglelefteq
G\)</span>,则<span class="math inline">\(G / H \cong ( G / \ker f ) / (
H / \ker f ) \cong G &#39; / H &#39;\)</span>.</p></li>
</ol>
<p>此形式与一开始的形式无太大差别,因为任何一个正规子群总对应某个映射的<span class="math inline">\(\ker\)</span>.</p>
<p>然而这个证明要比原本的大量堆砌要更为漂亮.我们断言这种一一对应恰好由<span class="math inline">\(f\)</span>给出.更进一步地,对于<span class="math inline">\(\ker f \leq H \leq G\)</span>,其对应了一个<span class="math inline">\(H &#39; \leq G &#39;\)</span>,满足:<span class="math inline">\(f ( H ) = H &#39;\)</span>,而且<span class="math inline">\(f^{ - 1 } ( H &#39; ) = H\)</span>.</p>
<p>先来证明我们找到是一个双射,那就需要对每个<span class="math inline">\(H\)</span>证明其对应的那个<span class="math inline">\(H &#39;\)</span>确实是对应自己的,反之亦然:</p>
<p>首先我们要证明<span class="math inline">\(H = f^{ - 1 } ( f ( H )
)\)</span>.显然有<span class="math inline">\(H \subseteq f^{ - 1 } ( f (
H ) )\)</span>,下面证明<span class="math inline">\(f^{ - 1 } ( f ( H ) )
\subseteq H\)</span>.也就是要证明<span class="math inline">\(\forall f (
x ) \in f ( H )\)</span>,也就是<span class="math inline">\(f ( x ) = f (
h ) , x \in G , h \in H\)</span>,都一定有<span class="math inline">\(x
\in H\)</span>.</p>
<p>可如若<span class="math inline">\(f ( x ) = f ( h
)\)</span>就一定有<span class="math inline">\(xh^{ - 1 } \in \ker f
\subseteq H\)</span>,这就搞定了<span class="math inline">\(x \in
H\)</span>.</p>
<p>反过来的<span class="math inline">\(H &#39; = f ( f^{ - 1 } ( H &#39;
) )\)</span>,回忆到<span class="math inline">\(f\)</span>是满射,其总有右逆,因此这是显然成立的.这就搞定了一一对应的关系,而且顺便还给出如果<span class="math inline">\(H_1 \subseteq H_2\)</span>,则<span class="math inline">\(H_1 &#39; = f ( H_1 ) \subseteq H_2 &#39; = f (
H_2 )\)</span>.至于<span class="math inline">\(H
&#39;\)</span>的正规性,只需要回忆到<span class="math inline">\(\forall
\bar{ x } \in G &#39;\)</span>,<span class="math inline">\(\exists x \in
G , \bar{ x } = f ( x )\)</span>.这就给出<span class="math inline">\(\bar{ x } f ( H ) ( \bar{ x } )^{ - 1 } = f (
xHx^{ - 1 } ) = f ( H )\)</span>.</p>
<p>最后考虑映射<span class="math inline">\(G \to G &#39; / H &#39; , g
\mapsto f ( g ) H &#39;\)</span>,它的<span class="math inline">\(\ker =
f^{ - 1 } ( H &#39; ) = H\)</span>,所以同态基本定理给出<span class="math inline">\(G / H \cong G &#39; / H
&#39;\)</span>,这就搞定.</p>
<p>总之,第一同构定理给出的是”商”这个操作究竟对一个群有了怎样的影响,其实就是切片了对吧,然后把每一片缩起来.有下述交换图表:</p>
<p><span class="math display">\[
\xymatrix{ G \ar[r]^f \ar[d] &amp; G &#39; \ar[d] \\
G / H \ar[r] &amp; G &#39; / H &#39; }
\]</span></p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H \trianglelefteq G , K \leq G\)</span>,则:</p>
<ol type="1">
<li><p><span class="math inline">\(H \cap K \trianglelefteq
K\)</span>.<span class="math inline">\(HK = KH \leq G\)</span>.</p></li>
<li><p><span class="math inline">\(( HK ) / H \cong K / ( H \cap K
)\)</span>.</p></li>
</ol>
<p>考虑(1)的证明:</p>
<p>先看前半部分,只需证明<span class="math inline">\(\forall k \in K , w
\in H \cap K\)</span>,<span class="math inline">\(kwk^{ - 1 } \in H \cap
K\)</span>.</p>
<p>注意到<span class="math inline">\(k , w \in K\)</span>,所以<span class="math inline">\(kwk^{ - 1 } \in K\)</span>;又注意到<span class="math inline">\(H \trianglelefteq G\)</span>,所以<span class="math inline">\(kwk^{ - 1 } \in H\)</span>,这就证明了该结论.</p>
<p>对于后半部分先证明<span class="math inline">\(HK =
KH\)</span>,考虑<span class="math inline">\(hk \in Hk = kH \subseteq
KH\)</span>.</p>
<p>再证<span class="math inline">\(HK\)</span>的确是一个子群,我们早在子群判定引理处就证明了此结论.</p>
<p>再看(2)的证明:</p>
<p>考虑构造<span class="math inline">\(\varphi : K \to ( HK ) / H , k
\mapsto kH\)</span>.这显然是良定义的群同态.</p>
<p>考虑<span class="math inline">\(\varphi ( k ) = H \Leftrightarrow k
\in H \Leftrightarrow k \in K \cap H\)</span>,于是<span class="math inline">\(\ker \varphi = K \cap H\)</span>.</p>
<p>接下来还需要解释其满性,考虑<span class="math inline">\(\forall hkH =
H ( hk ) = Hk = kH\)</span>,这就证明了其满性,于是上述命题自然成立.</p>
<p>根据第二同构定理还可以立刻得到:<span class="math inline">\(H , K \leq
G\)</span>,<span class="math inline">\(G\)</span>是有限群,<span class="math inline">\(| HK | = \frac{ | H | | K | }{ | H \cap K |
}\)</span>.</p>
<p>另外容易见到,其实只要<span class="math inline">\(H \leq N_G ( K
)\)</span>,上述结论依然过得去,因为只需要把群限制在<span class="math inline">\(N_G ( K )\)</span>上即可.</p>
<h5><span id="交换化">交换化</span></h5>
<p>如果群<span class="math inline">\(G\)</span>的子群<span class="math inline">\(H\)</span>对于所有自同构<span class="math inline">\(\varphi : G \cong G\)</span>都满足<span class="math inline">\(\varphi ( H ) = H\)</span>,则称<span class="math inline">\(H\)</span>是一个<strong>特征子群</strong>.取<span class="math inline">\(\varphi = \mathrm{ Ad
}\)</span>可以见到特征子群总是正规子群.</p>
<p>还可以见到群的中心总是特征子群,原因是任取<span class="math inline">\(z \in Z_G , \forall g \in G\)</span>,都满足:</p>
<p><span class="math display">\[
\begin{aligned}
zg &amp; = gz \\
\varphi ( z ) \varphi ( g ) &amp; = \varphi ( g ) \varphi ( z )
\end{aligned}
\]</span></p>
<p>由于<span class="math inline">\(g\)</span>可以取遍<span class="math inline">\(G\)</span>,所以<span class="math inline">\(\varphi
( g )\)</span>可以取遍<span class="math inline">\(G\)</span>,所以<span class="math inline">\(\varphi ( z ) \in Z_G\)</span>.</p>
<p>我们还可以定义群的<strong>导出子群</strong><span class="math inline">\(G_{ der } = \langle aba^{ - 1 } b^{ - 1 } | a , b
\in G \rangle\)</span>也是特征子群.原因是<span class="math inline">\(\varphi ( aba^{ - 1 } b^{ - 1 } ) = \varphi ( a )
\varphi ( b ) \varphi ( a )^{ - 1 } \varphi ( b )^{ - 1 }\)</span>.</p>
<p>既如此,考虑商群<span class="math inline">\(G_{ ab } = G / G_{ der
}\)</span>.留意到<span class="math inline">\(\forall g_1 , g_2 \in G_{
ab }\)</span>:</p>
$$
<span class="math display">\[\begin{aligned}
g_1 g_2 G_{ der } &amp; = g_2 g_1 G_{ der } \\
&amp; \Leftrightarrow g_1^{ - 1 } g_2^{ - 1 } g_1 g_2 G_{ der } = G_{
der } \\
&amp; \Leftrightarrow g_1^{ - 1 } g_2^{ - 1 } g_1 g_2 \in G_{ der } \\

\end{aligned}\]</span>
<p>$$</p>
<p>所以见到此商群交换,我们将此操作称为<strong>群的交换化</strong>.</p>
<p>我们可能还想说明这样的交换化是最为合理的,我们可以证明如果存在一个同态<span class="math inline">\(f : G \to A\)</span>,其中<span class="math inline">\(A\)</span>是一个交换群.则存在唯一的<span class="math inline">\(\bar{ f } : G_{ ab } \to
A\)</span>,使下列图表交换:</p>
<p><span class="math display">\[
\xymatrix{ G \ar[d] \ar[r]^f &amp; A \\
G_{ ab } \ar[ru]_{ \bar{ f } } &amp; }
\]</span></p>
<p>首先注意到必须满足<span class="math inline">\(\bar{ f } ( gG_{ der }
) = f ( g )\)</span>,这就给出唯一性,其次要给出存在性,就要证明如果<span class="math inline">\(g_1 G_{ der } = g_2 G_{ der }\)</span>则<span class="math inline">\(f ( g_1 ) = f ( g_2 )\)</span>.只需检验<span class="math inline">\(G_{ der } \subseteq \ker
f\)</span>就行,然而由于<span class="math inline">\(f ( aba^{ - 1 } b^{ -
1 } ) = e_A\)</span>,原因是<span class="math inline">\(A\)</span>的交换性,因此这就给定了.</p>
<h6><span id="example1">Example1</span></h6>
<p>证明<span class="math inline">\(GL ( n , F )_{ der } = SL ( n , F
)\)</span>,其中<span class="math inline">\(F\)</span>是含有至少三个元素的域.</p>
<p>显然<span class="math inline">\(GL ( n , F )_{ der } \subseteq SL ( n
, F )\)</span>,只需要证明上述导出子群的确生成了<span class="math inline">\(SL ( n , F )\)</span>即可.</p>
<p>考虑所有的矩阵都可以通过若干次初等行列变换变到对角线全<span class="math inline">\(1\)</span>的矩阵,只需要把这些初等行列变换全都拿到即可,略去不谈.</p>
<p>此时也可以见到<span class="math inline">\(GL ( n , F ) / SL ( n , F )
= F\)</span>,其实也就是行列式.</p>
<h6><span id="example2岩泽健吉iwasawa判准">Example2(岩泽健吉(Iwasawa)判准)</span></h6>
<p>设群<span class="math inline">\(G\)</span>作用在集合<span class="math inline">\(X\)</span>上,<span class="math inline">\(| X |
\geq 2\)</span>,若<span class="math inline">\(\forall ( x , y ) , ( x
&#39; , y &#39; ) \in X^2\)</span>,其中<span class="math inline">\(x \ne
y , x &#39; \ne y &#39;\)</span>,都存在<span class="math inline">\(g \in
G\)</span>使得<span class="math inline">\(gx = x &#39; , gy = y
&#39;\)</span>,则称该作用是<strong>双传递的</strong>.下面我们设<span class="math inline">\(G\)</span>双传递于<span class="math inline">\(X\)</span>,并且记<span class="math inline">\(H_x =
\mathrm{ Stab }_G ( x )\)</span>.</p>
<p>先证明一个引理:<span class="math inline">\(\forall
H_x\)</span>都是<span class="math inline">\(G\)</span>的极大真子群.</p>
<p>为证明此,只需要证明任意往里面多添一个<span class="math inline">\(g
\in G \setminus H_x\)</span>,都会使得这个群扩充到<span class="math inline">\(G\)</span>本身.一个想法是证明<span class="math inline">\(G = H_x \cup H_x g H_x\)</span>.</p>
<p>既然如此,考虑只要证<span class="math inline">\(\forall g_1 \in G
\setminus H_x , \exists h_1 , h_2 \in H_x\)</span>使得<span class="math inline">\(g_1 = h_1 gh_2\)</span>即可,也就是<span class="math inline">\(\exists h_1\)</span>使得<span class="math inline">\(g_1^{ - 1 } h_1 g \in H_x \Leftrightarrow g_1^{ -
1 } h_1 g ( x ) = x \Leftrightarrow g ( x ) = h_1^{ - 1 } g_1 ( x
)\)</span>.</p>
<p>考虑到<span class="math inline">\(g ( x ) \ne x , g_1 ( x ) \ne
x\)</span>.由双传递性一定存在一个<span class="math inline">\(h_1^{ - 1
}\)</span>把<span class="math inline">\(( x , g_1 ( x ) ) \to ( x , g (
x ) )\)</span>,这就搞定了.</p>
<p>接下来再证明一个引理:任何正规子群<span class="math inline">\(N
\trianglelefteq G\)</span>在<span class="math inline">\(X\)</span>上的作用要么是平凡的,要么是传递的.</p>
<p>若<span class="math inline">\(N\)</span>的作用不是平凡的,也就是存在<span class="math inline">\(x , n\)</span>使得<span class="math inline">\(nx
\ne x\)</span>,那我们下面证明对于任意<span class="math inline">\(y \ne y
&#39;\)</span>,都可以找到一个元素<span class="math inline">\(m \in
N\)</span>使得<span class="math inline">\(my = y
&#39;\)</span>.原因是可以取<span class="math inline">\(g : ( x , nx )
\mapsto ( y , y &#39; )\)</span>,于是<span class="math inline">\(gx = y
, gnx = y &#39; , gng^{ - 1 } y = y &#39;\)</span>,由于<span class="math inline">\(N\)</span>正规知道<span class="math inline">\(gng^{ - 1 } \in N\)</span>,这就搞定了.</p>
<p>接下来证明岩泽判准,假设<span class="math inline">\(G\)</span>作用忠实,<span class="math inline">\(G =
G_{ der }\)</span>,而且存在<span class="math inline">\(x\)</span>使得<span class="math inline">\(H_x\)</span>有正规交换子群<span class="math inline">\(U\)</span>,而<span class="math inline">\(U\)</span>在<span class="math inline">\(G\)</span>中的所有共轭生成<span class="math inline">\(G\)</span>.我们下面证明<span class="math inline">\(G\)</span>是单群.</p>
<p>取定<span class="math inline">\(N \trianglelefteq G\)</span>和<span class="math inline">\(x \in X\)</span>,由于<span class="math inline">\(H_x\)</span>是极大真子群,所以要么<span class="math inline">\(NH_x = H_x\)</span>,要么<span class="math inline">\(NH_x = G\)</span>.</p>
<p>当<span class="math inline">\(NH_x = H_x , N \subseteq
H_x\)</span>的时候,此时<span class="math inline">\(N\)</span>作用并非传递,所以<span class="math inline">\(N\)</span>作用平凡.由于作用是忠实的,作用平凡的元素也就只有<span class="math inline">\(\{ id \}\)</span>.</p>
<p>当<span class="math inline">\(NH_x = G\)</span>的时候,我们先证明<span class="math inline">\(NU \trianglelefteq NH_x =
G\)</span>.首先第二同构定理的部分已经给出了<span class="math inline">\(NU \leq NH_x\)</span>,现在考虑<span class="math inline">\(\forall nu \in NU , n_1 h_1 \in
NH_x\)</span>,下面证明<span class="math inline">\(n_1 h_1 nuh_1^{ - 1 }
n_1^{ - 1 } \in NU\)</span>.</p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
n_1 h_1 nuh_1^{ - 1 } n_1^{ - 1 } \\
= n_1 ( h_1 nh_1^{ - 1 } ) ( h_1 uh_1^{ - 1 } ) n_1^{ - 1 } \\
\in NUN = NU
\end{aligned}
\]</span></p>
<p>此时由于<span class="math inline">\(U \leq
NU\)</span>,而后者正规,前者的所有共轭生成<span class="math inline">\(G\)</span>,这必然意味着<span class="math inline">\(NU = G\)</span>,第二同态定理给出<span class="math inline">\(G / N \cong U / ( N \cap U
)\)</span>而后者交换,这给出了一种<span class="math inline">\(G\)</span>向交换群的同态,我们知道此时必然有<span class="math inline">\(G_{ ab
}\)</span>上也有一个向交换群的同态,然而<span class="math inline">\(G_{
ab }\)</span>是平凡群,因此<span class="math inline">\(G /
N\)</span>必然也是平凡群,意味着<span class="math inline">\(N =
G\)</span>.</p>
<h6><span id="example3">Example3</span></h6>
<p>设<span class="math inline">\(F\)</span>为域且<span class="math inline">\(| F | \geq 4\)</span>,记<span class="math inline">\(Z\)</span>是<span class="math inline">\(SL ( n , F
)\)</span>的中心,下面我们证明当<span class="math inline">\(n \geq
2\)</span>的时候,<span class="math inline">\(PSL ( 2 , F ) = SL ( 2 , F
) / Z\)</span>是单群.</p>
<p>我们想要用岩泽健吉判准,首先要检验<span class="math inline">\(SL ( n ,
F ) = SL ( n , F )_{ der
}\)</span>,这个与之前的做法几乎类似,只需要简单说明.</p>
<p>接下来设<span class="math inline">\(\mathbb{ P }^{ n - 1 } ( F
)\)</span>为<span class="math inline">\(F^n\)</span>的<span class="math inline">\(1\)</span>维子空间,让<span class="math inline">\(PSL ( n , F
)\)</span>作用在上面,留意到中心的作用也的确是平凡的.</p>
<p>当<span class="math inline">\(n = 2\)</span>的时候,记录<span class="math inline">\(( x , y ) \in F^2 \setminus \{ 0
\}\)</span>生成的空间为<span class="math inline">\(( x : y
)\)</span>,我们来证明它是双传递的,事实上这较为显然.</p>
<p>接下来我们来看<span class="math inline">\(( 1 : 0
)\)</span>上的稳定化子群<span class="math inline">\(H\)</span>,其实也就是所有的上三角矩阵,然后还要验证作用是忠实的,总之请检验以上事实.然后取<span class="math inline">\(U = \{ \begin{bmatrix}1 &amp; \_ \\ 0 &amp;
1\end{bmatrix} Z \}\)</span>.</p>
<p>当<span class="math inline">\(n \geq
3\)</span>和上面是同理的,对于<span class="math inline">\(( 1 : 0 \cdots
: 0 )\)</span>的稳定化子群取分块上三角矩阵<span class="math inline">\(\begin{bmatrix}a &amp; \_ \\ &amp; A\end{bmatrix}
Z\)</span>,然后取<span class="math inline">\(U = \{ \begin{bmatrix}1
&amp; \_ \\ 0 &amp; I\end{bmatrix} Z \}\)</span>.</p>
<h4><span id="群的直和与直积">群的直和与直积</span></h4>
<h5><span id="直和">直和</span></h5>
<p>在两个群<span class="math inline">\(G_1 , G_2\)</span>的笛卡尔积<span class="math inline">\(G_1 \times
G_2\)</span>集合上定义二元运算,满足<span class="math inline">\(( a_1 ,
b_1 ) ( a_2 , b_2 ) = ( a_1 a_2 , b_1 b_2
)\)</span>,这个集合和这个二元运算显然组成群,称这个群为<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>的<strong>外直和</strong>,记为<span class="math inline">\(G_1 \oplus G_2\)</span>,<span class="math inline">\(G_1 ,
G_2\)</span>称作其的<strong>直和因子</strong>.如果要对无限个群做类似操作,则可以区分出<strong>直积</strong>的版本,仍是因为是否有限个分量非零的问题.</p>
<p>显然<span class="math inline">\(G_1 \oplus
G_2\)</span>中存在两个正规子群<span class="math inline">\(\bar{ G_1 } =
\{ ( a , e_2 ) | a \in G_1 \} , \bar{ G_2 } = \{ ( e_1 , b ) | b \in G_2
\}\)</span>,并且不难发现<span class="math inline">\(G_1 \oplus G_2 =
\bar{ G_1 } \bar{ G_2 }\)</span>.</p>
<p>这给出了一种分解群的策略,事实上,设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H , K
\trianglelefteq G , G = HK\)</span>,我们有以下命题互推:</p>
<ol type="1">
<li><p>映射<span class="math inline">\(\sigma : H \oplus K \rightarrow G
, ( h , k ) \mapsto hk\)</span>是同构.</p></li>
<li><p><span class="math inline">\(G\)</span>的任一元素表示为<span class="math inline">\(H , K\)</span>的乘积的表示法唯一.</p></li>
<li><p><span class="math inline">\(G\)</span>的幺元表示为<span class="math inline">\(H , K\)</span>的元素的乘积的表示法唯一.</p></li>
<li><p><span class="math inline">\(H \cap K = \{ e \}\)</span>.</p></li>
</ol>
<p>显然<span class="math inline">\(( 1 ) \Rightarrow ( 2 ) \Rightarrow (
3 )\)</span>.对于<span class="math inline">\(( 3 ) \Rightarrow ( 4
)\)</span>,如果<span class="math inline">\(\exists g \in H \cap K , g
\ne e\)</span>,则<span class="math inline">\(e = gg^{ - 1 } =
ee\)</span>,这就给出了两种表示法,不符.</p>
<p>只需证明<span class="math inline">\(( 4 ) \Rightarrow ( 1
)\)</span>.根据我们的经验,先证良定义(显然),再证群同态,再证单射,再证满射(显然).</p>
<p>我们先干个事,我们断言<span class="math inline">\(\forall h \in H , k
\in K , hk = kh\)</span>.</p>
<p>这个怎么断言呢?我们考虑由于<span class="math inline">\(H
\trianglelefteq G\)</span>,有<span class="math inline">\(k^{ - 1 } hk
\in H\)</span>,所以<span class="math inline">\(h^{ - 1 } k^{ - 1 } hk
\in H\)</span>,同理可证明<span class="math inline">\(h^{ - 1 } k^{ - 1 }
hk \in K\)</span>,于是<span class="math inline">\(h^{ - 1 } k^{ - 1 } hk
= e\)</span>,<span class="math inline">\(kh =
hk\)</span>.由此显然证明是群同态.</p>
<p>接下来只需要证明单射,只需要证明<span class="math inline">\(\ker
\sigma = \{ e , e \}\)</span>.不妨设<span class="math inline">\(( h , k
) \in \ker \sigma\)</span>,则<span class="math inline">\(hk =
e\)</span>,<span class="math inline">\(h = k^{ - 1 } \in H \cap K =
e\)</span>.所以<span class="math inline">\(\ker \sigma = \{ e , e
\}\)</span>.</p>
<p>我们也将<span class="math inline">\(G\)</span>称作<span class="math inline">\(H\)</span>和<span class="math inline">\(K\)</span>的<strong>内直和</strong>,将<span class="math inline">\(H , K\)</span>称作其<strong>直和因子</strong>.</p>
<p>上面的概念还可以扩展,设<span class="math inline">\(G\)</span>是群,<span class="math inline">\(H_1 ,
\cdots , H_n \trianglelefteq G , G = H_1 \cdots
H_n\)</span>,我们有以下命题互推:</p>
<ol type="1">
<li><p>映射<span class="math inline">\(\sigma : H_1 \oplus \cdots \oplus
H_n \rightarrow G , ( h_1 , \cdots , h_n ) \mapsto h_1 \cdots
h_n\)</span>是同构.</p></li>
<li><p><span class="math inline">\(G\)</span>的任一元素表示为<span class="math inline">\(H_1 , \cdots ,
H_n\)</span>的乘积的表示法唯一.</p></li>
<li><p><span class="math inline">\(G\)</span>的幺元表示为<span class="math inline">\(H_1 , \cdots ,
H_n\)</span>的元素的乘积的表示法唯一.</p></li>
<li><p><span class="math inline">\(H_i \cap ( H_1 \cdots H_{ i - 1 } H_{
i + 1 } \cdots H_n ) = \{ e \}\)</span>.</p></li>
</ol>
<h5><span id="半直积">半直积</span></h5>
<p>取<span class="math inline">\(H ,
N\)</span>是给定的两个任意的群,以及给定的群同态<span class="math inline">\(\varphi : H \to \mathrm{ Aut } ( N ) , h \mapsto
\varphi_h\)</span>.</p>
<p>接下来在<span class="math inline">\(N \times
H\)</span>上定义一种二元运算,定义为<span class="math inline">\(( n , h )
( n &#39; , h &#39; ) = ( n \varphi_h ( n &#39; ) , hh &#39;
)\)</span>.我们下面证明这种运算的确使得<span class="math inline">\(N
\times H\)</span>成为群,记作<span class="math inline">\(N
\rtimes_\varphi H\)</span>.见到:</p>
<ol type="1">
<li><p>幺元存在:<span class="math inline">\(1_{ N \times H } = ( 1_N ,
1_H )\)</span>.</p></li>
<li><p>逆元存在:<span class="math inline">\(( n , h )^{ - 1 } = (
\varphi_{ h^{ - 1 } } ( n^{ - 1 } ) , h^{ - 1 } )\)</span>.</p></li>
</ol>
<p>结合律的验证比较多,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( n_1 , h_1 ) ( n_2 , h_2 ) ( n_3 , h_3 ) \\
= &amp; ( n_1 \varphi_{ h_1 } ( n_2 ) \varphi_{ h_1 h_2 } ( n_3 ) , h_1
h_2 h_3 )
\end{aligned}
\]</span></p>
<p>而:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( n_1 , h_1 ) ( ( n_2 , h_2 ) ( n_3 , h_3 ) ) \\
= &amp; ( n_1 , h_1 ) ( n_2 \varphi_{ h_2 } ( n_3 ) , h_2 h_3 ) \\
= &amp; ( n_1 \varphi_{ h_1 } ( n_2 \varphi_{ h_2 } ( n_3 ) ) , h_1 h_2
h_3 )
\end{aligned}
\]</span></p>
<p>于是我们要证明的就是<span class="math inline">\(\varphi_{ h_1 } ( n_2
) \varphi_{ h_1 h_2 } ( n_3 ) = \varphi_{ h_1 } ( n_2 \varphi_{ h_2 } (
n_3 )\)</span>.由于<span class="math inline">\(\varphi\)</span>是同态,里面的乘积可以拆出,只需证明<span class="math inline">\(\varphi_{ h_1 h_2 } = \varphi_{ h_1 } \circ
\varphi_{ h_2 }\)</span>,然而这恰是同态<span class="math inline">\(\varphi : H \to \mathrm{ Aut } ( N
)\)</span>本身的性质,这就搞定.</p>
<p>接下来,我们考虑搞两个嵌入映射,考虑<span class="math inline">\(N \to N
\times H , n \mapsto ( n , 1_H )\)</span>.同理定义<span class="math inline">\(H \to N \times H , h \mapsto ( 1_N , h
)\)</span>.在这种嵌入下见到<span class="math inline">\(( n , h ) = ( n ,
1_H ) ( 1_N , h )\)</span>,可以发现<span class="math inline">\(N
\trianglelefteq N \times H\)</span>.原因是:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( n_1 , h_1 ) ( n , 1_H ) ( n_1 , h_1 )^{ - 1 } \\
= &amp; ( n_1 , 1_H ) ( 1_N , h_1 ) ( n , 1_H ) ( 1_N , h_1 )^{ - 1 } (
n_1 , 1_H )^{ - 1 }
\end{aligned}
\]</span></p>
<p>而考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( 1_N , h ) ( n , 1_H ) ( 1_N , h )^{ - 1 } \\
= &amp; ( 1_N , h ) ( n , 1_H ) ( 1_N , h^{ - 1 } ) \\
= &amp; ( \varphi_h ( n ) , h ) ( 1_N , h^{ - 1 } ) \\
= &amp; ( \varphi_h ( n ) , 1_H )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>上述操作看上去一团迷雾,我们想要说明半直积定义的动机:其实就是想让<span class="math inline">\(N , H\)</span>嵌入同一个群中,并且使得<span class="math inline">\(N\)</span>是这个群的一个正规子群.</p>
<p>于是我们的目标终于明晰:假设<span class="math inline">\(H \leq G , N
\trianglelefteq G , H \cap N = \{ 1 \} , G = NH =
HN\)</span>,考虑由<span class="math inline">\(\mathrm{ Ad }_h ( n ) =
hnh^{ - 1 }\)</span>给出的映射,下面我们要证明存在同构<span class="math inline">\(\Phi : N \rtimes_\mathrm{ Ad } H \cong G , ( n , h
) \mapsto nh\)</span>.</p>
<p>首先验证这的确是个同态,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \Phi ( ( n , h ) ( n &#39; , h &#39; ) ) \\
= &amp; \Phi ( nhn &#39; h^{ - 1 } , hh &#39; ) \\
= &amp; nhn &#39; h^{ - 1 } hh &#39; \\
= &amp; nhn &#39; h &#39; = \Phi ( n , h ) \Phi ( n &#39; , h &#39; )
\end{aligned}
\]</span></p>
<p>满性显然,单性的话考虑<span class="math inline">\(\Phi ( n , h ) = 1
\Leftrightarrow nh = 1 \Leftrightarrow n = 1 , h =
1\)</span>,这就搞定.</p>
<p>上述构造舍弃了<span class="math inline">\(\varphi\)</span>,因此比起之前的版本,这个更像是一种内的版本.事实上上述也有第二同构定理给出<span class="math inline">\(G / N \cong
H\)</span>,所以你可以将商看作半直积的逆运算,然而反之不可.例如<span class="math inline">\(( \mathbb{ Z } / 4 \mathbb{ Z } ) / ( 2 \mathbb{ Z
} / 4 \mathbb{ Z } ) \cong ( \mathbb{ Z } / 2 \mathbb{ Z }
)\)</span>,注意到<span class="math inline">\(( 2 \mathbb{ Z } / 4
\mathbb{ Z } ) \cong ( \mathbb{ Z } / 2 \mathbb{ Z } )\)</span>,但<span class="math inline">\(\mathbb{ Z } / 4 \mathbb{ Z }\)</span>和<span class="math inline">\(( \mathbb{ Z } / 2 \mathbb{ Z }
)^2\)</span>并不同构,前者是循环群后者是克莱因四元群.</p>
<p>半直积的作用要么是通过两个群得到一个新的群,要么反之将一个群拆分为两个不同的群.</p>
<h6><span id="example1">Example1</span></h6>
<p>一个例子是将置换群<span class="math inline">\(S_n\)</span>拆成偶置换群<span class="math inline">\(A_n\)</span>和任何一个单置换<span class="math inline">\(\tau = ( i , j )\)</span>的半直积,有:<span class="math inline">\(S_n = A_n \rtimes \langle \tau
\rangle\)</span>.</p>
<p>然而当<span class="math inline">\(n &gt;
2\)</span>的时候,见到永远不可能出现<span class="math inline">\(S_n = A_n
\times \langle \tau
\rangle\)</span>的情形,证明可以考虑左侧的中心只有<span class="math inline">\(id\)</span>而右侧至少有<span class="math inline">\(( 1 , 1 )\)</span>和<span class="math inline">\(1
, \tau\)</span>两个.</p>
<h6><span id="example2二面体群">Example2(二面体群)</span></h6>
<p>回忆到<span class="math inline">\(O ( 2 )\)</span>为<span class="math inline">\(\mathbb{ R
}^2\)</span>上的正交变换,上面有一个正规子群<span class="math inline">\(SO ( 2 )\)</span>为<span class="math inline">\(\det = 1\)</span>的部分.</p>
<p>设<span class="math inline">\(n \geq
3\)</span>,取平面上的一个中心为<span class="math inline">\(( 0 , 0
)\)</span>的正<span class="math inline">\(n\)</span>边形,适当缩放后可以使得顶点分别为<span class="math inline">\(\omega_n^k = e^{ \frac{ 2 k \pi i }{ n }
}\)</span>,设<span class="math inline">\(D_{ 2 n
}\)</span>为所有使得正<span class="math inline">\(n\)</span>边形不变的正交变换,容易见到<span class="math inline">\(D_{ 2 n } \leq O ( 2 )\)</span>.</p>
<p>接下来看<span class="math inline">\(D_{ 2 n
}\)</span>中的两种元素:</p>
<ol type="1">
<li><p>旋转:那肯定要将一个角挪到另一个角上,因此等价于复平面上的<span class="math inline">\(\omega_n^k\)</span>,记<span class="math inline">\(\sigma = \omega_n\)</span>则旋转群也就是<span class="math inline">\(\langle \sigma \rangle \cong \mathbb{ Z } / n
\mathbb{ Z }\)</span>.</p></li>
<li><p>镜射:任取一个<span class="math inline">\(\tau\)</span>使得图形沿某条轴翻转.容易见到<span class="math inline">\(\langle \tau \rangle \cong \mathbb{ Z } / 2
\mathbb{ Z }\)</span>.</p></li>
</ol>
<p>下面我们说明<span class="math inline">\(D_{ 2 n } \cong \langle
\sigma \rangle \rtimes \langle \tau \rangle \cong \mathbb{ Z } / n
\mathbb{ Z } \rtimes_\varphi \mathbb{ Z } / 2 \mathbb{ Z
}\)</span>.其中<span class="math inline">\(\varphi_{ 1 + 2 \mathbb{ Z }
} ( a + n \mathbb{ Z } ) = - a + n \mathbb{ Z }\)</span>.</p>
<p>首先见到<span class="math inline">\(D_{ 2 n } \cap SO ( 2 ) = \langle
\sigma \rangle\)</span>,原因显然.这样两边取交就可以说明<span class="math inline">\(\langle \sigma \rangle \trianglelefteq D_{ 2 n
}\)</span>.</p>
<p>此外容易见到<span class="math inline">\(\langle \sigma \rangle \cap
\langle \tau \rangle = \{ 1
\}\)</span>.其余性质也容易说明,唯一可能稍不显然的是为何<span class="math inline">\(\langle \sigma \rangle \rtimes \langle \tau
\rangle\)</span>的确生成了整个群.</p>
<p>策略是转回去!假设这个变换将<span class="math inline">\(0\)</span>号顶点搞到了某个位置,你可以把它转回去,于是此时图形保持了<span class="math inline">\(0\)</span>号顶点不动,此时要么就是恒等,要么就是按照实轴翻转,这样就搞定了.</p>
<h3><span id="环">环</span></h3>
<p>定义一个<strong>环</strong>是一个集合<span class="math inline">\(R\)</span>和两种二元运算<span class="math inline">\(+ , \times\)</span>.它应当满足如下性质:</p>
<ol type="1">
<li><p>集合对两种运算封闭.</p></li>
<li><p><span class="math inline">\(( R , +
)\)</span>构成阿贝尔群,加法幺元一般记作<span class="math inline">\(0_R\)</span>,<span class="math inline">\(x\)</span>的加法逆元一般记作<span class="math inline">\(- x\)</span>.</p></li>
<li><p>乘法有结合律.</p></li>
<li><p>乘法对加法有分配律.</p></li>
<li><p>(幺环存在乘法幺元,一般记作<span class="math inline">\(1_R\)</span>)</p></li>
<li><p>(交换环的乘法具有交换律)</p></li>
</ol>
<p>最平凡的环只包含一个<span class="math inline">\(0\)</span>元素,被称为<strong>零环</strong>.</p>
<p>下面证明一些环的基础性质:</p>
<ol type="1">
<li><span class="math inline">\(\forall a \in R , a 0 = 0 a =
0\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(a 0 = a ( 0 + 0 ) = a 0 + a
0\)</span>,所以<span class="math inline">\(a 0 = 0\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(\forall a , b \in R , ( - a ) b = a ( -
b ) = - ( ab )\)</span>.</li>
</ol>
<p>注意到<span class="math inline">\(( - a ) b + ab = b ( a - a ) =
0\)</span>,所以<span class="math inline">\(- ( ab ) = ( - a )
b\)</span>.</p>
<ol start="3" type="1">
<li><span class="math inline">\(\forall a , b \in R , ( - a ) ( - b ) =
ab\)</span>.</li>
</ol>
<p>由(2)是显然的.</p>
<p>注意到环的定义中并没有提及乘法逆元.如果环<span class="math inline">\(R\)</span>是幺环,且对于某一个<span class="math inline">\(a \in R\)</span>,<span class="math inline">\(a\)</span>有逆元(或者既有左逆元又有右逆元,类似群,左右逆元必相等且唯一),那么称其为<strong>可逆元</strong>或<strong>单位元</strong>,有时又称其为unit.</p>
<p>容易验证幺环的可逆元的全体构成乘法群,记作<span class="math inline">\(R^\times\)</span>.</p>
<p>对于一个元素<span class="math inline">\(a \in
R\)</span>来说,如果<span class="math inline">\(\exists b \in R \setminus
\{ 0 \}\)</span>,<span class="math inline">\(ab = 0\)</span>,我们称<span class="math inline">\(a\)</span>是<span class="math inline">\(R\)</span>中的一个<strong>左零因子</strong>,同理可定义<strong>右零因子</strong>,如果一个<span class="math inline">\(a\)</span>既是左零因子又是右零因子,我们称其为一个<strong>零因子</strong>.</p>
<p>我们事实上可以说明这里的加法和乘法与我们平时使用的相当类似,换言之,我们可以说明对于任意环<span class="math inline">\(R\)</span>而言,单同态<span class="math inline">\(\varphi : \mathbb{ Z } \rightarrow
R\)</span>唯一.</p>
<p>首先我们应该满足<span class="math inline">\(\varphi ( 1 ) = 1_R ,
\varphi ( 0 ) = 0_R\)</span>.</p>
<p>其次我们应当有<span class="math inline">\(\varphi ( n ) = \varphi ( 1
+ 1 + \cdots + 1 ) = \varphi ( 1 ) + \varphi ( 1 ) + \cdots + \varphi (
1 )\)</span>.我们不妨把后者简写为<span class="math inline">\(n \varphi (
1 )\)</span>,倍数运算是环中相当重要的运算.</p>
<h4><span id="子环">子环</span></h4>
<p>要验证<span class="math inline">\(S\)</span>是<span class="math inline">\(R\)</span>的子环,只需验证<span class="math inline">\(S\)</span>对加法下是子群,然后<span class="math inline">\(S\)</span>对乘法封闭.</p>
<p>而事实上由于<span class="math inline">\(- x = ( - 1 )
x\)</span>,所以实际上只需要验证<span class="math inline">\(S\)</span>对加法和乘法都封闭即可.</p>
<h4><span id="理想">理想</span></h4>
<p>由于环上有两种运算,如果我们想在陪集上保持环的两种运算,就需要在上面加一些限制.</p>
<p>进一步地,如果<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个加法子群(由于加法有交换律,所以加法子群一定是加法正规子群),并且<span class="math inline">\(\forall r \in R\)</span>,有<span class="math inline">\(rI \subseteq I\)</span>(那么自然有<span class="math inline">\(rI = I\)</span>),则称<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个<strong>左理想</strong>,同理定义<strong>右理想</strong>,既是左理想又是右理想则称其为一个<strong>理想</strong>.</p>
<p>事实上,如果对于<span class="math inline">\(R\)</span>上的一个理想<span class="math inline">\(I\)</span>,我们容易证明<span class="math inline">\(I = R \Leftrightarrow 1 \in I\)</span>.</p>
<p>由于这是一个加法子群,所以加法运算肯定是满足的,容易发现如果<span class="math inline">\(I\)</span>是<span class="math inline">\(R\)</span>的一个理想,那么<span class="math inline">\(\forall r , s \in R , ( r + I ) ( s + I ) = rs +
I\)</span>.</p>
<p>类似群中的结构,子环的交仍然是子环,理想的交仍然是理想.于是类似可以定义由<span class="math inline">\(M \subseteq R , M \ne
\emptyset\)</span>生成的理想<span class="math inline">\(( M
)\)</span>.可由一个元素生成的理想称为<strong>主理想</strong>,可由有限多个元素生成的理想叫做<strong>有限生成理想</strong>.容易发现如果<span class="math inline">\(R\)</span>是交换环,那么<span class="math inline">\(( a ) = aR\)</span>.不然<span class="math inline">\(( a ) = RaR\)</span>.</p>
<p>既然我们在陪集上保持了环的运算,我们自然可以称<span class="math inline">\(R / I\)</span>为<span class="math inline">\(R\)</span>关于<span class="math inline">\(I\)</span>的<strong>商环</strong>,也就是<span class="math inline">\(R / I = \{ r + I | r \in R
\}\)</span>.必须要说明的是商环本身也是一个环,其加法幺元是<span class="math inline">\(0 + I\)</span>,乘法幺元是<span class="math inline">\(1 + I\)</span>.</p>
<p>子环和理想疑似没有对应的符号表示,我们下面不严谨地盗用子群和正规子群的符号(正常情况下好像不让这么干),在不引起混淆的前提下将<span class="math inline">\(( R , + , \times )\)</span>简写为<span class="math inline">\(R\)</span>.</p>
<h4><span id="同态和同构">同态和同构</span></h4>
<p>类似群同态和同构,要同时保持两种运算并且需要将乘法幺元映射到对应的乘法幺元.</p>
<p>不过,如果将环同态的定义中的<span class="math inline">\(\varphi ( ab )
= \varphi ( a ) \varphi ( b )\)</span>改为<span class="math inline">\(\varphi ( ab ) = \varphi ( b ) \varphi ( a
)\)</span>,则称这样的映射为环的<strong>反同态</strong>.</p>
<p>和群略有区别的地方在于如何定义<span class="math inline">\(\ker
\varphi\)</span>,事实上我们一般用加法幺元(因为乘法逆元不一定存在)定义<span class="math inline">\(\ker \varphi = \{ a \in R | \varphi ( a ) = 0
\}\)</span>.那么<span class="math inline">\(\varphi\)</span>是单射当且仅当<span class="math inline">\(\ker \varphi = \{ 0 \}\)</span>.</p>
<p>类比一下群同态,可以知道对于<span class="math inline">\(\varphi : R
\rightarrow R_1\)</span>,<span class="math inline">\(\text{ im } \varphi
\leq R_1 , \ker \varphi \trianglelefteq R\)</span>.</p>
<p>对于前者:由于加法上的性质已经很好了,只需验证其对乘法封闭,这个是好做的.</p>
<p>对于后者:只需验证其封闭且是理想,同样可行.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>也就是<span class="math inline">\(R / \ker \varphi \cong \text{ im }
\varphi\)</span>.</p>
<p>设<span class="math inline">\(f : R_1 \to
R_2\)</span>是线性映射,<span class="math inline">\(I_1 \trianglelefteq
R_1 , I_2 \subseteq R_2\)</span>并构造两个商映射<span class="math inline">\(\varphi_1 , \varphi_2\)</span>,并且<span class="math inline">\(f ( I_1 ) \subseteq
I_2\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar{ f }
: R_1 / I_1 \to R_2 / I_2\)</span>使得<span class="math inline">\(f
\varphi_2 = \bar{ f } \varphi_1\)</span>.具体地,<span class="math inline">\(\bar{ f } ( r + I_1 ) = f ( r ) +
I_2\)</span>.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix{ R_1 \ar[r]^f \ar[d]_{ \varphi_1 } &amp; R_2 \ar[r]^g \ar[d]_{
\varphi_2 } &amp; R_3 \ar[d]_{ \varphi_3 } \\
R_1 / I_1 \ar[r]^{ \bar{ f } } &amp; R_2 / I_2 \ar[r]^{ \bar{ g } }
&amp; R_3 / I_3 \\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>设<span class="math inline">\(R\)</span>是环,<span class="math inline">\(I \trianglelefteq R\)</span>,考虑典范同态:<span class="math inline">\(\pi : R \rightarrow R / I , r \mapsto r +
I\)</span>,那么:</p>
<ol type="1">
<li><p><span class="math inline">\(R\)</span>的包含<span class="math inline">\(I\)</span>的子环与<span class="math inline">\(R /
I\)</span>的子环在<span class="math inline">\(\pi\)</span>下一一对应.</p></li>
<li><p>在此对应下,理想对应于理想.</p></li>
<li><p>若<span class="math inline">\(I \trianglelefteq J \trianglelefteq
R\)</span>,则<span class="math inline">\(R / J \cong ( R / I ) / ( J / I
)\)</span>.</p></li>
</ol>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p>设<span class="math inline">\(R\)</span>是环,<span class="math inline">\(I \trianglelefteq R , S \leq R\)</span>,则:</p>
<ol type="1">
<li><p><span class="math inline">\(I + S \leq R\)</span>.<span class="math inline">\(I \cap S \trianglelefteq S\)</span>.<span class="math inline">\(I \trianglelefteq I + S\)</span></p></li>
<li><p><span class="math inline">\(( I + S ) / I \cong S / ( S \cap I
)\)</span>.</p></li>
</ol>
<h4><span id="整环">整环</span></h4>
<p>如果一个交换幺环至少含有两个元素(或说<span class="math inline">\(0
\ne 1\)</span>),且其满足<span class="math inline">\(xy = 0 \Rightarrow x
= 0 \lor y =
0\)</span>(或说其没有非零零因子),那么我们称其是一个整环.</p>
<p>显然,整环上对乘法满足左右消去律.原因是<span class="math inline">\(ax
= ay \Leftrightarrow a ( x - y ) = 0\)</span>.</p>
<h5><span id="特征">特征</span></h5>
<p>我们之前证明过<span class="math inline">\(\mathbb{ Z
}\)</span>可以唯一射到任何一个环上,如果这个环是整环,那么其实有更好的性质:</p>
<p>对于任意一个整环<span class="math inline">\(R\)</span>,存在唯一一个环的<strong>特征</strong><span class="math inline">\(\text{ char } R \in \mathbb{ N }\)</span>使得<span class="math inline">\(n 1_R = 0_R \Leftrightarrow \text{ char } R |
n\)</span>.我们还可以知道<span class="math inline">\(\text{ char }
R\)</span>要么是<span class="math inline">\(0\)</span>要么是素数.</p>
<p>怎么证明呢?考虑如果<span class="math inline">\(\text{ char } R =
ab\)</span>,自然有<span class="math inline">\(ab 1_R =
0_R\)</span>,于是<span class="math inline">\(( a 1_R ) ( b 1_R ) =
0_R\)</span>,由于这是一个整环,我们当然有<span class="math inline">\(a
1_R = 0_R \lor b 1_R = 0_R \Rightarrow \text{ char } R | a \lor \text{
char } R | b\)</span>.</p>
<p>如果<span class="math inline">\(R\)</span>中有一个整子环<span class="math inline">\(R_0\)</span>,当然可以发现<span class="math inline">\(\text{ char } R = \text{ char }
R_0\)</span>,于是当然有<span class="math inline">\(\text{ char } R =
\text{ char } \ \text{ Frac } ( R )\)</span>.</p>
<p>另一个性质在于容易发现<span class="math inline">\(\text{ char } R
\times x = 0_R\)</span>.</p>
<h5><span id="整除性">整除性</span></h5>
<p><span class="math inline">\(\forall a , b \in R\)</span>,如果<span class="math inline">\(\exists c \in R , a = bc\)</span>,就称<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的<strong>因子</strong>,记作<span class="math inline">\(b | a\)</span>.我们可以说明<span class="math inline">\(b | a \Leftrightarrow ( a ) \subseteq ( b
)\)</span>,因为对于必要性:<span class="math inline">\(( a ) = aR = bcR
\subseteq bR\)</span>,而对于充分性则是因为<span class="math inline">\(a
\in ( a ) \subseteq ( b )\)</span>.</p>
<p>如果两个元素互为因子,则称它们<strong>相伴</strong>,暂且用<span class="math inline">\(\sim\)</span>代表这种关系.容易验证这等价于<span class="math inline">\(\exists u \in R^\times , a =
bu\)</span>.原因是如果<span class="math inline">\(\exists u , v \in R ,
a = ub , b = va\)</span>,那么<span class="math inline">\(a =
uva\)</span>,由消去律得知<span class="math inline">\(uv =
1\)</span>.此时它们生成的主理想必然相等.相伴关系显然是一种等价关系,<span class="math inline">\(R\)</span>对于相伴关系的商集上的因子关系是一种偏序关系(但不是全序的).</p>
<p>事实上还可以定义<strong>真因子</strong>:如果<span class="math inline">\(( a ) \subsetneq ( b )\)</span>,那么显然<span class="math inline">\(b | a\)</span>,我们称此时<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的真因子.容易发现<span class="math inline">\(b\)</span>是<span class="math inline">\(a\)</span>的真因子当且仅当<span class="math inline">\(b | a\)</span>并且<span class="math inline">\(b\)</span>不与<span class="math inline">\(a\)</span>相伴.</p>
<p>称一个元素<span class="math inline">\(a\)</span>是<strong>不可约元</strong>,当它不是<span class="math inline">\(0\)</span>也不是单位元而且<span class="math inline">\(\forall b , c \in R , a = bc \Rightarrow b \in
R^\times \lor c \in R^{ \times }\)</span>.或者说:<span class="math inline">\(a = bc \Rightarrow c \sim a \lor b \sim
a\)</span>.或者说<span class="math inline">\(a\)</span>不存在真因子.</p>
<p>称一个元素<span class="math inline">\(a\)</span>是<strong>素元</strong>,当它不是<span class="math inline">\(0\)</span>也不是单位元而且<span class="math inline">\(\forall b , c \in R , a | bc \Rightarrow a | b
\lor a | c\)</span>.</p>
<p>我们可以证明:在整环中,素元一定是不可约元,但是不可约元不一定是素元.</p>
<p>如何证明素元一定是不可约元呢?考虑如果<span class="math inline">\(a
\in \mathrm{ prime }\)</span>,并且<span class="math inline">\(a =
bc\)</span>,则<span class="math inline">\(a | bc \Rightarrow a | b \lor
a | c\)</span>,不妨假设<span class="math inline">\(a |
b\)</span>,那么设<span class="math inline">\(b = ad\)</span>,自然有<span class="math inline">\(a = adc\)</span>,<span class="math inline">\(( dc
) = 1\)</span>,于是<span class="math inline">\(c \in \mathrm{ unit
}\)</span>.</p>
<h5><span id="唯一分解整环ufd">唯一分解整环(UFD)</span></h5>
<p>称<span class="math inline">\(R\)</span>是唯一分解整环,如果<span class="math inline">\(\forall a \in R , a \ne 0\)</span>,都可以将<span class="math inline">\(a\)</span>分解成有限个不可约元的乘积的相伴,也就是可以将<span class="math inline">\(a = u \prod_{ k = 1 }^n p_k\)</span>,其中<span class="math inline">\(u \in \mathrm{ unit }\)</span>,<span class="math inline">\(p_k\)</span>是不可约元.并且这种分解需要在相伴意义下唯一,也就是如果存在另一种分解<span class="math inline">\(a = v \prod_{ k = 1 }^m
q_k\)</span>,那么需要满足<span class="math inline">\(n =
m\)</span>并且可以交换乘积顺序使得<span class="math inline">\(p_k\)</span>和<span class="math inline">\(q_k\)</span>相伴.</p>
<p>我们下面可以证明:在唯一分解整环中,不可约元一定也是素元.</p>
<p>不妨设<span class="math inline">\(a\)</span>是不可约元,那么我们要证明<span class="math inline">\(a | bc \Rightarrow a | b \lor a |
c\)</span>.考虑设<span class="math inline">\(ad = bc\)</span>,对<span class="math inline">\(b , c , d\)</span>均作唯一分解,那么<span class="math inline">\(a\)</span>会剩下来并且和对面的某个分解出来的不可约元相伴,自然会有<span class="math inline">\(a | b \lor a | c\)</span>.</p>
<p>在唯一分解整环中可以定义最大公因子.最大公因子当然可能不唯一,但最大公因子之间一定相伴.进一步地,如果最大公因子是可逆元,我们称两个数互素.</p>
<p>当且仅当一个整环有以下两个性质,它是一个唯一分解整环:</p>
<ol type="1">
<li><p>任意不可约元都是素元.</p></li>
<li><p>(存在分解)所有的<span class="math inline">\(r \in R \setminus \{
0 \}\)</span>都能写成有限不可约元的乘积.</p></li>
</ol>
<p>先数学归纳,然后用反证法,假设不成立,那么<span class="math inline">\(r
= \prod p_k = \prod q_j\)</span>.</p>
<p>接下来任取左边的一个<span class="math inline">\(p_1\)</span>,如果右边也有一个<span class="math inline">\(q_1 \sim
p_1\)</span>就直接消去.反之考虑不可约元也是素元,因此<span class="math inline">\(p_1 | \prod q_j\)</span>,因此<span class="math inline">\(\exists j , p_1 | q_j\)</span>,不妨设<span class="math inline">\(tp_1 = q_j\)</span>,因为<span class="math inline">\(q_j\)</span>是不可约元,所以<span class="math inline">\(t \in R^\times\)</span>,所以<span class="math inline">\(p_1 \sim q_j\)</span>.于是唯一分解性自然得出.</p>
<p>另一种等价条件是:</p>
<ol type="1">
<li><p>任意不可约元都是素元.</p></li>
<li><p>主理想的Noether性质:对于一条主理想的链<span class="math inline">\(( a_1 ) \subseteq ( a_2 ) \subseteq
\cdots\)</span>,一定存在一个<span class="math inline">\(k\)</span>,使得从<span class="math inline">\(k\)</span>之后<span class="math inline">\(( a_k )
= ( a_{ k + 1 } ) =
\cdots\)</span>.这条性质也等价于一条因子链一定需要是有限的.</p></li>
</ol>
<p>用主理想的Noether性质直接就可以得出任何一个<span class="math inline">\(r\)</span>都存在有限分解,于是等价于上面那个等价性质.</p>
<p>另外,真实的Noether性质其实是任何一个理想列(不一定是主理想),然而UFD并不一定满足此.最经典的例子是环<span class="math inline">\(\mathbb{ Q } [ x_1 , x_2 , \cdots
]\)</span>,显然<span class="math inline">\(( x_1 ) \subseteq ( x_1 , x_2
) \subseteq \cdots\)</span>.</p>
<h5><span id="主理想整环pid">主理想整环(PID)</span></h5>
<p>如果一个整环的所有理想都是主理想,则称其为一个主理想整环.交换除环当然是主理想整环的一个典型例子.</p>
<p>需要证明PID一定是UFD,对此,我们考虑:</p>
<p>首先证明PID上的不可约元是素元,这里需要拿出裴蜀定理.然而我们目前不能定义最大公因子的概念,因此退而求其次只定义互素的概念:如果<span class="math inline">\(\forall c , c | a \land c | b \Rightarrow c \in
R^\times\)</span>,则称<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>互素.</p>
<p>我们需要证明在主理想整环上有裴蜀定理,换言之如果两个元素互素,那么<span class="math inline">\(\exists x , y \in R , ax + by =
1\)</span>,或者说<span class="math inline">\(( \{ a , b \} ) =
R\)</span>.原因是<span class="math inline">\(\exists h , ( h ) = ( \{ a
, b \} )\)</span>,那么此时必有<span class="math inline">\(h | a \land h
| b\)</span>,于是<span class="math inline">\(h \sim 1\)</span>.</p>
<p>其次需要证明PID上的Noether性质,注意到一条主理想的链<span class="math inline">\(I_1 \subseteq I_2 \subseteq
\cdots\)</span>,直接取<span class="math inline">\(I = \bigcup_j
I_j\)</span>,这个<span class="math inline">\(I\)</span>必然也是理想(乘法封闭性是显然的,加法封闭性的话考虑<span class="math inline">\(\forall x \in I_a , y \in I_b\)</span>,<span class="math inline">\(x + y \in I_{ \max ( a , b )
}\)</span>),那么它就必然是一个主理想,也就是<span class="math inline">\(\exists h , I = ( h )\)</span>.此时注意到<span class="math inline">\(\exists k , h \in I_k\)</span>,那么<span class="math inline">\(I_k = I_{ k + 1 } = \cdots =
I\)</span>,这就证毕了.</p>
<p>综上可看出PID一定是UFD.</p>
<p>设<span class="math inline">\(R\)</span>为主理想整环,<span class="math inline">\(t \in ( R \setminus \{ 0 \} ) \setminus
R^\times\)</span>.那么以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(R / ( t )\)</span>是域.</p></li>
<li><p><span class="math inline">\(R / ( t )\)</span>是整环.</p></li>
<li><p><span class="math inline">\(t\)</span>是素元.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)当然是平凡的,考虑(2)<span class="math inline">\(\Rightarrow\)</span>(3)如何证明:</p>
<p>由于<span class="math inline">\(R / ( t )\)</span>是整环,考虑<span class="math inline">\(t = ab\)</span>,那么我们有<span class="math inline">\(( a + ( t ) ) ( b + ( t ) ) = ab + ( t ) = 0 + ( t
)\)</span>,由于这是一个整环,这必然意味着:</p>
<p><span class="math display">\[
\begin{aligned}
a + ( t ) &amp; = 0 + ( t ) \lor b + ( t ) = 0 + ( t ) \\
&amp; \Rightarrow t | a \lor t | b \\
&amp; \Rightarrow t \sim a \lor t \sim b
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(t\)</span>是不可约元,因此<span class="math inline">\(t\)</span>是素元.</p>
<p>接下来考虑(3)<span class="math inline">\(\Rightarrow\)</span>(1),只需证明非零元<span class="math inline">\(a + ( t
)\)</span>均可逆即可.考虑主理想整环上的裴蜀定理,存在<span class="math inline">\(x , y\)</span>使得<span class="math inline">\(ax =
1 - yt\)</span>,此时<span class="math inline">\(x + ( t
)\)</span>就是<span class="math inline">\(a + ( t )\)</span>的逆元.</p>
<p>还可进一步扩展裴蜀定理,容易证明在主理想环中<span class="math inline">\(( \{ r_1 , \cdots , r_n \} ) = \gcd ( r_1 , \cdots
, r_n ) R\)</span>.</p>
<p>事实上还可以在这里拿出拓展版的中国剩余定理,具体地,如果<span class="math inline">\(a_1 , \cdots , a_n \in R \setminus \{ 0
\}\)</span>,并且它们两两互素,取<span class="math inline">\(a = \prod
a_k\)</span>,那么我们事实上有环同构<span class="math inline">\(\varphi :
R / ( a ) \to \prod_{ k = 1 }^n R / ( a_k ) , r + ( a ) \mapsto ( r + (
a_i ) )_{ k = 1 }^n\)</span>.</p>
<p>用数学归纳只需证明<span class="math inline">\(n =
2\)</span>的情形就可以了.</p>
<p>先证明<span class="math inline">\(\varphi\)</span>是单射,观察<span class="math inline">\(\ker \varphi\)</span>,如果<span class="math inline">\(\varphi ( r + ( a ) ) = ( 0 + ( a_1 ) , 0 + ( a_2
) )\)</span>自然意味着<span class="math inline">\(a_1 | r , a_2 | r
\Rightarrow a | r\)</span>,于是<span class="math inline">\(r + ( a ) = 0
+ ( a )\)</span>,这立刻得到<span class="math inline">\(\varphi\)</span>是单射.</p>
<p>再证明<span class="math inline">\(\varphi\)</span>是满射,用裴蜀定理容易取<span class="math inline">\(x_1 , x_2 \in R\)</span>使得<span class="math inline">\(a_1 x_1 + a_2 x_2 = 1\)</span>,那么<span class="math inline">\(ra_1 x_1 + ra_2 x_2 = r\)</span>,此时注意到<span class="math inline">\(\varphi ( ra_1 x_1 + ( a ) ) = ( 0 + ( a_1 ) , r +
( a_2 ) )\)</span>,<span class="math inline">\(\varphi ( ra_2 x_2 + ( a
) ) = ( r + ( a_1 ) , 0 + ( a_2 )
)\)</span>.这样就可以看出其满性.其实这当然也是中国剩余定理在整数上的构造的类似版本.</p>
<h3><span id="多项式环">多项式环</span></h3>
<h4><span id="一元多项式环">一元多项式环</span></h4>
<p>一个系数属于特定非零环<span class="math inline">\(R\)</span>的一元多项式定义为系数在<span class="math inline">\(R\)</span>上的一元多项式环,记作<span class="math inline">\(R [ x ]\)</span>,注意到如果<span class="math inline">\(R\)</span>是整环,<span class="math inline">\(R [ x
]\)</span>仍然是整环.多元多项式环可以不断在多元多项式环上定义一元多项式环.不妨将一个多项式记作<span class="math inline">\(f ( x )\)</span>.另外如果我们记<span class="math inline">\(R^{ \times }\)</span>为<span class="math inline">\(R\)</span>中可逆元素的集合,那么显然<span class="math inline">\(R [ x ]^{ \times } = R^{ \times }\)</span>.</p>
<p>一般而言,我们下面默认讨论<span class="math inline">\(R\)</span>是整环的情况.</p>
<p>在多项式环上可以定义最高次数函数<span class="math inline">\(\deg\)</span>,容易验证<span class="math inline">\(\deg ( fg ) = \deg f + \deg g , \deg ( f + g )
\leq \max \{ \deg f , \deg g \}\)</span>,可定义<span class="math inline">\(\deg 0 = - \infty\)</span>.</p>
<p>整环上的多项式有长除法和取模运算,也就是对于任意多项式<span class="math inline">\(f\)</span>,以及最高项系数为<span class="math inline">\(1\)</span>的多项式<span class="math inline">\(d\)</span>,存在唯一一组<span class="math inline">\(q , r\)</span>满足<span class="math inline">\(f =
dq + r\)</span>并且<span class="math inline">\(\deg
r\)</span>最小.这样还可以定义整除也就是当<span class="math inline">\(r =
0\)</span>的时候.</p>
<p>长除法的正确性可以反证,如果存在两组,那么自然有<span class="math inline">\(d ( q_1 - q_2 ) = r_2 - r_1\)</span>,如果<span class="math inline">\(q_1 \ne q_2\)</span>,那么<span class="math inline">\(\deg ( q_1 - q_2 ) \geq 0\)</span>,那么<span class="math inline">\(\deg d ( q_1 - q_2 ) \geq \deg
d\)</span>,但是<span class="math inline">\(\deg ( r_2 - r_1 ) &lt; \deg
d\)</span>,这样的话等式就不能成立了.因此必定有<span class="math inline">\(q_1 = q_2 , r_1 = r_2\)</span>.</p>
<p>这就可以保证代入数值操作.因为我们考虑存在唯一的多项式<span class="math inline">\(q\)</span>和唯一一个<span class="math inline">\(s
\in R\)</span>满足<span class="math inline">\(f = ( x - \alpha ) q +
s\)</span>,那我们就可以称<span class="math inline">\(f ( \alpha ) =
s\)</span>.</p>
<p>另外,定义在域<span class="math inline">\(F\)</span>上的多项式<span class="math inline">\(F [ x
]\)</span>是UFD,原因是可以两边对某一个根作长除法.</p>
<h4><span id="多元多项式环">多元多项式环</span></h4>
<p>显然,<span class="math inline">\(R [ x_1 , \cdots , x_n ] \cong ( R [
x_1 , \cdots , x_{ n - 1 } ] ) [ x_n ]\)</span>.</p>
<h4><span id="不可约多项式">不可约多项式</span></h4>
<p>不可约多项式,也就是定义在域上的多项式环上的不可约元.换言之如果<span class="math inline">\(f\)</span>是不可约的,那么对于<span class="math inline">\(f\)</span>的任何一个分解<span class="math inline">\(f = g_1 g_2\)</span>,都一定有<span class="math inline">\(g_1 \in F^\times\)</span>或者<span class="math inline">\(g_1 \in F^\times\)</span>.</p>
<h5><span id="本原多项式">本原多项式</span></h5>
<p>为何我们定义不可约多项式的时候需要定义在域上,而不是简单定义在整环上呢?这是因为,例如,<span class="math inline">\(2 x \in \mathbb{ Z } [ x
]\)</span>,它并非是一个不可约元.但只要把<span class="math inline">\(\mathbb{ Z }\)</span>扩成<span class="math inline">\(\mathbb{ Q }\)</span>,它就成为了一个不可约元.</p>
<p>那么在整数上怎么搞呢?我们考虑设<span class="math inline">\(f = a_0 +
\cdots + a_n x^n \in \mathbb{ Z } [ x ] \setminus \{ 0
\}\)</span>,并设<span class="math inline">\(c ( f ) = | \gcd ( a_0 ,
\cdots , a_n ) |\)</span>,如若<span class="math inline">\(c ( f ) =
1\)</span>,则称其是一个<strong>本原多项式</strong>.</p>
<p>接下来我们有<strong>高斯引理</strong>:如果<span class="math inline">\(g , h \in \mathbb{ Z } [ x
]\)</span>都是本原多项式,那么<span class="math inline">\(gh\)</span>也是本原多项式.</p>
<p>如何证明?考虑对于任何一个素数<span class="math inline">\(p\)</span>,我们找到<span class="math inline">\(g\)</span>中的最高次系数不被<span class="math inline">\(p\)</span>整除,设为<span class="math inline">\(r\)</span>.换言之设<span class="math inline">\(g =
\sum_{ k \geq 0 } a_k x^k\)</span>,则<span class="math inline">\(\forall
k &gt; r , p | a_k\)</span>,而<span class="math inline">\(p \nmid
a_r\)</span>.对<span class="math inline">\(f = \sum_{ k \geq 0 } b_k
x^k\)</span>同样根据上面找到一个最高次<span class="math inline">\(s\)</span>,满足<span class="math inline">\(p \nmid
b_s\)</span>.</p>
<p>现在观察:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; [ x^{ r + s } ] gh \\
= &amp; \sum_{ i + j = r + s } a_i b_j \equiv a_r b_s \pmod{ p } \\
\ne &amp; 0 \pmod{ p }
\end{aligned}
\]</span></p>
<p>这就搞定.</p>
<p>另一个证明策略是干脆把<span class="math inline">\(\mathbb{ Z } \to
\mathbb{ Z } / p \mathbb{ Z
}\)</span>,后者是一个域,于是可以见到其非零.其实和上面是同一个想法,也许后者在做完映射后更好描述.</p>
<p>高斯引理的推论是<span class="math inline">\(c ( gh ) = c ( g ) c ( h
)\)</span>.</p>
<p>接下来我们来搞一些<span class="math inline">\(\mathbb{ Q
}\)</span>上的结构,我们下面来证明,对于本原多项式来说,只要其在<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>上可约,那它就在<span class="math inline">\(\mathbb{ Z } [ x ]\)</span>上可约.换言之,假设<span class="math inline">\(f \in \mathbb{ Z } \setminus \{ 0
\}\)</span>是本原多项式,如果<span class="math inline">\(f =
gh\)</span>,其中<span class="math inline">\(g , h \in \mathbb{ Q } [ x ]
, \deg g &gt; 0 , \deg h &gt; 0\)</span>,那我们断言<span class="math inline">\(\exists \alpha \in \mathbb{ Q
}^\times\)</span>使得<span class="math inline">\(g_1 = \alpha g , h_1 =
\alpha^{ - 1 } h\)</span>使得<span class="math inline">\(g_1 , h_1 \in
\mathbb{ Z } [ x ]\)</span>且它们都是本原多项式.</p>
<p>考虑总存在一对<span class="math inline">\(u , v \in \mathbb{ N
}_+\)</span>使得<span class="math inline">\(ug , vh \in \mathbb{ Z } [ x
]\)</span>,此时有:</p>
<p><span class="math display">\[
uv = c ( uvf ) = c ( ugvh ) = c ( ug ) c ( vh )
\]</span></p>
<p>所以:</p>
<p><span class="math display">\[
f = \frac{ ugvh }{ uv } = \frac{ ug }{ c ( ug ) } \frac{ vh }{ c ( vh )
}
\]</span></p>
<p>这就搞定.</p>
<p>还有一条性质是说,假设<span class="math inline">\(f \in \mathbb{ Z }
\setminus \{ 0 \}\)</span>是本原多项式,当<span class="math inline">\(\deg f &gt; 0\)</span>的时候,下面两个命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{ Q } [ x
]\)</span>上的不可约多项式.</p></li>
<li><p><span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{ Z } [ x
]\)</span>上的不可约多项式.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)的话考虑反证,如若存在<span class="math inline">\(\mathbb{ Z } [ x ]\)</span>上的<span class="math inline">\(g , h\)</span>使得<span class="math inline">\(f =
gh\)</span>,那<span class="math inline">\(f\)</span>在<span class="math inline">\(\mathbb{ Z } [ x ]\)</span>上都可约,当然在<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>上可约.</p>
<p>(2)<span class="math inline">\(\Rightarrow\)</span>(1)的话仍然考虑反证,如果存在<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>上的<span class="math inline">\(g , h\)</span>使得<span class="math inline">\(f =
gh\)</span>,那之前的推论告诉我们<span class="math inline">\(f\)</span>可以分解为两个本原多项式的乘积,这就矛盾了.</p>
<p>接下来我们证明<span class="math inline">\(\mathbb{ Z } [ x
]\)</span>是一个UFD,在此之前,我们先对<span class="math inline">\(\mathbb{ Z } [ x
]\)</span>上的不可约元做分类,我们断言其分为以下两种:</p>
<ol type="1">
<li><p><span class="math inline">\(\mathbb{ Z
}\)</span>的不可约元.</p></li>
<li><p><span class="math inline">\(\deg f &gt; 0\)</span>并且满足<span class="math inline">\(f\)</span>作为<span class="math inline">\(\mathbb{
Q } [ x ]\)</span>上的不可约元的本原多项式<span class="math inline">\(f\)</span>.</p></li>
</ol>
<p>首先<span class="math inline">\(\deg f =
0\)</span>的情况自然是(1),下面尝试分类<span class="math inline">\(\deg f
&gt; 0\)</span>的情况.</p>
<p>如若<span class="math inline">\(c ( f ) \ne 1\)</span>,当然有<span class="math inline">\(f = c ( f ) \frac{ f }{ c ( f )
}\)</span>,因此可约.所以不可约当且仅当<span class="math inline">\(c ( f
) = 1\)</span>,也就是<span class="math inline">\(f\)</span>得是一个本原多项式.那就知道其不可约性可以从<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>过渡到<span class="math inline">\(\mathbb{ Z } [ x ]\)</span>上.</p>
<p>最终我们来说明<span class="math inline">\(\mathbb{ Z } [ x
]\)</span>是唯一分解的,首先可以提系数使得只对本原多项式说明唯一分解性.</p>
<p>既然如此,考虑如果<span class="math inline">\(f\)</span>可以被分解为两种<span class="math inline">\(a_1 \cdots a_r\)</span>和<span class="math inline">\(b_1 \cdots
b_s\)</span>两种,它们都是本原多项式,乘积后亦然,其中<span class="math inline">\(a_i , b_i\)</span>均满足<span class="math inline">\(\deg &gt; 0\)</span>,那么直接扩域到<span class="math inline">\(\mathbb{ Q } [ x
]\)</span>上,由于定义在域上的多项式有唯一分解行,因此<span class="math inline">\(s = r\)</span>而且适当重排后<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>差了一个<span class="math inline">\(\mathbb{ Q
}^\times\)</span>,然而两个本原多项式如果差了一个<span class="math inline">\(\mathbb{ Q
}^\times\)</span>,当然意味着它俩只差一个正负号,这是显然的,就给出了分解的唯一性.</p>
<p>接下来有<strong>Eisenstein判准</strong>,不妨设<span class="math inline">\(n \geq 1\)</span>,而<span class="math inline">\(f
= \sum_{ k = 0 }^n a_k x^k \in \mathbb{ Z } [ x
]\)</span>,如果存在一个素数<span class="math inline">\(p\)</span>满足<span class="math inline">\(p \nmid
a_n\)</span>,而且<span class="math inline">\(p | a_0 , \cdots , a_{ n -
1 }\)</span>,并且<span class="math inline">\(p^2 \nmid
a_0\)</span>,则<span class="math inline">\(f\)</span>是<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>中的不可约多项式.</p>
<p>为证明此,考虑既然<span class="math inline">\(p \nmid
a_n\)</span>,那当然<span class="math inline">\(p \nmid c ( f
)\)</span>,因此,我们可以将<span class="math inline">\(f\)</span>调整为<span class="math inline">\(\frac{
f }{ c ( f ) }\)</span>,这并不会对<span class="math inline">\(p\)</span>的性质产生影响,而可以将<span class="math inline">\(f\)</span>化约成本原多项式的情形.</p>
<p>如何证明呢?考虑反证,对本原多项式来说<span class="math inline">\(\mathbb{ Q } [ x ]\)</span>上不可约等价于在<span class="math inline">\(\mathbb{ Z } [ x
]\)</span>上不可约,假设此情形下<span class="math inline">\(f =
gh\)</span>,其中<span class="math inline">\(g = \sum_{ k = 0 }^m b_k x^k
, h = \sum_{ k = 0 }^l c_k x^k\)</span>,其中<span class="math inline">\(l , m &gt; 0\)</span>,而且<span class="math inline">\(g , h \in \mathbb{ Z } [ x ]\)</span>.</p>
<p>既如此,注意到<span class="math inline">\(a_n = b_m
c_l\)</span>,因此一定有<span class="math inline">\(p \nmid b_m , p \nmid
c_l\)</span>.而又有<span class="math inline">\(p | a_0 = b_0
c_0\)</span>,不妨假设<span class="math inline">\(p |
b_0\)</span>.此时,可以取一个<span class="math inline">\(1 \leq k \leq
m\)</span>,使得<span class="math inline">\(p | b_0 , \cdots , p | b_{ k
- 1 }\)</span>但是有<span class="math inline">\(p \nmid
b_k\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
a_k &amp; \equiv 0 \pmod{ p } \\
\sum_{ j = 0 }^k b_j c_{ k - j } &amp; \equiv 0 \pmod{ p } \\
b_k c_0 &amp; \equiv 0 \pmod{ p }
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(p | c_0\)</span>,所以<span class="math inline">\(p^2 | a_0 = b_0 c_0\)</span>,矛盾.</p>
<p>我们可以在此基础上证明一些有趣的结论:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall n \geq 1\)</span>,<span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(p +
x^n\)</span>是不可约的.</p></li>
<li><p><span class="math inline">\(p\)</span>是质数,则<span class="math inline">\(\Phi_p = 1 + x + \cdots + x^{ p - 1 } = \frac{ x^p
- 1 }{ x - 1 }\)</span>是不可约的.</p></li>
</ol>
<p>对于(2),考虑:</p>
<p><span class="math display">\[
\begin{aligned}
\Phi_p &amp; = \frac{ x^p - 1 }{ x - 1 } \\
&amp; = \frac{ ( x - 1 + 1 )^p - 1 }{ x - 1 } \\
&amp; = \frac{ \sum_{ k = 0 }^p \binom{ p }{ k } ( x - 1 )^k - 1 }{ x -
1 } \\
&amp; = \sum_{ k = 1 }^p \binom{ p }{ k } ( x - 1 )^{ k - 1 }
\end{aligned}
\]</span></p>
<p>取<span class="math inline">\(h ( x ) = \sum_{ k = 1 }^p \binom{ p }{
k } x^{ k - 1 }\)</span>,则<span class="math inline">\(\Phi_p ( x ) = h
( x - 1 )\)</span>,显然,二者的不可约性是等价的,下面观察<span class="math inline">\(h ( x )\)</span>的不可约性.然而<span class="math inline">\(h ( x
)\)</span>当然满足Eisenstein判准,这就搞定.</p>
<p>这里可以见到,其实上面的过程可以全部挪到某个UFD以及与其配套的分式域上,均可以起效果.而且也可以看到在某一个UFD上定义的多项式环也一定是UFD.</p>
<h5><span id="一个判定不可约的算法">一个判定不可约的算法</span></h5>
<p>考虑判定一个<span class="math inline">\(f\)</span>是否可以被拆成两个<span class="math inline">\(f = gh\)</span>,并且它们都在<span class="math inline">\(\mathbb{ Z } [ x ]\)</span>上,其中<span class="math inline">\(\deg g \leq k\)</span>.</p>
<p>如何判断呢?首先我们任取不同的<span class="math inline">\(x_0 , \cdots
, x_k \in \mathbb{ Z }\)</span>,并取<span class="math inline">\(f ( x_0
) , \cdots , f ( x_k )\)</span>,如果它们中有<span class="math inline">\(0\)</span>就完工了对吧.如果没有,我们一定有<span class="math inline">\(g ( x_i ) | f ( x_i )\)</span>,因此<span class="math inline">\(g ( x_i
)\)</span>只有有限种可能性.我们枚举所有的可能性并插值判<span class="math inline">\(g\)</span>.这就给出了一个有限次实现的算法.</p>
<h5><span id="不可约多项式上的扩域">不可约多项式上的扩域</span></h5>
<p>如果域<span class="math inline">\(F\)</span>上的多项式<span class="math inline">\(f \in F [ x
]\)</span>可以分解为若干个一次多项式的乘积,则称其可<strong>分裂</strong>.</p>
<p>那么如果定义在一个域上的每个<span class="math inline">\(\deg \geq
1\)</span>的多项式都分裂,那么就称这个域是<strong>代数闭</strong>的.</p>
<p>定义在域<span class="math inline">\(F\)</span>上的多项式未必有根,但理应在其上面可以做扩域使其有根.具体而言我们对于域<span class="math inline">\(F\)</span>,想要找到一个单同态<span class="math inline">\(\varphi : F \to L\)</span>使得<span class="math inline">\(L\)</span>是一个更大的域.而应当见到<span class="math inline">\(L\)</span>实际上在某种意义上是定义在<span class="math inline">\(F\)</span>上的向量空间.</p>
<p>在这里需要发现的是,定义在域上的<span class="math inline">\(F [ x
]\)</span>一定是主理想整环,原因是可以在理想<span class="math inline">\(I\)</span>中取出<span class="math inline">\(\deg\)</span>最小的一个非零的<span class="math inline">\(f\)</span>,那么其中的任何一个<span class="math inline">\(g \in I\)</span>,用带余除法立刻得到<span class="math inline">\(g = pf + r\)</span>,其中<span class="math inline">\(\deg r &lt; \deg f , r \in
I\)</span>,必然得到<span class="math inline">\(r =
0\)</span>.这意味着<span class="math inline">\(I = ( f
)\)</span>.同时容易见到<span class="math inline">\(\deg f =
0\)</span>的时候,<span class="math inline">\(( f ) = F [ x
]\)</span>.</p>
<p>我们尝试研究<span class="math inline">\(F [ x ] / ( f
)\)</span>的形态,那么见到<span class="math inline">\(\deg f \geq
1\)</span>的时候这个形态应当才是有意义的.构造一个同态<span class="math inline">\(\tau : F \to F [ x ] / ( f ) , a \mapsto a + ( f
)\)</span>,容易见到<span class="math inline">\(\tau\)</span>应当是一个单射,原因是在<span class="math inline">\(\deg f \geq 1\)</span>的前提下,有<span class="math inline">\(\ker \tau = \{ 0 \}\)</span>.此时应当见到<span class="math inline">\(F [ x ] / ( f )\)</span>可以看作一个定义在<span class="math inline">\(F\)</span>上的向量空间.而运用代余除法得知<span class="math inline">\(\{ 1 + ( f ) , x + ( f ) , \cdots , x^{ \deg f - 1
} + ( f ) \}\)</span>显然给出了<span class="math inline">\(F [ x ] / ( f
)\)</span>的一组基.</p>
<p>在此基础上,若<span class="math inline">\(f = \sum a_k
x^k\)</span>,定义<span class="math inline">\(f^\varphi = \sum \varphi (
a_k ) \varphi ( x )^k\)</span>.</p>
<p>由于<span class="math inline">\(F [ x
]\)</span>是主理想环,我们在之前已经证明过了当<span class="math inline">\(f\)</span>不可约的时候,<span class="math inline">\(F [ x ] / ( f )\)</span>是一个域,令<span class="math inline">\(E = F [ x ] / ( f
)\)</span>.回到我们一开始的目的.当<span class="math inline">\(\deg f
\geq 1\)</span>,并且<span class="math inline">\(f\)</span>在<span class="math inline">\(F [ x ]\)</span>环上不可约的时候,若令<span class="math inline">\(\alpha = x + ( f )\)</span>,此时<span class="math inline">\(\alpha\)</span>应作为一个<span class="math inline">\(E\)</span>上的元素,注意到此时:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; f^\tau ( x + ( f ) ) \\
= &amp; \sum ( a_k + ( f ) ) ( x + ( f ) )^k \\
= &amp; \sum a_k x^k + ( f ) \\
= &amp; f + ( f ) = 0 + ( f )
\end{aligned}
\]</span></p>
<p>这意味着在<span class="math inline">\(E [ X ]\)</span>上<span class="math inline">\(f^\tau\)</span>是一个可约的多项式,因为提供了其一个元素<span class="math inline">\(\alpha \in E\)</span>作为其的一个零点.</p>
<p>从上面的过程来看,我们理应可以通过若干次扩张使得一个<span class="math inline">\(f\)</span>在某个<span class="math inline">\(E_r [
X ]\)</span>上是分裂的,其中<span class="math inline">\(r \leq \deg
f\)</span>,也即每一次扩域次数都至少降低<span class="math inline">\(1\)</span>.</p>
<p>我们应当思考这个域扩大了多少,见到如果<span class="math inline">\(\deg
f = n\)</span>,我们一开始已经声明过此时选取基的大小,自然得到<span class="math inline">\([ E_r : F ] = [ E_r : E_{ r - 1 } ] \cdots [ E_1 :
F ] \leq n !\)</span>.</p>
<p>不过我们理应简单说明这样的构造是泛的,具体来讲,我们已经声明过我们需要构造一个交换环<span class="math inline">\(L\)</span>并将<span class="math inline">\(F\)</span>以环同态<span class="math inline">\(\varphi : F \to
L\)</span>的形式嵌入其中,并在环<span class="math inline">\(L\)</span>中找到一个<span class="math inline">\(\beta \in L\)</span>使得<span class="math inline">\(f^\varphi ( \beta ) =
0\)</span>,那么此时应当存在一个唯一的环同态<span class="math inline">\(\psi : E \to L\)</span>使得<span class="math inline">\(\psi ( \alpha ) =
\beta\)</span>,并且下面是一个交换图表:</p>
<p><span class="math display">\[
\xymatrix{ E \ar[r]^\psi &amp; L \\
F \ar[u]^\tau \ar[ru]_\varphi }
\]</span></p>
<p>考察商同态<span class="math inline">\(\pi : F [ x ] \to E = F [ x ] /
( f
)\)</span>,将此关系嵌入上述图表应当得到上述图表交换的等价条件是下述图表交换:</p>
<p><span class="math display">\[
\xymatrix{ F [ x ] \ar[r]^\pi &amp; E \ar[r]^\psi &amp; L \\
&amp; F \ar[ul] \ar[u]^\tau \ar[ru]_\varphi }
\]</span></p>
<p>直接令<span class="math inline">\(\Psi = \psi
\pi\)</span>,上图可以简化为:</p>
<p><span class="math display">\[
\xymatrix{ F [ x ] \ar[rr]^\Psi &amp; &amp; L \\
&amp; F \ar[ul] \ar[ru]_\varphi }
\]</span></p>
<p>现在观察此结构,若我们一开始的假设成立,此图表的确交换并且满足求值同态<span class="math inline">\(\Psi ( x ) = \psi ( \pi ( x ) ) = \psi ( \alpha )
= \beta\)</span>,那么对于一般的多项式<span class="math inline">\(g =
\sum b_k x^k\)</span>,立刻得到<span class="math inline">\(\Psi ( g ) =
\sum \varphi ( b_k ) \beta^n = g^\varphi ( \beta
)\)</span>,这立刻得到了<span class="math inline">\(\Psi\)</span>的唯一性,而直接使用此同态容易证明其存在性.</p>
<p>这个交换图表有什么用呢?来看其在复数上的表现情况.取<span class="math inline">\(F = \mathbb{ R }\)</span>并且<span class="math inline">\(f = x^2 + 1\)</span>,此时<span class="math inline">\(- 1\)</span>自然出现了平方根<span class="math inline">\(\alpha = x + ( x^2 + 1
)\)</span>.此时在上述图表中只需简单规定<span class="math inline">\(i\)</span>具体的正负取值立刻得到一个<span class="math inline">\(\mathbb{ R } [ x ] / ( x^2 + 1 ) \cong \mathbb{ C
}\)</span>的同构.</p>
<h4><span id="对称多项式">对称多项式</span></h4>
<p>将置换的定义,挪到多元多项式环上,具体而言,<span class="math inline">\(\sigma f ( x_1 , \cdots , x_n ) = f ( x_{ \sigma (
1 ) } , \cdots , x_{ \sigma ( n ) } )\)</span>.</p>
<p>那么,如果带<span class="math inline">\(n\)</span>个变元的多项式<span class="math inline">\(f\)</span>其对任意置换都不变,换言之<span class="math inline">\(\forall \sigma , \sigma f =
f\)</span>,则称其是一个<strong>对称多项式</strong>.</p>
<p>我们记<span class="math inline">\(F [ x_1 , \cdots , x_n
]^S\)</span>为所有在域<span class="math inline">\(F\)</span>上定义的<span class="math inline">\(n\)</span>个变元的对称多项式组成的集合,其当然是<span class="math inline">\(F [ x_1 , \cdots , x_n
]\)</span>上的一个子环,因为如果<span class="math inline">\(f ,
g\)</span>对称,那么<span class="math inline">\(fg\)</span>和<span class="math inline">\(\alpha f + \beta
g\)</span>亦然.从这里也可以见到其还是一个线性空间.</p>
<p>接下来定义<span class="math inline">\(e_k = \sum_{ 1 \leq i_1 &lt;
\cdots &lt; i_k \leq n } x_{ i_1 } \cdots x_{ i_k }\)</span>为第<span class="math inline">\(k\)</span>个<strong>初等对称多项式</strong>,例如<span class="math inline">\(e_n = x_1 \cdots x_n , e_1 = x_1 + \cdots +
x_n\)</span>.并且还见到<strong>Vieta公式</strong>:<span class="math inline">\(\prod_{ k = 1 }^n ( y + x_k ) = \sum_{ k = 0 }^n
e_k y^{ n - k }\)</span>或写作<span class="math inline">\(\prod_{ k = 1
}^n ( y - x_k ) = \sum_{ k = 0 }^n ( - 1 )^k e_k y^{ n - k
}\)</span></p>
<p>接下来我们要证明<strong>对称多项式基本定理</strong>,<span class="math inline">\(\forall f \in F [ x_1 , \cdots , x_n ]^S , \exists
g \in F [ x_1 , \cdots , x_n ] , f = g ( e_1 , \cdots , e_n
)\)</span>.</p>
<p>接下来我们定义<span class="math inline">\(f_d = \sum_{ i_1 + \cdots +
i_n = d } c_{ i_1 , \cdots , i_n } x_1^{ i_1 } \cdots x_n^{ i_n
}\)</span>为<span class="math inline">\(d\)</span><strong>齐次多项式</strong>,容易见到任何一个多项式都可以写成若干齐次多项式之和.定义<span class="math inline">\(\deg
f\)</span>为它分解出来的最大的可能非零齐次多项式的次数.</p>
<p>接下来我们证明一个引理:对于<span class="math inline">\(f \in F [ x_1
, \cdots , x_n ]^S\)</span>,则<span class="math inline">\(f ( x_1 ,
\cdots , x_{ n - 1 } , 0 ) = 0\)</span>的充分必要条件是<span class="math inline">\(e_n | f\)</span>.</p>
<p>充分性显然,因为<span class="math inline">\(x_n | e_n\)</span>.</p>
<p>必要性的话,如若<span class="math inline">\(f ( x_1 , \cdots , x_{ n -
1 } , 0 ) = \sum_{ i_n = 0 } c_{ i_1 , \cdots , i_n } x_1^{ i_1 } \cdots
x_{ n - 1 }^{ i_{ n - 1 } } = 0\)</span>,这也就意味着<span class="math inline">\(c_{ i_1 , \cdots , i_n } \ne 0 \Rightarrow i_n
\geq 1\)</span>,而由于对称,意味着<span class="math inline">\(c_{ i_1 ,
\cdots , i_n } \ne 0 \Rightarrow i_k \geq 1\)</span>,这就说明了<span class="math inline">\(e_n | f\)</span>.</p>
<p>对<span class="math inline">\(n\)</span>元对称多项式<span class="math inline">\(h\)</span>,记<span class="math inline">\(h^b = h (
x_1 , \cdots , x_{ n - 1 } , 0 )\)</span>,观察到<span class="math inline">\(h^b\)</span>当然是<span class="math inline">\(n -
1\)</span>次多项式,而且<span class="math inline">\(e_1^b , \cdots , e_{
n - 1 }^b\)</span>正好是第<span class="math inline">\(1 , \cdots , n -
1\)</span>个初等<span class="math inline">\(n -
1\)</span>元对称多项式.</p>
<p>继续考虑证明对称多项式基本定理,首先对于<span class="math inline">\(f
= \sum f_d\)</span>来说,<span class="math inline">\(f\)</span>是对称的当然等价于每一个<span class="math inline">\(f_d\)</span>都是对称的,所以我们下面不妨假设<span class="math inline">\(f = f_d\)</span>.</p>
<p>对于一个<span class="math inline">\(g \in F [ x_1 , \cdots , x_n
]\)</span>,定义其权重为<span class="math inline">\(wt ( g ) =
\begin{cases}\max \{ \sum_{ k = 1 }^n k i_k \mid c_{ i_1 , \cdots , i_n
} \ne 0 \} &amp; g \ne 0 \\ - \infty &amp; g =
0\end{cases}\)</span>.</p>
<p>容易见到<span class="math inline">\(\deg g ( e_1 , \cdots , e_n )
\leq wt ( g )\)</span>,这恰也是我们如此定义权重的原因.</p>
<p>下面我们证明:如果<span class="math inline">\(f\)</span>是<span class="math inline">\(d\)</span>次齐次的,则断言中的<span class="math inline">\(g\)</span>不仅存在还能取到<span class="math inline">\(wt ( g ) \leq d\)</span>.下面我们对<span class="math inline">\(n + d\)</span>递归地论证.</p>
<p>当<span class="math inline">\(d = 0 , f \in
F\)</span>当然是平凡的,下面设<span class="math inline">\(d \geq
1\)</span>.由于数学归纳,我们知道<span class="math inline">\(f^b\)</span>的元数量减少了<span class="math inline">\(1\)</span>.</p>
<p>当<span class="math inline">\(f^b \ne 0\)</span>时,那么如果<span class="math inline">\(f\)</span>是<span class="math inline">\(d\)</span>齐次的,容易见到<span class="math inline">\(f^b\)</span>也该是<span class="math inline">\(d\)</span>齐次的,那此时数学归纳给出存在<span class="math inline">\(g_1 \in F [ x_1 , \cdots , x_{ n - 1 }
]\)</span>使得<span class="math inline">\(f^b = g_1 ( e_1^b , \cdots ,
e_{ n - 1 }^b )\)</span>,而且<span class="math inline">\(\deg g_1 ( e_1
, \cdots , e_{ n - 1 } ) \leq wt ( g_1 ) \leq d\)</span>.</p>
<p>此时设<span class="math inline">\(f_1 = f - g_1 ( e_1 , \cdots , e_{
n - 1 } )\)</span>,立刻见到<span class="math inline">\(f_1^b =
0\)</span>,那么<span class="math inline">\(e_n | f_1\)</span>,取<span class="math inline">\(f_2 = \frac{ f_1 }{ e_n
}\)</span>,这里就可以看到如若<span class="math inline">\(f^b =
0\)</span>,这里直接取<span class="math inline">\(f_1 = f , g_1 =
0\)</span>即可.所以上述讨论在这一步就消掉了.</p>
<p>于是,这里的<span class="math inline">\(f_2\)</span>当然也是对称多项式,并且<span class="math inline">\(\deg f_2 \leq d -
n\)</span>,那将其分解为齐次部分的和,运用递归假设知道存在<span class="math inline">\(f_2 = g_2 ( e_1 , \cdots , e_n ) , wt ( g_2 ) \leq
d - n\)</span>.此时:</p>
<p><span class="math display">\[
\begin{aligned}
f &amp; = f_1 + g_1 ( e_1 , \cdots , e_{ n - 1 } ) \\
&amp; = e_n g_2 ( e_1 , \cdots , e_n ) + g_1 ( e_1 , \cdots , e_{ n - 1
} )
\end{aligned}
\]</span></p>
<p>这就搞定了.</p>
<p>另一个问题是,上述算法只搞定了<span class="math inline">\(f = g ( e_1
, \cdots , e_n )\)</span>的存在性,它是否有唯一性呢?如若有<span class="math inline">\(g ( e_1 , \cdots , e_n ) = h ( e_1 , \cdots , e_n
)\)</span>,则<span class="math inline">\(( g - h ) ( e_1 , \cdots , e_n
) = 0\)</span>.我们应当证明以下定理,称为<span class="math inline">\(e_1
, \cdots , e_n\)</span>的<strong>代数无关性</strong>:</p>
<p>若<span class="math inline">\(g \in F [ x_1 , \cdots , x_n
]\)</span>满足<span class="math inline">\(g ( e_1 , \cdots , e_n ) =
0\)</span>,则<span class="math inline">\(g = 0\)</span>.</p>
<p>考虑证明其逆否命题,也就是<span class="math inline">\(g \ne
0\)</span>的话就一定有<span class="math inline">\(g ( e_1 , \cdots , e_n
) \ne 0\)</span>.</p>
<p>首要的观察是先扩域,如果这个定义在更大的域上满足,在更小的域上当然也满足.因此可以先一步将<span class="math inline">\(F\)</span>扩到一个无穷域上,例如直接将其扩到有理分式域<span class="math inline">\(F ( t )\)</span>上.下面假设<span class="math inline">\(F\)</span>是无穷域.则此时对于任意有限次数非零多项式<span class="math inline">\(g = 0\)</span>,一定存在一组<span class="math inline">\(( y_1 , \cdots , y_n )\)</span>使得<span class="math inline">\(g ( y_1 , \cdots , y_n ) \ne
0\)</span>,这是因为可以数学归纳,当<span class="math inline">\(n =
1\)</span>的时候,其最多只有<span class="math inline">\(\deg
g\)</span>个根但是<span class="math inline">\(F\)</span>无限,因此肯定存在.当<span class="math inline">\(n &gt; 1\)</span>的时候,直接取<span class="math inline">\(g = \sum g_k
x_n^k\)</span>,那么由归纳假设一定存在一组<span class="math inline">\((
y_1 , \cdots y_{ n - 1 } )\)</span>使得至少有一个<span class="math inline">\(g_k \ne 0\)</span>,此时再由<span class="math inline">\(n = 1\)</span>的结论就可以知道原命题成立.</p>
<p>接下来考虑<span class="math inline">\(p = \sum_{ k = 0 }^n x^{ n - k
} ( - 1 )^k
y_k\)</span>,回忆到可以扩域使得该多项式分裂,假设分裂成了<span class="math inline">\(p = \prod_{ k = 1 }^n ( x - x_i
)\)</span>,此时由于Vieta公式,<span class="math inline">\(p = \sum_{ k =
0 }^n ( - 1 )^k e_k ( x_1 , \cdots , x_n ) x^{ n - k
}\)</span>,于是<span class="math inline">\(e_k ( x_1 , \cdots , x_n ) =
y_k\)</span>,这就导出了<span class="math inline">\(g ( e_1 , \cdots ,
e_n ) = g ( y_1 , \cdots , y_n ) \ne 0\)</span>.</p>
<p>容易见到上述论证不涉及域中的除法,所以上述结论对整环也是成立的.</p>
<h5><span id="牛顿公式">牛顿公式</span></h5>
<p>设<span class="math inline">\(p_k = \sum_{ j = 1 }^n
x_j^k\)</span>,这里的<span class="math inline">\(p_0\)</span>其实比较特殊,我们一般不去讨论<span class="math inline">\(p_0\)</span>.那么牛顿公式说:</p>
<ol type="1">
<li><p>当<span class="math inline">\(1 \leq k \leq
n\)</span>的时候,<span class="math inline">\(\sum_{ j = 0 }^{ k - 1 } (
- 1 )^j e_j p_{ k - j } = ( - 1 )^{ k - 1 } k e_k\)</span>.</p></li>
<li><p>当<span class="math inline">\(k &gt; n\)</span>的时候,<span class="math inline">\(\sum_{ j = 0 }^n ( - 1 )^j e_j p_{ k - j } =
0\)</span>.</p></li>
</ol>
<p>牛顿公式的一个相当大的作用是可以用递归的方式用<span class="math inline">\(\{ e_k \}\)</span>和<span class="math inline">\(\{
p_k \}\)</span>相互表示.更进一步地,可以用<span class="math inline">\(\{
e_k \}\)</span>的整系数多项式表示<span class="math inline">\(\{ p_k
\}\)</span>也可以用<span class="math inline">\(\{ p_k
\}\)</span>的有理系数多项式表示<span class="math inline">\(\{ e_k
\}\)</span>,当然对应的域要包含<span class="math inline">\(\mathbb{ Z
}\)</span>和<span class="math inline">\(\mathbb{ Q }\)</span>.</p>
<p>如何证明上面那个结论?考虑以<span class="math inline">\(y\)</span>为变元的形式幂级数,定义:</p>
<p><span class="math display">\[
\begin{aligned}
P ( y ) &amp; = \sum_{ k \geq 1 } p_k y^{ k - 1 } \\
&amp; = \sum_{ k \geq 1 } \sum_{ i = 1 }^n x_i^k y^{ k - 1 } \\
&amp; = \sum_{ i = 1 }^n \frac{ x_i }{ 1 - x_i y }
\end{aligned}
\]</span></p>
<p>再定义:</p>
<p><span class="math display">\[
\begin{aligned}
E ( y ) &amp; = \sum_{ k = 0 }^n e_k y^k \\
&amp; = \prod_{ i = 1 }^n ( 1 + x_i y )
\end{aligned}
\]</span></p>
<p>接下来观察到:</p>
<p><span class="math display">\[
\begin{aligned}
P ( - y ) &amp; = \sum_{ i = 1 }^n \frac{ x_i }{ 1 + x_i y } \\
&amp; = \frac{ \mathrm{ d } }{ \mathrm{ d } y } \ln E ( y ) \\
&amp; = \frac{ E &#39; ( y ) }{ E ( y ) }
\end{aligned}
\]</span></p>
<p>接下来观察:</p>
<p><span class="math display">\[
\begin{aligned}
E ( y ) P ( - y ) &amp; = E &#39; ( y ) \\
&amp; = \sum_{ k = 1 }^n k e_k y^{ k - 1 }
\end{aligned}
\]</span></p>
<p>可是左边直接展开就有:</p>
$$
<span class="math display">\[\begin{aligned}
E ( y ) P ( - y ) &amp; = ( \sum_{ l = 0 }^n e_l ( - y )^l ) ( \sum_{ j
\geq 1 } p_j y^{ j - 1 } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>两边提取<span class="math inline">\([ y^{ k - 1 }
]\)</span>,就有:</p>
<p><span class="math display">\[
\sum_{ l + j = k , 0 \leq l \leq n , j \geq 1 } e_l p_{ j } ( - 1 )^{ j
- 1 } = k e_k
\]</span></p>
<p>两边倒腾一下正负号就是牛顿公式.</p>
<h4><span id="结式">结式</span></h4>
<p>让<span class="math inline">\(F\)</span>是一个域并且<span class="math inline">\(f , g \in F [ x
]\)</span>,我们想要检验它们是否互素.一个好的算法当然是辗转相除法,但我们更想去找一个精确的量来判定.例如矩阵的行列式可以用消元法求,然而我们也可以用代数余子式展开.</p>
<p>具体地,考虑<span class="math inline">\(F [ x ]\)</span>的元素:</p>
<p><span class="math display">\[
\begin{aligned}
f &amp; = v_0 x^n + \cdots + v_n \\
g &amp; = w_0 x^m + \cdots + w_m
\end{aligned}
\]</span></p>
<p>注意这里并不要求<span class="math inline">\(v_0 , w_0 \ne
0\)</span>,结式并不在乎这个.</p>
<p>我们定义<span class="math inline">\(f ,
g\)</span>的<strong>结式</strong>为:</p>
<p><span class="math display">\[
Res ( f , g ) = \left | \begin{matrix}
v_0 &amp; \cdots &amp; \cdots &amp; v_n &amp; &amp; \\
&amp; \ddots &amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; v_0 &amp; \cdots &amp; \cdots &amp; v_n \\
w_0 &amp; \cdots &amp; \cdots &amp; w_m &amp; &amp; \\
&amp; \ddots &amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; w_0 &amp; \cdots &amp; \cdots &amp; w_m
\end{matrix} \right |
\]</span></p>
<p>其中上面那个平行四边形是<span class="math inline">\(m\)</span>行的,下面那个是<span class="math inline">\(n\)</span>行的.这样总共就是<span class="math inline">\(( n + m ) \times ( n + m
)\)</span>的,该行列式的定义是有意义的.如若将系数<span class="math inline">\(v_0 , \cdots ,
w_m\)</span>视作变量,容易见到上述行列式仍然是关于<span class="math inline">\(v_0 , \cdots , w_m\)</span>的整系数<span class="math inline">\(n + m + 2\)</span>元多项式,且系数和<span class="math inline">\(F\)</span>无关.</p>
<p>考虑下述性质:</p>
<ol type="1">
<li><p><span class="math inline">\([ v_0^m w_m^n ] Res ( f , g ) =
1\)</span>.</p></li>
<li><p><span class="math inline">\(Res ( g , f ) = ( - 1 )^{ nm } Res (
f , g )\)</span>.</p></li>
<li><p><span class="math inline">\(\forall t \in F , Res ( tf , g ) =
t^m Res ( f , g ) , Res ( f , tg ) = t^n Res ( f , g
)\)</span>.</p></li>
</ol>
<p>考虑(1),应当见到第<span class="math inline">\(m\)</span>行的那个<span class="math inline">\(v_0\)</span>恰好是第<span class="math inline">\(m\)</span>列,所以上述行列式对角线恰好由<span class="math inline">\(m\)</span>个<span class="math inline">\(v_0\)</span>和<span class="math inline">\(n\)</span>个<span class="math inline">\(w_m\)</span>构成,根据行列式最初始的那个排列定义,要凑出<span class="math inline">\(v_0^m w_m^n\)</span>就只能沿着对角线乘.</p>
<p>考虑(2),只需要交换行列即可对吧,每次把<span class="math inline">\(v\)</span>那里的最后一行暴力换到最下面,这样就需要交换<span class="math inline">\(nm\)</span>次.</p>
<p>(3)是显然的.</p>
<p>接下来证明一个引理:如果<span class="math inline">\(Res ( f , g ) =
0\)</span>,当且仅当<span class="math inline">\(\exists f_1 , g_1 \in F [
x ]\)</span>满足<span class="math inline">\(\deg f_1 &lt; n , \deg g_1
&lt; m\)</span>并且<span class="math inline">\(f_1\)</span>和<span class="math inline">\(g_1\)</span>不全为<span class="math inline">\(0\)</span>,使得<span class="math inline">\(fg_1 +
gf_1 = 0\)</span>.</p>
<p>不妨展开<span class="math inline">\(f_1\)</span>和<span class="math inline">\(g_1\)</span>如下:</p>
<p><span class="math display">\[
\begin{aligned}
f_1 &amp; = a_1 x^{ n - 1 } + \cdots + a_n \\
g_1 &amp; = b_1 x^{ m - 1 } + \cdots + b_m
\end{aligned}
\]</span></p>
<p>如若设<span class="math inline">\(H = fg_1 + gf_1 =
0\)</span>,那么:</p>
<p><span class="math display">\[
\begin{aligned}
[ x^{ n + m - 1 } ] H &amp; = b_1 v_0 + a_1 w_0 = 0 \\
[ x^{ n + m - 2 } ] H &amp; = b_1 v_1 + b_2 v_0 + a_1 w_1 + a_2 w_0 = 0
\\
\cdots \\
[ x^{ 0 } ] H &amp; = b_m v_n + a_n w_m = 0
\end{aligned}
\]</span></p>
<p>如果假设<span class="math inline">\(v_0 , \cdots ,
w_m\)</span>均是已知量而尝试求解<span class="math inline">\(f_1 ,
g_1\)</span>,自然拿到了一个大小为<span class="math inline">\(n +
m\)</span>的线性方程组,容易见到其系数矩阵为:</p>
<p><span class="math display">\[
\begin{bmatrix}
v_0 &amp; &amp; &amp; w_0 &amp; &amp; \\
\vdots &amp; \ddots &amp; &amp; \vdots &amp; \ddots &amp; \\
v_n &amp; &amp; v_0 &amp; w_m &amp; &amp; w_0 \\
&amp; \ddots &amp; \vdots &amp; &amp; \ddots &amp; \vdots \\
&amp; &amp; v_n &amp; &amp; &amp; w_m
\end{bmatrix}
\]</span></p>
<p>(很遗憾这里把第<span class="math inline">\(n + 1\)</span>行和第<span class="math inline">\(m +
1\)</span>行画到一行了,然而是无奈之举,请读者自行在脑中错开一下位置)</p>
<p>线性方程组理论告诉我们这有一组非<span class="math inline">\(0\)</span>解当且仅当行列式为<span class="math inline">\(0\)</span>,然而这恰好是<span class="math inline">\(Res ( f , g
)\)</span>的转置,而行列式转置不变,这就证毕.</p>
<p>下面我们证明,<span class="math inline">\(Res ( f , g ) =
0\)</span>当且仅当以下任何一个条件成立:</p>
<ol type="1">
<li><p><span class="math inline">\(v_0 = w_0 = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\deg \gcd ( f , g ) &gt;
0\)</span>.</p></li>
</ol>
<p>(1)是平凡的,只需观察上述行列式定义即可发现此时第一列全部为<span class="math inline">\(0\)</span>,那行列式当然为<span class="math inline">\(0\)</span>.</p>
<p>对于(2),先证必要性,考虑如果<span class="math inline">\(\exists h ,
\deg h &gt; 0\)</span>,<span class="math inline">\(h | f , h |
g\)</span>,那么注意到<span class="math inline">\(\deg \frac{ f }{ h }
&lt; n , \deg \frac{ g }{ h } &lt; m\)</span>而且由于<span class="math inline">\(v_0\)</span>和<span class="math inline">\(w_0\)</span>不全为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(\frac{
f }{ h } , \frac{ g }{ h }\)</span>不全为<span class="math inline">\(0\)</span>,而<span class="math inline">\(f \frac{
g }{ h } - g \frac{ f }{ h } = 0\)</span>,用引理得证<span class="math inline">\(Res ( f , g ) = 0\)</span>.</p>
<p>再证(2)的充分性.如若<span class="math inline">\(f ,
g\)</span>其一为<span class="math inline">\(0\)</span>,不失一般性设<span class="math inline">\(f = 0\)</span>.如若此时<span class="math inline">\(\deg g &gt; 0\)</span>,则取<span class="math inline">\(h = g\)</span>自然是公因式;如若<span class="math inline">\(\deg g = 0\)</span>,容易见到<span class="math inline">\(w_0 = Res ( f , g ) =
0\)</span>,这就是(1)的情况.</p>
<p>如若<span class="math inline">\(f , g\)</span>都不是<span class="math inline">\(0\)</span>,而且<span class="math inline">\(v_0 ,
w_0\)</span>不全为<span class="math inline">\(0\)</span>,不妨设<span class="math inline">\(w_0 \ne 0\)</span>,既如此<span class="math inline">\(g \ne 0\)</span>,此时如若<span class="math inline">\(Res ( f , g ) = 0\)</span>,由引理拿到了<span class="math inline">\(f_1 , g_1\)</span>不全为<span class="math inline">\(0\)</span>并且使得<span class="math inline">\(fg_1
+ gf_1 = 0\)</span>,其中<span class="math inline">\(\deg g_1 &lt;
m\)</span>.</p>
<p>直接把当前的多项式环<span class="math inline">\(F [ x
]\)</span>扩到有理分式域<span class="math inline">\(F ( x
)\)</span>,此时有<span class="math inline">\(\frac{ f }{ g } g_1 =
f_1\)</span>,两边通分立刻见到,如果<span class="math inline">\(\deg gcd (
f , g ) = 0\)</span>,那么左边就是<span class="math inline">\(f \frac{
g_1 }{ g }\)</span>,这应该给出<span class="math inline">\(g |
g_1\)</span>,然而<span class="math inline">\(\deg g = m , \deg g_1 &lt;
m\)</span>,不符.这就证毕.</p>
<p>最后,我们来讨论一下当<span class="math inline">\(f ,
g\)</span>均是分裂的时候如何体现,不妨设<span class="math inline">\(f = a
\prod_{ k }^n ( x - \alpha_k ) , g = b \prod_{ k }^m ( x - \beta_k
)\)</span>,我们下面证明:</p>
<p><span class="math display">\[
\begin{aligned}
Res ( f , g ) &amp; = a^m \prod_k^n g ( \alpha_k ) = ( - 1 )^{ nm } b^n
\prod_j^m f ( \beta_j ) \\
&amp; = a^m b^n \prod_{ k , j } ( \alpha_k - \beta_j )
\end{aligned}
\]</span></p>
<p>有一连串等式,其中中间两个是对称的<span class="math inline">\(Res ( f
, g )\)</span>和<span class="math inline">\(Res ( g , f
)\)</span>的形式,而最后一个等式只需带入就属显然.因此需要证明的只有第一个等式.</p>
<p>由于<span class="math inline">\(Res ( tf , g ) = t^m Res ( f , g
)\)</span>,所以不妨设<span class="math inline">\(a = 1\)</span>.</p>
<p>假设<span class="math inline">\(g ( \alpha_1 ) , \cdots , g (
\alpha_n )\)</span>两两相异,则引入一个新的变元<span class="math inline">\(y\)</span>并在<span class="math inline">\(F [ y
]\)</span>上考虑<span class="math inline">\(Res ( f , g - y
)\)</span>,回看一开始的矩阵形状,对于<span class="math inline">\([ y^n ]
Res ( f , g - y
)\)</span>,见到其意味着下半部分的对角线被全部选择,上半部分选择的话如果非零当然也要选择对角线,所以<span class="math inline">\([ y^n ] Res ( f , g - y ) = ( - 1
)^n\)</span>,而显然<span class="math inline">\([ y^0 ] Res ( f , g - y )
= Res ( f , g )\)</span>.既然如此,注意到<span class="math inline">\(\alpha_k\)</span>是<span class="math inline">\(f\)</span>和<span class="math inline">\(g - g (
\alpha_k )\)</span>的公共根,则<span class="math inline">\(Res ( f , g -
g ( \alpha_k ) ) = 0\)</span>,从而<span class="math inline">\(( g (
\alpha_k ) - y ) | Res ( f , g - y )\)</span>,又由于<span class="math inline">\(g ( \alpha_1 ) , \cdots , g ( \alpha_n
)\)</span>两两相异,<span class="math inline">\(\prod_k ( g ( \alpha_k )
- y ) , Res ( f , g - y )\)</span>的最高次系数都是<span class="math inline">\(( - 1
)^n\)</span>,这立刻意味着它们相等,原命题自然成立.</p>
<p>然而既然如此,可以见到直接假设<span class="math inline">\(\alpha_1 ,
\cdots , \alpha_n\)</span>并非常数而是若干个变元,具体而言用<span class="math inline">\(z_1 , \cdots ,
z_n\)</span>代替它们,于是上述立刻有<span class="math inline">\(g ( z_1 )
, \cdots , g ( z_n )\)</span>两两相异,得到结论后带入<span class="math inline">\(\alpha_1 , \cdots , \alpha_n\)</span>即可.</p>
<h4><span id="判别式">判别式</span></h4>
<p>对于一个多项式<span class="math inline">\(f = \sum_k c_k ( - 1 )^{ k
} x^{ n - k }\)</span>,假设其可分裂而且<span class="math inline">\(f =
\prod_j ( x - \alpha_j )\)</span>,我们称其判别式<span class="math inline">\(disc ( f ) = \prod_{ i &lt; j } ( \alpha_i -
\alpha_j )^2\)</span>如果我们将<span class="math inline">\(\alpha_1 ,
\cdots , \alpha_n\)</span>看作变量,则我们注意到<span class="math inline">\(disc ( f )\)</span>是一个对称多项式,原因是<span class="math inline">\(disc ( f ) = ( \prod_{ i &lt; j } ( \alpha_i -
\alpha_j ) )^2\)</span>,而中间那个东西在重排后会差一个<span class="math inline">\(\mathrm{ { sgn } } ( \sigma
)\)</span>,这就证毕.</p>
<p>既然如此,<span class="math inline">\(disc ( f
)\)</span>就可以拆成<span class="math inline">\(e_1 , \cdots ,
e_n\)</span>这若干个对称多项式的多项式,然而注意到由于Vieta公式,<span class="math inline">\(e_1 = c_1 , \cdots , e_n = c_n\)</span>.于是<span class="math inline">\(disc ( f )\)</span>当然是关于<span class="math inline">\(c_1 , \cdots ,
c_n\)</span>的多项式.这里由于没有讨论具体的值,而只是把这些涉及到的值用变量来表示,所以你可以先一步把范围控制在整环<span class="math inline">\(\mathbb{ Z }\)</span>上,见到<span class="math inline">\(disc ( f )\)</span>当然是关于<span class="math inline">\(c_1 , \cdots , c_n\)</span>的整系数多项式.</p>
<p>例如当<span class="math inline">\(n = 2\)</span>的时候,<span class="math inline">\(f ( x ) = x^2 - bx + c = ( x - \alpha_1 ) ( x -
\alpha_2 )\)</span>,那么<span class="math inline">\(disc ( f ) = (
\alpha_1 - \alpha_2 )^2 = ( \alpha_1 + \alpha_2 )^2 - 4 \alpha_1
\alpha_2 = b^2 - 4 c\)</span>,这就是二次方程的判别式.</p>
<p>取<span class="math inline">\(n =
3\)</span>的时候,特别地取二次项为<span class="math inline">\(0\)</span>的情况,<span class="math inline">\(f =
x^3 + px + q = ( x - \alpha_1 ) ( x - \alpha_2 ) ( x - \alpha_3 ) ,
\alpha_1 + \alpha_2 + \alpha_3 = 0\)</span>,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
disc ( f ) &amp; = \left ( ( \alpha_1 - \alpha_2 ) ( \alpha_2 - \alpha_3
) ( \alpha_1 - \alpha_3 ) \right )^2 \\
&amp; = - 4 p^3 - 27 q^2
\end{aligned}
\]</span></p>
<p>而如果将判别式的定义推广到非首一的情形,也就是对于<span class="math inline">\(f = a \prod_j ( x - \alpha_j
)\)</span>,我们称其判别式<span class="math inline">\(disc ( f ) = a^{ 2
n - 2 } \prod_{ i &lt; j } ( \alpha_i - \alpha_j )^2\)</span>,对<span class="math inline">\(f\)</span>有形式导数<span class="math inline">\(f
&#39;\)</span>,我们下面证明:<span class="math inline">\(a \cdot disc ( f
) = ( - 1 )^{ \frac{ n ( n - 1 ) }{ 2 } } Res ( f , f &#39;
)\)</span>.</p>
<p>证明的话,用Leibniz法则,知道:</p>
<p><span class="math display">\[
\begin{aligned}
f &#39; &amp; = a \sum_{ k = 1 }^n \prod_{ j \ne k } ( x - \alpha_j ) \\
f &#39; ( \alpha_k ) &amp; = a \prod_{ j \ne k } ( \alpha_k - \alpha_j )
\end{aligned}
\]</span></p>
<p>因此:</p>
<p><span class="math display">\[
\begin{aligned}
Res ( f , f &#39; ) &amp; = a^{ n - 1 } \prod_{ k = 1 }^n f &#39; (
\alpha_k ) \\
&amp; = a^{ 2 n - 1 } \prod_{ k = 1 }^n \prod_{ j \ne k } ( \alpha_k -
\alpha_j ) \\
&amp; = a^{ 2 n - 1 } ( - 1 )^{ \frac{ n ( n - 1 ) }{ 2 } } \prod_{ i
&lt; j } ( \alpha_i - \alpha_j )^2
\end{aligned}
\]</span></p>
<p>这就证毕.</p>
<p>顺便一提,将<span class="math inline">\(f = a_0 x^n + \cdots +
a_n\)</span>,则<span class="math inline">\(Res ( f , f &#39;
)\)</span>是<span class="math inline">\(a_0 , \cdots ,
a_n\)</span>的整系数多项式,而其行列式首列能提出<span class="math inline">\(a = a_0\)</span>,因此<span class="math inline">\(a^{ - 1 } Res ( f , f &#39;
)\)</span>确实表作<span class="math inline">\(a_0 , \cdots ,
a_n\)</span>的整系数多项式,这说明<span class="math inline">\(disc ( f
)\)</span>在<span class="math inline">\(f\)</span>非首一的时候定义确实合理.</p>
<h3><span id="域">域</span></h3>
<p>设<span class="math inline">\(D\)</span>是含有至少两个元素的幺环,如果<span class="math inline">\(D\)</span>的每个元素都可逆,则称<span class="math inline">\(D\)</span>是一个<strong>体</strong>.有乘法交换律的体称为<strong>域</strong>.</p>
<h4><span id="分式域">分式域</span></h4>
<p>之前尝试使用过商集来用<span class="math inline">\(\mathbb{ Z
}\)</span>构造<span class="math inline">\(\mathbb{ Q
}\)</span>,我们同样可以用整环的商集来构造形如<span class="math inline">\(\frac{ f }{ g }\)</span>的域,将其记作<span class="math inline">\(\text{ Frac } ( R
)\)</span>,也就是<strong>分式域</strong>.</p>
<p>可以说明如果<span class="math inline">\(\varphi : R \rightarrow R
&#39;\)</span>并且<span class="math inline">\(\varphi ( R \setminus \{ 0
\} ) \subseteq R &#39;^{ \times }\)</span>,又取一个<span class="math inline">\(i : R \rightarrow \text{ Frac }
R\)</span>,那么存在唯一一个映射<span class="math inline">\(\Phi : \text{
Frac } R \rightarrow R &#39;\)</span>的映射.更具体来说,只需验证<span class="math inline">\(\Phi ( \frac{ f }{ g } ) \equiv \varphi ( f )
\varphi ( g )^{ - 1 }\)</span>即可(当然需要检验良定义).</p>
<p>如果我们将一开始的映射改为<span class="math inline">\(\varphi : R
\hookrightarrow F\)</span>,其中<span class="math inline">\(F\)</span>是一个域并且<span class="math inline">\(\forall x \in F , \exists f , g \in R , x =
\varphi ( f ) \varphi ( g )^{ - 1 }\)</span>,那我们可以证明<span class="math inline">\(\text{ Frac } ( R ) \cong
F\)</span>,过程太无聊,略过.</p>
<p>这说明分式域具有某种唯一性和泛性质.</p>
<p>一般把<span class="math inline">\(\text{ Frac } ( R [ x ]
)\)</span>写作<span class="math inline">\(R ( x )\)</span>.</p>
<h4><span id="子域">子域</span></h4>
<p>由于子域的交还是子域,我们当然可以取所有子域的交得到一个子域<span class="math inline">\(F_{ \mathrm{ prime } }\)</span>,容易验证当<span class="math inline">\(\text{ char } F_{ \mathrm{ prime } } =
0\)</span>的时候,<span class="math inline">\(F_{ \mathrm{ prime } }
\cong \mathbb{ Q }\)</span>;当<span class="math inline">\(p = \text{
char } F_{ \mathrm{ prime } } \in \mathrm{ prime }\)</span>的时候,<span class="math inline">\(F_{ \mathrm{ prime } } \cong \mathbb{ Z } /
\mathbb{ Z }_p\)</span>.</p>
<h2><span id="线性代数">线性代数</span></h2>
<h3><span id="矩阵引入">矩阵引入</span></h3>
<p>我们称有<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列的<strong>矩阵</strong>为<span class="math inline">\(A_{ m \times n }\)</span>,其中第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的元素称作<span class="math inline">\(a_{ i , j
}\)</span>,也有的称其为<strong>矩阵元</strong>.</p>
<p>也可以将其中中的列写作<span class="math inline">\(F^m\)</span>中列向量的形式,即写作<span class="math inline">\(A_{ m \times n } = \begin{bmatrix}\vec{ a_1 }
&amp; \vec{ a_2 } &amp; . . . &amp; \vec{ a_n
}\end{bmatrix}\)</span>.</p>
<p>若<span class="math inline">\(n = m\)</span>,则称<span class="math inline">\(A\)</span>为<strong>方阵</strong>.</p>
<h4><span id="矩阵运算">矩阵运算</span></h4>
<p>大小相同的矩阵本身应当是一个线性空间.事实上,我们可以定义:</p>
<ol type="1">
<li><p><strong>矩阵加法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是<span class="math inline">\(m \times
n\)</span>矩阵,则它们的和也是<span class="math inline">\(m \times
n\)</span>矩阵,且元素为<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>中对应元素的加和.显然有交换律.</p></li>
<li><p><strong>标量乘法</strong>:若<span class="math inline">\(c\)</span>是标量而<span class="math inline">\(A\)</span>是一个<span class="math inline">\(m
\times n\)</span>矩阵,则<span class="math inline">\(cA\)</span>是一个<span class="math inline">\(m
\times n\)</span>矩阵,且元素为A中对应元素的<span class="math inline">\(c\)</span>倍.显然有交换律以及对矩阵加法的分配律.</p></li>
</ol>
<p>事实上,我们还可以定义:</p>
<ol start="3" type="1">
<li><strong>矩阵乘法</strong>:若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times
n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n \times p\)</span>矩阵,那么它们的乘积<span class="math inline">\(AB_{ i , j } = \sum_{ k = 1 }^n A_{ i , k } B_{ k
, j }\)</span>.</li>
</ol>
<p>矩阵乘法也可以表示为:若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n \times
p\)</span>矩阵,且<span class="math inline">\(B = \begin{bmatrix}\vec{
b_1 } &amp; \vec{ b_2 } &amp; . . . &amp; \vec{ b_p
}\end{bmatrix}\)</span>那么它们的乘积<span class="math inline">\(AB =
\begin{bmatrix}A \vec{ b_1 } &amp; A \vec{ b_2 } &amp; . . . &amp; A
\vec{ b_p }\end{bmatrix}\)</span>.</p>
<p>若<span class="math inline">\(AB = BA\)</span>我们称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>彼此<strong>可交换</strong>.</p>
<p>不难发现<span class="math inline">\(\forall A_{ m \times n
}\)</span>,对于矩阵<span class="math inline">\(I_{ n \times n } =
\begin{bmatrix}1 &amp; 0 &amp; . . . &amp; 0 \\ 0 &amp; 1 &amp; . . .
&amp; 0 \\ . . . &amp; . . . &amp; . . . &amp; . . . \\ 0 &amp; 0 &amp;
. . . &amp; 1\end{bmatrix}\)</span>有<span class="math inline">\(AI =
A\)</span>,我们称<span class="math inline">\(I_{ n \times n
}\)</span>为<strong>单位矩阵</strong>.单位矩阵的第<span class="math inline">\(i\)</span>列通常记作<span class="math inline">\(\vec{ e }_i\)</span>.</p>
<p>定义<strong>乘幂</strong><span class="math inline">\(A^k\)</span>为<span class="math inline">\(k\)</span>个<span class="math inline">\(A\)</span>连续相乘的乘积.</p>
<p>设<span class="math inline">\(A\)</span>为<span class="math inline">\(m \times n\)</span>矩阵,<span class="math inline">\(B\)</span>和<span class="math inline">\(C\)</span>的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li><p>乘法结合律:<span class="math inline">\(( AB ) C = A ( BC
)\)</span>.</p></li>
<li><p>乘法左分配律:<span class="math inline">\(A ( B + C ) = AB +
AC\)</span>.</p></li>
<li><p>乘法右分配律:<span class="math inline">\(( B + C ) A = BA +
CA\)</span>.</p></li>
<li><p><span class="math inline">\(c ( AB ) = ( cA ) B = A ( cB
)\)</span>.</p></li>
<li><p>乘法恒等式:<span class="math inline">\(I_m A = A =
AI_n\)</span>.</p></li>
</ol>
<p>注意到向量可以看为一个<span class="math inline">\(n \times
1\)</span>的矩阵,事实上,我们有:</p>
<p>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{ a_1 } , \vec{ a_2 } , . . . \vec{ a_n
}\)</span>,而<span class="math inline">\(\vec{ u } , \vec{ v } \in
\mathbb{ R }^n\)</span>,那么:</p>
<ol type="1">
<li><p><span class="math inline">\(A ( \vec{ u } + \vec{ v } ) = A \vec{
u } + A \vec{ v }\)</span>.</p></li>
<li><p><span class="math inline">\(A ( c \vec{ u } ) = c ( A \vec{ u }
)\)</span>.</p></li>
</ol>
<p>定义<strong>矩阵转置</strong>:对于<span class="math inline">\(m
\times n\)</span>矩阵<span class="math inline">\(A\)</span>,它的<strong>转置</strong>是一个<span class="math inline">\(n \times m\)</span>矩阵,该矩阵的列是由<span class="math inline">\(A\)</span>的对应行构成的,记作<span class="math inline">\(A^T\)</span>,即<span class="math inline">\(A^T_{ i
, j } = A_{ j , i }\)</span>.有的时候也写作<span class="math inline">\(^t A\)</span>.</p>
<p>设<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的维数使下列各式的乘积有定义,c是标量,有:</p>
<ol type="1">
<li><p><span class="math inline">\(( A^T )^T = A\)</span>.</p></li>
<li><p><span class="math inline">\(( A + B )^T = A^T +
B^T\)</span>.</p></li>
<li><p><span class="math inline">\(( rA )^T = rA^T\)</span>.</p></li>
<li><p><span class="math inline">\(( AB )^T = B^T A^T\)</span>.</p></li>
</ol>
<h4><span id="分块矩阵">分块矩阵</span></h4>
<p>我们考虑将一个矩阵看作若干个子矩阵的拼接,类似于我们求逆矩阵时做的那样:将若干个矩阵拼接起来.</p>
<p>换句话说,我们尝试将矩阵看作元素放入矩阵中,并尝试根据基本的矩阵运算去做这种矩阵的运算.</p>
<p>分块矩阵的<strong>矩阵加法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>维数相同且都以同样的方式分块,则矩阵的和<span class="math inline">\(A + B\)</span>也以同样的方式分块且每一块都是<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>对应块的和.</p>
<p>分块矩阵的<strong>标量乘法</strong>:若<span class="math inline">\(c\)</span>是一个常数,<span class="math inline">\(A\)</span>是一个分块矩阵,则<span class="math inline">\(cA\)</span>是<span class="math inline">\(A\)</span>的子矩阵乘<span class="math inline">\(c\)</span>再以同样的方式组合起来的结果.</p>
<p>分块矩阵的<strong>矩阵乘法</strong>:若矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的维数使得<span class="math inline">\(AB\)</span>有定义,并且<span class="math inline">\(A\)</span>列的分法与<span class="math inline">\(B\)</span>行的分法一致,那我们显然可以直接将矩阵作为元素来直接进行矩阵乘法.</p>
<p>由上面的讨论自然发现:</p>
<p>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>矩阵,<span class="math inline">\(B\)</span>是<span class="math inline">\(n \times
p\)</span>矩阵,我们定义<span class="math inline">\(row_i ( A
)\)</span>为<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列,<span class="math inline">\(col_i ( A
)\)</span>为<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行,则:</p>
<p><span class="math inline">\(AB = \begin{bmatrix}col_1 ( A ) &amp;
col_2 ( A ) &amp; . . . &amp; col_n ( A )\end{bmatrix}
\begin{bmatrix}row_1 ( B ) \\ row_2 ( B ) \\ . . \\ row_n ( B
)\end{bmatrix}\)</span></p>
<p>证明是显然的.</p>
<h3><span id="线性方程组">线性方程组</span></h3>
<p>包含变量<span class="math inline">\(x_1 , x_2 . . . ,
x_n\)</span>的<strong>线性方程</strong>是形如<span class="math inline">\(a_1 x_2 + a_2 x_2 + . . . + a_n x_n =
b\)</span>的方程,其中b与系数是实数或复数,通常是已知数.</p>
<p><strong>线性方程组</strong>是由一个或几个包含相同变量<span class="math inline">\(x_1 , x_2 , . . . ,
x_n\)</span>的线性方程组成的.</p>
<p><strong>线性方程组的解</strong>是一组数<span class="math inline">\(\{
s_1 , s_2 , . . . , s_n \}\)</span>,用这组数分别代替<span class="math inline">\(x_1 , x_2 , . . .
x_n\)</span>时所有方程的两边相等.</p>
<p>线性方程组所有可能的解的集合称为<strong>线性方程组的解集</strong>.</p>
<p>若两个线性方程组有相同的解集,则称这两个方程组是<strong>等价的</strong>.</p>
<p>我们称一个线性方程组是<strong>相容的</strong>,当且仅当它有一个解或无穷多个解,否则,称其为<strong>不相容的</strong>.</p>
<p>一个线性方程组要么无解,要么有一个解,要么有无穷多个解.</p>
<h4><span id="系数矩阵和增广矩阵">系数矩阵和增广矩阵</span></h4>
<p>考虑以下m个线性方程所组成的线性方程组:</p>
<p><span class="math display">\[
\begin{cases}
a_{ 1 , 1 } x_1 + a_{ 1 , 2 } x_2 + . . . + a_{ 1 , n } x_n = b_1 \\
a_{ 2 , 1 } x_1 + a_{ 2 , 2 } x_2 + . . . + a_{ 2 , n } x_n = b_2 \\
. . . \\
a_{ m , 1 } x_1 + a_{ m , 2 } x_2 + . . . + a_{ m , n } x_n = b_m
\end{cases}
\]</span></p>
<p>我们称它的<strong>系数矩阵</strong>为:</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{ 1 , 1 } &amp; a_{ 1 , 2 } &amp; . . . &amp; a_{ 1 , n } \\
a_{ 2 , 1 } &amp; a_{ 2 , 2 } &amp; . . . &amp; a_{ 2 , n } \\
. . . &amp; . . . &amp; . . . &amp; . . . \\
a_{ m , 1 } &amp; a_{ m , 2 } &amp; . . . &amp; a_{ m , n }
\end{bmatrix}
\]</span></p>
<p>两个系数矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<p>而称它的<strong>增广矩阵</strong>为:</p>
<p><span class="math display">\[
\begin{bmatrix}
a_{ 1 , 1 } &amp; a_{ 1 , 2 } &amp; . . . &amp; a_{ 1 , n } &amp; b_1 \\
a_{ 2 , 1 } &amp; a_{ 2 , 2 } &amp; . . . &amp; a_{ 2 , n } &amp; b_2 \\
. . . &amp; . . . &amp; . . . &amp; . . . &amp; . . . \\
a_{ m , 1 } &amp; a_{ m , 2 } &amp; . . . &amp; a_{ m , n } &amp; b_m
\end{bmatrix}
\]</span></p>
<p>两个增广矩阵是<strong>等价的</strong>当且仅当它们所对应的线性方程组是等价的.</p>
<h4><span id="矩阵的初等行变换">矩阵的初等行变换</span></h4>
<p>考虑如何解一个线性方程:根据我们已有的知识,等式可以任意两端加减相等的两项,也可以同时乘以一个不为0的数,同时等式的顺序并不重要.</p>
<p>我们用这一点来考虑如何解线性方程组.这里主要是考虑如何对线性方程组的增广矩阵进行变换.</p>
<p>由上面的知识,我们意识到对线性方程组的增广矩阵进行以下变换,是不会改变其解集的:</p>
<ol type="1">
<li><p>(倍加变换)把某一行换成它本身与另一行的倍数的和,记作<span class="math inline">\(R_i + kR_j \rightarrow R_i\)</span>.</p></li>
<li><p>(对换变换)把两行对换,记作<span class="math inline">\(R_i
\leftrightarrow R_j\)</span>.</p></li>
<li><p>(倍乘变换)把某一行的所有元素乘以同一个非零数<span class="math inline">\(k\)</span>,记作<span class="math inline">\(kR_i
\rightarrow R_i , k \ne 0\)</span>.</p></li>
</ol>
<p>以上三种变换称为<strong>矩阵的初等行变换</strong>,同理可以定义初等列变换.</p>
<p>由此可以发现,两个增广矩阵是等价的当且仅当其中一个增广矩阵可以通过若干次初等行变换变为另一个增广矩阵.</p>
<p>我们可以使用这些初等行变换来变换一个矩阵,使得它有一些特殊性质.</p>
<p>如果两个矩阵可以通过若干次初等行变换而转化,我们称二者<strong>行等价</strong>,不难证明行等价满足等价关系的三个性质(反身性,对称性,传递性).</p>
<p>由于简化行阶梯矩阵的唯一性,我们可以用其来判定行等价类.</p>
<h4><span id="阶梯形矩阵">阶梯形矩阵</span></h4>
<p>若矩阵的一行的元素全为0,称这一行为矩阵的一个<strong>零行</strong>,否则称为<strong>非零行</strong>.</p>
<p>非零行的最左边的非零元素称为该行的<strong>先导元素</strong>.</p>
<p>若一个矩阵有以下性质,则称它为<strong>阶梯形矩阵(REF)</strong>:</p>
<ol type="1">
<li><p>每一个非零行都在零行之上</p></li>
<li><p>某一行的先导元素所在的列位于前一行先导元素的右边</p></li>
<li><p>某一先导元素所在列下方元素都是0</p></li>
</ol>
<p>若一个矩阵还满足以下性质,则称它为<strong>简化阶梯形(RREF)</strong>:</p>
<ol start="4" type="1">
<li><p>每一非零行的先导元素是1</p></li>
<li><p>每一先导元素1是该元素所在列唯一的非零元素</p></li>
</ol>
<p>显然,任意一个矩阵都可以通过若干次初等行变换变为一个阶梯形矩阵或简化阶梯形矩阵.</p>
<p>一个矩阵所对应的阶梯形矩阵中先导元素的位置,被称为这个矩阵的一个<strong>主元位置</strong>,包含一个主元位置的列称为<strong>主元列</strong>.</p>
<p>注意:这里的位置是矩阵中的位置而非元素的位置,这也就是说主元位置上的元素可以不是最终的主元位置上的元素移动而来的.</p>
<h5><span id="简化阶梯形矩阵的唯一性">简化阶梯形矩阵的唯一性</span></h5>
<p>每个矩阵通过初等行变换只有可能对应唯一一个简化阶梯形矩阵.</p>
<p>证明:假设两个行等价的简化阶梯形矩阵不相等.那么我们找到它们的第一个不相等的列,设为<span class="math inline">\(j\)</span>.</p>
<p>如果<span class="math inline">\(A , B\)</span>中的<span class="math inline">\(j\)</span>均为主元列,显然它们这一列必然相等,不符.</p>
<p>反之,我们不妨去掉第<span class="math inline">\(j\)</span>列后面的所有列以及第<span class="math inline">\(j\)</span>列前面的所有非主元列,保留第<span class="math inline">\(j\)</span>列考虑剩下的两个矩阵一定也是行等价的,但它们对应的线性方程组的解显然不同,这导出了矛盾.</p>
<h4><span id="解线性方程组">解线性方程组</span></h4>
<p>考虑将线性方程组的增广矩阵通过初等行变换变换为一个简化阶梯形矩阵,我们称对应于主元列的变量为<strong>基本变量</strong>,其它变量称为<strong>自由变量</strong>.</p>
<p>如果线性方程组是相容的,显然我们可以使用自由变量表示基本变量,从而得到一组解.我们得到的基本变量的关于自由变量的表达式称作解集的<strong>参数表示</strong>.</p>
<p>这也意味着,如果没有自由变量,该方程组只有一解;如果有自由变量,由于自由变量取值任意,该方程组有无数组解.</p>
<p>而考虑何时线性方程组不相容,由于自由变脸取值任意,显然唯一的不相容可能性只是出现了<span class="math inline">\(0 x_1 + 0 x_2 + . . . + 0 x_n = b , b \ne
0\)</span>的情况.</p>
<p>以上的分析过程引出下面的定理.</p>
<h5><span id="存在与唯一性定理">存在与唯一性定理</span></h5>
<p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列.</p>
<p>若线性方程组相容,则它的解集可能有两种情形:</p>
<ol type="1">
<li><p>没有自由变量时,只有一个解.</p></li>
<li><p>有自由变量时,有无数个解.</p></li>
</ol>
<h4><span id="矩阵方程">矩阵方程</span></h4>
<p>设<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>的矩阵,它的各列是<span class="math inline">\(\vec{ a_1 } , \vec{ a_2 } , . . . , \vec{ a_n
}\)</span>,若<span class="math inline">\(\vec{ x }\)</span>是<span class="math inline">\(F^n\)</span>中向量,则<span class="math inline">\(A
\vec{ x }\)</span>即A的各列以<span class="math inline">\(\vec{ x
}\)</span>中对应元素为权的线性组合,也就是:</p>
<p><span class="math inline">\(A \vec{ x } = \begin{bmatrix}\vec{ a_1 }
&amp; \vec{ a_2 } &amp; . . . &amp; \vec{ a_n }\end{bmatrix}
\begin{bmatrix}x_1 \\ x_2 \\ . . . \\ x_n\end{bmatrix} = x_1 \vec{ a_1 }
+ x_2 \vec{ a_2 } + . . . + x_n \vec{ a_n }\)</span></p>
<p>如果令<span class="math inline">\(\vec{ b } \in
F^m\)</span>,那么上式可以写成<span class="math inline">\(A \vec{ x } =
\vec{ b }\)</span>,我们把形如这样的方程称作矩阵方程.</p>
<p>不难发现,若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{ a_1 } , \vec{ a_2 } , . . . \vec{ a_n
}\)</span>,而<span class="math inline">\(\vec{ b } \in F^m , \vec{ x }
\in F^n\)</span>,那么:</p>
<p>矩阵方程<span class="math inline">\(A \vec{ x } = \vec{ b
}\)</span>,向量方程<span class="math inline">\(x_1 \vec{ a_1 } + x_2
\vec{ a_2 } + . . . + x_n \vec{ a_n } = \vec{ b
}\)</span>,增广矩阵为<span class="math inline">\(\begin{bmatrix}\vec{
a_1 } &amp; \vec{ a_2 } &amp; . . . &amp; \vec{ a_n } &amp; \vec{ b
}\end{bmatrix}\)</span>的线性方程组有相同的解集.</p>
<p>事实上,若<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times n\)</span>矩阵,它的各列为<span class="math inline">\(\vec{ a_1 } , \vec{ a_2 } , . . . \vec{ a_n
}\)</span>,那么以下命题逻辑等价:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall \vec{ b } \in
F^m\)</span>,方程<span class="math inline">\(A \vec{ x } = \vec{ b
}\)</span>有解.</p></li>
<li><p><span class="math inline">\(\forall \vec{ b } \in
F^m\)</span>,<span class="math inline">\(\vec{ b }\)</span>是<span class="math inline">\(A\)</span>的列的一个线性组合.</p></li>
<li><p><span class="math inline">\(A\)</span>的各列生成<span class="math inline">\(\mathbb{ R }^m\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span>在每一行都有一个主元位置.</p></li>
</ol>
<h4><span id="齐次线性方程组">齐次线性方程组</span></h4>
<p>若一个线性方程组可以被写成<span class="math inline">\(A \vec{ x } =
\vec{ 0 }\)</span>的形式,其中<span class="math inline">\(A\)</span>是<span class="math inline">\(m \times
n\)</span>的矩阵,<span class="math inline">\(\vec{ x }\)</span>是<span class="math inline">\(\mathbb{ R
}^n\)</span>中的向量,称其为<strong>齐次线性方程组</strong>.</p>
<p>显然齐次线性方程组至少有一个解,即<span class="math inline">\(\vec{ x
} = \vec{ 0
}\)</span>,这个解称作线性齐次方程组的<strong>平凡解</strong>.</p>
<p>而满足<span class="math inline">\(\vec{ x } \ne \vec{ 0
}\)</span>的解称作线性齐次方程组的<strong>非平凡解</strong>.</p>
<p>根据存在与唯一性定理,显然其存在非平凡解的充要条件是该方程至少有一个自由变量.</p>
<p>考虑自由变量的取值任意,而且基本变量一定是由若干个自由变量乘以定值之和得到的.</p>
<p>我们把这些定值看作向量,把自由向量看作权重,我们发现:齐次线性方程组的解集总可以表示为<span class="math inline">\(\mathrm{ Span } \{ \vec{ v_1 } , \vec{ v_2 } , . .
. , \vec{ v_{ p } }
\}\)</span>,当然,如果该方程组仅有平凡解,那表示为<span class="math inline">\(\mathrm{ Span } \{ \vec{ 0 } \}\)</span>.</p>
<p>把解表示为<span class="math inline">\(\mathrm{ Span } \{ \vec{ v_1 }
, \vec{ v_2 } , . . . , \vec{ v_{ p } }
\}\)</span>中元素的形式,称之为<strong>解的参数向量形式</strong>.</p>
<p>对于方程<span class="math inline">\(A \vec{ x } = \vec{ b
}\)</span>,它的解一定可以写成<span class="math inline">\(\vec{ x } =
\vec{ p } + \vec{ x &#39; }\)</span>的形式,其中<span class="math inline">\(\vec{ x &#39; }\)</span>是方程<span class="math inline">\(A \vec{ x } = \vec{ 0 }\)</span>的一组解,<span class="math inline">\(\vec{ p }\)</span>是方程<span class="math inline">\(A \vec{ x } = \vec{ b }\)</span>的一组特解.</p>
<p>对于该定理的几何意义,我们考虑<span class="math inline">\(\vec{ x }
\in \mathbb{ R }^2\)</span>中,即<span class="math inline">\(\vec{ x } =
\vec{ p } + t \vec{ u
}\)</span>,如果我们把它看为向量加法的形式,它的解集应该是在一条直线上的任意向量,这条直线即<span class="math inline">\(\vec{ u }\)</span>所在直线沿向量<span class="math inline">\(\vec{ p }\)</span>方向平移后的直线.</p>
<h3><span id="线性空间">线性空间</span></h3>
<p>我们可以在一个域<span class="math inline">\(F\)</span>上定义一个<strong>线性空间</strong>(向量空间)<span class="math inline">\(V\)</span>,除了域本身带有的性质(加法的结合律交换律,加法单位元,加法逆元,乘法对加法有分配律)它应当满足以下公理:</p>
<ol type="1">
<li><p>定义向量加法<span class="math inline">\(V \times V \rightarrow
V\)</span>.向量加法应当有交换律和结合律.</p></li>
<li><p>定义标量乘法<span class="math inline">\(F \times V \rightarrow
V\)</span>.标量乘法应当有交换律,结合律以及对向量加法的分配律.</p></li>
<li><p>存在加法幺元以及加法逆元.</p></li>
</ol>
<p>由于<span class="math inline">\(V\)</span>对加法构成群,相应的性质可以从群的性质搬过来.</p>
<p>值得一提的是,其实标量乘法如果定义成<span class="math inline">\(V
\times F \rightarrow
V\)</span>后会有相当多的好处,但是由于历史原因一般还是定义左标量乘法.</p>
<p>当然容易验证我们平常用的线性空间<span class="math inline">\(V =
F^n\)</span>满足以上性质.</p>
<p>当然容易验证定义在域上的多项式环满足以上性质.</p>
<h4><span id="相关运算">相关运算</span></h4>
<h5><span id="直积">直积</span></h5>
<p>定义<span class="math inline">\(\prod_{ i \in I } V_i = ( \vec{ v }_i
)_{ i \in I } , \vec{ v }_i \in
V_i\)</span>为直积,容易发现线性空间的直积也是线性空间.</p>
<h5><span id="直和">直和</span></h5>
<p>我们如果取直积的一个子空间,使得至多只有有限个<span class="math inline">\(i \in I\)</span>使得<span class="math inline">\(\vec{ v }_i \ne 0\)</span>,则称这是一个直和.</p>
<h5><span id="叉乘">叉乘</span></h5>
<p>对<span class="math inline">\(\mathbb{ R
}^3\)</span>,定义新的向量运算:向量积(叉乘)<span class="math inline">\(\vec{ a } \times \vec{ b }\)</span>,
其运算结果仍为向量,设为<span class="math inline">\(\vec{ c
}\)</span>,它的模定义为<span class="math inline">\(\vec{ a } \times
\vec{ b } = | \vec{ a } | | \vec{ b } | \sin \theta\)</span>,其中<span class="math inline">\(\theta\)</span>为向量<span class="math inline">\(\vec{ a } , \vec{ b }\)</span>的夹角,<span class="math inline">\(| \vec{ c } |\)</span>为以<span class="math inline">\(a , b\)</span>为两边的平行四边形的面积,<span class="math inline">\(\vec{ c }\)</span>的方向定义为与<span class="math inline">\(\vec{ a } , \vec{ b
}\)</span>所形成的平面垂直,且<span class="math inline">\(\vec{ a } ,
\vec{ b } , \vec{ c }\)</span>构成右手螺旋定则(即现将四指指向<span class="math inline">\(\vec{ a }\)</span>方向再将四指弯曲指向<span class="math inline">\(\vec{ b }\)</span>的方向,则此时大拇指的方向为<span class="math inline">\(\vec{ c }\)</span>的方向),</p>
<p>向量叉乘满足以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\vec{ a } \times \vec{ b } = - \vec{
b } \times \vec{ a }\)</span>.</p></li>
<li><p><span class="math inline">\(\vec{ a } \times \vec{ a } = \vec{ 0
}\)</span></p></li>
<li><p><span class="math inline">\(\vec{ a } \times ( \vec{ b } + \vec{
c } ) = \vec{ a } \times \vec{ b } + \vec{ a } \times \vec{ c
}\)</span>.</p></li>
</ol>
<p>在三维坐标系中,设:</p>
<p><span class="math display">\[
\begin{aligned}
\vec{ a } &amp; = a_1 \vec{ i } + b_1 \vec{ j } + c_1 \vec{ k } \\
\vec{ b } &amp; = a_2 \vec{ i } + b_2 \vec{ j } + c_2 \vec{ k }
\end{aligned}
\]</span></p>
<p>由叉乘定义,得到:<span class="math inline">\(\vec{ c } = ( a_y b_z -
a_z b_y ) \vec{ i } + ( a_z b_x - a_x b_z ) \vec{ j } + ( a_x b_y - a_y
b_x ) \vec{ k }\)</span>.也就是:</p>
<p><span class="math display">\[
\vec{ c } = \vec{ a } \times \vec{ b } = \left | \begin{matrix}
\vec{ i } &amp; \vec{ j } &amp; \vec{ k } \\
a_x &amp; a_y &amp; a_z \\
b_x &amp; b_y &amp; b_z
\end{matrix} \right |
\]</span></p>
<p>对于任意一个面的法向量，我们总可以选取该面上的两个不共线向量来直接叉乘出来.</p>
<h4><span id="线性无关与线性相关">线性无关与线性相关</span></h4>
<p>称<span class="math inline">\(V\)</span>中一组向量<span class="math inline">\(\{ \vec{ v_1 } , \vec{ v_2 } , . . . , \vec{ v_p }
\}\)</span>是<strong>线性无关</strong>的,当且仅当向量方程<span class="math inline">\(x_1 \vec{ v_1 } + x_2 \vec{ v_2 } + . . . + x_p
\vec{ v_p } = \vec{ 0 }\)</span>仅有平凡解.</p>
<p>反之,称为<strong>线性相关</strong>,即存在一组不全为0的数<span class="math inline">\(c_1 , c_2 , . . . , c_p\)</span>使<span class="math inline">\(c_1 \vec{ v_1 } + c_2 \vec{ v_2 } + . . . + c_p
\vec{ v_p } = \vec{ 0 }\)</span>,这个式子也被称为<span class="math inline">\(\{ \vec{ v_1 } , \vec{ v_2 } , . . . , \vec{ v_p }
\}\)</span>之间的<strong>线性相关关系</strong>.</p>
<p>容易发现,两个或更多向量的集合<span class="math inline">\(S = \{ \vec{
v_1 } , \vec{ v_2 } , . . . , \vec{ v_p }
\}\)</span>线性相关,当且仅当其中至少有一个向量是其它向量的线性组合.</p>
<h4><span id="子空间">子空间</span></h4>
<p>我们定义<span class="math inline">\(V\)</span>的一个<strong>子空间</strong>是它的一个非空子集<span class="math inline">\(V_0\)</span>,具有以下三个性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\vec{ 0 } \in V_0\)</span>.</p></li>
<li><p><span class="math inline">\(\forall \vec{ u } , \vec{ v } \in V_0
, \vec{ u } + \vec{ v } \in V_0\)</span>.</p></li>
<li><p><span class="math inline">\(\forall \vec{ u } \in V_0 , c \in F ,
c \vec{ u } \in V_0\)</span>.</p></li>
</ol>
<p>线性空间的两个平凡子空间当然是零空间和它本身.</p>
<p>容易验证两个子空间的交仍然是子空间.</p>
<h5><span id="向量的线性组合">向量的线性组合</span></h5>
<p>给定<span class="math inline">\(V\)</span>中向量<span class="math inline">\(\vec{ v }_1 , \vec{ v }_2 , . . . , \vec{ v
}_p\)</span>和标量<span class="math inline">\(c_1 , c_2 , . . . , c_p
\in F\)</span>.</p>
<p>我们称向量<span class="math inline">\(\overrightarrow{ y } = c_1
\overrightarrow{ v_1 } + c_2 \overrightarrow{ v_2 } + . . . + c_p
\overrightarrow{ v_p }\)</span>为向量<span class="math inline">\(\overrightarrow{ v_1 } , \overrightarrow{ v_2 } ,
. . . , \overrightarrow{ v_p }\)</span>以<span class="math inline">\(c_1
, c_2 , . . . , c_p\)</span>为权的<strong>线性组合</strong>.</p>
<p>对于向量<span class="math inline">\(\overrightarrow{ v_1 } ,
\overrightarrow{ v_2 } , . . . , \overrightarrow{ v_p
}\)</span>,我们称它们的所有线性组合所成的集合为<span class="math inline">\(\mathrm{ Span } \{ \overrightarrow{ v_1 } ,
\overrightarrow{ v_2 } , . . . , \overrightarrow{ v_p }
\}\)</span>,也称为由<span class="math inline">\(\overrightarrow{ v_1 } ,
\overrightarrow{ v_2 } , . . . , \overrightarrow{ v_p
}\)</span>所<strong>生成</strong>的<span class="math inline">\(V\)</span>的子集,有时也记作<span class="math inline">\(\langle \vec{ v }_1 , \vec{ v }_2 , \cdots , \vec{
v }_p \rangle\)</span>.</p>
<p>不难发现,<span class="math inline">\(\mathrm{ Span
}\)</span>集合是<span class="math inline">\(V\)</span>的一个子空间,而且容易证明其是包含<span class="math inline">\(\{ \vec{ v }_1 , \vec{ v }_2 , \cdots , \vec{ v
}_p \}\)</span>的最小的子空间,所以我们又称其为由<span class="math inline">\(\overrightarrow{ v_1 } , \overrightarrow{ v_2 } ,
. . . , \overrightarrow{ v_p
}\)</span>所<strong>生成</strong>的子空间.</p>
<p>可以考虑一些特殊线性空间上<span class="math inline">\(\mathrm{ Span
}\)</span>的几何意义:</p>
<p>对于<span class="math inline">\(\mathbb{ R }^2\)</span>,当<span class="math inline">\(\vec{ v_1 }\)</span>和<span class="math inline">\(\vec{ v_2 }\)</span>不在一条直线上的时候,<span class="math inline">\(\mathrm{ Span } \{ \vec{ v_1 } , \vec{ v_2 }
\}\)</span>显然对应了整个平面.</p>
<p>对于<span class="math inline">\(\mathbb{ R }^3\)</span>,当<span class="math inline">\(\vec{ v_1 }\)</span>和<span class="math inline">\(\vec{ v_2 }\)</span>不在一条直线上的时候,<span class="math inline">\(\mathrm{ Span } \{ \vec{ v_1 } , \vec{ v_2 }
\}\)</span>显然对应了三维空间中的一个过<span class="math inline">\(\vec{
v_1 } , \vec{ v_2 }\)</span>这两条直线的平面.</p>
<p>要判断<span class="math inline">\(\overrightarrow{ b
}\)</span>是否在<span class="math inline">\(\mathrm{ Span } \{
\overrightarrow{ v_1 } , \overrightarrow{ v_2 } , . . . ,
\overrightarrow{ v_p } \}\)</span>中，即判断向量方程<span class="math inline">\(x_1 \overrightarrow{ v_1 } + x_2 \overrightarrow{
v_2 } + . . . + x_p \overrightarrow{ v_p } = \overrightarrow{ b
}\)</span>是否有解.</p>
<h5><span id="线性映射">线性映射</span></h5>
<p>映射<span class="math inline">\(T : V \rightarrow
W\)</span>是线性的,当且仅当它满足以下两个条件:</p>
<ol type="1">
<li><p>对<span class="math inline">\(T\)</span>的定义域中一切的向量<span class="math inline">\(\vec{ u } , \vec{ v }\)</span>,满足<span class="math inline">\(T ( \vec{ u } + \vec{ v } ) = T ( \vec{ u } ) + T
( \vec{ v } )\)</span>.</p></li>
<li><p>对<span class="math inline">\(T\)</span>的定义域中一切的向量<span class="math inline">\(\vec{ u }\)</span>和数<span class="math inline">\(c\)</span>,满足<span class="math inline">\(T ( c
\vec{ u } ) = cT ( \vec{ u } )\)</span>.</p></li>
</ol>
<p>线性映射有以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(T ( \vec{ 0 } ) = \vec{ 0
}\)</span>.</p></li>
<li><p>(叠加原理):<span class="math inline">\(T ( c_1 \vec{ v }_1 + c_2
\vec{ v }_2 + . . . + c_p \vec{ v }_p ) = c_1 T ( \vec{ v }_1 ) + c_2 T
( \vec{ v }_2 ) + . . . + c_p T ( \vec{ v }_p )\)</span>.</p></li>
</ol>
<p>称线性映射<span class="math inline">\(T : V \rightarrow
W\)</span>是<strong>可逆的</strong>或者<strong>同构的</strong>,当且仅当存在<span class="math inline">\(T^{ - 1 } : W \rightarrow V\)</span>.</p>
<p>我们可以验证<span class="math inline">\(T^{ - 1
}\)</span>也是线性映射,原因在于此时<span class="math inline">\(T\)</span>是双射:</p>
<p><span class="math display">\[
\begin{aligned}
T^{ - 1 } ( \vec{ w } + \vec{ w } &#39; ) &amp; = T^{ - 1 } ( \vec{ w }
) + T^{ - 1 } ( \vec{ w } &#39; ) \\
&amp; \Leftrightarrow \\
T ( T^{ - 1 } ( \vec{ w } + \vec{ w } &#39; ) ) &amp; = T ( T^{ - 1 } (
\vec{ w } ) + T^{ - 1 } ( \vec{ w } &#39; ) )
\end{aligned}
\]</span></p>
<p>而且:</p>
<p><span class="math display">\[
\begin{aligned}
T^{ - 1 } ( t \vec{ w } ) &amp; = tT^{ - 1 } ( \vec{ w } ) \\
&amp; \Leftrightarrow \\
T ( T^{ - 1 } ( t \vec{ w } ) ) &amp; = T ( tT^{ - 1 } ( \vec{ w } ) )
\end{aligned}
\]</span></p>
<p>我们记<span class="math inline">\(\text{ Hom } ( V , W
)\)</span>为所有的<span class="math inline">\(V \rightarrow
W\)</span>,并且其中的<span class="math inline">\(V ,
W\)</span>都是定义在<span class="math inline">\(F\)</span>上的线性空间的线性映射组成的集合.容易验证<span class="math inline">\(\text{ Hom } ( V , W )\)</span>构成<span class="math inline">\(F\)</span>上的线性空间.特别地,定义<span class="math inline">\(\text{ End } ( V ) = \text{ Hom } ( V , V
)\)</span>,容易发现<span class="math inline">\(\text{ End } ( V
)\)</span>是对复合和加法操作一个环.</p>
<p>特别地,定义矩阵映射<span class="math inline">\(T : F^n \rightarrow
F^m\)</span>为<span class="math inline">\(T ( \vec{ x } ) = A \vec{ x
}\)</span>,其中<span class="math inline">\(A\)</span>是一个<span class="math inline">\(m \times
n\)</span>的矩阵.矩阵映射显然是线性映射.</p>
<h5><span id="基和维数">基和维数</span></h5>
<p><span class="math inline">\(V\)</span>中子空间<span class="math inline">\(H\)</span>的一组<strong>基</strong>是<span class="math inline">\(H\)</span>中一个线性无关集,它生成<span class="math inline">\(H\)</span>.</p>
<p>事实上,以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>是<span class="math inline">\(V\)</span>的一组基.</p></li>
<li><p><span class="math inline">\(S\)</span>是极小的能生成<span class="math inline">\(V\)</span>的集合(不存在其的一个真子集能生成<span class="math inline">\(V\)</span>).</p></li>
<li><p><span class="math inline">\(S\)</span>是极大的<span class="math inline">\(V\)</span>中的线性无关集(不存在其的一个真张集线性无关).</p></li>
</ol>
<p>证明上列命题等价是容易的.</p>
<p>对于<span class="math inline">\(F^n\)</span>来说,其的基有更好的性质,我们称<span class="math inline">\(\{ \vec{ e }_1 , . . . , \vec{ e }_n \} , \vec{ e
}_i = \{ 0 , 0 , \cdots , 0 , 1 , 0 , \cdots \}\)</span>为<span class="math inline">\(F^n\)</span>的<strong>标准基</strong>.</p>
<p>对于<span class="math inline">\(n \times
m\)</span>的矩阵组成的线性空间,其当然也有一组标准基<span class="math inline">\(\{ \vec{ e }_{ i , j } \}\)</span>.</p>
<p>有如下结论:</p>
<ol type="1">
<li><p>(承认选择公理)对于任何一个线性无关的子集<span class="math inline">\(S\)</span>,存在一个基<span class="math inline">\(\mathcal{ B }\)</span>使得<span class="math inline">\(S \subseteq \mathcal{ B }\)</span>.特别地,取<span class="math inline">\(S =
\emptyset\)</span>可以说明任何一个线性空间总是有基.</p></li>
<li><p>(有限生成的情况)如果一个线性空间的子集<span class="math inline">\(S\)</span>满足<span class="math inline">\(| S |
&gt; | \mathcal{ B } |\)</span>,其中<span class="math inline">\(\mathcal{ B }\)</span>是一组有限大小的基,那么<span class="math inline">\(S\)</span>线性相关.</p></li>
<li><p>如果一个线性空间有两组基<span class="math inline">\(\mathcal{ B_1
} , \mathcal{ B_2 }\)</span>,那么<span class="math inline">\(| \mathcal{
B_1 } | = | \mathcal{ B_2 } |\)</span>.</p></li>
</ol>
<p>现在考虑(1)的证明,拿出所有的线性无关的<span class="math inline">\(T
\supseteq
S\)</span>并组成一个集合,用包含关系作为偏序关系,如果能证明其满足Zorn引理的条件,那当然可以取出一个极大的线性无关集合,这当然是一组基.为此我们取出一条链并且将上面的所有集合并起来得到一个集合<span class="math inline">\(T
&#39;\)</span>.此时就可以看出我们之前(几乎一笔略过的)要求从基扩张的时候只需要有限个元素的作用,它可以立刻断言<span class="math inline">\(T &#39;\)</span>是一个线性无关集合.</p>
<p>(2)的证明是容易的,不妨设<span class="math inline">\(n = | \mathcal{ B
} | , m = | S |\)</span>,由于<span class="math inline">\(m &gt;
n\)</span>,这当然是一个<span class="math inline">\(m\)</span>个变量的大小为<span class="math inline">\(n\)</span>的方程组,当然存在不全为<span class="math inline">\(0\)</span>的解.</p>
<p>(3)的定义较为复杂,略过.</p>
<p>在上述定理的基础上,我们可以定义非零向量空间<span class="math inline">\(V\)</span>的<strong>维数</strong>,记作<span class="math inline">\(\dim V = | \mathcal{ B } |\)</span>,零子空间<span class="math inline">\(\{ \vec{ 0 } \}\)</span>的维数定义为<span class="math inline">\(0\)</span>.</p>
<p>一般而言,我们大部分情况下都只讨论有限生成的情况.</p>
<p>有限生成的情况,我们还有以下若干条定理:</p>
<ol start="4" type="1">
<li>(基定理)设<span class="math inline">\(H\)</span>是<span class="math inline">\(V\)</span>的<span class="math inline">\(p\)</span>维子空间,<span class="math inline">\(H\)</span>中任何恰好由<span class="math inline">\(p\)</span>个元素组成的线性无关集构成<span class="math inline">\(H\)</span>的一个基.</li>
</ol>
<p>这当然是自然的,根据上面的推导,这个线性无关集合就是极大的线性无关集合.</p>
<ol start="5" type="1">
<li>如果线性空间的子空间<span class="math inline">\(V_0 \subseteq
V\)</span>,那么<span class="math inline">\(\dim V_0 \leq \dim
V\)</span>.特别地,<span class="math inline">\(V_0 = V \Leftrightarrow
\dim V_0 = \dim V\)</span>.</li>
</ol>
<p>只需要继续在<span class="math inline">\(V_0\)</span>里面取基就可以了.</p>
<ol start="6" type="1">
<li><span class="math inline">\(V\)</span>定义在域<span class="math inline">\(F\)</span>上,如果<span class="math inline">\(\dim
V = n\)</span>,那么<span class="math inline">\(V \cong
F^n\)</span>.</li>
</ol>
<p>考虑<span class="math inline">\(F^n\)</span>的一组标准基<span class="math inline">\(\vec{ e_1 } , \cdots \vec{ e
}_n\)</span>,然后我们取出<span class="math inline">\(V\)</span>的一组有序基<span class="math inline">\(B = \{ \vec{ v }_1 , \cdots , \vec{ v }_n
\}\)</span>,然后把<span class="math inline">\(T : F^n \rightarrow V ,
\sum k_i \vec{ e }_i \mapsto \sum k_i \vec{ v
}_i\)</span>.接下要当然要验证良定义和双射,通过基的定义是显然的.</p>
<p>这可以引出所谓坐标表示,即:设<span class="math inline">\(\mathcal{ B }
= \{ \vec{ b }_1 , . . . , \vec{ b }_n \}\)</span>是<span class="math inline">\(V\)</span>的一个基,则<span class="math inline">\(\forall \vec{ x } \in V\)</span>,<span class="math inline">\(\exists\)</span>唯一的一组<span class="math inline">\(\{ c_1 , . . . , c_n \}\)</span>满足<span class="math inline">\(\vec{ x } = c_1 \vec{ b }_1 + . . . + c_n \vec{ b
}_n\)</span>.我们称<span class="math inline">\(\begin{bmatrix}c_1 \\
\vdots \\ c_n\end{bmatrix}\)</span>是<span class="math inline">\(\vec{ x
}\)</span>的<span class="math inline">\(\mathcal{ B }
-\)</span>坐标向量,记作<span class="math inline">\([ x ]_{ \mathcal{ B }
}\)</span>,映射<span class="math inline">\(x \mapsto [ x ]_{ \mathcal{ B
} }\)</span>称为由<span class="math inline">\(\mathcal{ B
}\)</span>确定的<strong>坐标映射</strong>.</p>
<p>事实上,如果我们记<span class="math inline">\(P_{ \mathcal{ B } } =
\begin{bmatrix}\vec{ b }_1 &amp; \vec{ b }_2 &amp; \cdots &amp; \vec{ b
}_n\end{bmatrix}\)</span>,则我们有<span class="math inline">\(\vec{ x }
= P_{ \mathcal{ B } } [ x ]_{ \mathcal{ B } }\)</span>.我们称<span class="math inline">\(P_{ \mathcal{ B } }\)</span>为<span class="math inline">\(\mathcal{ B }\)</span>的坐标变换矩阵.</p>
<ol start="7" type="1">
<li>线性映射由它在基上的作用完全确定.</li>
</ol>
<p>原因是考虑<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(B = \{ \vec{ v }_1 , \cdots , \vec{ v }_n
\}\)</span>,那么<span class="math inline">\(T ( \sum k_i \vec{ v }_i ) =
\sum k_i T ( \vec{ v }_i )\)</span>.</p>
<ol start="8" type="1">
<li><span class="math inline">\(\text{ Hom } ( V , W ) \cong
W^n\)</span>,其中<span class="math inline">\(\dim V = n\)</span>.</li>
</ol>
<p>由(7),我们知道如果选定了<span class="math inline">\(C = \{ \vec{ w
}_1 , \cdots \vec{ w }_n
\}\)</span>,则只需要考虑在基上的具体变换即可.</p>
<ol start="9" type="1">
<li>(线性映射同构于矩阵映射)如果<span class="math inline">\(V ,
W\)</span>都是定义在<span class="math inline">\(F\)</span>上的线性空间,<span class="math inline">\(\dim V = n , \dim W = m\)</span>,那么<span class="math inline">\(\text{ Hom } ( V , W ) \cong W^n \cong F^{ m
\times n }\)</span>.更一般地,如果<span class="math inline">\(V\)</span>的基的指标集是<span class="math inline">\(J\)</span>,<span class="math inline">\(W\)</span>的基的指标集是<span class="math inline">\(I\)</span>.那么<span class="math inline">\(\text{
Hom } ( V , W ) \cong F^{ I \times J }\)</span>.另外地,<span class="math inline">\(\dim \text{ Hom } ( V , W ) =
mn\)</span>.特殊地,<span class="math inline">\(\text{ End } ( V ) \cong
F^{ n \times n }\)</span>.</li>
</ol>
<p>由(6)(8)显然.</p>
<p>现在我们就可以拿出矩阵了,我们在<span class="math inline">\(F\)</span>上定义<span class="math inline">\(m
\times n\)</span>的矩阵<span class="math inline">\(M\)</span>,于是<span class="math inline">\(\mathcal{ M } = \text{ Hom } ( V , W ) \cong M_{ m
\times n }\)</span>.</p>
<p>简单来说,如果<span class="math inline">\(B = \{ \vec{ v }_1 , \cdots
\vec{ v }_n \}\)</span>是<span class="math inline">\(V\)</span>的一组基,<span class="math inline">\(C =
\{ \vec{ w }_1 , \cdots \vec{ w }_m \}\)</span>是<span class="math inline">\(W\)</span>的一组基,我们事实上是把<span class="math inline">\(\vec{ v }_j \mapsto \sum a_{ i , j } \vec{ w
}_i\)</span>.</p>
<ol start="10" type="1">
<li>线性映射的复合同构于矩阵乘法.</li>
</ol>
<p>只需操演定义即可发现.</p>
<ol start="11" type="1">
<li>如果<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域,那么<span class="math inline">\(E\)</span>是在<span class="math inline">\(F\)</span>上的向量空间.同样,如果<span class="math inline">\(V\)</span>是<span class="math inline">\(E\)</span>的向量空间,那么<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>的向量空间.</li>
</ol>
<p>定义的简单操演.</p>
<ol start="12" type="1">
<li>如果<span class="math inline">\(V\)</span>是<span class="math inline">\(E\)</span>的向量空间,基为<span class="math inline">\(B\)</span>,<span class="math inline">\(E\)</span>是<span class="math inline">\(F\)</span>的向量空间,基为<span class="math inline">\(C\)</span>.那么<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>的向量空间,而且基是<span class="math inline">\(CB\)</span>.作为其的一个推论,如果我们定义<span class="math inline">\([ V : E ] = \dim_E V\)</span>,即在<span class="math inline">\(E\)</span>上的<span class="math inline">\(V\)</span>的维数.我们应当能见到<span class="math inline">\([ V : F ] = [ V : E ] [ E : F ]\)</span>.</li>
</ol>
<p>定义的简单操演.可以将这里理解为<span class="math inline">\([ V : F ]
= \log_F V\)</span>这个样子.</p>
<h4><span id="可逆矩阵">可逆矩阵</span></h4>
<p>称一个<span class="math inline">\(n \times n\)</span>的矩阵<span class="math inline">\(A\)</span>是<strong>可逆的</strong>,当且仅当<span class="math inline">\(\exists C_{ n \times n }\)</span>满足<span class="math inline">\(CA = AC = I_{ n }\)</span>,我们记<span class="math inline">\(C = A^{ - 1 }\)</span>.其实也就是<span class="math inline">\(F_{ n \times n
}\)</span>这个环上的可逆元.这当然意味着其对应的线性映射是可逆的,也就是其代表的线性映射是同构.</p>
<p>不可逆矩阵又被称为<strong>奇异矩阵</strong>.</p>
<p>事实上<span class="math inline">\(m \times n\)</span>的矩阵<span class="math inline">\(A\)</span>在<span class="math inline">\(m \ne
n\)</span>的时候当然是不可逆的,因为其代表的线性映射不可能是同构(不然两边的<span class="math inline">\(\dim\)</span>应当相等,应当有<span class="math inline">\(m = n\)</span>).</p>
<p>可逆矩阵有以下简单性质:</p>
<ol type="1">
<li><p>若<span class="math inline">\(A\)</span>是可逆方阵,则<span class="math inline">\(A^{ - 1 }\)</span>也可逆且<span class="math inline">\(( A^{ - 1 } )^{ - 1 } = A\)</span>.</p></li>
<li><p>若<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是可逆方阵,则<span class="math inline">\(AB\)</span>也可逆且<span class="math inline">\((
AB )^{ - 1 } = B^{ - 1 } A^{ - 1 }\)</span>.</p></li>
</ol>
<h5><span id="初等矩阵">初等矩阵</span></h5>
<p>将单位矩阵经过一次初等行变换得到的矩阵称作<strong>初等矩阵</strong>.</p>
<p>对任意<span class="math inline">\(m \times
n\)</span>矩阵进行初等行变换一定等价于将其左乘一个初等矩阵,原因在于只需要对单位矩阵验证以下性质即可.</p>
<ol type="1">
<li>倍加变换:<span class="math inline">\(R_i + kR_j \rightarrow R_i , i
\ne j\)</span>:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E_{ x , y } &amp; = \begin{cases}
k &amp; x = i , y = j \\
1 &amp; x = y \\
0 &amp; \text{ Otherwise }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<ol start="2" type="1">
<li>对换变换:<span class="math inline">\(R_i \leftrightarrow
R_j\)</span>:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E_{ x , y } &amp; = \begin{cases}
1 &amp; x = i , y = j \\
1 &amp; x = j , y = i \\
1 &amp; x = y , x \ne i , x \ne j \\
0 &amp; \text{ Otherwise }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<ol start="3" type="1">
<li>倍乘变换:<span class="math inline">\(kR_i \rightarrow R_i , k \ne
0\)</span>:</li>
</ol>
$$
<span class="math display">\[\begin{aligned}
E_{ x , y } &amp; = \begin{cases}
k &amp; x = y , x = i \\
1 &amp; x = y , x \ne i \\
0 &amp; \text{ Otherwise }
\end{cases} \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑如下事实:行变换是可逆的,那么初等矩阵显然是可逆的.</p>
<p>这引出下面的定理:</p>
<p><span class="math inline">\(n \times
n\)</span>矩阵是可逆的,当且仅当<span class="math inline">\(A\)</span>行等价于<span class="math inline">\(I_n\)</span>,也即<span class="math inline">\(A\)</span>可以通过一系列初等行变换变换为<span class="math inline">\(I_n\)</span>.</p>
<p>如果<span class="math inline">\(A\)</span>可以通过一系列初等行变换变换为<span class="math inline">\(I_n\)</span>,根据初等矩阵的知识,这等价于:</p>
<p><span class="math inline">\(E_1 E_2 . . . E_p A =
I_n\)</span>,由于初等矩阵显然可逆,我们有<span class="math inline">\(A =
( E_1 E_{ 2 } . . . E_p )^{ - 1 }\)</span>,有<span class="math inline">\(A^{ - 1 } = ( E_1 E_2 . . . E_p )\)</span>.</p>
<p>如果<span class="math inline">\(A\)</span>是可逆矩阵,显然<span class="math inline">\(A\)</span>的简化阶梯形是<span class="math inline">\(I\)</span>,也即二者行等价.</p>
<p>由于初等矩阵转置后仍然是初等矩阵,所以<span class="math inline">\(A\)</span>可逆等价于<span class="math inline">\(A^T\)</span>可逆.此时发现列变换等价于右乘初等矩阵.此外<span class="math inline">\(( A^T )^{ - 1 } = ( A^{ - 1 } )^T\)</span>.</p>
<h5><span id="求解逆矩阵">求解逆矩阵</span></h5>
<p>若<span class="math inline">\(A\)</span>可逆,我们考虑将<span class="math inline">\(A\)</span>和<span class="math inline">\(I\)</span>放在同一个<span class="math inline">\(n
\times 2 n\)</span>的矩阵中,记作<span class="math inline">\(\begin{bmatrix}A &amp;
I\end{bmatrix}\)</span>,它显然行等价于<span class="math inline">\(\begin{bmatrix}I &amp; A^{ - 1
}\end{bmatrix}\)</span>.</p>
<p>另外,考虑将<span class="math inline">\(I\)</span>写作<span class="math inline">\(\begin{bmatrix}\vec{ e_1 } &amp; \vec{ e_2 } &amp;
. . . &amp; \vec{ e_n
}\end{bmatrix}\)</span>的形式,则我们发现上述过程等价于求若干个形如<span class="math inline">\(A \vec{ x }_i = \vec{ e
}_i\)</span>的方程的解,并且<span class="math inline">\(A^{ - 1 } =
\begin{bmatrix}\vec{ x_1 } &amp; \vec{ x_2 } &amp; . . . &amp; \vec{ x_n
}\end{bmatrix}\)</span>.</p>
<h6><span id="example1lu分解">Example1(LU分解)</span></h6>
<p>考虑上面对一个矩阵做的过程,考虑把一个矩阵消成上三角的.在此过程中如果没有发生行交换操作,那所做的操作就是一列下三角的操作.因此可以把一个矩阵分解为<span class="math inline">\(A =
LU\)</span>.当然这里有一些条件才能进行,回头我们再讨论此.</p>
<h4><span id="核与像与秩">核与像与秩</span></h4>
<p>选取<span class="math inline">\(T : V \rightarrow
W\)</span>为线性映射,定义<span class="math inline">\(\ker T = T^{ - 1 }
( 0 )\)</span>,<span class="math inline">\(\text{ im } \ T = T ( V
)\)</span>.</p>
<p>容易证明<span class="math inline">\(\ker T\)</span>是<span class="math inline">\(V\)</span>的线性子空间,<span class="math inline">\(\text{ im } \ T\)</span>是<span class="math inline">\(W\)</span>的线性子空间.</p>
<p>对于任意<span class="math inline">\(w \in \text{ im }
T\)</span>,选取任意一个特解<span class="math inline">\(v_0 \in V , T (
v_0 ) = w\)</span>,那么容易看出<span class="math inline">\(T^{ - 1 } ( w
) = v_0 + \ker T\)</span>.于是<span class="math inline">\(T\)</span>是单射当且仅当<span class="math inline">\(\ker T = \{ 0 \}\)</span>.</p>
<p>当<span class="math inline">\(\dim V\)</span>有限的时候,我们有<span class="math inline">\(\dim V = \dim \ker T + \dim \text{ im } \
T\)</span>.</p>
<p>原因是可以选取<span class="math inline">\(\text{ im } \
T\)</span>的一组基<span class="math inline">\(\{ \vec{ w }_1 , \cdots
\vec{ w }_r \}\)</span>,找到其原像<span class="math inline">\(B = \{
\vec{ v }_1 , \cdots , \vec{ v }_r \}\)</span>,再取<span class="math inline">\(\ker T\)</span>的一组基<span class="math inline">\(C = \{ \vec{ u }_1 , \cdots \vec{ u }_s
\}\)</span>.</p>
<p>先来证明<span class="math inline">\(B \cup
C\)</span>是线性无关的.也就是考察<span class="math inline">\(\sum a_j
\vec{ v }_j + \sum b_i \vec{ u }_i = 0\)</span>.此时两边取像,当然有<span class="math inline">\(\sum a_j \vec{ w }_j + 0 =
0\)</span>,于是所有的<span class="math inline">\(a_j =
0\)</span>.此时考虑<span class="math inline">\(\ker T\)</span>是<span class="math inline">\(V\)</span>的子空间,所以当<span class="math inline">\(0 + \sum b_i \vec{ u }_i =
0\)</span>的时候也可以推出所有的<span class="math inline">\(b_i =
0\)</span>.</p>
<p>再来证明它确实可以生成<span class="math inline">\(V\)</span>.考虑<span class="math inline">\(\forall
\vec{ v } \in V\)</span>,首先<span class="math inline">\(T ( \vec{ v } )
= \sum a_j \vec{ w }_j\)</span>,这当然是可以找到的.那么<span class="math inline">\(T ( \vec{ v } - \sum a_j \vec{ v }_j ) =
0\)</span>,于是<span class="math inline">\(\vec{ v } - \sum a_j \vec{ v
}_j \in \ker T\)</span>,于是<span class="math inline">\(\vec{ v } - \sum
a_j \vec{ v }_j = \sum b_i \vec{ u
}_i\)</span>,这就证毕了.利用下面直和分解的原理也可以写作<span class="math inline">\(\ker T \oplus \text{ im } T \cong V\)</span>.</p>
<p>而我们知道<span class="math inline">\(T\)</span>的单性等价于<span class="math inline">\(\dim \ker T = 0\)</span>,满性等价于<span class="math inline">\(\dim \text{ im } \ T = \dim W = \dim
V\)</span>,于是<span class="math inline">\(\dim W = \dim
V\)</span>时单性等价于满性.</p>
<p>这样的话我们定义一个线性映射的秩<span class="math inline">\(\text{ rk
} \ T = \dim ( \text{ im } \ T )\)</span>.</p>
<p>我们来看一个特殊情况<span class="math inline">\(T : F^n \rightarrow
F^m\)</span>.那此时我们就可以定义这个映射所代表的矩阵<span class="math inline">\(M\)</span>的秩.我们注意到<span class="math inline">\(\text{ im } \ T = \text{ span } \{ M \vec{ e }_1 ,
\cdots M \vec{ e }_{ n } \} = \text{ span } \{ \vec{ m }_1 , \cdots ,
\vec{ m }_n \}\)</span>.也就是<span class="math inline">\(\text{ rk } \
M\)</span>其实就是列向量生成的空间的维度.特别地,如果<span class="math inline">\(\text{ rk } \ M = \min ( n , m
)\)</span>,那么我们称矩阵是满秩的.也就等于其消成简化阶梯型矩阵后的主元数量.那此时<span class="math inline">\(\dim \ker T = n - \text{ rk } \ M\)</span>.</p>
<p>容易从上面看出<span class="math inline">\(\text{ rk } ( ST ) \leq
\min ( \text{ rk } S , \text{ rk } T )\)</span>.且当<span class="math inline">\(T\)</span>是满的时候<span class="math inline">\(\text{ rk } ( ST ) = \text{ rk } ( S
)\)</span>,当<span class="math inline">\(S\)</span>是单的时候<span class="math inline">\(\text{ rk } ( ST ) = \text{ rk } ( T
)\)</span>.</p>
<h5><span id="sylvester秩不等式">Sylvester秩不等式</span></h5>
<p>考虑<span class="math inline">\(T : U \to V , S : V \to
W\)</span>,则<span class="math inline">\(\text{ rk } ( ST ) \geq \text{
rk } \ S + \text{ rk } \ T - \dim V = \text{ rk } \ T - ( \dim V -
\text{ rk } \ S )\)</span>.可以认为后者<span class="math inline">\(\dim
V - \text{ rk } \ S\)</span>实际上是<span class="math inline">\(S\)</span>这个映射所带来的维度损失(<span class="math inline">\(\ker S\)</span>),而这个损失有可能叠到<span class="math inline">\(T\)</span>上也可能不叠到<span class="math inline">\(T\)</span>上.</p>
<p>对于其证明,考虑<span class="math inline">\(\text{ rk } ( ST
)\)</span>实际上应当是<span class="math inline">\(S : \text{ im } \ T
\to W\)</span>的秩,这给出<span class="math inline">\(\text{ rk } ( ST )
= \text{ rk } \ T - \dim ( \text{ im } \ T \cap \ker S )\)</span>.</p>
<p>而<span class="math inline">\(\dim ( \text{ im } \ T \cap \ker S )
\leq \dim \ker S = \dim V - \text{ rk } \ S\)</span>.于是得证.</p>
<p>其一个特例是<span class="math inline">\(\text{ rk } ( ST ) =
0\)</span>时给出<span class="math inline">\(\dim V \geq \text{ rk } \ S
+ \text{ rk } \ T\)</span>.</p>
<p>在上述式子左右两边进行简单变形:</p>
<p><span class="math display">\[
\begin{aligned}
\text{ rk } ( ST ) &amp; \geq \text{ rk } \ T - \dim \ker S \\
\dim U - \text{ rk } ( T ) &amp; \geq \dim U - \text{ rk } \ ( ST ) -
\dim \ker S \\
\ker T + \ker S &amp; \geq \ker ( ST )
\end{aligned}
\]</span></p>
<p>换言之就是线性映射的<span class="math inline">\(\ker\)</span>扩张的过程中可能会出现包含的情况,所以扩不到简单相加的情形.</p>
<h5><span id="frobenius秩不等式">Frobenius秩不等式</span></h5>
<p>有<span class="math inline">\(\text{ rk } ( ABC ) \geq \text{ rk } (
AB ) + \text{ rk } ( BC ) - \text{ rk } B\)</span>.</p>
<p>不妨设<span class="math inline">\(B : U \to V\)</span>,考虑:</p>
$$
<span class="math display">\[\begin{aligned}
\text{ rk } ( ABC ) &amp; = \text{ rk } ( BC ) - \dim ( \text{ im } ( BC
) \cap \ker A ) \\
&amp; \geq \text{ rk } ( BC ) - \dim ( \text{ im } ( B ) \cap \ker A )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们事实上有<span class="math inline">\(\text{ rk } ( AB ) = \text{
rk } \ B - \dim ( \text{ im } B \cap \ker A
)\)</span>,于是上述式子得证.</p>
<p>仍然对上式进行变形:</p>
<p><span class="math display">\[
\ker ( AB ) + \ker ( BC ) \geq \ker ( ABC ) + \ker ( B )
\]</span></p>
<p>这个式子还不能简单从Sylvester不等式推导,但可以见到这仍然是关于<span class="math inline">\(\ker\)</span>扩张上的意义.</p>
<h4><span id="对偶空间">对偶空间</span></h4>
<p>定义<strong>对偶空间</strong><span class="math inline">\(V^* = \text{
Hom } ( V , F )\)</span>(也可以记作<span class="math inline">\(\check{ V
}\)</span>),其中<span class="math inline">\(V\)</span>是定义在<span class="math inline">\(F\)</span>上的向量空间.对偶空间当然是线性空间.</p>
<p>当线性空间是有限维的时候.我们考虑以下事实:</p>
<p>取<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(\cal B = \{ \vec{ v }_1 , \cdots , \vec{ v }_n
\}\)</span>,我们考虑取<span class="math inline">\(\check{ v }_i \in
V^\vee\)</span>使得<span class="math inline">\(\check{ v }_i ( \vec{ w }
) = a_i\)</span>,当<span class="math inline">\(\vec{ w } = \sum_j a_j
\vec{ v
}_j\)</span>.容易验证它们构成一组<strong>对偶基</strong>,这告诉我们<span class="math inline">\(\dim V = \dim V^\vee\)</span>.</p>
<p>特别地,当<span class="math inline">\(V =
F^n\)</span>的时候,容易验证如果取标准基<span class="math inline">\(\cal
B\)</span>,那么得到的对偶基实际上等价于标准基的转置(也就是列向量改为行向量).这可能会给我们带来错觉,认为对偶空间无非是行向量组成的空间,但如此理解有所偏差.既然是向量空间,就应当理解为列向量,否则线性变换理解为矩阵乘法就会收到阻碍,只是其作用效果等价于先转置为行向量再作矩阵乘法.</p>
<p>如果<span class="math inline">\(T : V \to
W\)</span>是线性映射,那我们可以定义其<strong>转置映射</strong><span class="math inline">\(^t T : W^\vee \to V^\vee , \lambda \mapsto \lambda
T\)</span>.容易验证转置映射仍然是线性映射.另外,如果<span class="math inline">\(S , T\)</span>均是线性映射,那么<span class="math inline">\(^t{ ( ST ) } = \ ^t{ T }^t{ S
}\)</span>.简单画一下交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[d] \ar[r]^T &amp; W \ar[d] \\
\check{ V } &amp; \check{ W } \ar[l]_{ T^t } }
\]</span></p>
<p>我们接下来说明转置映射对应的矩阵是原映射的矩阵的转置.</p>
<p>不妨设<span class="math inline">\(\dim V = n , \dim W =
m\)</span>,原矩阵为<span class="math inline">\(A_{ m \times n
}\)</span>.</p>
<p>接下来看它们分别对对应基的操作:</p>
<p>不妨设<span class="math inline">\(T ( \vec{ v }_j ) = \sum a_{ i , j
} \vec{ w }_i\)</span>,则<span class="math inline">\(^t T ( \check{ w
}_i )\)</span>代表一个映射:</p>
<p><span class="math display">\[
\begin{aligned}
\vec{ v }_k &amp; \mapsto \check{ w_i } T ( \vec{ v }_k ) \\
&amp; = \check{ w_i } ( \sum_h a_{ h , k } w_h ) \\
&amp; = \sum_h a_{ h , k } \check{ w }_i ( w_h ) \\
&amp; = a_{ i , k } \\
&amp; = \sum_{ j } a_{ i , j } \check{ v }_j ( \vec{ v }_k )
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(^t T ( \check{ w }_i ) = \sum_{ j }
a_{ i , j } \check{ v }_j\)</span>.</p>
<p>如果我们将<span class="math inline">\(\lambda\)</span>看成一个<span class="math inline">\(1 \times m\)</span>的矩阵,那<span class="math inline">\(\lambda \to \lambda
T\)</span>不言自明为矩阵乘法.然而正是我们试图总是将空间表示为列向量,因此我们就自然带了一个转置,对于一个<span class="math inline">\(\vec{ v }\)</span>,我们对它实际上求的是乘法<span class="math inline">\(^t ( \lambda T ) \vec{ v } = (^t T ) (^t \lambda )
\vec{ v }\)</span>的结果,如此一来上述结论便显明了.</p>
<p>我们会在后面谈论矩阵的相抵的部分证明行秩等于列秩这一事实,然而,既然转置实际上表现了对偶空间上的性质,我们理应可以抛开矩阵本身而只从对偶空间的角度理解.换言之,取对偶基是一种非典范的无奈之举,我们会在讨论双线性形式的时候重新讨论于此.</p>
<h4><span id="直和分解与分块矩阵">直和分解与分块矩阵</span></h4>
<p>不妨取映射<span class="math inline">\(\sigma : \bigoplus_{ i \in I }
V_i \to V , ( v_i )_{ i \in I } \mapsto \sum v_i\)</span>,其中<span class="math inline">\(V_i\)</span>都是<span class="math inline">\(V\)</span>的子空间.容易验证其当且仅当在<span class="math inline">\(V_i \cap ( \sum_{ i \ne j } V_j ) = \{ 0
\}\)</span>时是单射.我们将此称作其<strong>直和分解</strong>.如果不满足上述条件一般称作<strong>外直和</strong>,满足的话则称作<strong>内直和</strong>,并容易发现内直和<span class="math inline">\(\bigoplus V_i \cong \sum V_i\)</span>.</p>
<p>外直和的一个经典应用是构造<span class="math inline">\(\varphi : V_1
\oplus V_2 \to V , ( \vec{ v }_1 , \vec{ v }_2 ) \mapsto \vec{ v }_1 -
\vec{ v }_2\)</span>的映射,立刻得到<span class="math inline">\(\ker
\varphi = V_1 \cap V_2 , \text{ im } \ \varphi = V_1 +
V_2\)</span>,于是<span class="math inline">\(\dim V_1 + \dim V_2 = \dim
( V_1 \cap V_2 ) + \dim ( V_1 + V_2
)\)</span>.这其实就是第二同构定理的维数表示.</p>
<p>接下来考虑<span class="math inline">\(V = \bigoplus_{ i = 1 }^n V_i ,
W = \bigoplus_{ j = 1 }^m W_j\)</span>,我们可以断言<span class="math inline">\(\text{ Hom } ( V , W ) \cong \bigoplus_{ 1 \leq i
\leq n , 1 \leq j \leq m } \text{ Hom } ( V_i , W_j
)\)</span>.这个的证明只需定义算子<span class="math inline">\(p_i :
\bigoplus_{ j } V_j \to V , ( \vec{ v }_j )_{ j \in J } \mapsto \vec{ v
}_i\)</span>即可.</p>
<p>对于对偶空间,事实上取<span class="math inline">\(W =
F\)</span>,就会有<span class="math inline">\(V^\vee \cong \bigoplus
V_i^\vee\)</span>.</p>
<p>接下来考虑映射的合成<span class="math inline">\(T : U \to V , S : V
\to W\)</span>.不妨设<span class="math inline">\(U \cong \bigoplus U_k ,
V \cong \bigoplus_j V_j , W \cong \bigoplus_i W_i\)</span>,容易验证<span class="math inline">\(( ST )_{ i , k } = \sum_{ j } S_{ i , j } T_{ j ,
k }\)</span>.</p>
<p>此时我们终于意识到了这个东西应当同构于分块矩阵.更具体地,<span class="math inline">\(\text{ Hom } ( V , W ) \cong A_{ n \times m } ,
A_{ j , i } \cong T_{ j , i } , A_{ j , i } \in M_{ m_j \times n_i } ,
m_j = \dim W_j , n_i = \dim V_i\)</span>.</p>
<p>容易类比普通矩阵定义对角线分块矩阵,上(下)三角分块矩阵之类的东西.并且还容易发现上三角矩阵相乘后仍是上三角,对角线矩阵相乘后仍是对角线.</p>
<p>如果考虑<span class="math inline">\(T \in \text{ End } ( V
)\)</span>,事实上对角线矩阵有相当漂亮的刻画,只需观察矩阵结构就可以发现此时<span class="math inline">\(T ( V_i ) \subseteq
V_i\)</span>.上三角矩阵有类似的刻画,观察矩阵结构也可以发现<span class="math inline">\(T ( V_i ) \subseteq \bigoplus_{ j \leq i }
V_j\)</span>.</p>
<p>下面我们来证明对于上三角分块矩阵<span class="math inline">\(A_{ r
\times r }\)</span>,如果对角线上的<span class="math inline">\(A_{ i
\times i }\)</span>均可逆,那么<span class="math inline">\(A_{ r \times r
}\)</span>的分块矩阵可逆,而且其逆的对角线上的矩阵是一列<span class="math inline">\(A_{ i \times i }^{ - 1 }\)</span>.</p>
<p>考虑数学归纳,这样的话就只需要证明<span class="math inline">\(\begin{bmatrix}A_{ 1 , 1 } &amp; A_{ 1 , 2 } \\ 0
&amp; A_{ 2 , 2 }\end{bmatrix}\)</span>,其中<span class="math inline">\(A_{ 1 , 1 }\)</span>和<span class="math inline">\(A_{ 2 , 2 }\)</span>均可逆即可.容易发现取<span class="math inline">\(\begin{bmatrix}A_{ 1 , 1 }^{ - 1 } &amp; - A_{ 1 ,
1 }^{ - 1 } A_{ 1 , 2 } A_{ 2 , 2 }^{ - 1 } \\ 0 &amp; A_{ 2 , 2 }^{ - 1
}\end{bmatrix}\)</span>即可.</p>
<p>那么反之成不成立呢?是不是此时按照合理的分块方式一定能得到对角线上的矩阵都可逆呢?也是可行的.假设<span class="math inline">\(\begin{bmatrix}A_{ 1 , 1 } &amp; A_{ 1 , 2 } \\ 0
&amp; A_{ 2 , 2 }\end{bmatrix}\)</span>可逆,其逆为<span class="math inline">\(\begin{bmatrix}A_{ 1 , 1 } &#39; &amp; A_{ 1 , 2 }
&#39; \\ A_{ 2 , 1 } &#39; &amp; A_{ 2 , 2 }
&#39;\end{bmatrix}\)</span>.容易发现:</p>
$$
<span class="math display">\[\begin{aligned}
\begin{bmatrix}
A_{ 1 , 1 } &#39; &amp; A_{ 1 , 2 } &#39; \\
A_{ 2 , 1 } &#39; &amp; A_{ 2 , 2 } &#39;
\end{bmatrix} \begin{bmatrix}
A_{ 1 , 1 } &amp; A_{ 1 , 2 } \\
0 &amp; A_{ 2 , 2 }
\end{bmatrix} = \begin{bmatrix}
A_{ 1 , 1 } A_{ 1 , 1 } &#39; &amp; \_ \\
\_ &amp; \_
\end{bmatrix} \\
\begin{bmatrix}
A_{ 1 , 1 } &amp; A_{ 1 , 2 } \\
0 &amp; A_{ 2 , 2 }
\end{bmatrix} \begin{bmatrix}
A_{ 1 , 1 } &#39; &amp; A_{ 1 , 2 } &#39; \\
A_{ 2 , 1 } &#39; &amp; A_{ 2 , 2 } &#39;
\end{bmatrix} = \begin{bmatrix}
\_ &amp; \_ \\
\_ &amp; A_{ 2 , 2 } A &#39;_{ 2 , 2 }
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是立刻见到<span class="math inline">\(A_{ 1 , 1 }\)</span>和<span class="math inline">\(A_{ 2 , 2 }\)</span>都有逆.</p>
<h4><span id="基的变换">基的变换</span></h4>
<h5><span id="矩阵的共轭相似">矩阵的共轭(相似)</span></h5>
<p>考虑线性映射<span class="math inline">\(T : V \to
W\)</span>,这个线性映射理应和所取的基无关,但如果我们想写出它的矩阵形式,写出来的矩阵当然取决于<span class="math inline">\(V\)</span>和<span class="math inline">\(W\)</span>取的基分别是什么(从而决定不同的坐标).不妨设<span class="math inline">\(V , W\)</span>都是定义在<span class="math inline">\(F\)</span>上的,维度分别为<span class="math inline">\(n , m\)</span>.现在取它们的有序基<span class="math inline">\(\mathcal{ B } = \{ \vec{ v }_1 , \cdots , \vec{ v
}_n \}\)</span>,<span class="math inline">\(\mathcal{ C } = \{ \vec{ w
}_1 , \cdots , \vec{ w }_m \}\)</span>,这样就可以确定一个同构<span class="math inline">\(\mathcal{ M }_{ \mathcal{ B } \to \mathcal{ C } }
: \text{ Hom } ( V , W ) \to M_{ m \times n
}\)</span>.再构造一个同构<span class="math inline">\(\varphi_{ \mathcal{
V } } : F^n \to V , ( x_1 , \cdots , x_n ) \mapsto \sum x_i \vec{ v
}_i\)</span>.然后我们可以画出如下交换图表(对其交换性的验证可以直接考虑对每个基验证交换性):</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T &amp; W \\
F^n \ar[u]^{ \varphi_{ \mathcal{ B } } } \ar[r]_{ \mathcal{ M }_{
\mathcal{ B } \to \mathcal{ C } } ( T ) } &amp; F^m \ar[u]_{ \varphi_{
\mathcal{ C } } } }
\]</span></p>
<p>如果我们尝试考虑更换它们的基,理论上说当然会得到不同的矩阵.换言之,我们取另一组有序基<span class="math inline">\(\mathcal{ B } &#39; = \{ \vec{ v }_1 &#39; ,
\cdots , \vec{ v }_n &#39; \} , \mathcal{ C } &#39; = \{ \vec{ w }_1
&#39; , \cdots , \vec{ w }_m &#39;
\}\)</span>,这样可以确定另一个同构<span class="math inline">\(\mathcal{
M }_{ B &#39; \to C &#39; }\)</span>.我们下面试图探索二者之间的关系.</p>
<p>由于选取的有序基的方式不同,我们再构造一个<span class="math inline">\(P_{ B &#39; \to B } : ( F^n ) &#39; \to F^n , ( x
&#39;_1 , \cdots , x &#39;_n ) \mapsto ( x_1 , \cdots x_n ) , \sum x
&#39;_i \vec{ v } &#39;_i = \sum x_i \vec{ v
}_i\)</span>,容易验证取<span class="math inline">\(P_{ V &#39; \to V }
={ ( \varphi_V ) }^{ - 1 } \varphi_{ V &#39;
}\)</span>即可并且是自同构,并且<span class="math inline">\(( P_{ V \to V
&#39; } )^{ - 1 } = P_{ V &#39; \to V
}\)</span>.写成交换图表的话应当形如:</p>
<p><span class="math display">\[
\xymatrix{ &amp; V &amp; \\
( F^n ) &#39; \ar[ru]^{ \varphi_{ \mathcal{ B } &#39; } } \ar[rr]_{ P_{
\mathcal{ B } &#39; \to \mathcal{ B } } } &amp; &amp; F^n \ar[lu]_{
\varphi_{ \mathcal{ B } } } }
\]</span></p>
<p>这里所有的箭头当然都是可逆的.</p>
<p>事实上,不妨设<span class="math inline">\(\vec{ v }_i &#39; = \sum_{ j
} p_{ j , i } \vec{ v }_j\)</span>,也就是将<span class="math inline">\(\vec{ v } &#39;\)</span>展开成列向量,对于<span class="math inline">\(\vec{ x } = \sum_{ i } x &#39;_i \vec{ v }
&#39;_i\)</span>,考虑<span class="math inline">\(\sum_{ i } x &#39;_i
\vec{ v } &#39;_i = \sum_{ i } x &#39;_i \sum_{ j } p_{ j , i } \vec{ v
}_j = \sum_{ j } \vec{ v }_j \sum_{ i } x &#39;_i p_{ j , i } = \sum_j
\vec{ v }_j x_j\)</span>,那么<span class="math inline">\(p_{ j , i
}\)</span>其实就是<span class="math inline">\(P_{ \mathcal{ B } &#39;
\to \mathcal{ B } }\)</span>的对应矩阵的第<span class="math inline">\(j\)</span>行<span class="math inline">\(i\)</span>列元素.此时我们称<span class="math inline">\(P_{ n \times n }\)</span>为从有序基<span class="math inline">\(\cal B &#39; \to \cal
B\)</span>的<strong>转换矩阵</strong>.事实上容易见到转换矩阵都是可逆的,并且事实上所有的可逆矩阵都可以看作标准基对某个矩阵的转换矩阵.</p>
<p>这样的话,我们就容易见到:<span class="math inline">\(\mathcal{ M }_{ B
&#39; \to C &#39; } ( T ) = P_{ C \to C &#39; } \mathcal{ M }_{ B \to C
} ( T ) P_{ B &#39; \to B } = ( P_{ C &#39; \to C } )^{ - 1 } \mathcal{
M }_{ B \to C } ( T ) P_{ B &#39; \to B }\)</span>.这里一定要注意<span class="math inline">\(\mathcal{ M }_{ B \to C
}\)</span>是一个将映射<span class="math inline">\(T\)</span>变为矩阵<span class="math inline">\(M\)</span>的映射.</p>
<p>具体地,我们可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix{ ( F^n ) &#39; \ar[rrr]^{ \mathcal{ M }_{ B &#39; \to C &#39;
} ( T ) } \ar[dd]_{ P_{ B &#39; \to B } } \ar[rd]^{ \varphi_{ B &#39; }
} &amp; &amp; &amp; ( F^m ) &#39; \ar[dd]^{ P_{ C &#39; \to C } }
\ar[ld]_{ \varphi_{ C &#39; } } \\
&amp; V \ar[r]^T &amp; W \\
F^n \ar[rrr]_{ \mathcal{ M }_{ B \to C } ( T ) } \ar[ru]_{ \varphi_B }
&amp; &amp; &amp; F^m \ar[lu]^{ \varphi_C } }
\]</span></p>
<p>接下来我们考虑<span class="math inline">\(T \in \text{ End } ( V
)\)</span>,自然可以导出<span class="math inline">\(\mathcal{ M }_{ B
&#39; \to B &#39; } ( T ) = P^{ - 1 } \mathcal{ M }_{ B \to B } ( T )
P\)</span>,其中<span class="math inline">\(P = P_{ B &#39; \to B
}\)</span>.</p>
<p>于是综上,我们称两个矩阵<span class="math inline">\(A_{ n \times n } ,
B_{ n \times n }\)</span>相似,当且仅当存在可逆矩阵<span class="math inline">\(P_{ n \times n }\)</span>使得<span class="math inline">\(A = P^{ - 1 }
BP\)</span>.由上面可以看出来,相似的两个矩阵实际上是不同基下的同种变换.</p>
<p>另外我们注意到,固定<span class="math inline">\(P_{ n \times n
}\)</span>后定义映射<span class="math inline">\(P : M_{ n \times n } \to
M_{ n \times n } , A \mapsto P^{ - 1 }
AP\)</span>不仅仅是线性同构,还是一个环同构.容易验证其满足环同构的性质.</p>
<p>此时注意到另一个事情:我们知道我们做共轭实际上是换基操作,那么如果我们需要换基,难道我们必须总是对着矩阵做矩阵乘法么?</p>
<p>事实上,我们应当观察如下矩阵:</p>
<p><span class="math display">\[
\begin{bmatrix}
&amp; \vec{ e }_1 &amp; \cdots &amp; \vec{ e }_n \\
\vec{ e }_1 &amp; a_{ 1 , 1 } &amp; \cdots &amp; a_{ n , 1 } \\
\vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
\vec{ e }_n &amp; a_{ 1 , n } &amp; \cdots &amp; a_{ n , n }
\end{bmatrix}
\]</span></p>
<p>最简单的改变,我们如果想要让它变成在另一组有序基下的操作,我们应当如何操作呢?如果我们带着这些向量去做,我们实际上可以发现:放在列上的这些向量随着列变换而操作,放在行上的这些向量随着行变换的逆变换而改变.这就是更加方便的做相似矩阵的办法.而这事实上也就是因为,任何一个可逆的矩阵都可以拆成若干初等矩阵,因此只需要将<span class="math inline">\(P\)</span>拆成初等矩阵两边分别做就可以.初等矩阵求逆当然是平凡的.</p>
<h5><span id="矩阵的相抵">矩阵的相抵</span></h5>
<p>我们称两个矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span><strong>相抵</strong>,当且仅当<span class="math inline">\(\exists P , Q\)</span>均可逆,<span class="math inline">\(A =
PBQ\)</span>.容易看出相抵是等价关系.由于可逆矩阵等价于若干初等矩阵的乘积,那么<span class="math inline">\(A , B\)</span>相抵当且仅当<span class="math inline">\(B\)</span>可以通过若干初等行变换和列变换变成<span class="math inline">\(A\)</span>.下面我们证明<span class="math inline">\(A , B\)</span>相抵等价于<span class="math inline">\(\text{ rk } \ A = \text{ rk } \ B\)</span>.</p>
<p><span class="math inline">\(A , B\)</span>相抵的时候当然有<span class="math inline">\(\text{ rk } \ A = \text{ rk } \
B\)</span>,因为此时<span class="math inline">\(\text{ rk } \ A = \dim
\text{ im ( PBQ ) }\)</span>,而<span class="math inline">\(P ,
Q\)</span>都是同构,所以此时有<span class="math inline">\(\text{ rk } \ A
= \dim \text{ im } \ B = \text{ rk } \ B\)</span>.</p>
<p>当<span class="math inline">\(\text{ rk } \ A = \text{ rk } \ B =
k\)</span>时,我们考虑二者都可以经过若干次行变换或者列变换变成形如<span class="math inline">\(m_{ i , j } = \begin{cases}1 &amp; i = j \leq k \\
0 &amp; \text{ otherwise }\end{cases}\)</span>.于是二者等价.</p>
<p>类似上面就可以发现<span class="math inline">\(\text{ rk } \ A =
\text{ rk } \
A^T\)</span>,原因是二者都可以消成上述那种矩阵,而那种矩阵的主元数量显然是确定且相等的.</p>
<p>用矩阵的相抵可以更快证明Frobenius秩不等式,具体地,考虑分块矩阵<span class="math inline">\(\begin{bmatrix}ABC &amp; 0 \\ 0 &amp;
B\end{bmatrix}\)</span>.考虑<span class="math inline">\(\begin{bmatrix}I
&amp; - A \\ 0 &amp; I\end{bmatrix} \begin{bmatrix}ABC &amp; 0 \\ 0
&amp; B\end{bmatrix} \begin{bmatrix}I &amp; 0 \\ C &amp; I\end{bmatrix}
= \begin{bmatrix}0 &amp; - AB \\ BC &amp;
B\end{bmatrix}\)</span>,于是我们知道<span class="math inline">\(\begin{bmatrix}ABC &amp; 0 \\ 0 &amp;
B\end{bmatrix}\)</span>和<span class="math inline">\(\begin{bmatrix}0
&amp; - AB \\ BC &amp; B\end{bmatrix}\)</span>相抵.</p>
<p>而<span class="math inline">\(\text{ rk } \ \begin{bmatrix}ABC &amp;
0 \\ 0 &amp; B\end{bmatrix} = \text{ rk } \ ABC + \text{ rk } \
B\)</span>,下面考虑证明<span class="math inline">\(\text{ rk } \
\begin{bmatrix}0 &amp; - AB \\ BC &amp; B\end{bmatrix} \geq \text{ rk }
\ AB + \text{ rk } \ BC\)</span>,而直接考虑<span class="math inline">\(BC\)</span>和<span class="math inline">\(AB\)</span>的行,<span class="math inline">\(BC\)</span>中线性无关行和<span class="math inline">\(AB\)</span>中线性无关行必定也线性无关,而原本线性相关的那些加上右下角的<span class="math inline">\(B\)</span>也有可能变得线性无关,于是上述不等式就得证了.</p>
<h4><span id="商空间">商空间</span></h4>
<p>如果我们考虑在线性空间上定义等价关系<span class="math inline">\(\vec{
v }_1 \sim \vec{ v }_2 \Leftrightarrow T \vec{ v }_1 = T \vec{ v
}_2\)</span>,其中<span class="math inline">\(T\)</span>是一个线性映射,容易发现此时<span class="math inline">\(\vec{ v }_1 - \vec{ v }_2 \in \ker
T\)</span>.所以其实和<span class="math inline">\(T\)</span>本身关系不大,而只和<span class="math inline">\(\ker T\)</span>这个子空间有关.</p>
<p>那我们不妨设<span class="math inline">\(U\)</span>是<span class="math inline">\(V\)</span>的子空间,立刻发现<span class="math inline">\(\vec{ v }_1 \sim \vec{ v }_2 \Leftrightarrow (
\vec{ v }_1 - \vec{ v }_2 ) \in U\)</span>是一个等价关系.</p>
<p>在此基础上定义<strong>陪集</strong><span class="math inline">\(\vec{
v } +
U\)</span>,容易发现陪集组成了一个新的线性空间(当然要验证良定义),将其称作<strong>商空间</strong>,并且可验证映射<span class="math inline">\(\varphi : V \to V / U , \vec{ v } \mapsto \vec{ v
} + U\)</span>是线性映射.类比陪群,得知<span class="math inline">\(\ker
\varphi = U\)</span>,综合前面的讨论得知此时<span class="math inline">\(\vec{ v }_1 \sim \vec{ v }_2 \Leftrightarrow \vec{
v }_1 + U = \vec{ v }_2 + U\)</span>.</p>
<p>顺便可以顺手引入<strong>余核</strong><span class="math inline">\(\text{ coker } ( T ) = W / \text{ im } \
T\)</span>,容易发现<span class="math inline">\(T\)</span>是满射当且仅当<span class="math inline">\(\text{ coker } ( T ) = \{ 0 \}\)</span>.</p>
<h5><span id="同态基本定理">同态基本定理</span></h5>
<p>下面来抛出另一个命题.对于线性映射<span class="math inline">\(T : V
\to W , \varphi : V \to V / U\)</span>,如果<span class="math inline">\(U
\subseteq \ker T\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar{ T } : V / U \to W\)</span>.使得<span class="math inline">\(T = \bar{ T } \varphi\)</span>.</p>
<p>这个证明看上去是相当正确的.由于<span class="math inline">\(\varphi\)</span>是满射,那么必定有<span class="math inline">\(\bar{ T } ( \vec{ v } + U ) = T \vec{ v
}\)</span>,这是显然是唯一的映射,也容易看出其是正确的线性映射.具体来讲,存在唯一的线性映射<span class="math inline">\(\bar{ T }\)</span>使得下图交换:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T \ar[d]_\varphi &amp; W \\
V / U \ar[ru]_{ \bar{ T } } }
\]</span></p>
<p>在上述命题中如果<span class="math inline">\(T\)</span>也是满射,也就是<span class="math inline">\(W = \text{ im } \ T\)</span>,取<span class="math inline">\(U = \ker T\)</span>,那么此时<span class="math inline">\(\bar{ T } \varphi = T\)</span>,这必定意味着<span class="math inline">\(\text{ im } \ \bar{ T } =
W\)</span>.接下来考虑一下<span class="math inline">\(\ker \bar{ T
}\)</span>的模样,考虑<span class="math inline">\(\bar{ T } ( \vec{ v } +
U ) = 0 \Leftrightarrow T ( \vec{ v } ) = 0 \Leftrightarrow \vec{ v }
\in U \Leftrightarrow \vec{ v } + U = U\)</span>,从而<span class="math inline">\(\ker \bar{ T } = \{ U \}\)</span>,于是<span class="math inline">\(\bar{ T }\)</span>是同构.</p>
<p>就可以发现对于一个线性映射<span class="math inline">\(T\)</span>,<span class="math inline">\(V / U = V /
\ker T \cong \text{ im } \
T\)</span>,这其实就是同态基本定理在线性空间上的表现.不过线性空间上还多一个标量乘法的运算,需要在群的基础上对此进行简单验证.另外线性空间上还有维数的概念,当然立即断言<span class="math inline">\(\dim V = \dim U + \dim ( V / U
)\)</span>.值得一提的是这同样也告知我们<span class="math inline">\(U\)</span>的基和<span class="math inline">\(V /
U\)</span>的反像的基合起来就是一组<span class="math inline">\(V\)</span>的基.</p>
<p>上述说了这么多其实都在着重于所谓商空间的结构,现在我们看到陪集的定义可以在相当的意义上刻画商空间.适当推广上面的结论可以有:</p>
<p>设<span class="math inline">\(T : V_1 \to
V_2\)</span>是线性映射,<span class="math inline">\(U_1 \subseteq V_1 ,
U_2 \subseteq V_2\)</span>并构造两个商映射<span class="math inline">\(\varphi_1 : V_1 \to V_1 / U_1 , \varphi_2 : V_2
\to V_2 / U_2\)</span>,并且<span class="math inline">\(T ( U_1 )
\subseteq U_2\)</span>,那么存在唯一的线性映射<span class="math inline">\(\bar{ T } : V_1 / U_1 \to V_2 /
U_2\)</span>使得<span class="math inline">\(T \varphi_2 = \bar{ T }
\varphi_1\)</span>.具体地,<span class="math inline">\(\bar{ T } ( \vec{
v } + U_1 ) = T \vec{ v } + U_2\)</span>.</p>
<p>如果再推广上述结论的话还可以来多个,具体可以看下面的交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V_1 \ar[rr]^T \ar[d]_{ \varphi_1 } &amp; &amp; V_2 \ar[rr]^S
\ar[d]_{ \varphi_2 } &amp; &amp; V_3 \ar[d]_{ \varphi_3 } \\
V_1 / U_1 \ar[rr]^{ \bar{ T } }_{ \ker \bar{ T } = T^{ - 1 } ( U_2 ) /
U_1 } &amp; &amp; V_2 / U_2 \ar[rr]^{ \bar{ S } }_{ \ker \bar{ S } = S^{
- 1 } ( U_3 ) / U_2 } &amp; &amp; V_3 / U_3 \\
}
\]</span></p>
<h5><span id="第一同构定理">第一同构定理</span></h5>
<p>将群论中的第一同构定理(不过线性空间下没有正规的概念)拿过来,即对于线性空间<span class="math inline">\(V\)</span>的一个子空间<span class="math inline">\(U\)</span>,在典范同态<span class="math inline">\(\pi : V \rightarrow V / U\)</span>下,我们有:</p>
<ol type="1">
<li><p><span class="math inline">\(V\)</span>的包含<span class="math inline">\(U\)</span>的子空间<span class="math inline">\(W\)</span>和<span class="math inline">\(V /
U\)</span>的子空间<span class="math inline">\(\bar{ W }\)</span>在<span class="math inline">\(\pi\)</span>下一一对应.不妨设此对应为<span class="math inline">\(\varphi : W \mapsto \bar{ W }\)</span>.</p></li>
<li><p>此对应是严格保序的,也就是<span class="math inline">\(W_1
\subseteq W_2 \Leftrightarrow \bar{ W }_1 \subseteq \bar{ W
}_2\)</span>.</p></li>
<li><p>若有<span class="math inline">\(U \subseteq W \subseteq
V\)</span>,则<span class="math inline">\(V / W \cong ( V / U ) / ( W / U
)\)</span>.</p></li>
</ol>
<p>考虑(1)(2)的证明:</p>
<p>先证明单射,对于两个包含<span class="math inline">\(U\)</span>的子空间<span class="math inline">\(W_1
\ne W_2\)</span>来说,不妨设<span class="math inline">\(W_1 \nsubseteq
W_2\)</span>,<span class="math inline">\(\exists \vec{ a } \in W_1 ,
\vec{ a } \notin W_2\)</span>.此时考虑<span class="math inline">\(\bar{
a }\)</span>,注意到如果<span class="math inline">\(\bar{ a } \in \bar{
W_2 }\)</span>,那么<span class="math inline">\(\vec{ a } + U \in W_2 +
U\)</span>.这表明<span class="math inline">\(\exists \vec{ b } \in
W_2\)</span>,<span class="math inline">\(\vec{ a } + U = \vec{ b } +
U\)</span>,此时<span class="math inline">\(\vec{ a } - \vec{ b } \in U
\subseteq W_2\)</span>,那么<span class="math inline">\(\vec{ a } \in
W_2\)</span>,这就不符合了,于是当然<span class="math inline">\(\bar{ W_1
} \ne \bar{ W_2 }\)</span>并且(2)上严格保序.</p>
<p>证明单射还有一种办法是考虑只需证明<span class="math inline">\(\pi^{ -
1 } ( \pi ( W ) ) = W\)</span>即可,而<span class="math inline">\(W
\subseteq \pi^{ - 1 } ( \pi ( W ) )\)</span>是显然的.又考虑<span class="math inline">\(\forall \vec{ v } \in \pi^{ - 1 } ( \pi ( W ) ) ,
\pi ( \vec{ v } ) \in \pi ( W )\)</span>,这意味着<span class="math inline">\(\exists \vec{ w } \in W , \pi ( \vec{ v } ) = \pi
( \vec{ w } )\)</span>,于是<span class="math inline">\(\vec{ v } \in
\vec{ w } + \ker \pi = \vec{ w } + U \subseteq \vec{ w } + W =
W\)</span>.这样就证明了<span class="math inline">\(W \supseteq \pi^{ - 1
} ( \pi ( W ) )\)</span>.</p>
<p>接下来要证明满射,也就是证明<span class="math inline">\(\forall N \leq
V / U , U \leq \pi^{ - 1 } ( N ) \leq G\)</span>.</p>
<p>首先要证明<span class="math inline">\(\pi^{ - 1 } ( N
)\)</span>是一个子空间,这个是容易验证的.</p>
<p>而由于保序性已经被证明了,我们就可以注意到由于<span class="math inline">\(\vec{ 0 } \in N\)</span>,于是有<span class="math inline">\(\bar{ 0 } = U \leq \pi^{ - 1 } ( N )\)</span>.</p>
<p>对于(3):</p>
<p>由同态基本定理,考虑构造满射<span class="math inline">\(\varphi : V /
U \rightarrow V / W\)</span>,只需证明<span class="math inline">\(\ker \
\varphi = W / U\)</span>即可.</p>
<p>直觉上会认为映射<span class="math inline">\(\varphi : \vec{ v } + U
\mapsto \vec{ v } + W\)</span>即可,下面验证其满足上述性质:</p>
<p>首先验证良定义,<span class="math inline">\(\vec{ v }_1 + U = \vec{ v
}_2 + U \Leftrightarrow \vec{ v }_1 - \vec{ v }_2 \in U \subseteq W
\Rightarrow \vec{ v }_1 + W = \vec{ v }_2 + W\)</span>.</p>
<p>然后验证线性映射,这个验证过程很平凡.</p>
<p>其满性显然.只需验证其<span class="math inline">\(\ker \varphi = W /
U\)</span>即可,而考虑<span class="math inline">\(\varphi ( \vec{ v } + U
) = W \Leftrightarrow \vec{ v } + W = W \Leftrightarrow \vec{ v } \in W
\Leftrightarrow \vec{ v } + U \in W /
U\)</span>.这样就证明了上述结论.</p>
<h5><span id="第二同构定理">第二同构定理</span></h5>
<p><span class="math inline">\(V ,
W\)</span>是一个更大的线性空间的子空间,那么我们有:</p>
<p><span class="math inline">\(V / ( V \cap W ) \cong ( V + W ) / W ,
\vec{ v } + ( V \cap W ) \mapsto \vec{ v } + W\)</span>.</p>
<p>考虑<span class="math inline">\(\varphi : V \to ( V + W ) / W , \vec{
v } \mapsto \vec{ v } + W\)</span>,那么显然<span class="math inline">\(\varphi ( \vec{ v } ) = W \Leftrightarrow \vec{ v
} \in V \cap W\)</span>,于是<span class="math inline">\(\ker \varphi = V
\cap W\)</span>.</p>
<p>接下来只需要证明它是满射就可以了.考虑<span class="math inline">\(\forall \vec{ v } + \vec{ w } + W = \vec{ v } + W
\in ( V + W ) / W\)</span>,这当然是满射.</p>
<p>第二同构定理的一个平凡推论是<span class="math inline">\(\dim ( V + W
) = ( \dim V ) + ( \dim W ) - \dim ( V \cap W )\)</span>.</p>
<p>第二同构定理的另一个推论是说如果<span class="math inline">\(V = U
\oplus W\)</span>,那么<span class="math inline">\(W \cong V /
U\)</span>.原因是<span class="math inline">\(U + W = V\)</span>并且<span class="math inline">\(U \cap W = \{ \vec{ 0 }
\}\)</span>.换言之取商是直和的逆运算.</p>
<p>第二同构定理证明的另一种思路是考虑<span class="math inline">\(\varphi
: V \times W \to V + W , ( \vec{ v } , \vec{ w } ) \mapsto ( \vec{ v } -
\vec{ w } )\)</span>,此时注意到<span class="math inline">\(\text{ im }
\varphi = ( V + W ) , \ker \varphi = V \cap W\)</span>.</p>
<h5><span id="旗">旗</span></h5>
<p>回看我们一开始拿到的映射<span class="math inline">\(T : V \to V
&#39;\)</span>和映射<span class="math inline">\(\bar{ T } : V / U \to V
&#39; / U &#39;\)</span>.也就是下面这个交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T \ar[d]_{ \varphi } &amp; V &#39; \ar[d]^{ \varphi
&#39; } \\
V / U \ar[r]_{ \bar{ T } } &amp; V &#39; / U &#39; \\
}
\]</span></p>
<p>现在我们尝试用矩阵刻画<span class="math inline">\(T\)</span>和<span class="math inline">\(\bar{ T
}\)</span>之间的关系.首先我们需要开始取基,不妨取<span class="math inline">\(\{ \vec{ u }_1 , \cdots , \vec{ u }_k
\}\)</span>是<span class="math inline">\(U\)</span>的一组有序基,<span class="math inline">\(\{ \bar{ v }_1 , \cdots , \bar{ v }_m
\}\)</span>是<span class="math inline">\(V /
U\)</span>的一组有序基.<span class="math inline">\(\{ \vec{ u }_1 &#39;
, \cdots , \vec{ u }_{ k &#39; } &#39; \}\)</span>是<span class="math inline">\(U &#39;\)</span>的一组有序基,<span class="math inline">\(\{ \bar{ v }_1 &#39; , \cdots , \bar{ v }_{ m
&#39; } &#39; \}\)</span>是<span class="math inline">\(V &#39; / U
&#39;\)</span>的一组有序基.此时由于<span class="math inline">\(\ker
\varphi = U\)</span>,我们之前证明<span class="math inline">\(\ker\)</span>的维度关系的时候已经说明过,<span class="math inline">\(\{ \vec{ u }_1 , \cdots , \vec{ u }_k , \vec{ v
}_1 , \cdots \vec{ v }_m \}\)</span>实际上是<span class="math inline">\(V\)</span>的一组有序基.尝试取出一个矩阵<span class="math inline">\(A \in M_{ ( k &#39; + m &#39; ) \times ( k + m )
}\)</span>来作为<span class="math inline">\(T\)</span>对应的矩阵.此时将<span class="math inline">\(A\)</span>分块,我们将其写作<span class="math inline">\(A = \begin{bmatrix}A_{ U \to U &#39; } &amp; A_{ V
/ U \to U &#39; } \\ A_{ U \to V &#39; / U &#39; } &amp; A_{ V / U \to V
&#39; / U &#39; }\end{bmatrix}\)</span>.由于<span class="math inline">\(T ( U ) \subseteq U &#39;\)</span>,我们知道<span class="math inline">\(A_{ U \to V &#39; / U &#39; } =
0\)</span>,而又有<span class="math inline">\(A_{ V / U \to V &#39; / U
&#39; }\)</span>当然就是<span class="math inline">\(\bar{ T
}\)</span>对应的矩阵<span class="math inline">\(\bar{ A
}\)</span>.总结一下就是<span class="math inline">\(A =
\begin{bmatrix}A_{ U \to U &#39; } &amp; \_ \\ 0 &amp; \bar{ A
}\end{bmatrix}\)</span>.</p>
<p>如此观察可以继续推广并得到<strong>旗</strong>的概念.我们称<span class="math inline">\(V\)</span>的<strong>旗</strong>是一列子空间<span class="math inline">\(\{ \vec{ 0 } \} = U_0 \subsetneq \cdots \subsetneq
U_d = V\)</span>.特别地,如果<span class="math inline">\(d = \dim
V\)</span>,则称其为<strong>完备旗</strong>,容易见到完备旗一定满足<span class="math inline">\(\dim V_i =
i\)</span>.对于给定的旗,如果线性映射<span class="math inline">\(T \in
\text{ End } ( V )\)</span>对<span class="math inline">\(\forall 0 \leq
i \leq m\)</span>满足<span class="math inline">\(T ( V_i ) \subseteq
V_i\)</span>,则称<span class="math inline">\(T\)</span>保持此旗.</p>
<p>如果一个映射<span class="math inline">\(T : V \to V
&#39;\)</span>满足<span class="math inline">\(\forall h , T ( U_h )
\subseteq U &#39;_h\)</span>,那我们可以对每个<span class="math inline">\(U_h / U_{ h - 1 }\)</span>和<span class="math inline">\(U &#39;_h / U &#39;_{ h - 1
}\)</span>选定有序基,那么得到的矩阵<span class="math inline">\(A\)</span>应当是一个分块上三角矩阵,而且<span class="math inline">\(A_{ i , i }\)</span>实际上就是<span class="math inline">\(\bar{ T }_h : U_h / U_{ h - 1 } \to U &#39;_h / U
&#39;_{ h - 1 }\)</span>所对应的矩阵.</p>
<h5><span id="不变子空间">不变子空间</span></h5>
<p>给定线性映射<span class="math inline">\(T \in \text{ End } ( V
)\)</span>,如果子空间<span class="math inline">\(U \subseteq
V\)</span>满足<span class="math inline">\(T ( U ) \subseteq
U\)</span>,那我们称<span class="math inline">\(U\)</span>是在<span class="math inline">\(T\)</span>下的一个<strong>不变子空间</strong>.根据前面我们已经讨论过的内容,得到下面这个交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T \ar[d]_{ \varphi } &amp; V \ar[d]^{ \varphi &#39;
} \\
V / U \ar[r]_{ \bar{ T } } &amp; V / U \\
}
\]</span></p>
<p>其中<span class="math inline">\(\bar{ T }\)</span>是唯一的.</p>
<p>提取<span class="math inline">\(T |_U\)</span>为只考虑<span class="math inline">\(T\)</span>在线性空间<span class="math inline">\(U\)</span>上的作用得到的线性映射,上述交换图表给出以下矩阵:<span class="math inline">\(T \cong \begin{bmatrix}T |_U &amp; \_ \\ 0 &amp;
\bar{ T
}\end{bmatrix}\)</span>.这个形式更好的用处是结合之后的迹/行列式/特征多项式等概念给出<span class="math inline">\(T , T |_U , \bar{ T
}\)</span>三者的关系:事实上<span class="math inline">\(\det ( T |_U )
\det ( \bar{ T } ) = \det ( T ) , \text{ tr } ( T |_U ) + \text{ tr } (
\bar{ T } ) = \text{ tr } ( T )\)</span>.</p>
<h3><span id="行列式">行列式</span></h3>
<h4><span id="置换排列">置换(排列)</span></h4>
<p>不妨假设<span class="math inline">\(X\)</span>是一个非空集合,那么我们定义其<strong>置换集合</strong><span class="math inline">\(S_X = \{ \sigma : X \to X , \sigma \ \text{ is a
bijection } \}\)</span>.容易看出<span class="math inline">\(S_X\)</span>对置换复合构成一个群.</p>
<p>我们也可以用<span class="math inline">\(\left ( \begin{matrix}1 &amp;
\cdots &amp; n \\ \sigma ( 1 ) &amp; \cdots &amp; \sigma ( n
)\end{matrix} \right )\)</span>.</p>
<p>我们还可以定义<strong>轮换</strong>为<span class="math inline">\(\left ( \begin{matrix}1 &amp; 2 &amp; \cdots &amp;
n - 1 &amp; n \\ 2 &amp; 3 &amp; \cdots &amp; n &amp; 1\end{matrix}
\right )\)</span>.</p>
<p>还可以定义<strong>对换</strong><span class="math inline">\(( i , j )
= \left ( \begin{matrix}1 &amp; \cdots &amp; i &amp; \cdots &amp; j
&amp; \cdots &amp; n \\ 1 &amp; \cdots &amp; j &amp; \cdots &amp; i
&amp; \cdots &amp; n\end{matrix} \right )\)</span>,其中<span class="math inline">\(i \ne j\)</span>.</p>
<p>在此基础上定义<strong>单对换</strong><span class="math inline">\(s_i
= ( i , i + 1 )\)</span>.</p>
<p>在置换的基础上可以定义逆序对:<span class="math inline">\(\text{ Inv
}_\sigma = \{ ( i , j ) \mid 1 \leq i &lt; j \leq n , \sigma ( i ) &gt;
\sigma ( j ) \}\)</span>,并定义逆序数<span class="math inline">\(l (
\sigma ) = | \text{ Inv }_\sigma |\)</span>.容易看出<span class="math inline">\(l ( \sigma ) = 0 \Leftrightarrow \sigma = \text{
id }\)</span>,<span class="math inline">\(l ( \sigma ) = \frac{ n ( n -
1 ) }{ 2 } \Leftrightarrow \sigma ( k ) = n - k +
1\)</span>.并且注意到<span class="math inline">\(l ( \sigma ) = l (
\sigma^{ - 1 } )\)</span>,原因是<span class="math inline">\(( i , j )
\mapsto ( \sigma ( j ) , \sigma ( i ) )\)</span>是双射.</p>
<p>容易发现一个<span class="math inline">\(\sigma\)</span>可以最少通过<span class="math inline">\(l ( \sigma )\)</span>次单对换变为<span class="math inline">\(\text{ id }\)</span>,原因是每次交换一对<span class="math inline">\(( i , i + 1 )\)</span>当<span class="math inline">\(\sigma ( i ) &gt; \sigma ( i + 1
)\)</span>时会让逆序数减少<span class="math inline">\(1\)</span>.或者说更一般地<span class="math inline">\(| l ( \sigma ) - l ( s_i \sigma ) | =
1\)</span>.由于<span class="math inline">\(( s_i )^{ - 1 } =
s_i\)</span>,容易发现<span class="math inline">\(| l ( \sigma ) - l (
\sigma s_i ) | = 1\)</span>.而事实上<span class="math inline">\(| l (
\sigma ) - l ( ( i , j ) \sigma ) | \in \text{ odd
}\)</span>.这意味着对换会改变逆序数的奇偶性.所以容易看出来一个置换<span class="math inline">\(\sigma\)</span>如果能拆成若干个对换,这些对换的数量的奇偶性一定与<span class="math inline">\(l ( \sigma )\)</span>相同.</p>
<p>而由于可以如上分解并合并,我们知道<span class="math inline">\(l (
\sigma \tau )\)</span>和<span class="math inline">\(l ( \sigma ) + l (
\tau )\)</span>的奇偶性必然相同.</p>
<p>于是我们可以定义<span class="math inline">\(\text{ sgn } ( \sigma ) =
( - 1 )^{ l ( \sigma ) }\)</span>,并且容易发现<span class="math inline">\(\text{ sgn } ( \sigma \tau ) = \text{ sgn } (
\sigma ) \text{ sgn } ( \tau )\)</span>.还可以看出<span class="math inline">\(\text{ sgn } ( \sigma^{ - 1 } ) = \text{ sgn } (
\sigma )\)</span>,那么立刻有<span class="math inline">\(\text{ sgn } (
\sigma^{ - 1 } \tau \sigma ) = \text{ sgn } ( \tau
)\)</span>.用此可以定义奇偶置换的概念,也就是<span class="math inline">\(l ( \sigma ) \in \text{ odd }\)</span>的置换<span class="math inline">\(\sigma\)</span>是奇置换.</p>
<h4><span id="交错形式">交错形式</span></h4>
<p>尝试刻画一种交错形式<span class="math inline">\(D : V^m \to
F\)</span>,其中<span class="math inline">\(V\)</span>是定义在<span class="math inline">\(F\)</span>上的线性空间,满足以下性质:</p>
<ol type="1">
<li><p>其对每一个分量都是线性的.也即固定其他<span class="math inline">\(m -
1\)</span>个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之<span class="math inline">\(D ( \cdots , t \vec{ v }_i , \cdots ) = tD (
\cdots , \vec{ v }_i , \cdots ) , D ( \cdots , \vec{ v }_i + v_i &#39; ,
\cdots ) = D ( \cdots , \vec{ v }_i , \cdots ) + D ( \cdots , \vec{ v
}_i &#39; , \cdots )\)</span>.</p></li>
<li><p>如果有两个分量相等,那么得到的是<span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>在上述基础上容易发现交错形式也是线性空间,不妨将其记作<span class="math inline">\(D_{ V , m }\)</span>.</p>
<p>容易发现<span class="math inline">\(D_{ V , 1 } =
V^\vee\)</span>.</p>
<p>初看会觉得(2)是一个很奇怪的事情,但实际上其定义了一种很好的性质:首先我们应当需要一种东西使得如果有一个分量是<span class="math inline">\(\vec{ 0 }\)</span>则给出<span class="math inline">\(0\)</span>,但如果直接这么定义的话容易看到难以判定一个东西在没有分量为<span class="math inline">\(0\)</span>的时候是否为<span class="math inline">\(0\)</span>,因此这个定义的性质更为优良.事实上,我们有以下性质:</p>
<ol type="1">
<li><p>对于一个固定的<span class="math inline">\(D\)</span>而言,将其某一个分量乘以若干倍加到另一个分量上不会引起取值的变化.</p></li>
<li><p>对于一个固定的<span class="math inline">\(D\)</span>而言,将某一个分量乘以<span class="math inline">\(t\)</span>倍,则取值需要乘以<span class="math inline">\(t\)</span>倍.</p></li>
<li><p>对于一个固定的<span class="math inline">\(D\)</span>而言,如果其收到的向量组是线性相关的,那么取值为<span class="math inline">\(0\)</span>.</p></li>
<li><p>作为(3)的推论,如果<span class="math inline">\(m &gt; \dim
V\)</span>,那么<span class="math inline">\(D_{ V , m } = \{ 0
\}\)</span>.</p></li>
<li><p>对于一个固定的<span class="math inline">\(D\)</span>而言,<span class="math inline">\(D ( \cdots , \vec{ v }_i , \cdots , \vec{ v }_j ,
\cdots ) = - D ( \cdots , \vec{ v }_j , \cdots , \vec{ v }_i , \cdots
)\)</span>.</p></li>
<li><p>作为(5)的推论,<span class="math inline">\(D ( \vec{ v }_{
\sigma^{ - 1 } ( 1 ) } , \cdots , \vec{ v }_{ \sigma^{ - 1 } ( m ) } ) =
\text{ sgn } ( \sigma ) D ( \vec{ v }_1 , \cdots , \vec{ v }_m
)\)</span>.</p></li>
</ol>
<p>其它几个都是平凡的,下面考虑(5)的证明,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; = D ( \cdots , \vec{ v }_i + \vec{ v }_j , \cdots , \vec{ v }_j
+ \vec{ v }_i , \cdots ) \\
&amp; = D ( \cdots , \vec{ v }_i , \cdots , \vec{ v }_j , \cdots ) + D (
\cdots , \vec{ v }_i , \cdots , \vec{ v }_i , \cdots ) \\
+ D ( \cdots , \vec{ v }_j , \cdots , \vec{ v }_i , \cdots ) + D (
\cdots , \vec{ v }_j , \cdots , \vec{ v }_j , \cdots ) \\
&amp; = D ( \cdots , \vec{ v }_i , \cdots , \vec{ v }_j , \cdots ) + D (
\cdots , \vec{ v }_j , \cdots , \vec{ v }_i , \cdots )
\end{aligned}
\]</span></p>
<p>下面我们定义<span class="math inline">\(D_V = D_{ V , n
}\)</span>,其中<span class="math inline">\(n = \dim
V\)</span>,取出其一组有序基<span class="math inline">\(\{ \vec{ e }_1 ,
\cdots , \vec{ e }_n \}\)</span>.对于一组向量<span class="math inline">\(\{ \vec{ v }_{ 1 } , \cdots , \vec{ v }_n
\}\)</span>,尝试将其分解为<span class="math inline">\(\vec{ v }_i =
\sum_{ j } a_{ i , j } \vec{ e }_j\)</span>.此时逐个展开<span class="math inline">\(D ( \vec{ v }_1 , \cdots , \vec{ v }_n
)\)</span>中的向量,理应得知:</p>
<p><span class="math display">\[
\begin{aligned}
D ( \vec{ v }_1 , \cdots , \vec{ v }_n ) &amp; = \sum_{ \sigma \in S_n }
\prod_{ k = 1 }^n a_{ k , \sigma ( k ) } D ( \vec{ e }_{ \sigma ( 1 ) }
, \cdots , \vec{ e }_{ \sigma ( n ) } ) \\
&amp; = \sum_{ \sigma \in S_n } \text{ sgn } ( \sigma ) \prod_{ k = 1
}^n a_{ k , \sigma ( k ) } D ( \vec{ e }_1 , \cdots , \vec{ e }_n )
\end{aligned}
\]</span></p>
<p>这说明任何一个<span class="math inline">\(D\)</span>实际上只由其在基上的作用<span class="math inline">\(D ( \vec{ e }_1 , \cdots , \vec{ e }_n
)\)</span>唯一确定.因此<span class="math inline">\(\dim D \leq 1 = \dim
F\)</span>,原因是线性映射<span class="math inline">\(D_V \to F , D
\mapsto D / D ( \vec{ e }_1 , \cdots , \vec{ e }_n
)\)</span>是单射.事实上只要<span class="math inline">\(\dim V \geq
1\)</span>,当然可以如上构造<span class="math inline">\(D_e = \sum_{
\sigma \in S_n } \text{ sgn } ( \sigma ) \prod_{ k = 1 }^n a_{ k ,
\sigma ( k ) } \in D_V \setminus \{ 0 \}\)</span>,于是<span class="math inline">\(\dim D \ne 0\)</span>,于是<span class="math inline">\(\dim D = 1\)</span>.</p>
<p>验证<span class="math inline">\(D_e\)</span>映射符合定义的过程较为无聊,验证有相同元素则为<span class="math inline">\(0\)</span>是考虑交换它们后<span class="math inline">\(\text{ sgn }\)</span>会变号,而还容易简单验证<span class="math inline">\(D_e ( \vec{ e }_1 , \cdots \vec{ e }_n ) =
1\)</span>.</p>
<h4><span id="定义">定义</span></h4>
<p>考虑有限维的<span class="math inline">\(V ,
W\)</span>,并考虑映射<span class="math inline">\(T^* : D_{ W , m } \to
D_{ V , m } , D \mapsto ( ( T^* D ) : ( \vec{ v }_1 , \cdots , \vec{ v
}_m ) \mapsto D ( T \vec{ v }_1 , \cdots T \vec{ v }_m )\)</span>.</p>
<p>现在取<span class="math inline">\(W = V , m = n = \dim
V\)</span>,于是<span class="math inline">\(T \in \text{ End } ( V ) ,
T^* \in \text{ End } ( D_V )\)</span>,由于<span class="math inline">\(\dim D_V = 1\)</span>,于是<span class="math inline">\(T^*\)</span>必然是伸缩映射<span class="math inline">\(D \mapsto tD\)</span>,那么这个<span class="math inline">\(t\)</span>其实就是行列式.更确切地说,我们定义:</p>
<p><span class="math display">\[
\begin{aligned}
T^* ( D ) &amp; = ( \det T ) D \\
D ( T \vec{ v }_1 , \cdots , T \vec{ v }_n ) &amp; = \det T \times D (
\vec{ v }_1 , \cdots \vec{ v }_n )
\end{aligned}
\]</span></p>
<p>那么既然其是伸缩映射,我们就当然注意到<span class="math inline">\(\det
T = \frac{ D_e ( T \vec{ e }_1 , \cdots , T \vec{ e }_n ) }{ D_e ( \vec{
e }_1 , \cdots , \vec{ e }_n ) } = D_e ( T \vec{ e }_1 , \cdots , T
\vec{ e }_n )\)</span>.</p>
<p>只需简单利用定义就可以注意到行列式的以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\det \text{ id }_V =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\det ( ST ) = \det S \times \det
T\)</span>.</p></li>
<li><p><span class="math inline">\(T\)</span>可逆时,<span class="math inline">\(\det ( T^{ - 1 } ) = ( \det T )^{ - 1
}\)</span>.</p></li>
<li><p><span class="math inline">\(T\)</span>不可逆时,<span class="math inline">\(\det T = 0\)</span>.</p></li>
</ol>
<p>应当警觉的一个事情是我们上面给出的计算<span class="math inline">\(D\)</span>的方式是观察<span class="math inline">\(D\)</span>在某一组基上的作用,而我们理应判定当选取的基不同的时候<span class="math inline">\(\det
T\)</span>的唯一性,我们还应当确认的是我们可以将一个<span class="math inline">\(\dim V = n\)</span>的线性空间用某一个基打到<span class="math inline">\(F^n\)</span>后也不会有问题,从而引出矩阵的行列式的定义.综上,我们应当验证当以下图表是交换时:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T \ar[d]_S &amp; V \ar[d]^S \\
W \ar[r]_{ T &#39; } &amp; W }
\]</span></p>
<p>也即<span class="math inline">\(T &#39; = STS^{ - 1 }\)</span>时<span class="math inline">\(\det T = \det T
&#39;\)</span>.那么这由行列式的乘法性质当然就可以予以说明.</p>
<p>综上就可以定义矩阵的行列式,我们称方阵<span class="math inline">\(A_{
n \times n }\)</span>的行列式是一个将其映射到标量的函数,记作<span class="math inline">\(\det ( A )\)</span>或者<span class="math inline">\(| A |\)</span>.由于一般自然地将<span class="math inline">\(\text{ End } ( V ) \cong M_{ n \times n
}\)</span>,于是从上面的计算方式容易见到<span class="math inline">\(\det
A = \sum_{ \sigma \in S_n } \text{ sgn } ( \sigma ) \prod_{ k = 1 }^n
a_{ k , \sigma ( k ) } = \sum_{ \sigma \in S_n } \text{ sgn } ( \sigma )
\prod_{ k = 1 }^n a_{ \sigma ( k ) , k }\)</span>.</p>
<p>我们应当容易从上述过程中看出以下事实:</p>
<ol type="1">
<li><p><span class="math inline">\(\det A = \det A^T\)</span>.</p></li>
<li><p><span class="math inline">\(\det I_{ n \times n } =
1\)</span>.</p></li>
<li><p><span class="math inline">\(\det
A\)</span>可以看作列向量(或行向量)上的某种交错形式.</p></li>
<li><p>如果两个矩阵相似,那么它们的<span class="math inline">\(\det\)</span>相等.</p></li>
</ol>
<p>而由于行列式是某种交错形式,我们立即可以断言当对其作三种初等行变换的时候:</p>
<ol type="1">
<li><p>(倍加变换):行列式的值不变.</p></li>
<li><p>(对换变换):行列式的值取反.</p></li>
<li><p>(倍乘变换):行列式的值取相同倍数.</p></li>
</ol>
<p>说到这里要声明的某些事情是,我们应当将行列式看作某种交错形式,而并非将所有的交错形式都看作行列式.原因是交错形式一般带有单位,而行列式只是单纯的比例常数.例如我们用行列式求面积的时候,算的其实并不是面积,而是其相对于单位面积的比例常数.</p>
<h4><span id="余子式与代数余子式">余子式与代数余子式</span></h4>
<p>对于矩阵<span class="math inline">\(A\)</span>,<span class="math inline">\(A\)</span>的<strong>余子式</strong><span class="math inline">\(M_{ i , j }\)</span>定义为<span class="math inline">\(A\)</span>去掉第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的矩阵的行列式.其中形如<span class="math inline">\(M_{ i , i
}\)</span>的余子式称为<strong>主余子式</strong>.</p>
<p>对于矩阵<span class="math inline">\(A\)</span>,其<strong>代数余子式</strong>(又称<strong>余因子</strong>)<span class="math inline">\(C_{ i , j } = ( - 1 )^{ i + j } M_{ i , j }
\\\)</span>.</p>
<p>那么我们有一种计算行列式的方式是<strong>代数余子式展开</strong>:</p>
<p><span class="math display">\[
\det A = \sum_{ k = 1 }^n a_{ i , k } C_{ i , k } = \sum_{ k = 1 }^n a_{
k , j } C_{ k , j }
\]</span></p>
<p>原因是<span class="math inline">\(\sigma ( i ) =
j\)</span>的位置对逆序对的贡献的奇偶性等同于<span class="math inline">\(i +
j\)</span>的奇偶性.每次我看这个结论都无法第一时间理解这个性质.但你可以考虑以<span class="math inline">\(\sigma ( i ) =
j\)</span>作为分界线,然后发现此时怎么交换其它的部分,这个点的奇偶性贡献都是不变的.因此直接考虑在最普通的排列上挪一下,奇偶性就等价于<span class="math inline">\(i - j\)</span>的奇偶性了.</p>
<p>值得一提的是我们其实还有类似的公式,当<span class="math inline">\(i
\ne j\)</span>的时候:</p>
<p><span class="math display">\[
0 = \sum_{ k = 1 }^n a_{ i , k } C_{ j , k } = \sum_{ k = 1 }^n a_{ k ,
i } C_{ k , j }
\]</span></p>
<p>原因是直接定义一个矩阵<span class="math inline">\(B\)</span>使得<span class="math inline">\(B\)</span>的第<span class="math inline">\(j\)</span>行与<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>行相等,其余行照搬<span class="math inline">\(A\)</span>,那么展开也是上面这个东西,而由于<span class="math inline">\(B\)</span>有两行相等,所以<span class="math inline">\(\det B = 0\)</span>.</p>
<p>代数余子式构成的矩阵<span class="math inline">\(C = [ C_{ i , j }
]\)</span>称为<strong>余子矩阵</strong>.其转置称为<strong>伴随矩阵</strong>,我们不妨将伴随矩阵直接记作<span class="math inline">\(\check{ A }\)</span>,也有时记其为<span class="math inline">\(\text{ adj } ( A )\)</span>.</p>
<p>其满足<span class="math inline">\(A \check{ A } = \check{ A } A = (
\det A ) I\)</span>.二者类似,只考虑证明前者:</p>
<p>考虑前者的第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列应该是<span class="math inline">\(\sum_{ k } a_{ i , k } C_{ j , k
}\)</span>,我们早在前面就证明过当<span class="math inline">\(i =
j\)</span>的时候这个东西应当为<span class="math inline">\(\det
A\)</span>,反之为<span class="math inline">\(0\)</span>.</p>
<p>由上面立刻得到推论为<span class="math inline">\(A^{ - 1 } = \frac{
\check{ A } }{ \det A }\)</span>.</p>
<p>我们可能还希望去了解<span class="math inline">\(\check{ A
}\)</span>的<span class="math inline">\(\text{ rk }\)</span>与<span class="math inline">\(\det\)</span>.事实上我们给出以下若干命题:</p>
<ol type="1">
<li><p><span class="math inline">\(\det \check{ A } = ( \det A )^{ n - 1
}\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ rk } ( \check{ A } ) =
\begin{cases}n &amp; \text{ rk } \ A = n \\ 1 &amp; \text{ rk } \ A = n
- 1 \\ 0 &amp; \text{ rk } \ A &lt; n - 1\end{cases}\)</span>.</p></li>
</ol>
<p>(1)无非是(2)的推论,下面只看(2).</p>
<p>(2)的话,由于<span class="math inline">\(\det A \ne 0 \Rightarrow \det
\check{ A } \ne 0\)</span>,所以当<span class="math inline">\(A\)</span>满秩的时候也很显然.</p>
<p>当<span class="math inline">\(\text{ rk } \ A &lt; n -
1\)</span>的时候,由于取出的所有余子式都线性相关,于是此时<span class="math inline">\(\check{ A }\)</span>是<span class="math inline">\(0\)</span>矩阵.</p>
<p>当<span class="math inline">\(\text{ rk } \ A = n -
1\)</span>的时候,首先证明其<span class="math inline">\(\text{ r } k \geq
1\)</span>,也就是只需证明至少存在一个余子式不为<span class="math inline">\(0\)</span>.取出<span class="math inline">\(n -
1\)</span>个线性无关的列组成一个<span class="math inline">\(n \times ( n
- 1
)\)</span>大小的矩阵.我们之前已经声明过其行秩等于列秩,这样就可以删去其中一行得到一个<span class="math inline">\(( n - 1 ) \times ( n - 1
)\)</span>的满秩矩阵,这个矩阵的行列式不为零.</p>
<p>于是其<span class="math inline">\(\text{ rk } \geq
1\)</span>,我们又根据Frobenius秩不等式,知道考虑<span class="math inline">\(0 = \text{ rk } \ ( AI \check{ A } ) \geq \text{
rk } \ A + \text{ rk } \ \check{ A } - \text{ rk } \
I\)</span>,于是<span class="math inline">\(\text{ rk } \ \check{ A }
\leq 1\)</span>.</p>
<h4><span id="行列式定向">行列式定向</span></h4>
<p>我们知道我们用行列式求平行四边形面积的时候求的是所谓有向面积,问题在于这个方向具体是什么样子呢.</p>
<p>容易见得不同的基对应的矩阵行列式应当是相等的.但基的变换可能拥有不同的行列式.我们曾经研究过<span class="math inline">\(P_{ \mathcal{ B } \to \mathcal{ B } &#39;
}\)</span>这个坐标变换矩阵的若干性质,而这个变换当然是同构的,所以这个矩阵行列式理应非零,那它就会天然带有正负的区别.我们定义一种基上的等价关系<span class="math inline">\(\sim\)</span>,或者称为<strong>同定向的</strong>.具体来说<span class="math inline">\(\mathcal{ B } \sim \mathcal{ B } &#39;
\Leftrightarrow \det P_{ \mathcal{ B } &#39; \to \mathcal{ B } } &gt;
0\)</span>,由于行列式的乘法性质,立刻见到这将所有的基分为了两类.对于<span class="math inline">\(F^n\)</span>来说,我们一般将其标准基所在的那一类称为<strong>标准定向</strong>.这就是为什么我们求行列式的时候会出现正负的差别.</p>
<h4><span id="克拉默cramer法则">克拉默(Cramer)法则</span></h4>
<p>若<span class="math inline">\(A\)</span>可逆,用<span class="math inline">\(A_i ( \vec{ b } )\)</span>表示将<span class="math inline">\(A\)</span>的第<span class="math inline">\(i\)</span>列替换为<span class="math inline">\(\vec{ b }\)</span>后的矩阵,则<span class="math inline">\(A \vec{ x } = \vec{ b
}\)</span>的唯一解可由下式给出:</p>
<p><span class="math display">\[
x_i = \cfrac{ \det A_i ( \vec{ b } ) }{ \det A }
\]</span></p>
<p>证明:由于<span class="math inline">\(A\)</span>实际上可以看作线性映射不难发现<span class="math inline">\(A \times I_i ( \vec{ x } ) = A_i ( \vec{ b }
)\)</span>,则根据行列式的乘法原理,有<span class="math inline">\(( \det A
) ( \det I_i ( \vec{ x } ) ) = \det A_i ( \vec{ b } )\)</span>.而<span class="math inline">\(\det I_i ( \vec{ x } ) =
x_i\)</span>,于是该定理显然.</p>
<p>或者直接考虑<span class="math inline">\(\vec{ x } = A^{ - 1 } \vec{ b
} = \frac{ 1 }{ \det A } \check{ A } \vec{ b }\)</span>,于是<span class="math inline">\(x_i = \frac{ 1 }{ \det A } \sum_{ k = 1 }^n C_{ k
, i } b_k\)</span>,后者刚好是<span class="math inline">\(A_i ( \vec{ b }
)\)</span>沿第<span class="math inline">\(i\)</span>列作余子式展开后的结果.</p>
<p>值得一提的是,Cramer法则揭示了<span class="math inline">\(\det \in
R^\times\)</span>的环上的矩阵必有逆矩阵</p>
<h4><span id="一些特殊行列式">一些特殊行列式</span></h4>
<h5><span id="置换矩阵">置换矩阵</span></h5>
<p>对于一个置换<span class="math inline">\(\sigma\)</span>,我们记它的置换矩阵<span class="math inline">\(P_\sigma\)</span>满足<span class="math inline">\(P_{ \sigma , i , j } = \begin{cases}1 &amp; i =
\sigma ( j ) \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>,容易发现它对应了线性映射<span class="math inline">\(\vec{ e }_j \mapsto \vec{ e }_{ \sigma ( j )
}\)</span>.容易看出<span class="math inline">\(P_\sigma P_\tau = P_{
\sigma \tau }\)</span>并且<span class="math inline">\(P_{ \sigma^{ - 1 }
} = ( P_\sigma )^{ - 1 } = ( P_\sigma
)^T\)</span>.容易由行列式理论得知<span class="math inline">\(| P_\sigma
| = \text{ sgn } ( \sigma )\)</span>.</p>
<h5><span id="上三角矩阵">上三角矩阵</span></h5>
<p>用代数余子式展开立刻见到上三角矩阵的行列式就是其对角线的乘积.这比用高斯消元更好,因为对角线未必可逆.</p>
<h5><span id="分块上三角矩阵">分块上三角矩阵</span></h5>
<p>也即<span class="math inline">\(\left | \begin{matrix}A_{ 1 , 1 }
&amp; \cdots &amp; \cdots \\ 0 &amp; \ddots &amp; \vdots \\ 0 &amp; 0
&amp; A_{ n , n }\end{matrix} \right | = \prod_{ i = 1 }^n \det A_{ i ,
i }\)</span>.</p>
<p>证明考虑数学归纳,先把左上角那一坨变成一个分块矩阵,那我们只需要证明<span class="math inline">\(\left | \begin{matrix}A_{ 1 , 1 } &amp; A_{ 1 , 2
} \\ 0 &amp; A_{ 2 , 2 }\end{matrix} \right | = \det A_{ 1 , 1 } \det
A_{ 2 , 2 }\)</span>.</p>
<p>这个怎么证明呢?考虑直接套定义,我们知道行列式的定义是:<span class="math inline">\(\det A = \sum_{ \sigma \in S_n } \text{ sgn } (
\sigma ) \prod_{ k = 1 }^n a_{ k , \sigma ( k )
}\)</span>,此时意识到如果<span class="math inline">\(k &gt; n_1 , \sigma
( k ) \leq n_1\)</span>那么此时<span class="math inline">\(a_{ k ,
\sigma ( k ) } = 0\)</span>,所以这个<span class="math inline">\(\sigma\)</span>应当分为两部分,一部分是<span class="math inline">\([ 1 , n_1 ]\)</span>部分内部交换,另一部分是<span class="math inline">\([ n_1 + 1 , n_1 + n_2
]\)</span>内部交换,这样我们把<span class="math inline">\(\sigma =
\sigma_1 \sigma_2\)</span>,上述表达式变为:</p>
<p><span class="math display">\[
\begin{aligned}
\det A &amp; = \sum_{ \sigma \in S_n } \text{ sgn } ( \sigma_1 ) \prod_{
k = 1 }^{ n_1 } a_{ k , \sigma_1 ( k ) } \text{ sgn } ( \sigma_2 )
\prod_{ k = n_1 + 1 }^{ n_1 + n_2 } a_{ k , \sigma_2 ( k ) } \\
&amp; = \det A_{ 1 , 1 } \det A_{ 2 , 2 }
\end{aligned}
\]</span></p>
<h5><span id="范德蒙德vandermonde行列式">范德蒙德(Vandermonde)行列式</span></h5>
<p>即<span class="math inline">\(\left | \begin{matrix}1 &amp; \cdots
&amp; 1 \\ x_1 &amp; \cdots &amp; x_n \\ \vdots &amp; &amp; \vdots \\
x_1^{ n - 1 } &amp; \cdots &amp; x_n^{ n - 1 }\end{matrix} \right | =
\prod_{ 1 \leq i &lt; j \leq n } ( x_j - x_i )\)</span>.</p>
<p>这个怎么求呢?我们先逐个消第一列(先用第<span class="math inline">\(n -
1\)</span>行消第<span class="math inline">\(n\)</span>行,再用第<span class="math inline">\(n - 2\)</span>行消第<span class="math inline">\(n
- 1\)</span>行,以此类推),我们得到的就是以下行列式:</p>
<p><span class="math display">\[
\left | \begin{matrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
0 &amp; x_2 - x_1 &amp; \cdots &amp; x_n - x_1 \\
0 &amp; \vdots &amp; &amp; \vdots \\
0 &amp; x_2^{ n - 1 } - x_1 x_2^{ n - 2 } &amp; \cdots &amp; x_n^{ n - 1
} - x_1 x_n^{ n - 2 }
\end{matrix} \right |
\]</span></p>
<p>对这个的第一列作代数余子式展开,知道它应当等于:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \left | \begin{matrix}
x_2 - x_1 &amp; \cdots &amp; x_n - x_1 \\
\vdots &amp; &amp; \vdots \\
x_2^{ n - 1 } - x_1 x_2^{ n - 2 } &amp; \cdots &amp; x_n^{ n - 1 } - x_1
x_n^{ n - 2 }
\end{matrix} \right | \\
= &amp; \left | \begin{matrix}
1 &amp; \cdots &amp; 1 \\
\vdots &amp; &amp; \vdots \\
x_2^{ n - 2 } &amp; \cdots &amp; x_n^{ n - 2 }
\end{matrix} \right | \prod_{ 1 &lt; j \leq n } ( x_j - x_1 )
\end{aligned}
\]</span></p>
<p>然后数学归纳就证完了.</p>
<h5><span id="一类分块矩阵">一类分块矩阵</span></h5>
<p>考虑<span class="math inline">\(\left | \begin{matrix}I &amp; B \\ A
&amp; I\end{matrix} \right | = \det ( I - AB
)\)</span>.此时观测其对基的作用,注意到其和<span class="math inline">\(\begin{bmatrix}I &amp; A \\ B &amp;
I\end{bmatrix}\)</span>无非是在不同基下的同种线性映射,于是<span class="math inline">\(\det ( I - AB ) = \det ( I - BA )\)</span>.</p>
<h4><span id="特征多项式">特征多项式</span></h4>
<p>自映射<span class="math inline">\(T = \text{ End } ( V
)\)</span>本身作为一个定义了乘法和加法的元素,理应可以嵌入多项式结构中.因此不妨定义多项式<span class="math inline">\(f ( T ) = \sum_{ k = 0 }^m a_k T^k\)</span>.</p>
<p>此时设<span class="math inline">\(\dim V = n\)</span>有限,那么<span class="math inline">\(\dim T = n^2\)</span>,考虑以下<span class="math inline">\(n^2 + 1\)</span>个此空间上的向量<span class="math inline">\(T^0 , \ldots , T^{ n^2
}\)</span>,它们必定线性相关,也就是存在一组不全为<span class="math inline">\(0\)</span>的<span class="math inline">\(\{ c_k
\}\)</span>使得<span class="math inline">\(f ( T ) = \sum_{ k = 0 }^{
n^2 } c_k T^k = 0\)</span>.</p>
<p>如果<span class="math inline">\(T\)</span>可逆,那我们考虑可以取一个满足上述条件的<span class="math inline">\(f\)</span>使得<span class="math inline">\(c_0 \ne
0\)</span>,原因是可以不断两边除去<span class="math inline">\(T\)</span>.那最终就会拿到<span class="math inline">\(c_0 \text{ id } + \sum_{ k = 1 }^m c_k T^k =
0\)</span>,对此式子再简单处理可知以下结论:对于一个可逆的<span class="math inline">\(T\)</span>,存在一个多项式<span class="math inline">\(g ( T )\)</span>使得<span class="math inline">\(T^{ - 1 } = g ( T ) = - \frac{ 1 }{ c_0 } \sum_{ k
= 1 }^{ m } c_k T^{ k - 1 }\)</span>.并且注意到<span class="math inline">\(\deg g ( T ) \leq n^2\)</span>.</p>
<p>将此定义挪到矩阵上,定义其特征多项式<span class="math inline">\(\text{
char }_A ( x ) = \det ( xI - A )\)</span>.由定义立刻得知<span class="math inline">\(\text{ char }_A ( x ) = \sum_{ \sigma } \text{ sgn
} ( \sigma ) \prod_{ i = 1 }^n ( [ i = \sigma ( i ) ] x - a_{ i , \sigma
( i ) } )\)</span>.于是容易发现<span class="math inline">\(\text{ char
}_A ( 0 ) = ( - 1 )^n \det A\)</span>.并且这个多项式应该首项为<span class="math inline">\(1\)</span>.</p>
<p>容易观察到相似的矩阵应当有相同的特征多项式,原因是<span class="math inline">\(\det ( xI - A ) = \det ( P^{ - 1 } ( xI - B ) P )
= \det ( xI - B
)\)</span>.这意味着其和基的选取无关,因此特征多项式可以拓展到一般的线性映射上.</p>
<p>另外转置不影响特征多项式的取值,原因是转置也不影响<span class="math inline">\(\det\)</span>的取值.</p>
<p>分块上三角矩阵的特征多项式就是对角线矩阵特征多项式的乘积.</p>
<p>我们还可以有以下性质:当<span class="math inline">\(A \in M_{ m \times
n } , B \in M_{ n \times m }\)</span>,则<span class="math inline">\(\cfrac{ \text{ char }_{ AB } }{ x^m } = \cfrac{
\text{ char }_{ BA } }{ x^n }\)</span>.</p>
<p>原因是考虑:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; x^{ - m } \text{ char }_{ AB } \\
= &amp; x^{ - m } \det ( xI - AB ) \\
= &amp; \det ( I - x^{ - 1 } AB ) \\
= &amp; \det ( I - x^{ - 1 } BA ) \\
= &amp; x^{ - n } \text{ char }_{ BA }
\end{aligned}
\]</span></p>
<p>原因是我们已经证明过了<span class="math inline">\(\det ( I - AB ) =
\det ( I - BA )\)</span>.</p>
<p>仅仅如此当然不够好用,然而注意到如果<span class="math inline">\(AB\)</span>以<span class="math inline">\(\lambda_0
\ne 0\)</span>为特征值的特征向量是<span class="math inline">\(\vec{ v
}\)</span>,那么<span class="math inline">\(BA\)</span>以<span class="math inline">\(\lambda_0\)</span>为特征值的特征向量就是<span class="math inline">\(B \vec{ v }\)</span>.</p>
<p>应当研究伴随矩阵在特征多项式下的情形,事实上有以下定理:如果<span class="math inline">\(\text{ char }_A = \sum_{ k = 0 }^n c_k
x^k\)</span>,那么<span class="math inline">\(( - 1 )^{ n - 1 } \check{ A
} = \sum_{ k = 1 }^n c_{ k } A^{ k - 1 }\)</span>.</p>
<p>考虑证明以上定理,考虑<span class="math inline">\(\text{ adj } ( xI -
A )\)</span>的每一个元素都是一个次数<span class="math inline">\(\leq n -
1\)</span>的多项式,对其进行分解得到<span class="math inline">\(\text{
adj } ( xI - A ) = \sum_{ k = 0 }^{ n - 1 } x^k D_k\)</span>,其中<span class="math inline">\(D_k\)</span>是一个矩阵,代表不同位置<span class="math inline">\(x^k\)</span>前的系数.</p>
<p>而我们知道<span class="math inline">\(\text{ char }_A ( x ) I = ( xI
- A ) \times \text{ adj } ( xI - A ) = ( xI - A ) \sum_{ k = 0 }^{ n - 1
} x^k D_k\)</span>.</p>
<p>两边提取系数,于是:</p>
<p><span class="math display">\[
\begin{aligned}
c_n I &amp; = D_{ n - 1 } \\
c_{ n - 1 } I &amp; = - AD_{ n - 1 } + D_{ n - 2 } \\
c_{ n - 2 } I &amp; = - AD_{ n - 2 } + D_{ n - 3 } \\
\cdots
\end{aligned}
\]</span></p>
<p>将上面这些若干式子右边乘以<span class="math inline">\(A^{ k
}\)</span>并相加就可以做到相消,得到<span class="math inline">\(D_0 =
\sum_{ k = 1 }^n c_{ k } A^{ k - 1 }\)</span>,而<span class="math inline">\(D_0\)</span>按照定义就是<span class="math inline">\(\text{ adj } ( 0 I - A ) = ( - 1 )^{ n - 1 }
\check{ A }\)</span>.</p>
<p>根据上述定理有以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(( A^\vee )^T = ( A^T
)^\vee\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ adj }{ ( P^{ - 1 } AP ) } =
P^{ - 1 } \check{ A } P\)</span>.</p></li>
</ol>
<p>另外,如果<span class="math inline">\(\text{ char }_A = \sum_{ k = 0
}^n c_k x^k\)</span>,那么<span class="math inline">\(\text{ char }_{ A^{
- 1 } } = \sum_{ k = 0 }^n \frac{ c_k }{ c_0 } x^{ n - k }\)</span>.</p>
<p>原因是观察到<span class="math inline">\(( - 1 )^n c_0 \times \text{
char }_{ A^{ - 1 } } = \det A \times \det ( xI - A^{ - 1 } ) = ( - x )^n
\det ( x^{ - 1 } I - A )\)</span>.</p>
<h4><span id="cayley-hamilton定理">Cayley-Hamilton定理</span></h4>
<p>即:<span class="math inline">\(\text{ char }_A ( A ) =
0\)</span>.</p>
<p>原因是根据上述定理,由于<span class="math inline">\(c_0 = ( - 1 )^n
\det A\)</span>,我们有:</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{ k = 0 }^n c_k A^k &amp; = ( ( - 1 )^n \det A ) \times I + A
\sum_{ k = 1 }^n c_k A^{ k - 1 } \\
&amp; = ( ( - 1 )^n \det A ) \times I + ( - 1 )^{ n - 1 } A \check{ A }
\\
&amp; = 0
\end{aligned}
\]</span></p>
<h4><span id="矩阵的迹">矩阵的迹</span></h4>
<p>定义<span class="math inline">\(A \in M_{ n \times n } ( F
)\)</span>的<strong>迹</strong><span class="math inline">\(\text{ tr } \
A = \sum_{ i = 1 }^n a_{ i , i }\)</span>.显然<span class="math inline">\(tr ( A + B ) = tr ( A ) + tr ( B
)\)</span>.容易验证<span class="math inline">\(tr : M_{ n \times n } ( F
) \to F\)</span>是线性映射,并且<span class="math inline">\(\forall A \in
M_{ n \times m } ( F ) , B \in M_{ m \times n } ( F )\)</span>有<span class="math inline">\(tr ( AB ) = tr ( BA )\)</span>.</p>
<p>于是共轭的矩阵有相同的迹,原因是<span class="math inline">\(tr ( P^{ -
1 } AP ) = tr ( APP^{ - 1 } ) = tr ( A
)\)</span>.这应当意味着迹这个东西有一些更好的性质.事实上,迹的等价定义是<span class="math inline">\(tr ( A ) = - [ x^{ n - 1 } ] \text{ char
}_A\)</span>,原因是<span class="math inline">\(\text{ char }_A ( x ) =
\sum_{ \sigma } \text{ sgn } ( \sigma ) \prod_{ i = 1 }^n ( [ i = \sigma
( i ) ] x - a_{ i , \sigma ( i ) }
)\)</span>,从这里立刻看出只有恒等映射<span class="math inline">\(\sigma
= \text{ id }\)</span>的时候才会对<span class="math inline">\([ x^{ n -
1 } ]\)</span>产生贡献.</p>
<h6><span id="example">Example</span></h6>
<p>证明:如果<span class="math inline">\(tr ( A ) =
0\)</span>,而且域的特征<span class="math inline">\(\text{ char } \ F =
0\)</span>,那么存在<span class="math inline">\(A &#39; = PAP^{ - 1
}\)</span>使得<span class="math inline">\(\forall i \in [ 1 , n ] , a
&#39;_{ i , i } = 0\)</span>.</p>
<p>如果<span class="math inline">\(A = 0\)</span>就下班了对吧,如果<span class="math inline">\(A \ne 0\)</span>,我们下面来数学归纳证明.假设<span class="math inline">\(&lt; n\)</span>的时候已经得证.</p>
<p>首先我们说明:如果对于所有的<span class="math inline">\(\vec{ v } \in
F^n\)</span>都存在<span class="math inline">\(c_v \in
F\)</span>使得<span class="math inline">\(A \vec{ v } = c_v \vec{ v
}\)</span>,那么存在<span class="math inline">\(c \in F\)</span>使得<span class="math inline">\(A = cI\)</span>.</p>
<p>考虑线性无关的两个向量<span class="math inline">\(\vec{ v } , \vec{ w
}\)</span>,如果<span class="math inline">\(c_v \ne
c_w\)</span>,考虑<span class="math inline">\(c_v \vec{ v } + c_w \vec{ w
} = A ( \vec{ v } + \vec{ w } ) = c_{ v + w } ( \vec{ v } + \vec{ w }
)\)</span>,于是自然导出<span class="math inline">\(c_v = c_{ v + w } =
c_w\)</span>,矛盾.于是上述命题成立.</p>
<p>对于一个<span class="math inline">\(tr ( A ) =
0\)</span>的矩阵当然不是<span class="math inline">\(cI\)</span>的形式,那我们就可以找到一个<span class="math inline">\(\vec{ v }\)</span>使得<span class="math inline">\(A \vec{ v } \ne c \vec{ v }\)</span>,于是<span class="math inline">\(A \vec{ v }\)</span>和<span class="math inline">\(\vec{ v
}\)</span>线性无关.此时考虑将其扩充为一个基<span class="math inline">\(\{ \vec{ v } , A \vec{ v } , \vec{ v }_3 , \cdots
, \vec{ v }_n \}\)</span>,考虑当然存在一个<span class="math inline">\(C\)</span>使得<span class="math inline">\(C =
P_1^{ - 1 } AP_1\)</span>这样<span class="math inline">\(C\)</span>是对上述基的作用.那我们考虑<span class="math inline">\(C ( \vec{ v } ) = A \vec{ v }\)</span>,于是<span class="math inline">\(C\)</span>应当形如:</p>
<p><span class="math display">\[
\begin{bmatrix}
0 &amp; \cdots \\
1 &amp; \vdots \\
0 &amp; \vdots \\
\vdots &amp; \vdots
\end{bmatrix}
\]</span></p>
<p>不妨设<span class="math inline">\(C = \begin{bmatrix}0 &amp; T \\ L
&amp; B\end{bmatrix}\)</span>,我们知道根据归纳假设,对于<span class="math inline">\(B\)</span>来说存在一个<span class="math inline">\(P_2\)</span>使得<span class="math inline">\(P_2^{
- 1 } BP_2\)</span>的对角线全零,那我们考虑:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 \\
0 &amp; P_2^{ - 1 }
\end{bmatrix} \begin{bmatrix}
0 &amp; T \\
L &amp; B
\end{bmatrix} \begin{bmatrix}
1 &amp; 0 \\
0 &amp; P_2
\end{bmatrix} = \begin{bmatrix}
0 &amp; \_ \\
\_ &amp; P_2^{ - 1 } BP_2
\end{bmatrix}
\]</span></p>
<p>这样就做完了.</p>
<h4><span id="binet-cauchy定理">Binet-Cauchy定理</span></h4>
<p>定义大小分别为<span class="math inline">\(n \times m\)</span>和<span class="math inline">\(m \times n\)</span>(其中<span class="math inline">\(n \leq m\)</span>)的矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>,令<span class="math inline">\(A [ S
]\)</span>表示矩阵<span class="math inline">\(A\)</span>只取<span class="math inline">\(S\)</span>集合中的列所形成的矩阵,<span class="math inline">\(B [ S ]\)</span>表示矩阵<span class="math inline">\(B\)</span>只取<span class="math inline">\(S\)</span>集合中的行所形成的矩阵,则有:</p>
<p><span class="math display">\[
\det ( AB ) = \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } (
\det ( A [ S ] ) ) ( \det ( B [ S ] ) )
\]</span></p>
<p>下面设<span class="math inline">\(\lambda ( P )\)</span>为排列<span class="math inline">\(P\)</span>的逆序对数.</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } ( \det (
A [ S ] ) ) ( \det ( B [ S ] ) ) \\
= &amp; \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } (
\sum_{ P } ( - 1 )^{ \lambda ( P ) } \prod_{ i = 1 }^n A_{ i , S_{ P_i }
} ) ( \sum_{ Q } ( - 1 )^{ \lambda ( Q ) } \prod_{ i = 1 }^n B_{ S_i ,
Q_i } ) \\
= &amp; \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } \sum_{
P } \sum_{ Q } ( - 1 )^{ \lambda ( P ) + \lambda ( Q ) } \prod_{ i = 1
}^n A_{ i , S_{ P_i } } B_{ S_i , Q_i }
\end{aligned}
\]</span></p>
<p>若让<span class="math inline">\(R\)</span>为可重集合,换言之让其取遍<span class="math inline">\(m^n\)</span>种情况,又有:</p>
<p><span class="math display">\[
\begin{aligned}
\det ( AB ) &amp; = \sum_{ P } ( - 1 )^{ \lambda ( P ) } \prod_{ i = 1
}^n ( \sum_{ j = 1 }^m A_{ i , j } B_{ j , P_i } ) \\
&amp; = \sum_{ P } ( - 1 )^{ \lambda ( P ) } \sum_{ R , \forall i , R_i
\in [ 1 , m ] } ( \prod_{ i = 1 }^n A_{ i , R_i } B_{ R_i , P_i } ) \\
&amp; = \sum_{ R , \forall i , R_i \in [ 1 , m ] } \sum_P ( - 1 )^{
\lambda ( P ) } ( \prod_{ i = 1 }^n A_{ i , R_i } ) ( \prod_{ i = 1 }^n
B_{ R_i , P_i } )
\end{aligned}
\]</span></p>
<p>如果<span class="math inline">\(\exists 1 \leq i , j \leq n , i \ne
j\)</span>,<span class="math inline">\(R_i = R_j\)</span>,则交换<span class="math inline">\(P_i ,
P_j\)</span>后,后面的值仍然不变,可逆序对的奇偶性改变了.如果我们对于每一个重复序列都选取最靠前的一对,那么显然只有<span class="math inline">\(R\)</span>不重的情况才有可能产生贡献.既然如此,<span class="math inline">\(R\)</span>的生成方式就应该是先顺序取子集再用一个排列打乱顺序.</p>
<p>所以我们有:</p>
$$
<span class="math display">\[\begin{aligned}
\det ( AB ) &amp; = \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | =
n } \sum_{ Q } \sum_{ P } ( - 1 )^{ \lambda ( P ) } ( \prod_{ i = 1 }^n
A_{ i , S_{ Q_i } } ) ( \prod_{ i = 1 }^n B_{ S_{ Q_i } , P_i } ) \\
&amp; = \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } \sum_{
Q } \sum_{ P_{ Q &#39; } } ( - 1 )^{ \lambda ( P_{ Q &#39; } ) } (
\prod_{ i = 1 }^n A_{ i , S_{ Q_i } } ) ( \prod_{ i = 1 }^n B_{ S_i ,
P_{ Q &#39;_i } } ) \\
&amp; = \sum_{ S \subseteq \{ 1 , 2 , . . . , m \} , | S | = n } \sum_{
Q } \sum_{ P_{ Q &#39; } } ( - 1 )^{ \lambda ( P ) + \lambda ( Q ) } (
\prod_{ i = 1 }^n A_{ i , S_{ Q_i } } ) ( \prod_{ i = 1 }^n B_{ S_i ,
P_{ Q &#39;_i } } ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>左右显然相等.</p>
<p>另外,这个定理有更简单的证明方法,即使用LGV引理与组合意义证明.</p>
<p>不妨设现在有个点的集合<span class="math inline">\(A , B ,
C\)</span>,现在想求出<span class="math inline">\(A \rightarrow B
\rightarrow
C\)</span>的不交路径的奇偶数量差,会发现左右的组合意义是相等的.</p>
<p>于此之外,还有一个纯代数的证明策略,不妨定义符号<span class="math inline">\(A \binom{ I }{ J } = A \binom{ i_1 , \cdots , i_r
}{ j_1 , \cdots , j_s }\)</span>表示提取下标集<span class="math inline">\(I\)</span>和<span class="math inline">\(J\)</span>分别作为行列得到的矩阵.</p>
<p>先证明一个引理:<span class="math inline">\(C \in M_{ n \times n } , [
x^{ n - k } ] \det ( xI + C ) = \sum_{ I \in \{ 1 , \cdots , n \} , | I
| = k } \det C \binom{ I }{ I }\)</span>.</p>
<p>回忆到运算符<span class="math inline">\(\delta_{ i , j } = [ i = j
]\)</span>,应当注意到:<span class="math inline">\(\det ( xI + C ) =
\sum_{ \sigma } \text{ sgn } ( \sigma ) \prod_{ i = 1 }^n ( x [ i = j ]
+ c_{ i , \sigma ( i ) } )\)</span>,此时要想凑出<span class="math inline">\(x^{ n - k }\)</span>,就需要有<span class="math inline">\(n -
k\)</span>个位置被卡死,而剩下的部分无非是提取剩下<span class="math inline">\(k\)</span>行<span class="math inline">\(k\)</span>列后的结果.就可以见到上述引理无非定义的平凡推论.</p>
<p>然后开始证明该定理,回忆到我们已经证明过<span class="math inline">\(x^{ m - n } \det ( xI + AB ) = \det ( xI + BA
)\)</span>.此时对左右两边取<span class="math inline">\([ x^{ m - n }
]\)</span>,左边取出了<span class="math inline">\(\det ( xI + AB
)\)</span>的常数项,亦即<span class="math inline">\(\det ( AB
)\)</span>.而右边,按上述引理得知得到了<span class="math inline">\(\sum_{
I \in \{ 1 , \cdots , n \} , | I | = k } \det \left ( ( BA ) \binom{ I
}{ I } \right )\)</span>,而这恰为原本右式的矩阵乘法定义.</p>
<p>由该定理得知,对于<span class="math inline">\(A \in M_{ m \times n
}\)</span>,<span class="math inline">\(\det{ A^T A } \geq
0\)</span>.</p>
<h4><span id="特征值与特征向量">特征值与特征向量</span></h4>
<p>我们之前应当已经见到,如果一个矩阵是分块对角矩阵,那这个矩阵应当相当容易处理,原因是其加减乘运算无非只是在对角线上的适当操作而已.这引发我们选取适当的直和分解<span class="math inline">\(V = \bigoplus
V_k\)</span>将原本的矩阵化为合适的分块对角矩阵.</p>
<p>然而如果我们想要拿到具体的矩阵就不可避免地需要选基,因此在固定的基意义下,我们对于一个矩阵<span class="math inline">\(A\)</span>,应当思考能否通过换基操作使得<span class="math inline">\(A = P^{ - 1 } BP\)</span>,其中<span class="math inline">\(B\)</span>是一个分块对角矩阵,那此时<span class="math inline">\(A\)</span>也拥有相当好的性质.</p>
<p>考虑最简单的情况,即每个分块都是单个元素的情况,此时该矩阵应当就是一个对角矩阵.这相当于选定一组基<span class="math inline">\(\{ \vec{ v }_1 , \cdots , \vec{ v }_n
\}\)</span>后,取<span class="math inline">\(V_k = \text{ span } \{ \vec{
v }_k \}\)</span>并将这些<span class="math inline">\(V_k\)</span>取直和得到<span class="math inline">\(V\)</span>,此时该线性映射应当给出<span class="math inline">\(T \vec{ v }_k = \lambda_k \vec{ v
}_k\)</span>,即只能做一个伸缩变换.上面的种种操作都引诱我们去思考能否进行以上操作,这就引入下面的定义:</p>
<p>设<span class="math inline">\(T \in \text{ End } ( V
)\)</span>并且<span class="math inline">\(\lambda \in
F\)</span>,我们引入如下定义:</p>
<ol type="1">
<li><p>称子空间<span class="math inline">\(V_\lambda = \ker ( \lambda
\times \text{ id }_V - T )\)</span>为<span class="math inline">\(T\)</span>的<span class="math inline">\(\lambda\)</span><strong>特征子空间</strong>,若<span class="math inline">\(V_\lambda \ne \{ 0 \}\)</span>,则称<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(T\)</span>的<strong>特征值</strong>.</p></li>
<li><p>对于<span class="math inline">\(\vec{ v } \in
V_\lambda\)</span>,换言之<span class="math inline">\(T \vec{ v } =
\lambda \vec{ v }\)</span>,而且<span class="math inline">\(\vec{ v } \ne
0\)</span>,则称<span class="math inline">\(\vec{ v }\)</span>是<span class="math inline">\(T\)</span>的一个<strong>特征向量</strong>,以<span class="math inline">\(\lambda\)</span>为特征值.</p></li>
</ol>
<p>考虑特征值的定义等价于<span class="math inline">\(\det ( \lambda
\times I - T ) = 0\)</span>,于是等价于<span class="math inline">\(\text{
char }_T ( \lambda ) = 0\)</span>.立刻见到一个<span class="math inline">\(\lambda\)</span>是特征值等价于其是<span class="math inline">\(\text{ char }_T = 0\)</span>的一个根.反之,<span class="math inline">\(\text{ char }_T =
0\)</span>的一个根也一定对应了一个非空的特征子空间,也就对应了一组非零特征向量.如果<span class="math inline">\(T\)</span>分裂,见到行列式其实是特征值的乘积,而迹实际上是特征值的加和.应当见到,一个矩阵可逆等价于其不存在<span class="math inline">\(0\)</span>特征值.</p>
<p>考虑对角化,如果我们能在上面取出若干<span class="math inline">\(\vec{
v }\)</span>组成一组基,那直接用这组基就可以把<span class="math inline">\(T\)</span>拆成在这组基上的伸缩变换,这样就实现了对角化.因此如果我们能取出一组基使得每一个基对<span class="math inline">\(A\)</span>都是特征向量,我们称<span class="math inline">\(A\)</span>是<strong>可对角化的</strong>.立刻见到可对角化的必要条件是<span class="math inline">\(\text{ char }_A\)</span>分裂.</p>
<p>如果<span class="math inline">\(T\)</span>可对角化,我们有<span class="math inline">\(\dim V_\lambda = d\)</span>,其中<span class="math inline">\(d\)</span>是<span class="math inline">\(\lambda\)</span>作为特征多项式的根的重数.如果其可对角化,直接按上述方式取基得到<span class="math inline">\(z\)</span>,并且<span class="math inline">\(PTP^{ -
1 }\)</span>就是在标准基下的变换矩阵.那么直接考虑<span class="math inline">\(\text{ rk } ( \lambda_n I - T ) = n -
d\)</span>,其中<span class="math inline">\(d\)</span>是<span class="math inline">\(\lambda_n\)</span>的重数.用同态基本定理立刻得到<span class="math inline">\(V_{ \lambda_n } =
d\)</span>.(注意这里都是在讨论可对角化的前提下)</p>
<p>我们希望能把<span class="math inline">\(V_{ \lambda_k
}\)</span>给做直和,那我们就需要做前置工作.具体而言,我们需要证明选取<span class="math inline">\(\vec{ v }_k \in V_{ \lambda_k }\)</span>,那么<span class="math inline">\(\sum \vec{ v }_k = \vec{ 0 } \Leftrightarrow
\forall k , \vec{ v }_k = \vec{ 0 }\)</span>.使用数学归纳,注意到<span class="math inline">\(T ( \sum \vec{ v }_k ) = \sum \lambda_k \vec{ v
}_k = 0\)</span>,又知道<span class="math inline">\(\lambda_1 \sum \vec{
v }_k = 0\)</span>,两者一消就可以进行数学归纳.</p>
<p>由上面的过程得知下述命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化.</p></li>
<li><p><span class="math inline">\(\sum_{ \lambda \in F } \dim V_{
\lambda } = \dim V\)</span>.</p></li>
<li><p><span class="math inline">\(\bigoplus_{ \lambda \in F } V_\lambda
= V\)</span>.</p></li>
</ol>
<p>其推论是如果所有的<span class="math inline">\(\lambda_k\)</span>互不相同,那么<span class="math inline">\(\dim V_{ \lambda_k } \geq
1\)</span>,这必然给出<span class="math inline">\(T\)</span>可对角化.这似乎告诉我们去除重数有某种很好的性质.</p>
<h4><span id="极小多项式">极小多项式</span></h4>
<p>考虑对于一个多项式<span class="math inline">\(h \in F [ x
]\)</span>,当我们将<span class="math inline">\(T \in \text{ End } ( V
)\)</span>带入之后当然会得到一个<span class="math inline">\(h ( T ) \in
\text{ End } ( V )\)</span>,现在固定<span class="math inline">\(h ,
T\)</span>,以此构造一个子空间<span class="math inline">\(V [ h ] = \ker
( h ( T ) ) = \{ \vec{ v } \in V | h ( T ) \vec{ v } = 0
\}\)</span>.</p>
<p>此时注意到<span class="math inline">\(T ( V [ h ] ) \subseteq V [ h
]\)</span>,原因是<span class="math inline">\(T\)</span>与自身交换,于是<span class="math inline">\(\forall \vec{ v } \in V [ h ]\)</span>,应当有<span class="math inline">\(h ( T ) ( T \vec{ v } ) = Th ( T ) \vec{ v } = T (
\vec{ 0 } ) = \vec{ 0 }\)</span>,这意味着<span class="math inline">\(T
\vec{ v } \in V [ h ]\)</span>.于是可见到<span class="math inline">\(V [
h ]\)</span>实际上是一个<span class="math inline">\(T\)</span>不变子空间.</p>
<p>取<span class="math inline">\(h = x - \lambda I\)</span>,那么<span class="math inline">\(V [ h ]\)</span>其实就是我们上述所说的<span class="math inline">\(V_\lambda\)</span>,因此<span class="math inline">\(V_\lambda\)</span>也是<span class="math inline">\(T\)</span>不变的.从这里立刻能看出些什么,比如当<span class="math inline">\(\dim V_\lambda = 1\)</span>的时候,<span class="math inline">\(T\)</span>不变当然意味着伸缩变换.</p>
<p>那我们既然需要这个东西用在<span class="math inline">\(V_\lambda\)</span>上,首要要做的当然是分析在其上面的直和分解.换言之,我们下面试图证明如下引理(核引理):<span class="math inline">\(f \bot g\)</span>的时候,<span class="math inline">\(V [ fg ] = V [ gf ] = V [ f ] \oplus V [ g
]\)</span>.</p>
<p>原因是考虑<span class="math inline">\(F [ x
]\)</span>的主理想性引出其裴蜀定理,那么就存在多项式<span class="math inline">\(a , b\)</span>使得<span class="math inline">\(af +
bg = 1\)</span>.此时<span class="math inline">\(\vec{ v } = ( af + bg )
( T ) \vec{ v } = a ( T ) ( f ( T ) \vec{ v } ) + b ( T ) ( g ( T )
\vec{ v } )\)</span>.注意到如果<span class="math inline">\(\vec{ v } \in
V [ fg ]\)</span>,那么<span class="math inline">\(f ( T ) \vec{ v } \in
V [ g ] , g ( T ) \vec{ v } \in V [ f ]\)</span>,而<span class="math inline">\(V [ g ]\)</span>和<span class="math inline">\(V [
f ]\)</span>对<span class="math inline">\(a ( T )\)</span>和<span class="math inline">\(b ( T )\)</span>都是不变子空间,原因是它们对<span class="math inline">\(T\)</span>都是不变子空间,这必然意味着<span class="math inline">\(a ( T ) ( f ( T ) \vec{ v } ) \in V [ g
]\)</span>,后者亦然同理.这意味着<span class="math inline">\(V [ fg ]
\subseteq V [ f ] + V [ g ]\)</span>,而<span class="math inline">\(V [ f
] \subseteq V [ fg ] , V [ g ] \subseteq V [ fg
]\)</span>,这立刻得到<span class="math inline">\(V [ fg ] = V [ f ] + V
[ g ]\)</span>.此时检查<span class="math inline">\(\vec{ v } \in V [ g ]
\cap V [ f ]\)</span>,发现<span class="math inline">\(\vec{ v } = ( af +
bg ) ( T ) \vec{ v } = \vec{ 0 }\)</span>,这就意味着<span class="math inline">\(V [ fg ] = V [ f ] \oplus V [ g ]\)</span>.</p>
<p>考虑<span class="math inline">\(I = \{ f \in F [ x ] | f ( T ) = 0_V
\}\)</span>,容易见到其应当也有某种<span class="math inline">\(\ker\)</span>的性质,事实上可以证明它是一个理想,原因是当然满足加法和乘法的封闭律.而由于<span class="math inline">\(F [ x
]\)</span>是一个主理想环,那么上面就应当存在一个<span class="math inline">\(\deg\)</span>极小的<span class="math inline">\(h\)</span>,使得<span class="math inline">\(I = ( h
)\)</span>,不妨将<span class="math inline">\(h\)</span>规范化为首一的多项式.那么以上操作给出:<span class="math inline">\(f ( T ) = 0 \Leftrightarrow h | f\)</span>.</p>
<p>由Cayley-Hamilton定理,当维度有限的时候,这样的多项式必然存在,这就意味着<span class="math inline">\(I \ne \{ 0 \}\)</span>,此时我们就把上面的这个<span class="math inline">\(h\)</span>叫做<span class="math inline">\(T\)</span>的<strong>极小多项式</strong><span class="math inline">\(\text{ Min }_T\)</span>.</p>
<p>值得一提的是如果<span class="math inline">\(A\)</span>是在<span class="math inline">\(F\)</span>上的矩阵,其极小多项式为<span class="math inline">\(\text{ Min }_{ A , F }\)</span>,<span class="math inline">\(F\)</span>是<span class="math inline">\(E\)</span>的子域,<span class="math inline">\(A\)</span>在<span class="math inline">\(E\)</span>上的极小多项式为<span class="math inline">\(\text{ Min }_{ A , E }\)</span>,则<span class="math inline">\(\text{ Min }_{ A , F } = \text{ Min }_{ A , E
}\)</span>.原因是首先<span class="math inline">\(\text{ Min }_{ A , E }
| \text{ Min }_{ A , F }\)</span>,于是<span class="math inline">\(\text{
Min }_{ A , E } = \text{ Min }_{ A , F }\)</span>等价于<span class="math inline">\(A^0 , \cdots , A^{ d - 1
}\)</span>线性无关,其中<span class="math inline">\(d = \deg \text{ Min
}_{ A , F
}\)</span>.而判定线性无关实际上是用高斯消元判定的,和域的选取无关.</p>
<p>用一次Cayley-Hamilton定理,知道<span class="math inline">\(\text{ Min
}_T | \text{ char }_T\)</span>.既然如此,<span class="math inline">\(\text{ Min }_T\)</span>保留了<span class="math inline">\(\text{ char
}_T\)</span>的哪些具体性质呢?它们之间的关系又如何呢?我们下面尝试证明:如果<span class="math inline">\(\lambda\)</span>是<span class="math inline">\(T\)</span>的特征值,当且仅当<span class="math inline">\(\text{ Min }_T ( \lambda ) = 0\)</span>.</p>
<p>充分性显然,因为我们已经声明了只要是<span class="math inline">\(\text{
char }_T\)</span>的一个根就自动是特征值.</p>
<p>下面证明必要性:注意到如果<span class="math inline">\(\lambda\)</span>是特征值,此时<span class="math inline">\(\vec{ 0 } = \text{ Min }_T ( T ) \vec{ v } =
\text{ Min }_T ( \lambda ) \vec{ v }\)</span>,原因是观察到如果<span class="math inline">\(T \vec{ v } = \lambda \vec{ v
}\)</span>,那么立刻得到<span class="math inline">\(f ( T ) \vec{ v } = f
( \lambda ) \vec{ v }\)</span>.于是立刻得到<span class="math inline">\(\text{ Min }_T ( \lambda ) = 0\)</span>.</p>
<p>此时见到端倪,我们再证明以下定理:</p>
<p>对于固定的<span class="math inline">\(T \in \text{ End } ( V
)\)</span>如果有直和分解<span class="math inline">\(V = \bigoplus
V_k\)</span>,其中每个<span class="math inline">\(V_k\)</span>都是<span class="math inline">\(T\)</span>不变子空间,那么就可以把<span class="math inline">\(T\)</span>限制到相应的<span class="math inline">\(V_k\)</span>空间内,记作<span class="math inline">\(T |_{ V_k } \in \text{ End } ( V_k
)\)</span>,那在这些空间内部自然有它们自己的极小多项式<span class="math inline">\(\text{ Min }_{ T_k }\)</span>,我们断言<span class="math inline">\(\text{ Min }_T = \text{ lcm }_k ( \text{ Min }_{
T_k } )\)</span>.原因是由于直和的性质,<span class="math inline">\(f ( T
) = \vec{ 0 }\)</span>当且仅当对于每一个<span class="math inline">\(k\)</span>,<span class="math inline">\(f ( T_{ k }
) = 0\)</span>,应用极小多项式的定义立刻见到上述结论显然.</p>
<p>对于<span class="math inline">\(T \in \text{ End } ( V
)\)</span>,我们应当能见到此时<span class="math inline">\(V = V [ \text{
Min }_{ T } ]\)</span>.那么反过来,<span class="math inline">\(V [ \text{
Min }_T ] = V\)</span>的极小多项式当然也是<span class="math inline">\(\text{ Min }_T\)</span>本身,这只是定义.</p>
<p>不妨设<span class="math inline">\(\text{ Min }_T =
fg\)</span>并且<span class="math inline">\(f \bot
g\)</span>,从上面当然可以知道<span class="math inline">\(V = V [ f ]
\oplus V [ g ]\)</span>.此时我们应当思考的是<span class="math inline">\(V [ f ]\)</span>中的极小多项式是否是<span class="math inline">\(f\)</span>,<span class="math inline">\(V [ g
]\)</span>中的极小多项式是否是<span class="math inline">\(g\)</span>.而<span class="math inline">\(\text{
Min }_T\)</span>是<span class="math inline">\(V [ f ]\)</span>和<span class="math inline">\(V [ g
]\)</span>中极小多项式的乘积,它们中的极小多项式又只是<span class="math inline">\(f ,
g\)</span>的因子,那必然见到极小多项式就是它们.</p>
<p>我们理应从上面的分析中见到极小多项式形态的一种刻画,我们接下来尝试证明,如果<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化,其特征值去重后是<span class="math inline">\(\lambda_1 , \cdots ,
\lambda_m\)</span>,那么最小多项式<span class="math inline">\(\text{ Min
}_T = \prod_{ k = 1 }^m ( x - \lambda_k )\)</span>.</p>
<p>原因是考虑<span class="math inline">\(T\)</span>可对角化导致<span class="math inline">\(V\)</span>可以被拆成特征子空间的直和<span class="math inline">\(V = \bigoplus_{ k = 1 }^m V_{ \lambda_k
}\)</span>.而其限制在每一个特征子空间上都是一个伸缩变换,其对应的极小多项式无外乎<span class="math inline">\(x - \lambda_k\)</span>,这样就得到上面的结论.</p>
<p>上述结论反之依然成立,那我们可以拿出一个更好的结论了,即:<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可对角化的充要条件是极小多项式<span class="math inline">\(\text{ Min }_T \in F [ x
]\)</span>分裂并且无重根.</p>
<p>必要性在上面已经证明,接下来说明充分性.</p>
<p>当<span class="math inline">\(\text{ Min }_T = \prod_{ k = 1 }^m ( x
- \lambda_k )\)</span>的时候,我们下面证明<span class="math inline">\(T\)</span>可对角化,顺便说明此时<span class="math inline">\(\lambda_1 , \cdots , \lambda_m\)</span>就是<span class="math inline">\(T\)</span>的特征值去重后的结果.运用上述结论可以知道<span class="math inline">\(V = \bigoplus V [ x - \lambda_k
]\)</span>.然而<span class="math inline">\(V [ x - \lambda_k ] = V_{
\lambda_k
}\)</span>,这立刻就回到了可对角化的等价条件,于是充分性得证.</p>
<p>应当能从上面看出可对角化的某种拆分性,事实上,如果<span class="math inline">\(T \in \text{ End } ( V )\)</span>可对角化,<span class="math inline">\(V_0 \subseteq V\)</span>是<span class="math inline">\(T\)</span>下的不变子空间,则<span class="math inline">\(T |_{ V_0 } \in \text{ End } ( V_0
)\)</span>和<span class="math inline">\(\bar{ T } \in \text{ End } ( V /
V_0 )\)</span>都可以对角化.原因是它们的极小多项式都应当是<span class="math inline">\(\text{ Min }_T\)</span>的因子.</p>
<p>然而也可以看出来上述命题的逆并不成立,因为拆出来的两个的极小多项式并不一定互质.</p>
<h4><span id="同步对角化">同步对角化</span></h4>
<p>设<span class="math inline">\(\mathcal{ S } \subseteq \text{ End } (
V )\)</span>,如果存在<span class="math inline">\(V\)</span>的基<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v
}_n\)</span>使得每个<span class="math inline">\(\vec{ v
}_i\)</span>都是所有<span class="math inline">\(T \in \mathcal{ S
}\)</span>的共同的特征向量,换言之每一个<span class="math inline">\(T\)</span>都可以用同样的一个可逆矩阵<span class="math inline">\(P\)</span>使得<span class="math inline">\(P^{ - 1
} AP\)</span>是对角的,那我们称<span class="math inline">\(\mathcal{ S
}\)</span>在<span class="math inline">\(F\)</span>上可以<strong>同步对角化</strong>.</p>
<p>我们首先证明一个引理:如果<span class="math inline">\(ST =
TS\)</span>,那么<span class="math inline">\(T\)</span>的任何一个特征子空间<span class="math inline">\(V_\lambda\)</span>都是<span class="math inline">\(S\)</span>的一个不变子空间.原因是对于<span class="math inline">\(\vec{ v } \in V_\lambda\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
T \vec{ v } &amp; = \lambda \vec{ v } \\
ST \vec{ v } &amp; = \lambda ( S \vec{ v } ) \\
T ( S \vec{ v } ) &amp; = \lambda ( S \vec{ v } )
\end{aligned}
\]</span></p>
<p>所以<span class="math inline">\(S \vec{ v } \in
V_\lambda\)</span>.</p>
<p>我们得知同步对角化的充要条件应该是以下两条同时成立:</p>
<ol type="1">
<li><p>每个<span class="math inline">\(T \in \mathcal{ S
}\)</span>在<span class="math inline">\(F\)</span>上都可对角化.</p></li>
<li><p><span class="math inline">\(\forall T , T &#39; \in \mathcal{ S
}\)</span>,<span class="math inline">\(TT &#39; = T &#39;
T\)</span>.</p></li>
</ol>
<p>必要性显然,下面来说明充分性.</p>
<p>取出<span class="math inline">\(T_1\)</span>的所有特征子空间<span class="math inline">\(V_\lambda\)</span>,由于<span class="math inline">\(T &#39;\)</span>可对角化,所以其限制在<span class="math inline">\(T &#39; |_{ V_\lambda
}\)</span>上肯定也可对角化.如果我们能说明限制在每一个特征子空间<span class="math inline">\(V_\lambda\)</span>上时都可以同步对角化,由于特征子空间是直和分解,所以取直和后当然也可以.此时注意到限制后的<span class="math inline">\(T &#39;\)</span>必然也有交换律,而<span class="math inline">\(T_1 |_{ V_\lambda }\)</span>本身应当是<span class="math inline">\(\lambda
I\)</span>.这个东西怎么着都是可对角化的,因此就只需要对除了<span class="math inline">\(T_1\)</span>剩下部分继续做,这样就实现了数学归纳.</p>
<h4><span id="上三角化">上三角化</span></h4>
<p>回忆到我们之前曾经提过的旗的概念,我们在下面断言:若<span class="math inline">\(T \in \text{ End } ( V )\)</span>保持<span class="math inline">\(V\)</span>的一组完备旗,则<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上<strong>可上三角化</strong>,也就是其可以换基得到一个上三角矩阵.</p>
<p>我们已经得知一般的矩阵未必能对角化,那能不能退而求其次讲一个矩阵通过共轭转化为上三角的形式呢?我们下面证明:<span class="math inline">\(\text{ char }_T\)</span>在<span class="math inline">\(F\)</span>上分裂是<span class="math inline">\(T\)</span>在<span class="math inline">\(F\)</span>上可上三角化的充要条件.</p>
<p>先证明必要性:当其可上三角化的时候,可以取<span class="math inline">\(V\)</span>的一组有序基,使得<span class="math inline">\(T\)</span>对应的矩阵形如<span class="math inline">\(\begin{bmatrix}\lambda_1 &amp; \cdots &amp; \cdots
\\ 0 &amp; \ddots &amp; \cdots \\ 0 &amp; 0 &amp;
\lambda_n\end{bmatrix}\)</span>,此时立刻能得到其<span class="math inline">\(\text{ char }_T = \prod ( x - \lambda_k
)\)</span>,这立刻给出其可分裂.</p>
<p>再证明充分性:数学归纳,取出<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\vec{ v }_1 \in V_{ \lambda_1 } \setminus \{ 0
\}\)</span>,再令<span class="math inline">\(V_1 = \text{ span } \{ \vec{
v }_1 \}\)</span>,这里拿到的<span class="math inline">\(V_1\)</span>当然是一个不变子空间.仍取<span class="math inline">\(\pi : V \to V / V_1\)</span>,接下来观察<span class="math inline">\(V /
V_1\)</span>的维数降了一维,根据数学归纳那其当然可以上三角化.回忆到我们曾经声明过了此时<span class="math inline">\(\text{ char }_T = ( x - \lambda_1 ) \text{ char
}_{ \bar{ T }
}\)</span>,原因是之前曾提过的在此分解下行列式之间的关系.可上三角化应当给出在<span class="math inline">\(V / V_1\)</span>上的一个被<span class="math inline">\(\bar{ T }\)</span>保持的完备旗<span class="math inline">\(\{ 0 \} = \bar{ V_1 } \subsetneq \cdots \subsetneq
\bar{ V_n } = \bar{ V
}\)</span>.第一同构定理已经声明过对他们取原像后仍然是子空间,于是我们取原像应当可以重新得到一列完备旗:<span class="math inline">\(\{ 0 \} = V_0 \subsetneq V_1 \subsetneq \cdots
\subsetneq V_n = V\)</span>.</p>
<p>我们断言上述的旗也被<span class="math inline">\(T\)</span>保持,原因是<span class="math inline">\(\vec{ v } \in V_i \Rightarrow \pi ( T \vec{ v } )
= \bar{ T } ( \pi \vec{ v } ) \in \bar{ T } ( \bar{ V }_i ) \subseteq
\bar{ V }_i = \pi ( V_i )\)</span>,这当然意味着<span class="math inline">\(T \vec{ v } \in
V_i\)</span>,于是数学归纳就成立了.</p>
<p>值得一提的是上述证明可以原样拿来证明Cayley-Hamilton定理.方法是仍采取数学归纳,取<span class="math inline">\(V_1 = \text{ span } \{ \vec{ v }_1
\}\)</span>后,用数学归纳应当有<span class="math inline">\(\prod_{ k = 2
}^n ( \bar{ T } - \lambda_i I ) = \text{ char }_{ \bar{ T } } ( \bar{ T
} ) = 0\)</span>.然而我们早就知道了<span class="math inline">\(\bar{ T }
= \pi T\)</span>,于是立刻得知<span class="math inline">\(\forall \vec{ v
} \in V , \prod_{ k = 2 }^n ( T - \lambda_i I ) ( \vec{ v } ) \in
V_1\)</span>,两边同做<span class="math inline">\(T - \lambda_1
I\)</span>映射立刻得到结论.</p>
<h4><span id="广义特征子空间">广义特征子空间</span></h4>
<p>定义<span class="math inline">\(V_{ [ \lambda ] } = \bigcup_k V [ ( x
- \lambda )^k ]\)</span>.</p>
<p>先来分析其与通常讨论的特征子空间之间的关系,我们声明:<span class="math inline">\(V_{ [ \lambda ] } \ne 0 \Leftrightarrow V_\lambda
\ne 0\)</span>.</p>
<p>由于<span class="math inline">\(V_\lambda \subseteq V_{ [ \lambda ]
}\)</span>,右推左是显然的.</p>
<p>而考虑左推右,<span class="math inline">\(\exists \vec{ v } \in V_{ [
\lambda ] } , ( T - \lambda )^N \vec{ v } = \vec{ 0 } , ( T - \lambda
)^{ N - 1 } \vec{ v } \ne \vec{ 0 }\)</span>,那么<span class="math inline">\(( T - \lambda )^{ N - 1 } \vec{ v } \in V_{
\lambda }\)</span>.</p>
<p>这个无限取并能不能降下去呢?而且上面这个东西应当需要有一种划分原空间的策略,这就意味着其应当和极小多项式有一定关系.事实上,如果特征多项式<span class="math inline">\(\text{ char }_T = \prod ( x - \lambda_i )^{ a_i
}\)</span>,极小多项式<span class="math inline">\(\text{ Min }_T = \prod
( x - \lambda_i )^{ b_i }\)</span>,那么<span class="math inline">\(V_{ [
\lambda_i ] } = V [ ( x - \lambda_i )^{ b_i } ]\)</span>.首先肯定有<span class="math inline">\(V [ ( x - \lambda_i )^{ b_i } ] \subseteq V_{ [
\lambda_i ] }\)</span>,所以只需证明反向包含即可.</p>
<p>此时注意到<span class="math inline">\(\forall \vec{ v } \in V_{ [
\lambda_i ] }\)</span>,则存在<span class="math inline">\(k\)</span>使得<span class="math inline">\(( T -
\lambda_i )^k \vec{ v } = \vec{ 0 }\)</span>.此时取<span class="math inline">\(h = \gcd ( ( x - \lambda_i )^k , \text{ Min }_T
)\)</span>,用裴蜀定理立刻得到<span class="math inline">\(h = a ( x -
\lambda_i )^k + b \text{ Min }_T\)</span>,于是立刻见到<span class="math inline">\(h ( T ) \vec{ v } = \vec{ 0
}\)</span>.但容易注意到<span class="math inline">\(h | ( x - \lambda_i
)^{ b_i }\)</span>,这就证完了.</p>
<p>那么从之前我们的分析立刻得知<span class="math inline">\(V = V [
\text{ Min }_T ] = \bigoplus_{ i } V_{ [ \lambda_i ]
}\)</span>.并且见到<span class="math inline">\(V_{ [ \lambda_i ]
}\)</span>的极小多项式就是<span class="math inline">\(( x - \lambda_i
)^{ b_i
}\)</span>,而因为极小多项式和特征多项式的根集相同并且原本的特征多项式等于分空间的特征多项式的乘积,因此特征多项式就是<span class="math inline">\(( x - \lambda_i )^{ a_i }\)</span>.</p>
<p>接下来我们定义代数重数:作为特征多项式的根的重数.几何重数:<span class="math inline">\(\dim V_{ \lambda_i }\)</span>.</p>
<p>注意到代数重数<span class="math inline">\(\geq\)</span>几何重数,等式成立当且仅当<span class="math inline">\(V_{ \lambda_i } = V_{ [ \lambda_i ]
}\)</span>.原因是<span class="math inline">\(a_i = \deg \text{ char }_{
T_i } = \dim V_{ [ \lambda_i ] } \geq \dim V_{ \lambda_i }\)</span>.</p>
<p>由于可对角化等价于可以拆分成若干特征子空间的直和,我们之前又已经证明过可对角化的几何重数一定等于代数重数,于是可对角化当且仅当几何重数等于代数重数.</p>
<p>另外代数重数和几何重数的关系还可以从线性方程组的角度理解,因为特征空间的维度就是<span class="math inline">\(\lambda_k I - A\)</span>的自由变量的数量.而<span class="math inline">\(\lambda_k\)</span>的代数重数意味着<span class="math inline">\(( x - \lambda_k
)\)</span>这一项在对角线的出现次数,现在这些位置都变成了<span class="math inline">\(0\)</span>,也就最多会有这么多个自由变量(还有可能上面某位置也有可以当主元的点顶替了他).那么几何重数就是实际上的自由量.</p>
<h4><span id="特殊矩阵的特征值">特殊矩阵的特征值</span></h4>
<h6><span id="example">Example</span></h6>
<p>回忆道斐波那契数列应当转移矩阵为<span class="math inline">\(T =
\begin{bmatrix}0 &amp; 1 \\ 1 &amp;
1\end{bmatrix}\)</span>,如果能把这个东西对角化的话就会很舒服.直接解特征值能解出来<span class="math inline">\(\text{ char }_T = x^2 - x +
1\)</span>,两个特征值<span class="math inline">\(\lambda = \frac{ 1 \pm
\sqrt{ 5 } }{ 2 }\)</span>.</p>
<p>然后需要去解特征向量再用特征向量取基,解出来<span class="math inline">\(\vec{ v } = \left ( \begin{matrix}1 \\ \frac{ 1
\pm \sqrt{ 5 } }{ 2 }\end{matrix} \right
)\)</span>,这样立刻就拿到了换基矩阵<span class="math inline">\(P = [
\vec{ v }_1 , \vec{ v }_2 ]\)</span>和对角矩阵<span class="math inline">\(D = \begin{bmatrix}\lambda_1 &amp; 0 \\ 0 &amp;
\lambda_2\end{bmatrix}\)</span>,并且拿到<span class="math inline">\(D =
P^{ - 1 } TP\)</span>.</p>
<h3><span id="双线性形式">双线性形式</span></h3>
<h4><span id="线性映射">线性映射</span></h4>
<p>给定<span class="math inline">\(F\)</span>上的线性空间<span class="math inline">\(V_1 , \cdots , V_n ,
W\)</span>,我们定义一个<strong>多重线性映射</strong><span class="math inline">\(C : V_1 \times \cdots \times V_n \to
W\)</span>.满足其对每一个分量都是线性的.也即固定其他<span class="math inline">\(m -
1\)</span>个向量后,剩下的那一个向量的改变也会引起线性的改变.换言之:</p>
<p><span class="math display">\[
\begin{aligned}
C ( \cdots , t \vec{ v }_i , \cdots ) &amp; = tC ( \cdots , \vec{ v }_i
, \cdots ) \\
C ( \cdots , \vec{ v }_i + v_i &#39; , \cdots ) &amp; = C ( \cdots ,
\vec{ v }_i , \cdots ) + C ( \cdots , \vec{ v }_i &#39; , \cdots )
\end{aligned}
\]</span></p>
<p>特别地,当<span class="math inline">\(W =
F\)</span>的时候也叫做<strong>多重线性形式</strong>.</p>
<p>容易见到交错形式无非是多重线性形式的某种特例.</p>
<p>还可以看到多重线性映射的集合<span class="math inline">\(\text{ Mul }
( V_1 , \cdots , V_n ; W )\)</span>本身也是线性空间.</p>
<p>更常用的是双线性映射,一般记作<span class="math inline">\(\text{ Bil }
( V_1 , V_2 ; W
)\)</span>.矩阵乘法本身是双线性映射的一个典型例子,对偶空间本身也是双线性形式的一个典型例子.特别地,一般定义<span class="math inline">\(V\)</span>和<span class="math inline">\(\check{ V
}\)</span>之间的<strong>典范配对</strong>为<span class="math inline">\(\langle \_ , \_ \rangle : \check{ V } \times V \to
F\)</span>.其也可以看作点乘或者<span class="math inline">\(( 1 \times n
) \times ( n \times 1 )\)</span>的矩阵乘法.</p>
<p>留意到柯里化过程,设<span class="math inline">\(\dim V = n , \dim W =
m\)</span>,容易见到:</p>
<p><span class="math display">\[
\begin{aligned}
M_{ m \times n } &amp; \cong \\
\text{ Hom } ( V , \check{ W } ) &amp; \cong \text{ Bil } ( V , W ; F )
\cong \text{ Hom } ( W , \check{ V } ) \\
&amp; \cong M_{ n \times m }
\end{aligned}
\]</span></p>
<p>证明是平凡的.</p>
<p>这就能看出<span class="math inline">\(M_{ n \times m } \cong \text{
Bil } ( V \cong F^n , W \cong F^m ; F )\)</span>,留意到其实可以取<span class="math inline">\(A : W \to V\)</span>以<span class="math inline">\(( \vec{ v } , \vec{ w } ) \mapsto \check{ \vec{ v
} } A \vec{ w }\)</span>.取二者的坐标表示,立刻见到<span class="math inline">\(( \vec{ v } , \vec{ w } ) \mapsto \sum_{ i }
\sum_j v_i a_{ i , j } w_j = ( \vec{ v } )^T A \vec{ w
}\)</span>.留意到如果设<span class="math inline">\(C ( \vec{ w } , \vec{
v } ) = B ( \vec{ v } , \vec{ w } )\)</span>,这个<span class="math inline">\(C\)</span>对应的矩阵实际上就是对<span class="math inline">\(B\)</span>对应的矩阵取了转置.</p>
<p>接下来考虑对其取直和,不妨考虑<span class="math inline">\(B_1 : V_1
\times W_1 \to F , B_2 : V_2 \times W_2 \to F\)</span>,则令<span class="math inline">\(B_1 \oplus B_2 : ( V_1 \oplus V_2 ) \times ( W_1
\oplus W_2 ) \to F\)</span>,其中<span class="math inline">\(( ( \vec{ v
}_1 , \vec{ v }_2 ) , ( \vec{ w }_1 , \vec{ w }_2 ) ) \mapsto B_1 (
\vec{ v }_1 , \vec{ w }_1 ) + B_2 ( \vec{ v }_2 , \vec{ w }_2
)\)</span>.容易见到这是一个双线性形式.并且其代表的矩阵当然是原本的<span class="math inline">\(B_1 ,
B_2\)</span>对应的矩阵组成的分块对角矩阵.</p>
<p>考虑双线性形式<span class="math inline">\(B : V \times V \to
F\)</span>.称其为<strong>对称的</strong>当且仅当<span class="math inline">\(B ( \vec{ v } , \vec{ w } ) = B ( \vec{ w } ,
\vec{ v } )\)</span>,称其为<strong>反对称的</strong>当且仅当<span class="math inline">\(B ( \vec{ v } , \vec{ w } ) = - B ( \vec{ w } ,
\vec{ v }
)\)</span>.容易看到对称的当且仅当其对应的矩阵为<strong>对称矩阵</strong>,即<span class="math inline">\(A = A^T\)</span>,原因是<span class="math inline">\(B ( \vec{ w } , \vec{ v } ) = ( \vec{ w } )^T A
\vec{ v } = ( \vec{ v } )^T A^T \vec{ w
}\)</span>.反对称的对应的矩阵成为<strong>反对称矩阵</strong>或者<strong>斜对称矩阵</strong>,即<span class="math inline">\(- A = A^T\)</span>.</p>
<h4><span id="非退化形式">非退化形式</span></h4>
<p>对于双线性形式<span class="math inline">\(B : V \times W \to
F\)</span>,称<span class="math inline">\(\vec{ v }\)</span>是<span class="math inline">\(B\)</span>的一个<strong>左根</strong>当且仅当<span class="math inline">\(B ( \vec{ v } , \_ ) \equiv
0\)</span>.同理可以定义<strong>右根</strong>.容易见到左根右根集合分别应当是<span class="math inline">\(V , W\)</span>的子空间.将左根空间记作<span class="math inline">\(^{ \bot } V\)</span>,右根空间记作<span class="math inline">\(W^{ \bot }\)</span>.</p>
<p>当<span class="math inline">\(V = W\)</span>并且<span class="math inline">\(B\)</span>是对称的或者反对称的时候,此时左根和右根是一回事,一般将它们统称为<span class="math inline">\(B\)</span>的根基.</p>
<p>称<span class="math inline">\(B\)</span>是<strong>非退化的</strong>,当且仅当其左右根集合都是<span class="math inline">\(\{ \vec{ 0 } \}\)</span>.</p>
<p>现在考虑对于典范配对<span class="math inline">\(\langle \lambda ,
\vec{ v } \rangle \to \lambda \vec{ v
}\)</span>,考虑其左根和右根,显然都只是各自空间里的<span class="math inline">\(\vec{ 0
}\)</span>,原因是对于前者是一个映射,其映射所有都是<span class="math inline">\(0\)</span>,那它当然是<span class="math inline">\(0\)</span>映射本身.对于后者,考虑取<span class="math inline">\(\vec{ v } \ne \vec{ 0 }\)</span>,扩充<span class="math inline">\(\vec{ v }\)</span>为一组基<span class="math inline">\(\vec{ v } , \vec{ v }_2 \cdots , \vec{ v
}_n\)</span>,并取其对偶基<span class="math inline">\(\check{ v } ,
\check{ v }_2 , \cdots , \check{ v }_n\)</span>,此时就当然满足<span class="math inline">\(\langle \check{ v } , \vec{ v } \rangle =
1\)</span>,所以它是非退化的.</p>
<p>另一个例子是考虑迹映射<span class="math inline">\(Tr : \text{ End } (
V ) \times \text{ End } ( V ) \to F , ( S , T ) \mapsto \text{ tr } ( ST
)\)</span>,容易见到它是对称的.那么考虑其根基,只考虑左根,如果<span class="math inline">\(\forall T , \text{ tr } ( ST ) =
0\)</span>,应当满足对于基矩阵<span class="math inline">\(E_{ i , j
}\)</span>满足<span class="math inline">\(\text{ tr } ( SE_{ i , j } ) =
0\)</span>.容易见到<span class="math inline">\(tr ( SE_{ i , j } ) =
0\)</span>,所以<span class="math inline">\(S \equiv 0_{ n \times n
}\)</span>.这意味着迹映射是非退化的.</p>
<p>回忆道双线性形式同构于线性映射<span class="math inline">\(\psi \in
\text{ Hom } ( V , \check{ W } )\)</span>或<span class="math inline">\(\varphi \in \text{ Hom } ( W , \check{ V }
)\)</span>,注意到左根实际上就是<span class="math inline">\(\ker
\psi\)</span>,右根实际上就是<span class="math inline">\(\ker
\varphi\)</span>.</p>
<p>不妨假设<span class="math inline">\(\dim V &gt; \dim
W\)</span>,则<span class="math inline">\(\dim \ker \psi = \dim V -
\text{ rk } \psi \geq \dim V - \dim W &gt; 0\)</span>,所以注意到<span class="math inline">\(B\)</span>是非退化的一定要有<span class="math inline">\(\dim V = \dim W\)</span>.</p>
<p>现在我们对于<span class="math inline">\(B : V \times W \to
F\)</span>并且满足<span class="math inline">\(\dim V = \dim
W\)</span>,我们声称以下三条性质等价:</p>
<ol type="1">
<li><p><span class="math inline">\(B\)</span>是非退化的.</p></li>
<li><p>左根空间为<span class="math inline">\(0\)</span>.</p></li>
<li><p>右根空间为<span class="math inline">\(0\)</span>.</p></li>
</ol>
<p>显然只需说明(2)<span class="math inline">\(\Leftrightarrow\)</span>(3).两个方向类似,下面只证明(2)<span class="math inline">\(\Rightarrow\)</span>(3).而当<span class="math inline">\(\dim \ker \psi =
0\)</span>时,由于两边维数相等,自然得到<span class="math inline">\(\psi\)</span>是一个同构.接下来考虑<span class="math inline">\(\vec{ w
}\)</span>如果是一个右根,那么对此取一个空间<span class="math inline">\(H
= \{ \lambda \in \check{ W } \mid \lambda \vec{ w } = 0
\}\)</span>,见到<span class="math inline">\(\psi ( V
)\)</span>一定是<span class="math inline">\(H\)</span>的一个子空间.但是<span class="math inline">\(\dim V = \dim \psi ( V ) \leq \dim H \leq \dim
W\)</span>,这就看出<span class="math inline">\(\dim H = \dim V =
n\)</span>.然而当<span class="math inline">\(\vec{ w } \ne \vec{ 0
}\)</span>的时候,<span class="math inline">\(\dim
H\)</span>不可能取到满空间,原因是典范同态是非退化的.这就导出了右根空间也是<span class="math inline">\(0\)</span>空间.</p>
<p>另一种看法是直接观察矩阵,右根实际上就是<span class="math inline">\(\ker ( A )\)</span>,左根实际上就是<span class="math inline">\(\ker ( A^T )\)</span>,那它们的<span class="math inline">\(\dim\)</span>当然要相等,原因是它们的<span class="math inline">\(\text{ rk }\)</span>相等.</p>
<p>此时也容易注意到,非退化的矩阵实际上也就等价于可逆矩阵.</p>
<p>如果对商空间比较敏感,不妨设左根空间为<span class="math inline">\(L\)</span>,右根空间为<span class="math inline">\(R\)</span>,我们应当见到<span class="math inline">\(\bar{ B } : ( V / L ) \times ( W / R ) \to F , (
\vec{ v } + L , \vec{ w } + R ) \mapsto B ( \vec{ v } , \vec{ w }
)\)</span>是非退化双线性形式.此时见到其实<span class="math inline">\(\dim V - \dim L = \dim W - \dim R\)</span>.</p>
<p>适当推广上述结论,我们实际上可以定义任何子空间的<span class="math inline">\(V_0 \subseteq V\)</span>的正交空间为<span class="math inline">\(V_0^\bot = \{ \vec{ w } \in W \mid \forall \vec{ v
}_0 \in V_0 , B ( \vec{ v }_0 , \vec{ w } ) = 0
\}\)</span>.同理定义<span class="math inline">\(^\bot
W_0\)</span>.容易见到<span class="math inline">\(V_0 \subseteq^\bot (
V_0^\bot )\)</span>.</p>
<p>我们试图寻找一些更好的关系,不妨假设<span class="math inline">\(B\)</span>是非退化的,那么立刻有<span class="math inline">\(\dim V = \dim W\)</span>,我们下面证明<span class="math inline">\(\dim V_0^\bot + \dim V_0 = \dim V\)</span>.</p>
<p>令<span class="math inline">\(d = \dim V_0 , n = \dim V = \dim
W\)</span>已经知道<span class="math inline">\(B\)</span>会对应一个同构<span class="math inline">\(\psi : V \cong \check{ W }\)</span>,那么取<span class="math inline">\(V_0\)</span>在<span class="math inline">\(\psi\)</span>下的像,并取其基<span class="math inline">\(\check{ w }_1 , \cdots , \check{ w
}_d\)</span>,此时<span class="math inline">\(V_0^\bot \subseteq
W\)</span>是满足<span class="math inline">\(\langle \check{ w }_1 , \_
\rangle = \cdots = \langle \check{ w }_d , \_ \rangle =
0\)</span>的子空间.</p>
<p>不妨先考虑两个特殊情况并从中窥见归纳的办法.当<span class="math inline">\(d = n\)</span>的时候,此时<span class="math inline">\(V_0^\bot =
V^\bot\)</span>,也就是右根集合,我们之前已经证明过了这是一个零空间.而当<span class="math inline">\(d = 1\)</span>的时候,考虑<span class="math inline">\(\check{ w }_1\)</span>,因为它不是<span class="math inline">\(0\)</span>,所以它必然是<span class="math inline">\(W \to F\)</span>的满射,此时意味着<span class="math inline">\(\dim \text{ im } \ \check{ w }_1 =
1\)</span>,意味着此时<span class="math inline">\(V_0^\bot = \ker (
\check{ w }_1 )\)</span>的维数应当是<span class="math inline">\(n -
1\)</span>.</p>
<p>接下来从上面的结构中跳出来,直接观察<span class="math inline">\(\check{ W
}\)</span>上的情形,我们将上述的那一组基扩充为<span class="math inline">\(\check{ W }\)</span>的基<span class="math inline">\(\check{ w }_1 , \cdots \check{ w
}_n\)</span>并考虑<span class="math inline">\(W\)</span>的子空间列<span class="math inline">\(^\bot \langle \check{ w }_1 \rangle \supseteq
\cdots \supseteq^\bot \langle \check{ w }_1 , \cdots , \check{ w }_n
\rangle\)</span>.不妨设<span class="math inline">\(W_k =^\bot \langle
\check{ w }_1 , \cdots , \check{ w }_k \rangle\)</span>.</p>
<p>然而此时可以见到<span class="math inline">\(W_{ k + 1 } = W_k \cap{
^\bot \langle \check{ w }_{ k + 1 } \rangle
}\)</span>,用第二同构定理得到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim ( W_{ k + 1 } ) &amp; = \dim W_k + \dim^\bot \langle \check{ w }_{
k + 1 } \rangle - \dim ( W_k +^\bot \langle \check{ w }_{ k + 1 }
\rangle ) \\
&amp; \geq \dim W_k + \dim^\bot \langle \check{ w }_{ k + 1 } \rangle -
n \\
&amp; = \dim W_k - 1
\end{aligned}
\]</span></p>
<p>因此每加一个最多降一维(其实等价于把那个<span class="math inline">\(\dim =
1\)</span>的空间商掉了),然而注意到上述空间列的首项是<span class="math inline">\(n - 1\)</span>维,末项是<span class="math inline">\(0\)</span>维,每次降一维的话就可以得到<span class="math inline">\(\dim^\bot \langle \check{ w }_1 , \cdots , \check{
w }_d \rangle = n - d\)</span>,这就证明了上述的结论.</p>
<p>然而上述推断其实并不意味着<span class="math inline">\(V = V_0^\bot +
V_0\)</span>,也不意味着<span class="math inline">\(V_0 \cap V_0^\bot =
\{ \vec{ 0 } \}\)</span>,这两个结论都是得不到的.</p>
<p>然而好用的结论是我们之前已经提过<span class="math inline">\(V_0
\subseteq^\bot ( V_0^\bot
)\)</span>,此时我们注意到这个式子两边的维度实际上相等,因此<span class="math inline">\(^\bot ( V_0^\bot ) =
V_0\)</span>.再次声明此式子只在非退化的前提下成立.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>考虑两个双线性形式<span class="math inline">\(B_1 ,
B_2\)</span>,其中<span class="math inline">\(B_1 \in \text{ Bil } ( V_1
, V_1 &#39; , F )\)</span>,<span class="math inline">\(B_2\)</span>类似.我们声称存在唯一的线性映射<span class="math inline">\(\varphi : \text{ Hom } ( V_1 , V_2 ) \to \text{
Hom } ( V_2 &#39; , V_1 &#39; ) , T \mapsto T^*\)</span>满足<span class="math inline">\(B_2 ( T \vec{ v }_1 , \vec{ v }_2 &#39; ) = B_1 (
\vec{ v }_1 , T^* \vec{ v }_2 &#39; )\)</span>.其中这个<span class="math inline">\(T^*\)</span>称为<span class="math inline">\(T\)</span>相对于<span class="math inline">\(B_1\)</span>和<span class="math inline">\(B_2\)</span>的<strong>右伴随</strong>.同理可以定义<strong>左伴随</strong><span class="math inline">\(^* T\)</span>满足<span class="math inline">\(B_2 (
\vec{ v }_2 , T \vec{ v }_1 &#39; ) = B_1 (^* T \vec{ v }_2 , \vec{ v
}_1 &#39; )\)</span>,并且假设<span class="math inline">\(B_1\)</span>非退化,它对应的矩阵<span class="math inline">\(A_1\)</span>可逆.</p>
<p>如何证明这个结论呢?只考虑右伴随的情况,对于某个固定的<span class="math inline">\(\vec{ v }_2 &#39;\)</span>,取出映射<span class="math inline">\(B_2 ( T ( \_ ) , \vec{ v }_2 &#39; ) : V_1 \to
F\)</span>.那它当然是<span class="math inline">\(\check{ V_1
}\)</span>中的元素.而因为<span class="math inline">\(B_1\)</span>非退化,其对应了一个<span class="math inline">\(V_1 &#39; \to \check{ V
}_1\)</span>的同构,因此应当存在唯一的<span class="math inline">\(\vec{ v
}_1 &#39;\)</span>使得其映射到<span class="math inline">\(\check{ V_1
}\)</span>的时候恰好满足<span class="math inline">\(B_2 ( T ( \_ ) ,
\vec{ v }_2 &#39; ) = B_1 ( \_ , \vec{ v }_1 &#39;
)\)</span>,这就给出了<span class="math inline">\(T^* : \vec{ v }_2 &#39;
\mapsto \vec{ v }_1 &#39;\)</span>.换言之其唯一性取决于<span class="math inline">\(A_1\)</span>的非退化性.取<span class="math inline">\(\varphi_i : V_i &#39; \to \check{ V_i
}\)</span>且<span class="math inline">\(\varphi_1\)</span>可逆,回忆到之前过程可以知道这里的<span class="math inline">\(\varphi_1\)</span>实际上就是<span class="math inline">\(A_1\)</span>,下述图表的上半部分交换:</p>
<p><span class="math display">\[
\xymatrix{ V_2 &#39; \ar[r]^{ T^* } \ar[d]_{ A_2 } &amp; V_1 &#39;
\ar[d]^{ A_1 } \\
\check{ V_2 } \ar[r]^{ ^t T } &amp; \check{ V_1 } \\
V_2 \ar[u] &amp; V_1 \ar[u] \ar[l]_T }
\]</span></p>
<p>另外可以见到如果假设<span class="math inline">\(B_2\)</span>也是非退化的,当线性空间本身满足条件的时候应该有<span class="math inline">\(^* ( T^* ) = T = (^* T
)^*\)</span>.还可以见到<span class="math inline">\(( ST )^* = T^* S^*
,^* ( ST ) =^* T^* S\)</span>.这还顺便说明了<span class="math inline">\(( T^{ - 1 } )^* = ( T^* )^{ - 1 } ,^* ( T^{ - 1 }
) = (^* T )^{ - 1 }\)</span>.</p>
<p>上面的结论如何用矩阵刻画?只考虑右伴随的部分,选定一组有序基后,将双线性形式对应到矩阵应当有:</p>
<p><span class="math display">\[
\begin{aligned}
B_2 ( T \vec{ v }_1 , \vec{ v }_2 &#39; ) &amp; = ( \vec{ v }_1 )^T T^T
A_2 \vec{ v }_2 &#39; = ( \vec{ v }_1 )^T A_1 ( A_1^{ - 1 } T^T A_2 )
\vec{ v }_2 &#39; \\
B_1 ( \vec{ v }_1 , T^* \vec{ v }_2 &#39; ) &amp; = ( \vec{ v }_1 )^T
A_1 T^* \vec{ v }_2 &#39;
\end{aligned}
\]</span></p>
<p>比对就可以看到只需取<span class="math inline">\(T^* = A_1^{ - 1 } T^T
A_2\)</span>,这与上述交换图表的形式也是符合的.同理可以得到<span class="math inline">\(^* T = ( A_2 TA_1^{ - 1 }
)^T\)</span>.并从此看出当<span class="math inline">\(B_1 ,
B_2\)</span>都非退化的时候,伴随不改变矩阵的秩,因为此时伴随矩阵与原矩阵的转置是相抵的.事实上可以直接写出<span class="math inline">\(\ker ( T^* ) = ( \text{ im } T
)^\bot\)</span>,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
T^* \vec{ w } &amp; = 0 \Leftrightarrow \forall \vec{ v } , ( \vec{ v }
\mid T^* \vec{ w } ) = 0 \\
&amp; \Leftrightarrow \forall \vec{ v } , ( T \vec{ v } \mid \vec{ w } )
= 0 \Leftrightarrow \vec{ w } \in ( \text{ im } T )^\bot
\end{aligned}
\]</span></p>
<p>而由同态基本定理,<span class="math inline">\(\dim ( \text{ im } T
)^\bot = \dim \ker ( T^* )\)</span>,由上可以见到当<span class="math inline">\(\dim V = \dim W\)</span>时<span class="math inline">\(\text{ rk } \ T = \text{ rk } \ T^*\)</span>.</p>
<p>当对应的双线性形式非退化的时候回忆到可以两边取<span class="math inline">\(\bot\)</span>就拿到<span class="math inline">\(\ker ( T^* )^\bot = ( \text{ im } T
)\)</span>.</p>
<p>下面考虑<span class="math inline">\(V_1 = V_2 = V_1 &#39; = V_2 &#39;
= V\)</span>,并假设<span class="math inline">\(B_1 =
B_2\)</span>且二者要么对称要么反对称.此时注意到<span class="math inline">\(T\)</span>的左伴随和右伴随是没有区别的,我们将它们统一称作伴随,一般采取右伴随的记号记作<span class="math inline">\(T^*\)</span>并尝试通过上下文区分.特别地,如果<span class="math inline">\(T =
T^*\)</span>,那我们称其为<strong>自伴的</strong>,如果<span class="math inline">\(T = -
T^*\)</span>,则称其为<strong>反自伴的</strong>.</p>
<p>如果选取<span class="math inline">\(A_1 = A_2 =
I\)</span>,那么根据上面的分析见到<span class="math inline">\(T\)</span>是自伴的当且仅当<span class="math inline">\(T\)</span>是对称的,反自伴的当且仅当其是反对称的.</p>
<h4><span id="分类问题">分类问题</span></h4>
<p>定义双线性形式上的同构:称<span class="math inline">\(( V_1 , B_1 )
\cong ( V_2 , B_2 )\)</span>,其中<span class="math inline">\(B_1 : V_1
\times V_1 \to F , B_2 : V_2 \times V_2 \to
F\)</span>,当且仅当存在一个同构<span class="math inline">\(\varphi : V_1
\cong V_2\)</span>,满足<span class="math inline">\(B_2 ( \varphi ( \vec{
v } ) , \varphi ( \vec{ v } &#39; ) ) = B_1 ( \vec{ v } , \vec{ v }
&#39;
)\)</span>.容易验证这个同构满足等价条件的三条性质:反身性,对称性,传递性.并且双线性形式的几乎所有性质(左右根,根基,对称性,反对称性,退化性)都在同构关系下得到保持.这就意味着双线性形式应该可以以这种同构关系分类.</p>
<p>不失一般性,不妨直接假设<span class="math inline">\(V =
F^n\)</span>以简化描述.</p>
<p>我们定义两个<span class="math inline">\(n \times
n\)</span>的矩阵<span class="math inline">\(A , A
&#39;\)</span>是<strong>合同的</strong>,当且仅当<span class="math inline">\(\exists C \in ( M_{ n \times n }
)^\times\)</span>使得<span class="math inline">\(A = C^T A &#39;
C\)</span>.容易验证这是一个等价关系.必须要强调这里的<span class="math inline">\(C\)</span>是可逆矩阵.</p>
<p>接下来考虑两个双线性形式<span class="math inline">\(B , B &#39; : F^n
\times F^n \to F\)</span>,我们声称当且仅当它们对应的矩阵<span class="math inline">\(A , A &#39;\)</span>是合同的有<span class="math inline">\(A = C^T A &#39;
C\)</span>时是同构的.同构办法就是利用<span class="math inline">\(C\)</span>所代表的线性映射.</p>
<p>对于充分性:只需检验是否有<span class="math inline">\(B ( \vec{ v }_1
, \vec{ v }_2 ) = B &#39; ( C \vec{ v }_1 , C \vec{ v }_2
)\)</span>,而<span class="math inline">\(B &#39; ( C \vec{ v }_1 , C
\vec{ v }_2 ) = ( C \vec{ v }_1 )^T A &#39; ( C \vec{ v }_2 ) = ( \vec{
v }_1 )^T A \vec{ v }_2 = B ( \vec{ v }_1 , \vec{ v }_2 )\)</span>.</p>
<p>对于必要性:考虑所有的同构<span class="math inline">\(\varphi\)</span>当然都可以写作可逆矩阵形式,设这个矩阵为<span class="math inline">\(C\)</span>,立刻见到应当有<span class="math inline">\(A = C^T A &#39; C\)</span>.</p>
<h4><span id="二次型">二次型</span></h4>
<p>考虑<span class="math inline">\(\text{ char } \ne 2\)</span>的域<span class="math inline">\(F\)</span>,原因是这种域上面存在<span class="math inline">\(\frac{ 1 }{ 2
}\)</span>.为了方便讨论下面不妨直接假设<span class="math inline">\(V =
F^n\)</span>.</p>
<p>定义<span class="math inline">\(n\)</span>元<strong>二次型</strong>为一个<span class="math inline">\(F\)</span>上的齐次多项式<span class="math inline">\(f = \sum_i a_{ i , i } x_i^2 + 2 \sum_{ i &lt; j }
a_{ i , j } x_i x_j\)</span>,并在考虑对称的情况下设<span class="math inline">\(a_{ i , j } = a_{ j , i
}\)</span>成立,上述自然有<span class="math inline">\(f = \sum_{ i , j }
a_{ i , j } x_i x_j\)</span>.容易见到<span class="math inline">\(f\)</span>实际上可以表示为某一个对称的双线性形式,将这些<span class="math inline">\(a\)</span>排列成矩阵就可以见到上述<span class="math inline">\(f ( x ) = ( \vec{ x } )^T A \vec{ x } = B ( \vec{
x } , \vec{ x }
)\)</span>.这种对应实际上是双射,原因是该多项式也可以反过去确定一个对称的双线性形式,原因是注意到首先<span class="math inline">\(B ( \vec{ v } , \vec{ v }
)\)</span>肯定是可以被确定的,其次由于<span class="math inline">\(B (
\vec{ v }_1 + \vec{ v }_2 , \vec{ v }_1 + \vec{ v }_2 ) = B ( \vec{ v
}_1 , \vec{ v }_1 ) + B ( \vec{ v }_2 , \vec{ v }_2 ) + 2 B ( \vec{ v
}_1 , \vec{ v }_2 )\)</span>,于是立刻得到<span class="math inline">\(B (
\vec{ v }_1 , \vec{ v }_2 ) = \frac{ 1 }{ 2 } ( f ( \vec{ v }_1 + \vec{
v }_2 ) - f ( \vec{ v }_1 ) - f ( \vec{ v }_2 )
)\)</span>,这就给出了一组一一对应的关系.从这里顺便应该能看出对称双线性形式应该由其所有的<span class="math inline">\(B ( \vec{ v } , \vec{ v }
)\)</span>的取值唯一确定.我们会在内积空间里再次讨论这个技巧,这被称为<strong>配极化</strong>.</p>
<p>将合同关系挪到二次型上就可以见到,两个二次型同构当且仅当它们可以通过一个可逆的线性变量替换而相互过渡.</p>
<p>既然如此,应该见到二次型某种意义上同构于矩阵,那么能不能把二次型作对角化呢,也即能否将二次型同构于形如<span class="math inline">\(g = \sum b_i
x_i^2\)</span>的二次型.这个当然可以用配方法解决,具体操作是数学归纳,每次将和一个变量有关的全部赛到一个里面去.</p>
<p>具体地,我们执行以下策略:</p>
<ol type="1">
<li><p>如果当前存在一个<span class="math inline">\(a_{ i , i } \ne
0\)</span>,不妨设其为<span class="math inline">\(a_{ 1 , 1
}\)</span>,那就可以提出一个<span class="math inline">\(a_{ 1 , 1 } ( x_1
+ \frac{ 1 }{ a_{ 1 , 1 } } \sum_{ k \geq 2 } a_{ 1 , k } x_k
)^2\)</span>.</p></li>
<li><p>反之,则存在一个<span class="math inline">\(a_{ i , j } \ne
0\)</span>,不妨在此时做变量替换<span class="math inline">\(y_i = x_i -
x_j\)</span>换掉<span class="math inline">\(x_i\)</span>,这样<span class="math inline">\(x_j^2\)</span>前的系数就非<span class="math inline">\(0\)</span>,自然回到前一种情况.</p></li>
</ol>
<p>上述过程不好机械化,能不能用一些更加形式化的方式呢?考虑配方当然等价于寻找一个可逆矩阵<span class="math inline">\(C\)</span>使得对称矩阵<span class="math inline">\(A\)</span>被写作<span class="math inline">\(C^T AC
= A &#39;\)</span>,而可逆矩阵可以写作若干初等矩阵的乘积,不妨记作<span class="math inline">\(U_1 \cdots U_k\)</span>,于是知道我们想要让<span class="math inline">\(( U_1 \cdots U_k )^T A ( U_1 \cdots U_k
)\)</span>.</p>
<p>这里有一个算法是将矩阵排列成<span class="math inline">\(\begin{bmatrix}A \\
I\end{bmatrix}\)</span>的形式,然后对其做对称行列变换(这样列变换会影响到下面的<span class="math inline">\(I\)</span>,但是行变换不会影响),这样最后会消成<span class="math inline">\(\begin{bmatrix}A &#39; \\
C\end{bmatrix}\)</span>的形式,就会有<span class="math inline">\(A &#39;
= C^T AC\)</span>.</p>
<p>由此可以设<span class="math inline">\(r = \text{ rk } ( f
)\)</span>为对角化后剩余的元素个数.见到其根基的维数恰为<span class="math inline">\(n - r\)</span>,原因是<span class="math inline">\(\ker
A\)</span>的维数就是根基的维数.见到其非退化当且仅当<span class="math inline">\(n = r\)</span>.</p>
<p>如果我们做的域是一个代数闭域,那么我们上面的分类问题立刻得到了解决,原因是二次型当然可以进一步化简为<span class="math inline">\(\sum_{ k = 1 }^r
y_k^2\)</span>的形式,因此二次型完全由秩来决定.当然其实代数闭这个性质并没有用完全,实际上上述结论只需要求所有的<span class="math inline">\(F\)</span>中元素都有平方根即可.</p>
<h5><span id="实二次型">实二次型</span></h5>
<p>然而我们知道实数域并不满足以上性质,能不能把实数上的二次型进一步分类呢?虽然不能对<span class="math inline">\(- 1\)</span>开根,但总之可以将二次型同构成<span class="math inline">\(f = \sum_{ k = 1 }^p x_k^2 - \sum_{ j = p + 1 }^r
x_j^2\)</span>.将此称作该二次型的<strong>规范型</strong>.</p>
<p>先对于实二次型引入一些新的定义:对于一个对称双线性形式,如果<span class="math inline">\(\forall \vec{ v }\)</span>,<span class="math inline">\(B ( \vec{ v } , \vec{ v } ) \geq
0\)</span>恒成立,则称其为<strong>半正定的</strong>,如果在此基础上当<span class="math inline">\(\vec{ v } \ne 0\)</span>时<span class="math inline">\(B ( \vec{ v } , \vec{ v } ) &gt;
0\)</span>恒成立,则称其为<strong>正定</strong>的.同样可以定义<strong>半负定的</strong>和<strong>负定的</strong>概念.还可以定义<strong>不定的</strong>概念.容易见到如果一个对称双线性形式是正定的或者负定的时候它必然是非退化的,因为此时除了<span class="math inline">\(\vec{ 0
}\)</span>其无根基.一定要注意这里的正定是在对称性的基础上定义的.</p>
<p>容易见到半正定当且仅当上述<span class="math inline">\(f\)</span>中满足<span class="math inline">\(p =
r\)</span>,正定当且仅当满足<span class="math inline">\(p = r =
n\)</span>.到这里我们忽然疑问到同构的二次型的<span class="math inline">\(p\)</span>是否相等.</p>
<h5><span id="惯性sylvester定理">惯性(Sylvester)定理</span></h5>
<p>即:对于两个同构的二次型,它们的<span class="math inline">\(( p , r - p
)\)</span>相同,一般将<span class="math inline">\(p\)</span>称作<strong>正惯性系数</strong>而将<span class="math inline">\(r -
p\)</span>称作<strong>负惯性系数</strong>,两者的差<span class="math inline">\(2 p -
r\)</span>一般称作其<strong>符号差</strong>.</p>
<p>之所以会疑惑同构的二次型的<span class="math inline">\(p\)</span>不一定相等,是因为同构只搬运了空间上的性质.因此如果我们能把<span class="math inline">\(p\)</span>以某种基于空间上的形态,当然就可以显然看出两个同构的二次型的<span class="math inline">\(( p , r - p
)\)</span>相同.我们声明对于一个正惯性系数为<span class="math inline">\(p\)</span>的二次型以下命题成立:</p>
<ol type="1">
<li><p>存在一个<span class="math inline">\(p\)</span>维的正定子空间.</p></li>
<li><p>对于任何维数<span class="math inline">\(&gt;
p\)</span>的子空间,其都不可能是正定的.</p></li>
</ol>
<p>(1)显然,直接拿出其正部分对应的空间即可.</p>
<p>(2)的话无非是考虑将鸽笼原理用子空间之间的交写出来,设<span class="math inline">\(N\)</span>为后<span class="math inline">\(p + 1 ,
\cdots , n\)</span>这部分所代表的子空间,对于任何一个<span class="math inline">\(V &#39;\)</span>子空间满足<span class="math inline">\(\dim V &#39; &gt;
p\)</span>,直接拿第二同构定理得到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim ( V &#39; \cap N ) &amp; = \dim ( V &#39; ) + \dim ( N ) - \dim ( V
&#39; + N ) \\
&amp; \geq n - p + \dim V &#39; - n &gt; 0
\end{aligned}
\]</span></p>
<p>这意味着其不为空.</p>
<p>对负惯性系数当然可以类似做.这样惯性定理自然解决了实二次型的分类问题.</p>
<h4><span id="辛空间">辛空间</span></h4>
<p>回到特征不为<span class="math inline">\(2\)</span>的域<span class="math inline">\(F\)</span>上,考虑反对称形式,注意到<span class="math inline">\(B ( \vec{ v } , \vec{ v } ) = - B ( \vec{ v } ,
\vec{ v } )\)</span>,那此时它们就应该同时为<span class="math inline">\(0\)</span>.这当然类似我们之前说的交错形式.</p>
<p>观察这类反对称形式的根基,取<span class="math inline">\(R ( V ) = \{
\vec{ v } \in V \mid B ( \vec{ v } , \_ ) = 0
\}\)</span>.此时把补空间拿出来,取<span class="math inline">\(V = R ( V )
\oplus V &#39;\)</span>,我们断言<span class="math inline">\(( V , B )
\cong ( R ( V ) , 0 ) \oplus ( V &#39; , B \mid_{ V &#39; \times V &#39;
} )\)</span>,其中<span class="math inline">\(B \mid_{ V &#39; \times V
&#39; }\)</span>是<span class="math inline">\(V
&#39;\)</span>上的非退化线性形式.这个断言当然是显然的,只需简单拆分空间即可.问题在于如何证明<span class="math inline">\(B \mid_{ V &#39; \times V &#39; }\)</span>是<span class="math inline">\(V &#39;\)</span>上的非退化线性形式,只需证明<span class="math inline">\(R ( V &#39; ) = \{ 0 \}\)</span>,我们考虑如果<span class="math inline">\(\exists \vec{ v } &#39; \in V &#39;\)</span>,<span class="math inline">\(\forall \vec{ v }_1 &#39; \in V &#39; , B ( \vec{
v } &#39; , \vec{ v }_1 &#39; ) =
0\)</span>,由于根基当然和任何东西都会变零,因此这等价于<span class="math inline">\(\forall \vec{ v }_1 \in V , B ( \vec{ v } &#39; ,
\vec{ v }_1 ) = 0\)</span>,这必然意味着<span class="math inline">\(\vec{
v } &#39; \in R ( V )\)</span>,也就是<span class="math inline">\(\vec{ v
} &#39; \in R ( V ) \cap V &#39; = \{ 0 \}\)</span>.</p>
<p>因此其实反对称双线性形式更重要的是考虑其非退化的部分.将这些非退化反对称双线性形式称为<strong>辛形式</strong>,并将<span class="math inline">\(( V , B )\)</span>称作辛空间.</p>
<p>考虑取一对基<span class="math inline">\(\vec{ p } , \vec{ q
}\)</span>形成空间<span class="math inline">\(\langle \vec{ p } , \vec{
q } \rangle\)</span>并满足<span class="math inline">\(B ( \vec{ p } ,
\vec{ q } ) = 1 = - B ( \vec{ q } , \vec{ p }
)\)</span>,这当然唯一确定了一个辛形式<span class="math inline">\(B\)</span>,并且其实际上对应了一个反对称矩阵<span class="math inline">\(\begin{bmatrix}0 &amp; 1 \\ - 1 &amp;
0\end{bmatrix}\)</span>,这种二维辛空间一般还被称为<strong>双曲辛平面</strong>.</p>
<p>虽然研究范围被限制在了辛空间上,但仍然能看到辛形式中会因为正负相抵爆出大量的<span class="math inline">\(0\)</span>.设<span class="math inline">\(V_0\)</span>是<span class="math inline">\(V\)</span>的子空间,若<span class="math inline">\(B
\mid_{ V_0 \times V_0 } \equiv 0\)</span>,我们称<span class="math inline">\(V_0\)</span>是<strong>全迷向子空间</strong>,一个极大(真包含它的子空间全都不是全迷向的)的全迷向子空间称为<strong>拉格朗日子空间</strong>.</p>
<p>设<span class="math inline">\(( V , B )\)</span>为辛空间,<span class="math inline">\(L\)</span>是拉格朗日子空间,我们下面证明两个性质:</p>
<ol type="1">
<li><p><span class="math inline">\(L^\bot = L\)</span>.</p></li>
<li><p><span class="math inline">\(\dim V = 2 \dim L\)</span>.</p></li>
<li><p>辛空间必定是偶数维的.</p></li>
</ol>
<p>如果(1)得证,由于<span class="math inline">\(\dim V = \dim L + \dim
L^\bot\)</span>,(2)(3)也就显然了.所以问题在于如何证明(1).</p>
<p>首先全迷向性质自然等价于<span class="math inline">\(L \subseteq
L^\bot\)</span>.此时考虑若<span class="math inline">\(\exists \vec{ v }
\in L^\bot \setminus L\)</span>,则<span class="math inline">\(L +
\langle \vec{ v } \rangle\)</span>这个空间仍然是全迷向的(原因是<span class="math inline">\(\vec{ v
}\)</span>自身的部分会因为交错性质而成<span class="math inline">\(0\)</span>),这就与其极大性矛盾.</p>
<p>我们试图想要找到更好的策略去勾勒<span class="math inline">\(L\)</span>以及<span class="math inline">\(V /
L\)</span>这两部分.</p>
<h5><span id="达布定理">达布定理</span></h5>
<p>该定理是说:给定一个拉格朗日子空间<span class="math inline">\(L\)</span>,<span class="math inline">\(L\)</span>的任何有序基<span class="math inline">\(\vec{ p }_1 , \cdots , \vec{ p
}_n\)</span>都能扩充为<span class="math inline">\(V\)</span>的有序基<span class="math inline">\(\vec{ p }_1 , \cdots \vec{ p }_n , \vec{ q }_n ,
\cdots , \vec{ q }_1\)</span>,使得<span class="math inline">\(\forall 1
\leq i , j \leq n\)</span>:</p>
<ol type="1">
<li><p><span class="math inline">\(B ( p_i , p_j ) = B ( q_i , q_j ) =
0\)</span>.</p></li>
<li><p><span class="math inline">\(B ( p_i , q_j ) = - B ( q_j , p_i ) =
\begin{cases}1 &amp; i = j \\ 0 &amp; i \ne
j\end{cases}\)</span>.</p></li>
</ol>
<p>这组有序基又被称为<span class="math inline">\(V\)</span>的<strong>辛基</strong>.</p>
<p>考虑定义<span class="math inline">\(n - 1\)</span>维子空间<span class="math inline">\(L_i = \langle \vec{ p }_1 , \cdots , \vec{ p }_{ i
- 1 } , \vec{ p }_{ i + 1 } , \cdots , \vec{ p }_n
\rangle\)</span>.留意到此时会有<span class="math inline">\(L = L^\bot
\subsetneq L_i^\bot , \dim L_i^\bot = n + 1\)</span>.</p>
<p>接下来数学归纳构造这组<span class="math inline">\(q\)</span>.</p>
<p>对于<span class="math inline">\(k =
1\)</span>的情况,由于我们上面的分析,<span class="math inline">\(\exists
\vec{ q }_1 \in L_1^\bot \setminus L\)</span>,于是此时必然满足<span class="math inline">\(B ( \vec{ p }_1 , \vec{ q }_1 ) \ne
0\)</span>而<span class="math inline">\(\forall i \geq 2 , B ( \vec{ p
}_i , \vec{ q }_1 ) = 0\)</span>.适当伸缩即可满足条件.</p>
<p>在此之后,假设<span class="math inline">\(k &lt;
n\)</span>并且我们已经有了<span class="math inline">\(\vec{ q }_1 ,
\cdots , \vec{ q }_k\)</span>使得条件成立,仍然可以取<span class="math inline">\(\vec{ q }_{ k + 1 } &#39; \in L_{ k + 1 }^\bot
\setminus L\)</span>,使得<span class="math inline">\(B ( \vec{ p }_i ,
\vec{ q }_{ k + 1 } &#39; ) \begin{cases}1 &amp; i = k + 1 \\ 0 &amp; i
\ne k + 1\end{cases}\)</span>满足.</p>
<p>此时注意到,如果用<span class="math inline">\(\vec{ q }_{ k + 1 } =
\vec{ q }_{ k + 1 } &#39; + \sum_i a_i \vec{ p
}_i\)</span>后,上述条件实际上不受影响.然而,只需取<span class="math inline">\(a_i = B ( \vec{ q }_i , \vec{ q }_{ k + 1 } &#39;
)\)</span>就自动满足最后的条件.</p>
<p>接下来无非是要证明这些向量线性无关,对于<span class="math inline">\(\sum a_i \vec{ p }_i + \sum b_i \vec{ q }_i =
0\)</span>,两边取<span class="math inline">\(B ( \_ , \vec{ q }_i
)\)</span>就可以得到<span class="math inline">\(a_i = 0\)</span>,取<span class="math inline">\(B ( \vec{ p }_i , \_ )\)</span>就可以得到<span class="math inline">\(b_i = 0\)</span>,这样就做完了.</p>
<p>此时就可以见到,我们实际上是把原空间拆成了两个拉格朗日子空间的直和,并且这两个子空间之间以某种形式连接起来.此时其对应的矩阵就是:</p>
<p><span class="math display">\[
\begin{bmatrix}
&amp; &amp; &amp; &amp; &amp; 1 \\
&amp; &amp; &amp; &amp; \cdots &amp; \\
&amp; &amp; &amp; 1 &amp; &amp; \\
&amp; &amp; - 1 &amp; &amp; &amp; \\
&amp; \cdots &amp; &amp; &amp; &amp; \\
- 1 &amp; &amp; &amp; &amp; &amp;
\end{bmatrix}
\]</span></p>
<p>另外,如果<span class="math inline">\(W\)</span>是<span class="math inline">\(V\)</span>的子空间并且满足<span class="math inline">\(W \cap W^\bot = \{ 0
\}\)</span>,我们称这样的子空间是<strong>辛子空间</strong>.只需套用拉格朗日子空间的过程就可以证明:</p>
<ol type="1">
<li><p><span class="math inline">\(W\)</span>是辛子空间当且仅当<span class="math inline">\(B\)</span>在<span class="math inline">\(W\)</span>上的限制非退化.</p></li>
<li><p><span class="math inline">\(W\)</span>是辛子空间则有直和分解<span class="math inline">\(V = W \oplus W^\bot\)</span>.</p></li>
</ol>
<h4><span id="回看对偶空间">回看对偶空间</span></h4>
<p>应当回忆我们将一个有限维空间对应到其对偶空间的时候所做的努力:先找到原空间的一组基,再对应地找到一组对偶基.然而,这种对应并非空间自身典范的对应,而是需要选定基的人为构造的定义.</p>
<p>回忆我们上述拿到的所有东西,应当可以见到起码以下资料均是典范的:</p>
<ol type="1">
<li><p>典范配对<span class="math inline">\(\langle \_ , \_ \rangle :
V^\vee \times V \to F , \langle \lambda , \vec{ v } \rangle \mapsto
\lambda \vec{ v }\)</span>.</p></li>
<li><p>转置映射<span class="math inline">\(^t T : W^\vee \to V^\vee ,
\lambda \mapsto \lambda T\)</span>.</p></li>
</ol>
<h5><span id="双重对偶">双重对偶</span></h5>
<p>先分析典范配对的情形,考虑到典范配对会给出一个映射<span class="math inline">\(ev_V : V \to ( V^\vee )^\vee , \vec{ v } \mapsto
\langle \_ , \vec{ v }
\rangle\)</span>.容易验证这当然是一个同构,而且中途没有用任何取基操作,所以这是一个典范的同构<span class="math inline">\(\text{ ev }_V : V \cong ( V^\vee
)^\vee\)</span>.更确切地来说,这个<span class="math inline">\(\text{ ev
}_V\)</span>具有某种函子性.事实上有以下交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^T \ar[d]_{ \text{ ev }_V } &amp; W \ar[d]^{ \text{
ev }_W } \\
( V^\vee )^\vee \ar[r]^{ ( T^t )^t } &amp; ( W^\vee )^\vee }
\]</span></p>
<p>虽属显然,但也可以小心地展开定义以确实证明<span class="math inline">\(( \text{ ev }_W ) T = ( T^t )^t \text{ ev
}_V\)</span>.策略只需任取<span class="math inline">\(\check{ w
}\)</span>,而观察:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \langle ( ( T^t )^t \text{ ev }_V ) \vec{ v } , \check{ w }
\rangle \\
= &amp; \langle ( \text{ ev }_V ) \vec{ v } , T^t \check{ w } \rangle \\
= &amp; \langle T^t ( \check{ w } ) , \vec{ v } \rangle \\
= &amp; \langle \check{ w } , T \vec{ v } \rangle \\
= &amp; \langle \text{ ev }_W ( T \vec{ v } ) , \check{ w } \rangle
\end{aligned}
\]</span></p>
<p>而<span class="math inline">\(\check{ w
}\)</span>可以任取,立刻证毕.</p>
<p>回忆到还有一件重要的事情需要解释,那就是柯里化<span class="math inline">\(\text{ Hom } ( W , V^\vee ) \cong \text{ Bil } ( V
, W ; F ) \cong \text{ Hom } ( V , W^\vee
)\)</span>.从表面上看,它应当是典范的,可实则描述的时候却发现总需要标准内积结构来体现.为解决这个问题,我们下面证明上述同构映射将<span class="math inline">\(\varphi \in \text{ Hom } ( W , V^\vee
)\)</span>为<span class="math inline">\(( \varphi^t ) \circ \text{ ev
}_V \in \text{ Hom } ( V , W^\vee )\)</span>.</p>
<p>考虑将两边都映射到典范配对的结构上,由双线性形式的定义,<span class="math inline">\(\varphi \in \text{ Hom } ( W , V^\vee
)\)</span>必然映一组<span class="math inline">\(\vec{ w } , \vec{ v
}\)</span>为<span class="math inline">\(\langle \varphi ( \vec{ w } ) ,
\vec{ v } \rangle\)</span>,这当然是显然的.</p>
<p>回看<span class="math inline">\(( \varphi^t ) \circ \text{ ev
}_V\)</span>,它做到的是将一组<span class="math inline">\(\vec{ w } ,
\vec{ v }\)</span>映射到<span class="math inline">\(\langle \text{ ev
}_V ( \vec{ v } ) , \varphi ( \vec{ w } ) \rangle\)</span>,可只需用<span class="math inline">\(\text{ ev }_V ( \vec{ v }
)\)</span>的定义,上述两者当然是相同的.</p>
<p>再最后,我们终于回看基的选取,我们可以证明以下结论:设<span class="math inline">\(V\)</span>是有限维的向量空间,<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v }_n \in
V\)</span>是一组有序基,其对偶基记作<span class="math inline">\(\check{ v
}_1 , \cdots , \check{ v }_n\)</span>.我们声称:<span class="math inline">\(V^\vee\)</span>中的一组元素<span class="math inline">\(\text{ ev }_V ( \vec{ v }_1 ) , \cdots , \text{ ev
}_V ( \vec{ v }_n )\)</span>是<span class="math inline">\(\check{ v }_1
, \cdots , \check{ v
}_n\)</span>的对偶基.也就是说中间不管怎么取对偶形态,最终总会回到一种典范的同构<span class="math inline">\(V \cong V^\vee\)</span>上.</p>
<p>至于证明,无非只是:</p>
<p><span class="math display">\[
\langle \text{ ev }_V ( \vec{ v }_i ) , \check{ v }_j \rangle = \langle
\check{ v }_j , \vec{ v }_i \rangle
\]</span></p>
<p>立属显然.</p>
<h5><span id="核余核与对偶映射">核,余核与对偶映射</span></h5>
<p>上述证明揭露了对偶空间的一角.之所以<span class="math inline">\(T^t\)</span>会显示出伴随性质,实际上并不是代数形式上的巧合,而恰是<span class="math inline">\(T^t\)</span>的定义本身就是典范配对上的伴随,而自然会以某种形式显示在新的伴随中.既如此,请以下内容再观<span class="math inline">\(T : V \to W\)</span>以及其转置<span class="math inline">\(T^t : W^\vee \to V^\vee\)</span>的性质.</p>
<p>首先,容易观察到的应该是<span class="math inline">\(T\)</span>单则<span class="math inline">\(T^t\)</span>满,<span class="math inline">\(T\)</span>满则<span class="math inline">\(T^t\)</span>单.此结论我们早就得出,策略是使用行秩等于列秩,而由同态基本定理得到<span class="math inline">\(\dim V = \dim \ker T + \text{ rk }
T\)</span>,如若<span class="math inline">\(T\)</span>单,则<span class="math inline">\(\dim \ker T = 0\)</span>,意味着<span class="math inline">\(\text{ rk } T = \dim V\)</span>,也就意味着<span class="math inline">\(\text{ rk } T^t = \dim
V^\vee\)</span>,这就得到<span class="math inline">\(T^t\)</span>是满的.反之亦然同理.</p>
<p>然而回看<span class="math inline">\(\text{ rk } T^t = \text{ rk }
T\)</span>这个结论的得出其实并不典范,我们推出此结论使用的策略是矩阵的相抵.而找到一种典范的证明此的策略便是重要的.而只需稍有对商操作的直觉就可以看到,要抛开矩阵,用一种真正典范的策略证明行秩等于列秩,必然离不开上述的引理.这就是我们下述真正想要做的事.</p>
<p>现在,设<span class="math inline">\(T\)</span>是单射,对于任给的<span class="math inline">\(\mu \in V^\vee\)</span>,尝试找到一个<span class="math inline">\(\tilde{ \mu } \in W^\vee\)</span>使得<span class="math inline">\(\tilde{ \mu } ( T ( x ) ) = \mu ( x
)\)</span>,那根据对偶映射的定义,知道这里有<span class="math inline">\(T^t ( \tilde{ \mu } ) = \mu\)</span>.如果这里<span class="math inline">\(\mu\)</span>可以任选的话,换言之,对于任意的<span class="math inline">\(\mu\)</span>我们都能构造出一个<span class="math inline">\(\tilde{ \mu
}\)</span>来实现上述过程,当然意味着<span class="math inline">\(T^t\)</span>是满射.可既然这里是构造,我们终于可以放下”典范”的包袱,开始取基.</p>
<p>取<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(\mathcal{ X }\)</span>,而<span class="math inline">\(T ( \mathcal{ X } )\)</span>当然是<span class="math inline">\(W\)</span>的线性无关子集,可以扩展为一组基<span class="math inline">\(\mathcal{ Y }\)</span>,这样<span class="math inline">\(\forall \vec{ w } \in
W\)</span>都有唯一的展开<span class="math inline">\(\sum_{ \vec{ y } \in
\mathcal{ Y } } c_y \vec{ y }\)</span>,对于给定的<span class="math inline">\(\mu \in V^\vee\)</span>可以定义<span class="math inline">\(\tilde{ \mu } : W \to F\)</span>为:</p>
<p><span class="math display">\[
\tilde{ \mu } ( \sum_{ y \in \mathcal{ Y } } c_y \vec{ y } ) = \mu (
\sum_{ x \in \mathcal{ X } } c_{ T ( \vec{ x } ) \vec{ x } } )
\]</span></p>
<p>而当<span class="math inline">\(T\)</span>满的时候,设<span class="math inline">\(\tilde{ \mu } \in W^\vee\)</span>,此时如果<span class="math inline">\(T^t ( \tilde{ \mu } ) = \tilde{ \mu } T =
0\)</span>,因为<span class="math inline">\(T\)</span>是满的,这必然意味着<span class="math inline">\(\tilde{ \mu } = 0\)</span>,所以<span class="math inline">\(T^t\)</span>当然是单的.</p>
<p>换句话说,这里通过空间上的结构,用基强行凑出了一个<span class="math inline">\(\ker
T\)</span>的结构.然而取基总是会让我们忽略空间的结构,并给人一种使用文字游戏偷懒的感觉.或者说,构造性证明必然会有一种失掉典范性的感觉.</p>
<p>现在我们重新展现一下上述取出<span class="math inline">\(\tilde{ \mu
}\)</span>的合理性:设<span class="math inline">\(T : V \to
W\)</span>为线性映射,而<span class="math inline">\(\mu \in
V^\vee\)</span>,我们声称存在<span class="math inline">\(\tilde{ \mu }
\in W^\vee\)</span>使得<span class="math inline">\(T^t ( \tilde{ \mu } )
= \mu\)</span>当且仅当<span class="math inline">\(\mu |_{ \ker T } =
0\)</span>.</p>
<p>先证明充分性,当<span class="math inline">\(\mu |_{ \ker T } =
0\)</span>的时候,不妨设<span class="math inline">\(\twoheadrightarrow\)</span>是满射而<span class="math inline">\(\hookrightarrow\)</span>是单射,如下交换图表当然成立:</p>
<p><span class="math display">\[
\xymatrix{ V \ar @{-&gt;&gt;}[r]^T \ar[d]_\mu \ar @{-&gt;&gt;}[dr]^\pi
&amp; \text{ im } \ ( T ) \\
F &amp; V / \ker ( T ) \ar[l]^{ \bar{ \mu } } \ar @{^{(}-&gt;&gt;}[u]_{
\bar{ T } } }
\]</span></p>
<p>左下三角形的成立性完全依赖于<span class="math inline">\(\mu |_{ \ker
T } = 0\)</span>的性质,而此时取一个<span class="math inline">\(\tilde{
\mu_0 } = \bar{ \mu } \circ ( \bar{ T } )^{ - 1 } \in ( \text{ im } \ T
)^{ \vee }\)</span>,而由于<span class="math inline">\(\text{ im }
T\)</span>自然嵌入<span class="math inline">\(W\)</span>中,必有<span class="math inline">\(\text{ im } ( T ) \hookrightarrow
W\)</span>,那也就意味着<span class="math inline">\(W^\vee
\twoheadrightarrow \text{ im } ( T )^\vee\)</span>,因此<span class="math inline">\(\tilde{ \mu_0 }\)</span>就可以延拓为<span class="math inline">\(\tilde{ \mu } \in
W^\vee\)</span>,交换图表给出:</p>
<p><span class="math display">\[
\tilde{ \mu } T = \tilde{ \mu_0 } T = \bar{ \mu } ( \bar{ T } )^{ - 1 }
T = \bar{ m } u \circ \pi = \mu
\]</span></p>
<p>这就证明了充分性.至于必要性,由于<span class="math inline">\(T^t (
\tilde{ \mu } ) = \tilde{ \mu } T\)</span>,而<span class="math inline">\(\tilde{ \mu } T |_{ \ker T } =
0\)</span>当然是显然的.</p>
<p>接下来回忆到余核<span class="math inline">\(\text{ coker } ( T ) = W
/ \text{ im } ( T )\)</span>这个东西,尝试看看它和<span class="math inline">\(\ker
T\)</span>之间的关系,回忆到我们应该有包含映射<span class="math inline">\(i : \ker ( T ) \hookrightarrow
V\)</span>和商映射<span class="math inline">\(q : W \twoheadrightarrow
\text{ coker } ( T )\)</span>,取对偶见到:</p>
<p><span class="math display">\[
\xymatrix{ \text{ coker } ( T )^\vee \ar @{^{(}-&gt;}[r]^{ q^t } &amp;
W^\vee \ar[r]^{ T^t } &amp; V^\vee \ar @{-&gt;&gt;}[r]^{ i^t } &amp;
\ker ( T )^\vee \\
\lambda \ar @{|-&gt;}[r] &amp; \lambda q &amp; &amp; \\
&amp; \tilde{ \mu } \ar @{|-&gt;}[r] &amp; \tilde{ \mu } T &amp; \\
&amp; &amp; \mu \ar @{|-&gt;}[r] &amp; \mu i }
\]</span></p>
<p>这个当然没有问题,而我们试图借上面为辅助证明下面这张交换图表:</p>
<p><span class="math display">\[
\xymatrix{ \text{ coker } ( T )^\vee \ar @{^{(}-&gt;}[r]^{ q^t } \ar
@{^{(}-&gt;&gt;}[d] &amp; W^\vee \ar[r]^{ T^t } &amp; V^\vee \ar
@{-&gt;&gt;}[r]^{ i^t } \ar @{-&gt;&gt;}[rd] &amp; \ker ( T )^\vee \\
\ker ( T^t ) \ar @{^{(}-&gt;}[ur] &amp; &amp; &amp; \text{ coker } ( T^t
) \ar @{^{(}-&gt;&gt;}[u] }
\]</span></p>
<p>其中竖直方向的同构由左右两部分交换图表各自唯一确定.</p>
<p>先看左部分,我们尝试证明<span class="math inline">\(\text{ coker } ( T
)^\vee \hookrightarrow W^\vee\)</span>的像正好是<span class="math inline">\(\ker ( T^t )\)</span>.</p>
<p>先证明<span class="math inline">\(q^t ( \text{ coker } ( T )^\vee )
\subseteq \ker ( T^t )\)</span>,考虑<span class="math inline">\(\lambda
\in \text{ coker } ( T )^\vee\)</span>,那<span class="math inline">\(q^t\)</span>会将其射到<span class="math inline">\(\lambda q \in W^\vee\)</span>.留意到<span class="math inline">\(T^t ( \lambda q ) = \lambda q
T\)</span>,然而根据<span class="math inline">\(\text{ coker
}\)</span>的定义知道<span class="math inline">\(qT =
0\)</span>,这必然意味着<span class="math inline">\(T^t ( \lambda q ) =
0\)</span>.</p>
<p>再证明<span class="math inline">\(\ker ( T^t ) \subseteq q^t ( \text{
coker } ( T )^\vee )\)</span>,设<span class="math inline">\(\tilde{ \mu
} \in \ker{ T^t }\)</span>,也就是说<span class="math inline">\(T^t (
\tilde{ \mu } ) = \tilde{ \mu } T = 0\)</span>,我们要找到一个<span class="math inline">\(\lambda\)</span>使得<span class="math inline">\(q^t ( \lambda ) = \lambda q = \tilde{ \mu
}\)</span>,那么必然见到<span class="math inline">\(\lambda : \vec{ w } +
\text{ im } ( T ) \mapsto \tilde{ \mu } ( \vec{ w }
)\)</span>是满足条件的,只需验证<span class="math inline">\(\tilde{ \mu }
|_{ \text{ im } ( T ) } = 0\)</span>,这恰好由<span class="math inline">\(T^t ( \tilde{ \mu } ) = \tilde{ \mu } T =
0\)</span>给出.</p>
<p>至于右半部分,就是我们上面所刻画的<span class="math inline">\(\tilde{
\mu }\)</span>和<span class="math inline">\(\mu\)</span>的关系了,换言之<span class="math inline">\(\mu i = 0 \Leftrightarrow \exists \tilde{ \mu } ,
\mu = \tilde{ \mu } T\)</span>.</p>
<p>上述过程当然太过复杂了,尝试感性理解一下我们刚刚在做什么.我们的<span class="math inline">\(\ker T\)</span>的意义是,<span class="math inline">\(T : V \to
W\)</span>这个过程中所损失的信息对吧,那我们反观<span class="math inline">\(T^t : W^\vee \to V^\vee , \lambda \mapsto \lambda
T\)</span>这个过程中所损失的,也就是何时,<span class="math inline">\(\lambda T =
0\)</span>.由于这是两个映射,当然就等价于<span class="math inline">\(\forall \vec{ v } \in V\)</span>,<span class="math inline">\(\lambda T \vec{ v } = 0\)</span>.当然就等价于<span class="math inline">\(\forall \vec{ u } \in \text{ im } ( T
)\)</span>,<span class="math inline">\(\lambda \vec{ u } =
0\)</span>,这必然等价于<span class="math inline">\(\ker \lambda
\supseteq \text{ im } ( T )\)</span>.所以这些<span class="math inline">\(\lambda\)</span>都可以表示为一个<span class="math inline">\(\tilde{ \lambda } q\)</span>的形式,其中<span class="math inline">\(\ker q = \text{ im } ( T
)\)</span>,取余核是刚刚好的.</p>
<h5><span id="像自对偶">像自对偶</span></h5>
<p>对于映射<span class="math inline">\(T : V \to
W\)</span>,我们下面将给出典范同构:</p>
<p><span class="math display">\[
\text{ im } ( T )^\vee \cong \text{ im } ( T^t )
\]</span></p>
<p>如上,商映射<span class="math inline">\(q : W \to \text{ coker } ( T
)\)</span>满足<span class="math inline">\(\ker q = \text{ im } ( T
)\)</span>,于是:</p>
<p><span class="math display">\[
\begin{aligned}
\text{ im } ( T )^\vee &amp; \cong \text{ coker } ( q^t : \text{ coker }
( T )^\vee \to W^\vee ) \\
&amp; \cong \text{ coker } ( \ker T^t \hookrightarrow W^\vee ) \\
&amp; = W^\vee / \ker ( T^t ) \\
&amp; \cong \text{ im } ( T^t )
\end{aligned}
\]</span></p>
<p>两边取<span class="math inline">\(\dim\)</span>,得知行秩等于列秩.</p>
<h3><span id="实内积空间">实内积空间</span></h3>
<p>考虑正定对称双线性形式<span class="math inline">\(( \_ \mid \_ ) : V
\times V \to F\)</span>,这样的资料<span class="math inline">\(( V , ( \_
\mid \_ ) )\)</span>称为<strong>内积空间(IPS)</strong>.为了要一些<span class="math inline">\(\mathbb{ R
}\)</span>上的完备性质,我们下面主要讨论<span class="math inline">\(F =
\mathbb{ R }\)</span>的特殊情况.回忆道此时它应当满足的条件:</p>
<ol type="1">
<li><p>双线性:各位有分配律以及标量乘法.</p></li>
<li><p>对称性:<span class="math inline">\(( \vec{ v } \mid \vec{ w } ) =
( \vec{ w } \mid \vec{ v } )\)</span>.</p></li>
<li><p>正定性:<span class="math inline">\(( \vec{ v } \mid \vec{ v } )
\geq 0\)</span>,并且等号成立当且仅当<span class="math inline">\(\vec{ v
} = \vec{ 0 }\)</span>.</p></li>
</ol>
<p>回忆道二次型理论的时候我们曾经说过正定性是强于非退化的,因此内积一定是非退化的.</p>
<p>接下来定义<span class="math inline">\(\vec{ v } \in
V\)</span>的<strong>长度</strong>为<span class="math inline">\(\Vert
\vec{ v } \Vert = \sqrt{ ( \vec{ v } \mid \vec{ v } )
}\)</span>,并且如果<span class="math inline">\(( \vec{ v } \mid \vec{ w
} ) = 0\)</span>,则称它们<strong>正交</strong>,也写作<span class="math inline">\(\vec{ v } \bot \vec{ w
}\)</span>.同理可以定义正交空间<span class="math inline">\(V_0^\bot\)</span>.还将满足<span class="math inline">\(\Vert \vec{ v } \Vert = 1\)</span>的<span class="math inline">\(\vec{ v
}\)</span>称为<strong>单位向量</strong>.</p>
<h4><span id="勾股定理">勾股定理</span></h4>
<p>事实上可以写出所谓的<strong>配极化</strong>:<span class="math inline">\(( \vec{ v }_1 \mid \vec{ v }_2 ) = \frac{ 1 }{ 2 }
( \Vert \vec{ v }_1 + \vec{ v }_2 \Vert^2 - \Vert \vec{ v }_1 \Vert^2 -
\Vert \vec{ v }_2 \Vert^2 )\)</span>.</p>
<p>这里可以看出内积上的勾股定理:也就是当<span class="math inline">\(\vec{ v } \bot \vec{ w }\)</span>时<span class="math inline">\(\Vert \vec{ v } + \vec{ w } \Vert^2 = \Vert \vec{
v } \Vert^2 + \Vert \vec{ w } \Vert^2\)</span>.</p>
<h4><span id="柯西不等式">柯西不等式</span></h4>
<p>即<span class="math inline">\(( \vec{ v } \mid \vec{ w } )^2 \leq (
\vec{ v } \mid \vec{ v } ) ( \vec{ w } \mid \vec{ w }
)\)</span>,或言<span class="math inline">\(( \vec{ v } \mid \vec{ w } )
\leq \Vert \vec{ v } \Vert \cdot \Vert \vec{ w } \Vert\)</span>.</p>
<p>等式成立当且仅当<span class="math inline">\(\vec{ v } , \vec{ w
}\)</span>线性相关,此时也是容易证明的,只需要讨论<span class="math inline">\(\vec{ v } = t \vec{ w
}\)</span>以及反过来的情况即可.</p>
<p>当<span class="math inline">\(\vec{ v } , \vec{ w
}\)</span>线性无关时,那么<span class="math inline">\(\vec{ v } \ne 0 ,
\vec{ w } \ne 0\)</span>,于是<span class="math inline">\(\forall t ,
\vec{ v } + t \vec{ w } \ne 0\)</span>.这会导致:</p>
<p><span class="math display">\[
0 &lt; ( \vec{ v } + t \vec{ w } \mid \vec{ v } + t \vec{ w } ) = t^2 (
\vec{ w } \mid \vec{ w } ) + 2 t ( \vec{ v } \mid \vec{ w } ) + ( \vec{
v } \mid \vec{ v } )
\]</span></p>
<p>将此看作关于<span class="math inline">\(t\)</span>的二次多项式,那它就没有实根,于是观察判别式<span class="math inline">\(\Delta = 4 ( \vec{ v } \mid \vec{ w } )^2 - 4 (
\vec{ v } \mid \vec{ v } ) ( \vec{ w } \mid \vec{ w } ) &lt;
0\)</span>就见到柯西不等式成立.</p>
<p>用柯西不等式还可以定义两个向量之间的夹角,设其为<span class="math inline">\(\angle ( \vec{ v } , \vec{ w }
)\)</span>,并定义<span class="math inline">\(\cos \angle ( \vec{ v } ,
\vec{ w } ) = \frac{ ( \vec{ v } \mid \vec{ w } ) }{ \Vert \vec{ v }
\Vert \cdot \Vert \vec{ w } \Vert }\)</span>.</p>
<p>值得一提的是,柯西准则实际上保证了如果空间本身是连续的,那么内积就一定是连续的,原因是假设一列<span class="math inline">\(( \vec{ x }_n , \vec{ y }_n ) \to ( \vec{ x } ,
\vec{ y } )\)</span>,无论以何种方式逼近,一定有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; | ( \vec{ x }_n \mid \vec{ y }_n ) - ( \vec{ x } \mid \vec{ y } )
| \\
\leq &amp; | ( \vec{ x }_n - \vec{ x } \mid \vec{ y }_n ) | + | ( \vec{
x } \mid \vec{ y }_n - \vec{ y } ) | \\
\leq &amp; \Vert \vec{ x } - \vec{ x }_n \Vert \cdot \Vert \vec{ y }_n
\Vert + \Vert \vec{ x } \Vert \cdot \Vert \vec{ y }_n - \vec{ y } \Vert
\end{aligned}
\]</span></p>
<p>这样就可以将其控制住.</p>
<h4><span id="三角不等式">三角不等式</span></h4>
<p>先用配极化,再用柯西不等式得到:</p>
$$
<span class="math display">\[\begin{aligned}
\Vert \vec{ v }_1 + \vec{ v }_2 \Vert^2 &amp; = \Vert \vec{ v }_1
\Vert^2 + \Vert \vec{ v }_2 \Vert^2 + 2 ( \vec{ v }_1 \mid \vec{ v }_2 )
\\
&amp; \leq \Vert \vec{ v }_1 \Vert^2 + \Vert \vec{ v }_2 \Vert^2 + 2 | (
\vec{ v }_1 \mid \vec{ v }_2 ) | \\
&amp; \leq \Vert \vec{ v }_1 \Vert^2 + \Vert \vec{ v }_2 \Vert^2 + 2
\Vert \vec{ v }_1 \Vert \cdot \Vert \vec{ v }_2 \Vert \\
&amp; = ( \Vert \vec{ v }_1 \Vert + \Vert \vec{ v }_2 \Vert )^2 \\

\end{aligned}\]</span>
<p>$$</p>
<h4><span id="距离相关">距离相关</span></h4>
<p>如上可以定义<strong>距离函数</strong><span class="math inline">\(d :
V \times V \to \mathbb{ R }_{ \geq 0 } , ( \vec{ v } , \vec{ w } )
\mapsto \Vert \vec{ w } - \vec{ v }
\Vert\)</span>.容易见到其满足三角不等式<span class="math inline">\(d (
\vec{ u } , \vec{ v } ) + d ( \vec{ v } , \vec{ w } ) \geq d ( \vec{ u }
, \vec{ w } )\)</span>.</p>
<h4><span id="正交向量族">正交向量族</span></h4>
<p>选取<span class="math inline">\(V\)</span>中的一组两两正交的非零元素,称其为<strong>正交向量族</strong>或者<strong>正交子集</strong>.特别地如果所有向量都是单位向量,则称其为<strong>单位正交向量族</strong>或者<strong>单位正交子集</strong>.容易见到正交向量族应该是线性无关的,原因是反证,如果<span class="math inline">\(\sum a_k \vec{ v }_k = 0\)</span>,两边对<span class="math inline">\(\vec{ v }_k\)</span>做内积就可以得到<span class="math inline">\(a_k \Vert \vec{ v }_k \Vert^2 =
0\)</span>,根据正定性得到<span class="math inline">\(a_k =
0\)</span>.</p>
<p>既然如此,我们就将由一个单位正交子集所给出的基称为<strong>单位正交基(ONB)</strong>.</p>
<p>如果我们能拿出一组<span class="math inline">\(n\)</span>个元素的单位正交基<span class="math inline">\(\langle \vec{ v }_1 , \cdots \vec{ v }_n
\rangle\)</span>,那么考虑用这组有序基将<span class="math inline">\(V \to
\mathbb{ R }^n\)</span>.则注意到<span class="math inline">\(\forall
\vec{ v } \in V\)</span>,应当有:<span class="math inline">\(\vec{ v } =
\sum_k a_k \vec{ v }_k\)</span>.并且两边对<span class="math inline">\(\vec{ v }_k\)</span>取内积就可以见到<span class="math inline">\(a_k = ( \vec{ v } \mid \vec{ v }_k
)\)</span>.我们可以证明在这组基的同构下原本的内积就同构于<span class="math inline">\(\mathbb{ R
}^n\)</span>上的标准内积(点乘).因此需要验证这个映射是否是保距的,事实上注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( \sum_i a_i \vec{ v }_i \mid \sum_j b_j \vec{ v }_j ) \\
= &amp; \sum_{ i , j } a_i b_j ( \vec{ v }_i \mid \vec{ v }_j ) \\
= &amp; \sum_i a_i b_i
\end{aligned}
\]</span></p>
<h4><span id="gram-schmidt-正交化">Gram-Schmidt 正交化</span></h4>
<p>问题现在在于单位正交基是否总是存在以及如何找到一个.我们先取一组向量<span class="math inline">\(\vec{ v }_1 , \vec{ v }_2 ,
\cdots\)</span>线性无关(这里甚至允许可数无穷个向量),递归定义:</p>
<p><span class="math display">\[
\begin{aligned}
\vec{ w }_1 &amp; = \vec{ v }_1 \\
\vec{ w }_k &amp; = \vec{ v }_k - \sum_{ i = 1 }^{ k - 1 } \frac{ (
\vec{ w }_i \mid \vec{ v }_k ) }{ ( \vec{ w }_i \mid \vec{ w }_i ) }
\vec{ w }_i
\end{aligned}
\]</span></p>
<p>就可以取出一组正交基,之后只需令<span class="math inline">\(\vec{ u
}_k = \frac{ \vec{ w }_k }{ \Vert \vec{ w }_k \Vert
}\)</span>就可以转化为一组单位正交基.事实上还可以注意到<span class="math inline">\(\langle \vec{ w }_1 , \cdots \vec{ w }_k \rangle =
\langle \vec{ v }_1 , \cdots , \vec{ v }_k
\rangle\)</span>.其构造思路是每次添加一个拥有两项的元素,一项要是前面的空间内的部分,另一部分不是,然而它们之和要与前面空间正交.</p>
<p>证明的话,注意到:<span class="math inline">\(\vec{ w }_k \in \vec{ v
}_k + \langle \vec{ w }_1 , \cdots , \vec{ w }_{ k - 1 }
\rangle\)</span>,因此数学归纳证明<span class="math inline">\(\langle
\vec{ w }_1 , \cdots \vec{ w }_k \rangle = \langle \vec{ v }_1 , \cdots
, \vec{ v }_k \rangle\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \langle \vec{ w }_1 , \cdots , \vec{ w }_k \rangle \\
= &amp; \langle \vec{ w }_1 , \cdots , \vec{ w }_{ k - 1 } \rangle +
\langle \vec{ w }_k \rangle \\
= &amp; \langle \vec{ v }_1 , \cdots , \vec{ v }_{ k - 1 } \rangle +
\langle \vec{ v }_k \rangle \\
= &amp; \langle \vec{ v }_1 , \cdots , \vec{ v }_k \rangle
\end{aligned}
\]</span></p>
<p>此外上述的算法的优点在于如果<span class="math inline">\(\vec{ v
}_k\)</span>已经和前面的<span class="math inline">\(\vec{ w }_1 , \cdots
, \vec{ w }_{ k - 1 }\)</span>正交,自然有<span class="math inline">\(\vec{ w }_k = \vec{ v }_k\)</span>.</p>
<p>而验证正交无非是两边同时对<span class="math inline">\(\vec{ w
}_j\)</span>做内积并继续归纳即可.</p>
<p>由上给出两个推论:</p>
<ol type="1">
<li><p>任何有限维内积空间都有单位正交基.</p></li>
<li><p>任何单位正交子集都可以扩充为一个单位正交基.</p></li>
</ol>
<p>(1)找到一组基用上述算法即可,(2)的话可以先扩充成基,再按照上述算法,而前面原本已经正交的部分不会改变.</p>
<h6><span id="example1ru分解">Example1(RU分解)</span></h6>
<p>观察上述Gram-Schmidt正交化过程就可以看到,对于一个矩阵<span class="math inline">\(A = ( \vec{ v }_1 , \cdots , \vec{ v }_n
)\)</span>,对其作正交化,每次相当于右乘(列变换)一个上三角矩阵(没有交换列的操作),最终变换的形态则会是一个正交矩阵.因此,任何一个可逆矩阵都可以被分解成<span class="math inline">\(RU\)</span>,其中<span class="math inline">\(R\)</span>是一个正交矩阵,<span class="math inline">\(U\)</span>是一个上三角矩阵.</p>
<h6><span id="example2legendre多项式">Example2(Legendre多项式)</span></h6>
<p>考虑<span class="math inline">\(\mathbb{ R
}\)</span>上的多项式组成的<span class="math inline">\(\mathbb{ R }
-\)</span>向量空间<span class="math inline">\(\mathbb{ R } [ x
]\)</span>,定义内积<span class="math inline">\(( f \mid g ) = \int_{ - 1
}^1 f ( x ) g ( x ) \text{ d } x\)</span>,容易见到其满足定义.此外,<span class="math inline">\(\mathbb{ R } [ x ]\)</span>的一组自然的基是<span class="math inline">\(\langle 1 , x , x^2 \cdots \rangle\)</span>.</p>
<p>是否可以对其进行正交化呢?考虑限制得到的单位正交基的最高次系数均为<span class="math inline">\(1\)</span>,容易见到这组单位正交基如此便被唯一刻画,并且必然是上述做Gram-Schmidt正交化的产物.</p>
<p>既然如此,我们接下来尝试检验<span class="math inline">\(P_0 = 1 , P_n
= \frac{ 1 }{ 2^n n ! } ( ( x^2 - 1 )^n )^{ ( n )
}\)</span>就是一组正交基.我们声称以下命题成立:</p>
<ol type="1">
<li><p><span class="math inline">\([ x^n ] P_n = \frac{ ( 2 n ) ! }{ 2^n
( n ! )^2 }\)</span>.</p></li>
<li><p><span class="math inline">\(P_n ( 1 ) = 1\)</span>.</p></li>
<li><p>当<span class="math inline">\(0 \leq k &lt; n\)</span>时,<span class="math inline">\(\int_{ - 1 }^1 t^k P_n ( t ) \mathrm{ d } t =
0\)</span>.作为此的一个推论,<span class="math inline">\(n \ne
m\)</span>的时候<span class="math inline">\(\int_{ - 1 }^1 P_m ( t ) P_n
( t ) \mathrm{ d } t = 0\)</span>.</p></li>
<li><p><span class="math inline">\(P_n ( - t ) = ( - 1 )^n P_n ( t
)\)</span>.</p></li>
<li><p><span class="math inline">\(\int_{ - 1 }^1 P_n ( t )^2 \mathrm{ d
} t = \frac{ 2 }{ 2 n + 1 }\)</span>.</p></li>
<li><p>递归式:<span class="math inline">\(( n + 1 ) P_{ n + 1 } = ( 2 n
+ 1 ) x ( P_n ) - nP_{ n - 1 }\)</span>.</p></li>
</ol>
<p>对于(1),讨巧的策略是直接看<span class="math inline">\(\lim_{ x \to
\infty } \frac{ P_n }{ x^n }\)</span>,而于此使用洛必达法则上下求导<span class="math inline">\(n\)</span>次,立刻证毕.</p>
<p>对于(2),考虑<span class="math inline">\(( x^2 - 1 ) = ( x - 1 ) ( x +
1 )\)</span>,用Leibniz律求导,得到<span class="math inline">\(P_n ( 1 ) =
\frac{ 1 }{ 2^n n ! } n ! ( 1 + 1 )^n = 1\)</span>.</p>
<p>对于(3),只需分部积分,每次将<span class="math inline">\(P_n ( t
)\)</span>给扔到<span class="math inline">\(\rm
d\)</span>里,这样前面的<span class="math inline">\(t^k\)</span>就会被不断消耗,最终得到结果.</p>
<p>对于(4),考虑在求导前的部分当然都是一样的,因此只是求导的时候,<span class="math inline">\(P_n ( t )\)</span>是<span class="math inline">\(\frac{ 1 }{ ( \mathrm{ d } t )^n
}\)</span>,而<span class="math inline">\(P_n ( - t ) = \frac{ 1 }{ ( (
\mathrm{ d } ) ( - t ) )^n }\)</span>.</p>
<p>对于(5),把<span class="math inline">\(P_n ( t )^2 = P_n ( t ) \times
P_n ( t )\)</span>,然后使用分部积分,得到的结果当然就是:</p>
$$
<span class="math display">\[\begin{aligned}
&amp; ( - 1 )^n \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \int_{ - 1 }^1 ( t^2
- 1 )^n \mathrm{ d } t \\
= &amp; 2 ( - 1 )^n \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \int_{ 0 }^1 (
t^2 - 1 )^n \mathrm{ d } t \\
= &amp; 2 \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \int_{ 0 }^1 ( 1 - t^2 )^n
\mathrm{ d } t \\

\end{aligned}\]</span>
<p>$$</p>
<p>做换元<span class="math inline">\(\cos \theta = t\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; 2 \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \int_{ 0 }^1 ( 1 - t^2 )^n
\mathrm{ d } t \\
= &amp; 2 \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \int_{ 0 }^{ \frac{ \pi }{
2 } } \sin ( t )^{ 2 n + 1 } \mathrm{ d } t \\
= &amp; 2 \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \frac{ ( 2 n ) ! ! }{ ( 2
n + 1 ) ! ! } \\
= &amp; 2 \frac{ ( 2 n ) ! }{ ( 2^n n ! )^2 } \frac{ ( 2^n n ! )^2 }{ (
2 n + 1 ) ! } \\
= &amp; \frac{ 2 }{ 2 n + 1 }
\end{aligned}
\]</span></p>
<p>于是证毕.</p>
<p>对于(6),考虑既然上述Legendre多项式是一组基,那么<span class="math inline">\(xP_n\)</span>作为一个<span class="math inline">\(n
+ 1\)</span>次多项式,理应可以被表示出来.也就是有:</p>
<p><span class="math display">\[
xP_n = \sum_{ k = 0 }^{ n + 1 } a_k P_{ k }
\]</span></p>
<p>两边对<span class="math inline">\(P_{ k } , k \leq n -
2\)</span>做内积,那么左侧就是<span class="math inline">\(\int_{ - 1 }^1
( xP_k ( x ) ) P_n ( x ) \mathrm{ d } x\)</span>,此时考虑<span class="math inline">\(xP_k ( x )\)</span>是一个<span class="math inline">\(k + 1 &lt; n\)</span>次多项式,所以左侧理应为<span class="math inline">\(0\)</span>,于是右侧的<span class="math inline">\(a_k = 0\)</span>.上式被我们简化为:</p>
<p><span class="math display">\[
xP_n = a_n P_{ n + 1 } + b_n P_{ n } + c_n P_{ n - 1 }
\]</span></p>
<p>考虑两边提取<span class="math inline">\([ x^{ n + 1 }
]\)</span>,立刻知道<span class="math inline">\(a_n = \frac{ n + 1 }{ 2 n
+ 1 }\)</span>.</p>
<p>两边对<span class="math inline">\(P_n\)</span>做内积,注意到<span class="math inline">\(x ( P_n )^2\)</span>是一个奇函数,所以左边为<span class="math inline">\(0\)</span>,所以<span class="math inline">\(b_n =
0\)</span>.</p>
<p>接下来是<span class="math inline">\(c_n\)</span>.考虑<span class="math inline">\(( xP_n \mid P_{ n - 1 } ) = ( P_n \mid xP_{ n - 1
} )\)</span>,而由刚才的<span class="math inline">\(a_n\)</span>,<span class="math inline">\(xP_{ n - 1 } = \frac{ n }{ 2 n - 1 } P_n + P
&#39;\)</span>,因此立刻见到<span class="math inline">\(c_n = \frac{ n }{
2 n + 1 }\)</span>,这就得证了.</p>
<h4><span id="正交算子">正交算子</span></h4>
<p>如果拿出两个内积空间,并能找到一个映射<span class="math inline">\(\varphi : V \to W\)</span>使得保<span class="math inline">\(\Vert \varphi ( \vec{ v } ) \Vert_W = \Vert \vec{
v }
\Vert_V\)</span>,那么称其为<strong>保距同构</strong>.用配极化容易见到保距同构一定保持了内积.容易见到如果<span class="math inline">\(\varphi\)</span>是同构,那么<span class="math inline">\(\varphi^{ - 1 }\)</span>当然也是同构的.</p>
<p>考虑取两个有限维内积空间<span class="math inline">\(V ,
W\)</span>.由于内积非退化并且对称,于是应当对于所有线性映射<span class="math inline">\(T : V \to W\)</span>都有伴随<span class="math inline">\(T^* : W \to V\)</span>使得<span class="math inline">\(( T \vec{ v } \mid \vec{ w } )_W = ( \vec{ v }
\mid T^* \vec{ w } )_V\)</span>并且<span class="math inline">\(( T^*
\vec{ w } \mid \vec{ v } )_V = ( \vec{ w } \mid T \vec{ v }
)_W\)</span>.</p>
<p>接下来我们尝试证明:<span class="math inline">\(T\)</span>是保距同构当且仅当<span class="math inline">\(T^* = T^{ - 1 }\)</span>.</p>
<p>先证必要性:当<span class="math inline">\(T\)</span>是保距同构的时候,见到<span class="math inline">\(T^{ - 1 }\)</span>必然也是同构,这就意味着<span class="math inline">\(( T \vec{ v } \mid \vec{ w } )_W = ( T^{ - 1 } T
\vec{ v } \mid T^{ - 1 } \vec{ w } )_V = ( \vec{ v } \mid T^{ - 1 }
\vec{ w } )_V\)</span>对于<span class="math inline">\(\forall \vec{ v }
, \vec{ w }\)</span>都成立,这当然意味着<span class="math inline">\(T^* =
T^{ - 1 }\)</span>.</p>
<p>再证充分性,当<span class="math inline">\(T^* = T^{ - 1
}\)</span>时,考虑<span class="math inline">\(( T \vec{ v }_1 \mid T
\vec{ v }_2 )_W = ( \vec{ v }_1 \mid T^* T \vec{ v }_2 )_V = ( \vec{ v
}_1 \mid \vec{ v }_2 )_V , \forall \vec{ v }_1 , \vec{ v
}_2\)</span>,这就意味着其是保距同构.</p>
<p>另外还可以证明如果<span class="math inline">\(\vec{ v }_1 , \cdots ,
\vec{ v }_n\)</span>是<span class="math inline">\(V\)</span>的单位正交基时,<span class="math inline">\(T\)</span>是保距同构当且仅当<span class="math inline">\(T \vec{ v }_1 , \cdots , T \vec{ v
}_n\)</span>是<span class="math inline">\(W\)</span>的单位正交基.</p>
<p>必要性源于保距同构保持了关于内积的一切性质,因此显然.接下来考虑充分性,如果<span class="math inline">\(T \vec{ v }_1 , \cdots , T \vec{ v
}_n\)</span>是<span class="math inline">\(W\)</span>的单位正交基,那么:</p>
<p><span class="math display">\[
\begin{aligned}
\Vert \sum_k a_k \vec{ v }_k \Vert_V^2 &amp; = \sum_k a_k^2 \\
\Vert T ( \sum_k a_k \vec{ v }_k ) \Vert_W^2 &amp; = \Vert \sum_k a_k (
T \vec{ v }_k ) \Vert^2_W = \sum_k a_k^2
\end{aligned}
\]</span></p>
<p>这意味着其保距.并且<span class="math inline">\(\dim V = n = \dim
W\)</span>意味着是同构.</p>
<p>接下来定义有限维内积空间的自同构称为<span class="math inline">\(V\)</span>上的<strong>正交变换</strong>.现在不妨假设<span class="math inline">\(V = \mathbb{ R
}^n\)</span>并将视角转移到标准内积上(此时应当有<span class="math inline">\(A^* =
A^T\)</span>)尝试使用矩阵来描述该问题.容易见到以下命题等价,并将满足下列性质的矩阵称为<strong>实正交矩阵</strong>:</p>
<ol type="1">
<li><p><span class="math inline">\(A^{ - 1 } = A^T\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span>相对于标准内积是正交变换.</p></li>
</ol>
<p>由此得到以下推论:</p>
<ol type="1">
<li><p>单位矩阵是正交矩阵.</p></li>
<li><p>如果<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>都是正交矩阵,那么<span class="math inline">\(AB\)</span>亦然.</p></li>
<li><p>如果<span class="math inline">\(A\)</span>是正交矩阵,则<span class="math inline">\(A^T , A^{ - 1 }\)</span>均亦然.</p></li>
<li><p>正交矩阵的行列式为<span class="math inline">\(\pm
1\)</span>.</p></li>
<li><p>对于矩阵<span class="math inline">\(A = ( \vec{ v }_1 , \cdots ,
\vec{ v }_n )\)</span>,<span class="math inline">\(A\)</span>是正交矩阵当且仅当<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v
}_n\)</span>是一组单位正交基.</p></li>
<li><p>正交矩阵的特征值(无论实复)必然满足<span class="math inline">\(|
\lambda | = 1\)</span>.</p></li>
</ol>
<p>(1)(2)(3)显然,(4)则是因为<span class="math inline">\(( \det A )^2 =
\det ( A^T ) \det A = 1\)</span>.</p>
<p>(5)的话原因是<span class="math inline">\(\mathbb{ R }\)</span>下<span class="math inline">\(\vec{ e }_1 , \cdots \vec{ e
}_n\)</span>是一组标准正交基,而<span class="math inline">\(\vec{ v }_k =
A \vec{ e
}_k\)</span>,因此根据前面提到的正交矩阵对标准正交基的转译性质即证毕.</p>
<p>(6)的话,考虑标准内积空间<span class="math inline">\(( A \vec{ v }
\mid A \vec{ v } )\)</span>,其中<span class="math inline">\(\vec{ v
}\)</span>是以<span class="math inline">\(\lambda\)</span>为特征值的特征向量,那么首先,<span class="math inline">\(( A \vec{ v } \mid A \vec{ v } ) = | \lambda |^2 (
\vec{ v } \mid \vec{ v } )\)</span>,另一方面,其又是<span class="math inline">\(( ( A \vec{ v } )^t ) ( A \vec{ v } ) = ( \vec{ v
} \mid \vec{ v } )\)</span>.这就完事了.</p>
<h4><span id="正交补空间">正交补空间</span></h4>
<p>取<span class="math inline">\(S\)</span>为<span class="math inline">\(V\)</span>的任意子集,则称<span class="math inline">\(S^\bot = \{ \vec{ v } \in V \mid \forall \vec{ s }
\in S , ( \vec{ s } \mid \vec{ v } ) = 0 \}\)</span>为<span class="math inline">\(S\)</span>的<strong>正交补空间</strong>.</p>
<p>虽然在此定义下<span class="math inline">\(S\)</span>无需是子空间,但仍见到<span class="math inline">\(S^\bot\)</span>自动对加法和纯量乘法封闭,因此<span class="math inline">\(S^\bot\)</span>仍是一个子空间.然而其实这里<span class="math inline">\(S^\bot = ( \langle S \rangle
)^\bot\)</span>,这当然是显然的,因此后面只关注<span class="math inline">\(S = V_0\)</span>是<span class="math inline">\(V\)</span>的子空间的情况.</p>
<p>虽然之前我们做双线性形式的时候正交空间并没有太好的性质,但此时对于内积的情况有,我们声称<span class="math inline">\(V = V_0 \oplus
V_0^\bot\)</span>.原因是任取一组<span class="math inline">\(V_0\)</span>的单位正交基<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v
}_m\)</span>,注意到<span class="math inline">\(\vec{ v } = \sum_{ k } (
\vec{ v }_k \mid \vec{ v } ) \vec{ v }_k + ( \vec{ v } - \sum_{ k } (
\vec{ v }_k \mid \vec{ v } ) \vec{ v }_k )\)</span>,前者显然属于<span class="math inline">\(V_0\)</span>,而后者只需逐个对<span class="math inline">\(\vec{ v }_k\)</span>做内积就可以验证其属于<span class="math inline">\(V_0^\bot\)</span>.不妨将前者称为<span class="math inline">\(\vec{ v }\)</span>在<span class="math inline">\(V_0\)</span>上的正交投影.并将<span class="math inline">\(P : V \to V_0 , \vec{ v } \mapsto \vec{ v
}_0\)</span>称作正交投影算子,其中<span class="math inline">\(\vec{ v } =
\vec{ v }_0 + \vec{ v }_1\)</span>,<span class="math inline">\(\vec{ v
}_0 \in V_0 , \vec{ v }_1 \in
V_0^\bot\)</span>.另外,观察到伴随映射有<span class="math inline">\((
\text{ im } \ T )^\bot = \ker T^*\)</span>,见到<span class="math inline">\(V = \ker T^* + \text{ im } \ T\)</span>.</p>
<p>取<span class="math inline">\(V_0 \subseteq V\)</span>,并且取<span class="math inline">\(V = V_0 \oplus V_0^\bot\)</span>,考虑<span class="math inline">\(P\)</span>映射是从<span class="math inline">\(V\)</span>到<span class="math inline">\(V_0\)</span>的投影,那么<span class="math inline">\(\forall \vec{ v }\)</span>,<span class="math inline">\(\min_{ \vec{ u } \in V_0 } \Vert \vec{ u } - \vec{
v } \Vert\)</span>在<span class="math inline">\(\vec{ u } = P \vec{ v
}\)</span>的时候取最小.原因是不妨设<span class="math inline">\(\vec{ v }
= \vec{ v }_0 + \vec{ v }_1\)</span>,使用勾股定理:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \Vert \vec{ u } - \vec{ v } \Vert^2 \\
= &amp; \Vert \vec{ u } - \vec{ v }_0 - \vec{ v }_1 \Vert^2 \\
= &amp; \Vert \vec{ u } - \vec{ v }_0 \Vert^2 + \Vert \vec{ v }_1
\Vert^2 \\
\geq &amp; \Vert \vec{ v }_1 \Vert^2
\end{aligned}
\]</span></p>
<p>此时仔细观察投影算子<span class="math inline">\(P : V \to
V_0\)</span>,应当可以将<span class="math inline">\(P\)</span>视作<span class="math inline">\(\text{ End } ( V
)\)</span>中的某元素,我们下面证明<span class="math inline">\(P\)</span>是正交投影算子当且仅当<span class="math inline">\(P^* = P\)</span>和<span class="math inline">\(P^2
= P\)</span>同时成立.</p>
<p>先证明必要性:仍选择将<span class="math inline">\(\vec{ v } = \vec{ v
}_0 + \vec{ v }_1\)</span>,其中<span class="math inline">\(\vec{ v }_0
\in V_0\)</span>而<span class="math inline">\(\vec{ v }_1 \in
V_0^\bot\)</span>,此时<span class="math inline">\(P \vec{ v } = \vec{ v
}_0\)</span>,而<span class="math inline">\(P^2 \vec{ v } = \vec{ v }_0 =
P \vec{ v }\)</span>,因此<span class="math inline">\(P^2 =
P\)</span>总是成立.另外如果有<span class="math inline">\(\vec{ v } &#39;
= \vec{ v }_0 &#39; + \vec{ v }_1 &#39;\)</span>,那么应当注意到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( P \vec{ v } \mid \vec{ v } &#39; ) \\
= &amp; ( \vec{ v }_0 \mid \vec{ v } &#39; ) = ( \vec{ v }_0 \mid \vec{
v }_0 &#39; ) = ( \vec{ v } \mid \vec{ v }_0 &#39; ) \\
= &amp; ( \vec{ v } \mid P \vec{ v } &#39; )
\end{aligned}
\]</span></p>
<p>然后证明充分性,直接取<span class="math inline">\(V_0 = \text{ im } (
P )\)</span>,那么<span class="math inline">\(\forall \vec{ v } \in
V\)</span>当然<span class="math inline">\(\exists \vec{ u
}\)</span>有<span class="math inline">\(\vec{ v } = P \vec{ u } + \vec{
v }_1\)</span>.此时注意到<span class="math inline">\(P \vec{ v } = P
\vec{ u } + P \vec{ v }_1\)</span>.观察发现<span class="math inline">\((
P \vec{ v }_1 \mid P \vec{ v }_1 ) = ( P^* P \vec{ v }_1 \mid \vec{ v
}_1 ) = ( P \vec{ v }_1 \mid \vec{ v }_1 )\)</span>,然而<span class="math inline">\(\vec{ v }_1 \in V_0^\bot\)</span>而<span class="math inline">\(P \vec{ v }_1 \in V_0\)</span>,于是<span class="math inline">\(( P \vec{ v }_1 \mid P \vec{ v }_1 ) =
0\)</span>,于是<span class="math inline">\(P \vec{ v }_1 =
0\)</span>.因此<span class="math inline">\(P \vec{ v } = P \vec{ u
}\)</span>.</p>
<p>接下来定义一个正交投影算子的<strong>镜像</strong>为<span class="math inline">\(2 P - \text{ id }_V\)</span>,其将<span class="math inline">\(\vec{ v }_0 + \vec{ v }_1\)</span>映射到<span class="math inline">\(\vec{ v }_0 - \vec{ v
}_1\)</span>上.我们想要证明如果<span class="math inline">\(P\)</span>是正交投影算子,那么<span class="math inline">\(2 P - \text{ id
}_V\)</span>是正交变换.容易检验<span class="math inline">\(( 2 P -
\text{ id }_V )^* = ( 2 P - \text{ id }_V )\)</span>,那就只需要验证:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( 2 P - \text{ id }_V )^* ( 2 P - \text{ id }_V ) \\
= &amp; ( 2 P - \text{ id }_V ) ( 2 P - \text{ id }_V ) \\
= &amp; 4 P^2 - 4 P + \text{ id }_V \\
= &amp; \text{ id }_V
\end{aligned}
\]</span></p>
<p>还可以证明:如果<span class="math inline">\(V_0\)</span>是<span class="math inline">\(T\)</span>不变子空间,那么<span class="math inline">\(( V_0 )^\bot\)</span>是<span class="math inline">\(T^*\)</span>的不变子空间,证明的话只需考虑<span class="math inline">\(( T^* \vec{ w } \mid \vec{ v } ) = ( \vec{ w }
\mid T \vec{ v } ) = 0\)</span>,其中<span class="math inline">\(\vec{ v
} \in V_0\)</span>而<span class="math inline">\(\vec{ w } \in ( V_0
)^\bot\)</span>.这将为我们把空间分解为<span class="math inline">\(V_0
\oplus ( V_0 )^\bot\)</span>提供帮助.更详细的讨论将在自伴算子处讨论.</p>
<h4><span id="投影矩阵">投影矩阵</span></h4>
<p>考虑向量空间<span class="math inline">\(V\)</span>和<span class="math inline">\(A_1 , \cdots , A_s \in \text{ End } ( V
)\)</span>,满足<span class="math inline">\(A_1 + \cdots + A_s = \text{
id }\)</span>,并且<span class="math inline">\(\forall i \ne j , A_i A_j
= 0\)</span>,而且<span class="math inline">\(A_i^2 = A_i\)</span>.</p>
<p>此时令<span class="math inline">\(V_i = \text{ im } ( A_i
)\)</span>.我们下面证明以下三条事实:</p>
<ol type="1">
<li><p><span class="math inline">\(A_i ( \sum \vec{ v }_k ) = \vec{ v
}_i\)</span>,其中<span class="math inline">\(\vec{ v }_k \in
V_k\)</span>.</p></li>
<li><p><span class="math inline">\(V = \bigoplus V_k\)</span>.</p></li>
<li><p>若<span class="math inline">\(A^2 = A\)</span>,则<span class="math inline">\(V = \text{ im } ( A ) \oplus \text{ im } ( \text{
id } - A ) = \text{ im } A \oplus \ker A\)</span>.</p></li>
</ol>
<p>(1)显然.</p>
<p>考虑(2)的证明,由于<span class="math inline">\(V = \text{ im } (
\text{ id } ) \subseteq \sum V_k \subseteq V\)</span>,于是<span class="math inline">\(\sum V_k = V\)</span>.只需再证明<span class="math inline">\(\forall k , V_k \cap ( \sum_{ j \ne k } V_j ) = \{
\vec{ 0 } \}\)</span>即可.而<span class="math inline">\(\forall \vec{ w
} \in V_k\)</span>,考虑<span class="math inline">\(A_k ( \vec{ w } ) =
\vec{ w }\)</span>但<span class="math inline">\(A_k ( \sum_{ j \ne k }
V_j ) = 0\)</span>,这意味着<span class="math inline">\(\vec{ w } \notin
( \sum_{ j \ne k } V_j )\)</span>,这就证毕了.</p>
<p>考虑(3)的证明,只需检验<span class="math inline">\(A ( \text{ id } - A
) = 0\)</span>,这是显然的.</p>
<p>而在特征为<span class="math inline">\(0\)</span>的域上,我们尝试证明更强一点的结论:当<span class="math inline">\(\sum A_k = \text{ id
}\)</span>的时候,以下三条命题等价:</p>
<ol type="1">
<li><p>对于每个<span class="math inline">\(i\)</span>都有<span class="math inline">\(A_i^2 = A_i\)</span>.</p></li>
<li><p><span class="math inline">\(\sum \text{ rk } ( A_i ) = \dim
V\)</span>.</p></li>
<li><p><span class="math inline">\(\forall i \ne j\)</span>,<span class="math inline">\(A_i A_j = 0 = A_j A_i\)</span>.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)的话考虑对于单个<span class="math inline">\(A_i\)</span>,我们上面已经证明过当<span class="math inline">\(A_i^2 = A_i\)</span>的时候应当有直和分解<span class="math inline">\(V = \text{ im } ( A_i ) \oplus \text{ im } (
\text{ id } - A_i )\)</span>,此时任取一组基限制在<span class="math inline">\(\text{ im } ( A_i
)\)</span>上都是恒等变换,于是<span class="math inline">\(\text{ tr } (
A_i ) = \text{ rk } ( A_i
)\)</span>.这个证明可能略有口胡,或者你直接观察<span class="math inline">\(A_i\)</span>的极小多项式为<span class="math inline">\(x ( x - 1 ) =
0\)</span>,立刻得到其可对角化并且对角上只有<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span>,并且只划分了两个子空间<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>,再用迹对于相似不变就可以得到<span class="math inline">\(\text{ tr } ( A_i ) = \text{ rk } ( A_i
)\)</span>.于是<span class="math inline">\(\sum \text{ rk } ( A_i ) =
\sum \text{ tr } ( A_i ) = \text{ tr } ( \text{ id } ) = \dim
V\)</span>.</p>
<p>(2)<span class="math inline">\(\Rightarrow\)</span>(3)的话,考虑同上用<span class="math inline">\(V = \text{ im } ( \text{ id } ) \subseteq \sum V_k
\subseteq V\)</span>,所以<span class="math inline">\(\sum V_k =
V\)</span>.这就可以看到同态<span class="math inline">\(\sigma :
\bigoplus V_k \to V , ( \vec{ v }_i ) \mapsto \sum \vec{ v
}_i\)</span>是满的,比较维数就知道<span class="math inline">\(\dim \ker =
0\)</span>,所以这是同构.这意味着<span class="math inline">\(\forall k ,
j , \text{ im } ( A_k ) \cap \text{ im } ( A_j ) = \{ \vec{ 0 }
\}\)</span>.而我们知道<span class="math inline">\(\text{ im } ( A_k )
\oplus \ker A_k \cong V\)</span>,在这里的直和应该直接表现为<span class="math inline">\(\text{ im } ( A_k ) + \ker A_k =
V\)</span>,这样就直接把<span class="math inline">\(A_j\)</span>扔进了<span class="math inline">\(\ker
A_k\)</span>里面.</p>
<p>(3)<span class="math inline">\(\Rightarrow\)</span>(1)是简单的,原因是<span class="math inline">\(A_k = A_k ( \sum_{ j \ne k } A_j ) + A_k \times
A_k\)</span>.</p>
<p>如果我们将满足<span class="math inline">\(A^2 =
A\)</span>的矩阵称为投影矩阵的话,可以发现一个矩阵是投影矩阵的必要条件是<span class="math inline">\(\ker A + \text{ im } \ A =
V\)</span>.然而并不充分,除非再加上<span class="math inline">\(A ( I - A
) = 0\)</span>.</p>
<h4><span id="自伴算子">自伴算子</span></h4>
<p>对于一个内积空间<span class="math inline">\(( V , ( \_ , \_ ) \
)\)</span>,其中<span class="math inline">\(\dim V = n\)</span>.</p>
<p>称一个映射是<strong>自伴的</strong>,当且仅当<span class="math inline">\(T = T^*\)</span>.我们下面尝试证明如果<span class="math inline">\(T\)</span>是自伴的,那么<span class="math inline">\(T\)</span>可以正交对角化.换言之存在正交映射<span class="math inline">\(P\)</span>使得<span class="math inline">\(P^{ - 1
} TP = P^* TP\)</span>是对角的.另外,如果<span class="math inline">\(T\)</span>可以正交对角化,那么也仅当<span class="math inline">\(T =
T^*\)</span>.原因当然显然,因为只需两边取伴随即可见得.</p>
<p>对<span class="math inline">\(n = \dim
V\)</span>进行归纳,下面不妨假设<span class="math inline">\(n \geq
2\)</span>.</p>
<p>回忆到这个内积空间应该可以同构于标准内积空间<span class="math inline">\(( \mathbb{ R }^n , \cdot
)\)</span>,因此将自伴算子同构于<span class="math inline">\(A^T = A^* =
A\)</span>的矩阵.假设可以找到<span class="math inline">\(T\)</span>的某一个实特征值<span class="math inline">\(\lambda_1\)</span>,我们就可以取其对应的特征向量<span class="math inline">\(\vec{ v }_1 \ne 0\)</span>并且满足<span class="math inline">\(T \vec{ v }_1 = \lambda_1 \vec{ v
}_1\)</span>,而且满足<span class="math inline">\(\Vert \vec{ v }_1 \Vert
= 1\)</span>,并设<span class="math inline">\(V_0 = \text{ span } ( \vec{
v }_1 )\)</span>,回忆到我们有正交直和分解<span class="math inline">\(V =
V_0 \oplus ( V_0^\bot )\)</span>.</p>
<p>此时观察,既然<span class="math inline">\(V_0\)</span>是<span class="math inline">\(T\)</span>不变子空间,我们之前证明了<span class="math inline">\(V_0^\bot\)</span>是<span class="math inline">\(T^*
= T\)</span>的不变子空间,既然如此,<span class="math inline">\(T\)</span>限制在<span class="math inline">\(V_0^\bot\)</span>上就仍然自伴,这样就可以进行数学归纳.</p>
<p>那么怎么找到<span class="math inline">\(T\)</span>的一个实特征值呢?为了证明这个定理,我们可能需要先跳出实数域而在复数域上做一些操作.在复数域上的好处在于可以定义共轭,具体地容易发现<span class="math inline">\(\overline{ A + B } = \bar{ A } + \bar{ B
}\)</span>以及<span class="math inline">\(\overline{ A \times B } =
\bar{ A } \times \bar{ B }\)</span>.</p>
<p>对于复数域上的矩阵,我们约定<span class="math inline">\(A^\dagger =
\bar{ A^T }\)</span>,注意到<span class="math inline">\(\lambda^\dagger =
\bar{ \lambda }\)</span>,并且理应有<span class="math inline">\(( AB
)^\dagger = B^\dagger A^\dagger\)</span>.此时取<span class="math inline">\(\vec{ v } = ( z_1 , \cdots , z_n ) \in \mathbb{ C
}^n\)</span>,注意到<span class="math inline">\(( \vec{ v } )^\dagger (
\vec{ v } ) = \sum | z_k |^2 \in \mathbb{ R }_{ \geq 0
}\)</span>,并且其等于<span class="math inline">\(0\)</span>当且仅当<span class="math inline">\(\vec{ v } = 0\)</span>.</p>
<p>下面我们证明:当<span class="math inline">\(A^\dagger = cA , c \in
\mathbb{ C }\)</span>,那么<span class="math inline">\(A\)</span>的所有特征值都满足<span class="math inline">\(\bar{ \lambda } = c
\lambda\)</span>.不过容易见到这里只能取<span class="math inline">\(c =
\pm 1\)</span>,原因是<span class="math inline">\(c^2 =
1\)</span>.这个性质我们会在后面复内积空间中的hermite形式中进一步用到.</p>
<p>证明的话,考虑<span class="math inline">\(\vec{ v } \ne
0\)</span>是以<span class="math inline">\(\lambda \in \mathbb{ C
}\)</span>为特征值的特征向量,那么我们考虑<span class="math inline">\((
\vec{ v } )^\dagger ( A \vec{ v } ) = ( \vec{ v } )^\dagger ( \lambda )
\vec{ v }\)</span>.此时两边取<span class="math inline">\(\dagger\)</span>,左边给出<span class="math inline">\(( \vec{ v } )^\dagger A^\dagger \vec{ v } = c (
\vec{ v } )^\dagger A \vec{ v } = c \lambda ( \vec{ v } )^\dagger \vec{
v }\)</span>,而右边给出<span class="math inline">\(\bar{ \lambda } (
\vec{ v } )^\dagger ( \vec{ v } )\)</span>,这样就证明了上述结论.</p>
<p>那么这样做的意义是什么呢?已经知道实数上的自伴算子满足<span class="math inline">\(A^\dagger = A\)</span>,也就是在上面<span class="math inline">\(c = 1\)</span>,那意味着<span class="math inline">\(\lambda = \bar{ \lambda }\)</span>,意味着<span class="math inline">\(\lambda\)</span>是实数.然而,由于在<span class="math inline">\(\mathbb{ C
}\)</span>是代数闭的,那么就一定可以找到至少一个复特征值,由上知道这些特征值还都是实数,那我们就补上了上述证明的最后一步.</p>
<p>于是,回忆到直和与分块矩阵的关系,将我们拿到的这些特征向量做正交化后,取<span class="math inline">\(P\)</span>为这些单位正交基<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v
}_n\)</span>为列向量的矩阵,那么<span class="math inline">\(P^{ - 1 } AP
= \begin{bmatrix}\lambda_1 &amp; &amp; \\ &amp; \ddots &amp; \\ &amp;
&amp; \lambda_n\end{bmatrix}\)</span>.</p>
<p>或者直接来看,我们断言自伴算子对应的特征子空间一定互相正交,原因是设它们分别是<span class="math inline">\(V_{ \lambda_1 } , V_{ \lambda_2
}\)</span>,那么<span class="math inline">\(\lambda_1 ( \vec{ v }_1 \mid
\vec{ v }_2 ) = ( T \vec{ v }_1 \mid \vec{ v }_2 ) = ( \vec{ v }_1 \mid
T \vec{ v }_2 ) = \lambda_2 ( \vec{ v }_1 \mid \vec{ v }_2
)\)</span>.这就必然给出<span class="math inline">\(( \vec{ v }_1 \mid
\vec{ v }_2 ) =
0\)</span>.那只需先求特征向量,然后对此施加Gram-Schmidt正交化就赢了.</p>
<h5><span id="实sylvester-判准">(实)Sylvester 判准</span></h5>
<p>将一个矩阵的左上的<span class="math inline">\(k \times
k\)</span>的矩阵称为<span class="math inline">\(A\)</span>的顺序主子式.</p>
<p>容易发现,实对称矩阵正定当且仅当其所有特征值皆正,原因是正交对角化后的结果.</p>
<p>由此可以得到Sylvester判准,也就是一个实对称矩阵正定当且仅当其所有顺序主子式皆正.</p>
<p>必要性显然,把线性空间限制在左上角的那个<span class="math inline">\(k
\times k\)</span>里,如果有某个顺序主子式是负的,那就存在负的特征值.</p>
<p>下面证明充分性:考虑数学归纳,当<span class="math inline">\(n \geq
2\)</span>的时候,假设<span class="math inline">\(A\)</span>的每个顺序主子式都是正的,我们下面试图证明其所有特征值都是正的.记其特征值为<span class="math inline">\(\lambda_1 , \cdots ,
\lambda_n\)</span>,必定有等式<span class="math inline">\(\lambda_1
\cdots \lambda_n = \det A &gt; 0\)</span>.也就是说,如果<span class="math inline">\(A\)</span>有负特征值则必然成对出现,不妨设其为<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\lambda_2\)</span>(当然它们有可能相等,但总之应该取不同的特征向量),此时不妨取它们的特征向量并做单位正交化后得到<span class="math inline">\(\vec{ v }_1 , \vec{ v }_2\)</span>.此时<span class="math inline">\(\forall \alpha , \beta \in \mathbb{ R
}\)</span>,立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( \alpha \vec{ v }_1 + \beta \vec{ v }_2 )^t A ( \alpha \vec{ v
}_1 + \beta \vec{ v }_2 ) \\
= &amp; \alpha^2 \lambda_1 + \beta^2 \lambda_2 \leq 0
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\alpha ,
\beta\)</span>可以任取,当然存在不全为<span class="math inline">\(0\)</span>的一对<span class="math inline">\((
\alpha , \beta )\)</span>使得<span class="math inline">\(\alpha \vec{ v
}_1 + \beta \vec{ v }_2\)</span>作为列向量的第<span class="math inline">\(n\)</span>个坐标为<span class="math inline">\(0\)</span>,此时对于左上角的<span class="math inline">\(( n - 1 ) \times ( n - 1
)\)</span>的空间来说,由于进行了数学归纳,上面必然是正定的.这当然就矛盾了.</p>
<h5><span id="实正定矩阵的二次根">(实)正定矩阵的二次根</span></h5>
<p>设<span class="math inline">\(T \in \text{ End } ( V
)\)</span>正定(或者半正定),那么就存在唯一的正定(或半正定)的<span class="math inline">\(S \in \text{ End } ( V )\)</span>使得<span class="math inline">\(S^2 = T\)</span>,这样我们记<span class="math inline">\(S = \sqrt{ T }\)</span>.</p>
<p>(一定要记得正定蕴含着其对称啊,总是忘记这个定义)</p>
<p>存在性的话只需要对<span class="math inline">\(T\)</span>做单位正交分解,然后把对角线上的特征值全部取根号就可以了.唯一性的话,由于<span class="math inline">\(S\)</span>在每一个特征子空间上都应当表现为<span class="math inline">\(\sqrt{ \lambda_i } \text{ id
}\)</span>(原因是每一个特征子空间本身都是不变子空间,因此<span class="math inline">\(S\)</span>的特征子空间也需要是<span class="math inline">\(S^2 = T\)</span>的特征子空间,于是反之亦然),那<span class="math inline">\(S\)</span>当然是唯一确定的.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(A , B , A -
B\)</span>都是正定矩阵,求证<span class="math inline">\(\sqrt{ A } -
\sqrt{ B }\)</span>正定.</p>
<p>反证,假设<span class="math inline">\(\sqrt{ A } - \sqrt{ B
}\)</span>并非正定,那就一定存在一个特征值<span class="math inline">\(\lambda \leq 0\)</span>以及配套的特征向量<span class="math inline">\(\vec{ v } \ne 0\)</span>,使得<span class="math inline">\(( \sqrt{ A } - \sqrt{ B } ) \vec{ v } = \lambda
\vec{ v }\)</span>,也就是<span class="math inline">\(\sqrt{ B } \vec{ v
} = \sqrt{ A } \vec{ v } - \lambda \vec{ v }\)</span>.此时见到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( \vec{ v } )^t B \vec{ v } \\
= &amp; ( \sqrt{ B } \vec{ v } )^t ( \sqrt{ B } \vec{ v } ) \\
= &amp; ( \sqrt{ A } \vec{ v } - \lambda \vec{ v } )^t ( \sqrt{ A }
\vec{ v } - \lambda \vec{ v } ) \\
= &amp; ( \vec{ v } )^t A \vec{ v } + \lambda^2 \vec{ v }^t \vec{ v } -
2 \lambda ( \vec{ v } )^t \sqrt{ A } \vec{ v } \\
\geq &amp; ( \vec{ v } )^t A \vec{ v }
\end{aligned}
\]</span></p>
<p>这就与<span class="math inline">\(A - B\)</span>正定是矛盾的了.</p>
<h6><span id="example2">Example2</span></h6>
<p>设<span class="math inline">\(A , B , A -
B\)</span>都是正定矩阵,求证<span class="math inline">\(A^{ - 1 } - B^{ -
1 }\)</span>正定.</p>
<p>直接扩到复数域,这样一定存在一个<span class="math inline">\(C\)</span>,使得<span class="math inline">\(( C^* )
BC = I\)</span>,此时由于合同是内积空间上的同构,所以<span class="math inline">\(( C^* ) ( A - B ) C = C^* AC -
I\)</span>仍然正定,这就将情况化约到<span class="math inline">\(B =
I\)</span>的情况.</p>
<p>此时只需对<span class="math inline">\(A\)</span>做对角化即可见得了.</p>
<h5><span id="极分解">极分解</span></h5>
<p>对于内积空间,设<span class="math inline">\(T \in \text{ End } ( V
)\)</span>可逆,那么就存在唯一一对<span class="math inline">\(R , U \in
\text{ End } ( V )\)</span>使得<span class="math inline">\(R\)</span>正定并且<span class="math inline">\(U\)</span>是正交变换,<span class="math inline">\(T
= RU\)</span>.这其实类似于把一个复数拆成模长和辅角两个部分.</p>
<p>在此之前先证明一个引理:标准内积空间上<span class="math inline">\(T^*
T\)</span>是半正定的,并且如果<span class="math inline">\(T\)</span>单,那么其是正定的.</p>
<p>首先其自伴性质是已知的,半正定的原因是<span class="math inline">\(^t (
\vec{ v } ) ( T^* T ) ( \vec{ v } ) = ( T \vec{ v } \mid T \vec{ v }
)\)</span>,而后者继承了内积空间上的半正定性.并且从此可以看出<span class="math inline">\(T\)</span>单的话,也就是<span class="math inline">\(\ker T ={ 0
}\)</span>就可以继承内积空间上的正定性.</p>
<p>注意到<span class="math inline">\(TT^* = RUU^* R =
R^2\)</span>,因此必定有<span class="math inline">\(R = \sqrt{ TT^*
}\)</span>,因此<span class="math inline">\(R\)</span>是唯一且存在的且正定的(原因是<span class="math inline">\(T\)</span>是可逆的,因此<span class="math inline">\(TT^*\)</span>是正定的)而且<span class="math inline">\(R\)</span>还自伴.另外,因为<span class="math inline">\(R\)</span>可逆(正定性推出非退化性),因此<span class="math inline">\(U = R^{ - 1 } T\)</span>就确定.问题在于证明<span class="math inline">\(U\)</span>是否是正交变换,只需要证明<span class="math inline">\(U^* = U^{ - 1 }\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
U^* U &amp; = ( R^{ - 1 } T )^* ( R^{ - 1 } T ) \\
&amp; = T^* R^{ - 2 } T = \text{ id }
\end{aligned}
\]</span></p>
<p>这就得证.</p>
<h5><span id="最小二乘法">最小二乘法</span></h5>
<p>给定一个特定的<span class="math inline">\(T \in \text{ Hom } ( V , W
)\)</span>,现在对于一个<span class="math inline">\(\vec{ w } \in
W\)</span>,想要求一个<span class="math inline">\(\vec{ v } \in
V\)</span>使得<span class="math inline">\(\Vert T \vec{ v } - \vec{ w }
\Vert\)</span>最小.这个解被称为<strong>最小二乘解</strong>.</p>
<p>取<span class="math inline">\(W_0 = \text{ im }
T\)</span>,那么就可以将<span class="math inline">\(\vec{ w } = \vec{ w
}_0 + \vec{ w }_1\)</span>,其中<span class="math inline">\(\vec{ w }_0
\in W_0 , \vec{ w }_1 \in ( W_0 )^\bot\)</span>.此时就可以见到:</p>
<p><span class="math display">\[
\begin{aligned}
\Vert T \vec{ v } - \vec{ w } \Vert^2 &amp; = \Vert ( T \vec{ v } -
\vec{ w }_0 ) - \vec{ w }_1 \Vert^2 \\
&amp; = \Vert T \vec{ v } - \vec{ w }_0 \Vert^2 + \Vert \vec{ w }_1
\Vert^2
\end{aligned}
\]</span></p>
<p>只需让前面为<span class="math inline">\(0\)</span>就行,从这也可以看出来一般而言<span class="math inline">\(\vec{ v }\)</span>不是唯一的.然而<span class="math inline">\(\vec{ v } + \ker
T\)</span>总是唯一的,我们试图在其中找到<span class="math inline">\(\Vert
\vec{ v } \Vert\)</span>最小的一个作为代表.而<span class="math inline">\(\vec{ v }\)</span>仍可以分解为<span class="math inline">\(\ker T\)</span>和<span class="math inline">\((
\ker T )^\bot\)</span>两部分,这就能见到<span class="math inline">\(\Vert
\vec{ v } \Vert\)</span>最小时<span class="math inline">\(\vec{ v } \in
( \ker T )^\bot\)</span>.不妨将这个<span class="math inline">\(\vec{ v
}\)</span>定义为<span class="math inline">\(S ( \vec{ w } ) = \vec{ v
}\)</span>,应该见到<span class="math inline">\(S\)</span>是一个线性映射.</p>
<p>我们还可以证明,其最小二乘解正好是<span class="math inline">\(T^* T
\vec{ v } = T^* \vec{ w }\)</span>的解.原因是最小二乘解其实也就是<span class="math inline">\(T \vec{ v } - \vec{ w } \in ( \text{ im } T )^\bot
= \ker ( T^* )\)</span>.</p>
<p>而注意到<span class="math inline">\(T^*
T\)</span>是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><p><span class="math inline">\(\text{ im } \ ( T^* T ) = \text{ im }
\ ( T^* )\)</span>.</p></li>
<li><p><span class="math inline">\(\ker ( T^* T ) = \ker
T\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ rk } \ ( T^* T ) = \text{ rk }
\ ( T ) = \text{ rk } ( T^* )\)</span>.</p></li>
</ol>
<p>考虑(1), 首先显然有<span class="math inline">\(\text{ im } \ ( T^* T
) \subseteq \text{ im } \ ( T^* )\)</span>.而反方向的话,对于<span class="math inline">\(T^* \vec{ w } \in \text{ im } ( T^*
)\)</span>,只需取其最小二乘解<span class="math inline">\(\vec{ v } \in
V\)</span>就给出了<span class="math inline">\(T^* \vec{ w } = T^* T
\vec{ v } \in \text{ im } ( T^* T )\)</span>.</p>
<p>考虑(2),首先显然有<span class="math inline">\(\ker \ ( T^* T )
\subseteq \ker \ ( T )\)</span>.而反方向的话,若<span class="math inline">\(T^* T \vec{ v } = 0\)</span>,应该能看到<span class="math inline">\(( T \vec{ v } \mid T \vec{ v } ) = ( T^* T \vec{ v
} \mid \vec{ v } ) = 0\)</span>,这意味着<span class="math inline">\(T
\vec{ v } = 0\)</span>.</p>
<p>(3)是(1)(2)的推论.顺便一提,这里推出的<span class="math inline">\(\text{ rk } ( T ) = \text{ rk } ( T^*
)\)</span>是行秩等于列秩的另一个证明.</p>
<h4><span id="奇异值分解">奇异值分解</span></h4>
<p>取<span class="math inline">\(V ,
W\)</span>为有限维实内积空间并采取标准内积,不妨设<span class="math inline">\(m = \dim V , n = \dim
W\)</span>,注意这里的字母使用与习惯略有差别.并取<span class="math inline">\(T : V \to
W\)</span>为线性映射.接下来我们证明,存在<span class="math inline">\(V ,
W\)</span>的两组单位正交基,不妨记作<span class="math inline">\(\mathcal{
B }_V = \{ \vec{ v }_1 , \cdots , \vec{ v }_m \}\)</span>和<span class="math inline">\(\mathcal{ B }_W = \{ \vec{ w }_1 , \cdots , \vec{
w }_n \}\)</span>.记<span class="math inline">\(p = \text{ rk }
T\)</span>,以及存在一列非负实数<span class="math inline">\(\sigma_1 \geq
\cdots \geq \sigma_p\)</span>,使得<span class="math inline">\(T \vec{ v
}_i = \begin{cases}\sigma_i \vec{ w }_i &amp; 1 \leq i \leq p \\ 0 &amp;
i &gt; p\end{cases}\)</span>.我们称这列非负实数为<span class="math inline">\(T\)</span>的<strong>奇异值</strong>,并将在下面证明其由<span class="math inline">\(T\)</span>唯一确定.应当说明的是,下述中虽然有的时候会默认后面有一列<span class="math inline">\(0\)</span>来避开讨论,但<span class="math inline">\(\sigma_p \ne
0\)</span>.一般,我们也用非零奇异值的数量来判断<span class="math inline">\(T\)</span>的秩.可以认为,奇异值是特征值的某种推广.</p>
<p>考虑矩阵,此时的<span class="math inline">\(T\)</span>应当是一个<span class="math inline">\(n \times m\)</span>的矩阵.考虑<span class="math inline">\(V\)</span>的单位正交基组成的矩阵<span class="math inline">\(P \in M_{ m \times m }\)</span>,以及<span class="math inline">\(W\)</span>的单位正交基矩阵<span class="math inline">\(Q \in M_{ n \times n }\)</span>.</p>
<p>此时不妨考虑<span class="math inline">\(T\)</span>在标准基下表示为<span class="math inline">\(A\)</span>,那考虑<span class="math inline">\(Q^{ -
1 } AP\)</span>实际上就是在两个单位正交基内转化的过程.不妨令<span class="math inline">\(\Sigma = Q^{ - 1 } AP\)</span>,只需证明其在前<span class="math inline">\(p\)</span>个主对角线位置分别为<span class="math inline">\(\sigma_1 , \cdots , \sigma_p\)</span>即可.</p>
<p>留意到<span class="math inline">\(( \vec{ v }_i \mid T^* \vec{ w }_j
) = ( T \vec{ v }_i \mid \vec{ w }_j ) = \sigma_i ( \vec{ w }_i \mid
\vec{ w }_j ) = \sigma_i \delta_{ i , j }\)</span>,其中<span class="math inline">\(\delta_{ i , j } = [ i = j ]\)</span>.回忆到<span class="math inline">\(T^*\)</span>是唯一的,并注意到如果干脆定义<span class="math inline">\(T^*\)</span>满足<span class="math inline">\(T^*
\vec{ w }_j = \sigma_j \vec{ v }_j\)</span>上式依旧成立,因此<span class="math inline">\(T^*\)</span>的确有此性质.进一步得到推论<span class="math inline">\(T^* T \vec{ v }_i = \sigma_i^2 \vec{ v
}_i\)</span>.所以<span class="math inline">\(T^*
T\)</span>的特征值恰为<span class="math inline">\(\sigma_1^2 \geq
\cdots\)</span>.这样的话其唯一性立刻见到了.不过由于是在<span class="math inline">\(\mathbb{ R
}\)</span>上,因此我们还要说明其存在性.考虑对<span class="math inline">\(T^* T\)</span>做正交对角化.此时回忆到<span class="math inline">\(\text{ rk } ( T^* T ) = \text{ rk } ( T ) =
p\)</span>,又因为<span class="math inline">\(T^*
T\)</span>可对角化,<span class="math inline">\(\text{ rk
}\)</span>对应了非零特征值的数量.直接取<span class="math inline">\(\sigma_i = \sqrt{ \lambda_i }\)</span>,其中<span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(T^* T\)</span>的特征值,当然都是可行的.</p>
<p>接下来要反推出<span class="math inline">\(V ,
W\)</span>的两组单位正交基.任取一组<span class="math inline">\(V\)</span>的特征向量组成的基并从其构造<span class="math inline">\(W\)</span>的基,也就是取<span class="math inline">\(\vec{ w }_i = \frac{ T \vec{ v }_i }{ \sigma_i
}\)</span>(假设<span class="math inline">\(m \geq
n\)</span>的情况下,不然的话反之)并证明这也是一组单位正交基.</p>
<p>此时观察到<span class="math inline">\(( \vec{ w }_i \mid \vec{ w }_j
) = \frac{ 1 }{ \sigma_i \sigma_j } ( T \vec{ v }_i \mid T \vec{ v }_j )
= \frac{ 1 }{ \sigma_i \sigma_j } ( \vec{ v }_i \mid T^* T \vec{ v }_j )
= \frac{ \sigma_j }{ \sigma_i } \delta_{ i , j
}\)</span>,所以这当然也是一组单位正交基.</p>
<h4><span id="moore-penrose-广义逆">Moore-Penrose 广义逆</span></h4>
<p>取域<span class="math inline">\(F\)</span>上的有限维向量空间<span class="math inline">\(V , W\)</span>以及线性映射<span class="math inline">\(T : V \to W\)</span>.其中<span class="math inline">\(T\)</span>未必可逆,但有的时候我们又需要<span class="math inline">\(T\)</span>的逆的性质,我们的目标是去找到一个弱一点的替代品.</p>
<p>我们声明一定存在一个<span class="math inline">\(S : W \to
V\)</span>,满足以下性质:</p>
<ol type="1">
<li><p><span class="math inline">\(TST = T\)</span>.</p></li>
<li><p><span class="math inline">\(STS = S\)</span>.</p></li>
<li><p><span class="math inline">\(TS = ( TS )^*\)</span>.</p></li>
<li><p><span class="math inline">\(ST = ( ST )^*\)</span>.</p></li>
</ol>
<p>容易见到,如果<span class="math inline">\(T\)</span>可逆,它的逆当然是一个MP广义逆.事实上我们可以证明满足上述条件的MP广义逆是唯一的.</p>
<p>先来证明其存在性,<span class="math inline">\(\forall \vec{ v } \in
V\)</span>,做分解<span class="math inline">\(\vec{ v } = \vec{ v } &#39;
+ \vec{ v } &#39; &#39;\)</span>,其中<span class="math inline">\(\vec{ v
} &#39; \in \ker T\)</span>且<span class="math inline">\(\vec{ v } &#39;
&#39; \in ( \ker T )^\bot\)</span>.同样<span class="math inline">\(\forall \vec{ w } \in W\)</span>,做分解<span class="math inline">\(\vec{ w } = \vec{ w } &#39; + \vec{ w } &#39;
&#39;\)</span>,其中<span class="math inline">\(\vec{ w } &#39; \in
\text{ im } T\)</span>.</p>
<p>接下来应当见到,任取<span class="math inline">\(\vec{ v
}\)</span>使得<span class="math inline">\(T \vec{ v } = \vec{ w
}\)</span>,则<span class="math inline">\(T^{ - 1 } ( \vec{ w } &#39; ) =
\vec{ v } + \ker T\)</span>,而<span class="math inline">\(\vec{ v } +
\ker T\)</span>中的每个元素做投影后得到的<span class="math inline">\(\vec{ v } &#39;
&#39;\)</span>都是相同的,于是我们定义<span class="math inline">\(S \vec{
w } = \vec{ v } &#39; &#39;\)</span>.容易验证<span class="math inline">\(S\)</span>是线性映射,而且应当见到<span class="math inline">\(ST\)</span>和<span class="math inline">\(TS\)</span>其实都是正交投影,具体而言,<span class="math inline">\(ST : V \to ( \ker T )^\bot\)</span>而<span class="math inline">\(TS : W \to \text{ im }
T\)</span>,也容易验证上述四条性质.也就是我们想法是,干脆考虑映射<span class="math inline">\(V / \ker T \to \text{ im } \
T\)</span>必然是可逆的,直接在这个上面找逆而不顾其它.</p>
<p>接下来证明其唯一性,假设<span class="math inline">\(T\)</span>有两个MP广义逆<span class="math inline">\(S , R\)</span>,我们注意到:</p>
<p><span class="math display">\[
\begin{aligned}
TS &amp; = ( TS )^* = S^* T^* = S^* ( TRT )^* \\
&amp; = S^* T^* R^* T^* \\
&amp; = ( TS )^* ( TR )^* \\
&amp; = TSTR \\
&amp; = TR
\end{aligned}
\]</span></p>
<p>同理可证明<span class="math inline">\(ST = RT\)</span>,因此<span class="math inline">\(S = STS = STR = RTR =
R\)</span>,这就给出了唯一性的证明.</p>
<p>那么如何求出一个MP广义逆呢?考虑对于一个线性映射<span class="math inline">\(T : V \to
W\)</span>,将其视为标准基下的矩阵,做奇异值分解有<span class="math inline">\(T = Q \Sigma P^{ - 1 }\)</span>.</p>
<p>容易见到满足条件的MP逆<span class="math inline">\(S\)</span>应当满足<span class="math inline">\(S
\vec{ w }_j = \frac{ 1 }{ \sigma_j } \vec{ v
}_j\)</span>,而写作矩阵形式的话就是<span class="math inline">\(P \Pi Q^{
- 1 }\)</span>,其中<span class="math inline">\(\Pi\)</span>就是<span class="math inline">\(\Sigma\)</span>的非零对角线全部取倒数.验证此事实的策略,要么取检验MP广义逆的定义,要么取一组基并观察投影,但总之都是容易的.</p>
<p>如果想要进一步说明MP广义逆的合理性,不妨考虑设<span class="math inline">\(C ( t ) = T^* T + t \cdot \mathrm{ { id }
}_V\)</span>,我们证明MP广义逆实际上就是<span class="math inline">\(S =
\lim_{ t \to 0 , \det C ( t ) \ne 0 } C ( t )^{ - 1 }
T^*\)</span>,证明无非也只是使用奇异值分解,考虑<span class="math inline">\(T = Q \Sigma P^{ - 1 } , T^* = P \Sigma Q^{ - 1
}\)</span>,那么<span class="math inline">\(C ( t ) = P ( \Sigma^2 + tI )
P^{ - 1 }\)</span>,容易检验其满足性质.</p>
<h4><span id="极大化极小原理courant-fischer定理">极大化极小原理(Courant-Fischer定理)</span></h4>
<p>对于实空间<span class="math inline">\(V\)</span>,考察其标准内积<span class="math inline">\(( \_ \mid \_ )\)</span>和任一对称双线性形式<span class="math inline">\(B : V \times V \to \mathbb{ R
}\)</span>.当然存在唯一的<span class="math inline">\(S \in \text{ End }
( V )\)</span>使得<span class="math inline">\(B ( \vec{ v }_1 , \vec{ v
}_2 ) = ( \vec{ v }_1 \mid S \vec{ v }_2 )\)</span>恒成立,无非是把<span class="math inline">\(B\)</span>所代表的矩阵拿过来而已.</p>
<p>此时应有<span class="math inline">\(S =
S^*\)</span>,对其施加正交对角化拿到单位正交基<span class="math inline">\(\vec{ v }_1 , \cdots , \vec{ v
}_n\)</span>和对应的一列特征值<span class="math inline">\(\lambda_1 \geq
\cdots \geq \lambda_n\)</span>.对于单位球面上的向量<span class="math inline">\(\vec{ v }\)</span>,其应当满足<span class="math inline">\(| \vec{ v } | = 1\)</span>,此时我们注意到<span class="math inline">\(\lambda_1 = \max_{ | \vec{ v } | = 1 } B ( \vec{ v
} , \vec{ v } ) , \lambda_n = \min_{ | \vec{ v } | = 1 } B ( \vec{ v } ,
\vec{ v } )\)</span>.原因只是取<span class="math inline">\(\vec{ v } =
\sum a_k \vec{ v }_k\)</span>,然后<span class="math inline">\(B ( \vec{
v } , \vec{ v } ) = \sum_k a_k^2
\lambda_k\)</span>.上述当然成立.确定除此以外的其他特征值需要更精确地刻画,我们引入如下定理:</p>
$$
<span class="math display">\[\begin{aligned}
\lambda_k &amp; = \min_{ U \subseteq V , \dim U = n - k + 1 } \left (
\max_{ \vec{ v } \in U , | \vec{ v } | = 1 } B ( \vec{ v } , \vec{ v } )
\right ) \\
\lambda_k &amp; = \max_{ U \subseteq V , \dim U = k } \left ( \min_{
\vec{ v } \in U , | \vec{ v } | = 1 } B ( \vec{ v } , \vec{ v } ) \right
) \\

\end{aligned}\]</span>
<p>$$</p>
<p>将<span class="math inline">\(S\)</span>用<span class="math inline">\(-
S\)</span>替换,则降序的特征值序列要翻转,立刻见到上述两条等价.下面只证明第一条.</p>
<p>取<span class="math inline">\(W_k = \langle \vec{ v }_1 , \cdots ,
\vec{ v }_k \rangle\)</span>.应当见到:</p>
<p><span class="math display">\[
\begin{aligned}
\dim U \cap W_k &amp; = \dim U + k - \dim ( U + W_k ) \\
&amp; \geq \dim U + k - n = 1
\end{aligned}
\]</span></p>
<p>这意味着这两个空间的交非零空间,取出一个交集元素<span class="math inline">\(\vec{ v } = \sum_{ i = 1 }^k a_i \vec{ v }_i \in
U\)</span>且满足<span class="math inline">\(| \vec{ v } | =
1\)</span>.应当见到<span class="math inline">\(B ( \vec{ v } , \vec{ v }
) = \sum_k \lambda_k a_k^2 \geq \lambda_k\)</span>.这就意味着<span class="math inline">\(\max_{ \vec{ v } \in U , | \vec{ v } | = 1 } B (
\vec{ v } , \vec{ v } ) \geq \lambda_k\)</span>.或言之<span class="math inline">\(\inf \max_{ \vec{ v } \in U , | \vec{ v } | = 1 }
B ( \vec{ v } , \vec{ v } ) \geq
\lambda_k\)</span>.证明下界可取到只需取<span class="math inline">\(U =
\langle \vec{ v }_k , \cdots , \vec{ v }_n
\rangle\)</span>即可取到(证明取到的策略呢,可以直接看基立刻得到,也可以采取更加严谨好说的方式即前后分别表示一下发现其既满足<span class="math inline">\(\geq \lambda_k\)</span>又要<span class="math inline">\(\leq \lambda_k\)</span>).</p>
<p>这个定理也可以用来求奇异值,半正定条件下,奇异值无非是特征值开根后的结果.</p>
<p>这个原理的重要意义是将奇异值,特征值这些东西全部挪到了空间本身的性质上(类似惯性定理).于是从此只要我们能拿到空间的同构当然就能断言奇异值,特征值全都同构,这是无可置疑的.</p>
<p>应当能看出这个定理更多有一种拓扑性质,事实上的确如此,如果能取最大值的话,这实际上对应了某种李氏连续性质.</p>
<h4><span id="perron-frobenius定理">Perron-Frobenius定理</span></h4>
<p>约定<span class="math inline">\(A \geq
B\)</span>表示对于每一个位置<span class="math inline">\(a_{ i , j } \geq
b_{ i , j }\)</span>.于是约定<span class="math inline">\(A \geq
0\)</span>意味着<span class="math inline">\(A\)</span>中的任意元素都<span class="math inline">\(\geq 0\)</span>.</p>
<p>容易见到以下平凡引理:</p>
<ol type="1">
<li><p><span class="math inline">\(A &gt; 0 , x \geq 0 , x \ne 0
\Rightarrow Ax &gt; 0\)</span>.</p></li>
<li><p><span class="math inline">\(A \geq 0 , x \geq 0 \Rightarrow Ax
\geq 0\)</span>.</p></li>
</ol>
<p>定义实矩阵<span class="math inline">\(A\)</span>的<strong>谱半径</strong>为<span class="math inline">\(\rho ( A ) = \max{ | \lambda |
}\)</span>,也就是所有复特征值模长的极大值.</p>
<p>虽然这里用到了复特征值,但意义仅是使得多项式可裂,而矩阵仍然是实数域的.因此仍然认为该定理是实内积空间里的定理.</p>
<h5><span id="collatz-wielandt公式">Collatz-Wielandt公式</span></h5>
<p>对于实矩阵<span class="math inline">\(A &gt; 0\)</span>,我们考虑<span class="math inline">\(S = \{ \vec{ x } \in \mathbb{ R }^n \mid | \vec{ x
} | = 1 , \vec{ x } \geq 0
\}\)</span>,容易见到这是个紧集,考虑定义在其上的映射<span class="math inline">\(L : S \to \mathbb{ R_{ + } } , \vec{ x } \mapsto
\min \left ( \cfrac{ ( A \vec{ x } )_i }{ x_i } , x_i \ne 0 \right
)\)</span>.于是命<span class="math inline">\(\rho \in \mathbb{ R_+
}\)</span>为上述映射像中的极大值,我们下面证明两个事情:首先是这个<span class="math inline">\(\rho\)</span>是<span class="math inline">\(A\)</span>的一个特征值,其次是这个<span class="math inline">\(\rho\)</span>就是<span class="math inline">\(A\)</span>的谱半径.</p>
<p>首先证明其是一个特征值,而且对应的特征向量大于零,也就是<span class="math inline">\(\exists \vec{ v } &gt; 0 , A \vec{ v } = \rho
\vec{ v }\)</span>.容易由定义见到<span class="math inline">\(\exists
\vec{ v } , A \vec{ v } \geq \rho \vec{ v }\)</span>.假若<span class="math inline">\(A \vec{ v } \ne \rho \vec{ v
}\)</span>,则上述的平凡引理使得<span class="math inline">\(A ( A \vec{ v
} - \rho \vec{ v } ) &gt;
0\)</span>.这里我们就应当会思考一个事情是,能否进行微调来使得得到更大的<span class="math inline">\(\rho\)</span>从而导出矛盾.因此这里的思路应当是,取一个<span class="math inline">\(\epsilon\)</span>然后找到一个向量<span class="math inline">\(\vec{ w }\)</span>,使得<span class="math inline">\(A \vec{ w } &gt; ( \rho + \epsilon ) \vec{ w
}\)</span>从而导出矛盾.</p>
<p>回到我们拿到的条件,应该存在<span class="math inline">\(\epsilon &gt;
0\)</span>使得<span class="math inline">\(A ( A \vec{ v } - \rho \vec{ v
} ) &gt; \epsilon A \vec{ v }\)</span>,留意到由于平凡引理,应当<span class="math inline">\(A \vec{ v } &gt; 0\)</span>,取适当的<span class="math inline">\(t\)</span>来归一化,定义出<span class="math inline">\(\vec{ w } = tA \vec{ v } \in
S\)</span>,从而上式导出:</p>
<p><span class="math display">\[
\begin{aligned}
A ( A \vec{ v } ) &amp; &gt; ( \rho + \epsilon ) A \vec{ v } \\
A \vec{ w } &amp; &gt; ( \rho + \epsilon ) \vec{ w }
\end{aligned}
\]</span></p>
<p>立即导出矛盾.因此必有<span class="math inline">\(A \vec{ v } = \rho
\vec{ v }\)</span>.此外,引理告诉我们<span class="math inline">\(A \vec{
v } &gt; 0\)</span>恒成立,则<span class="math inline">\(\vec{ v } =
\rho^{ - 1 } A \vec{ v } &gt; 0\)</span>亦然成立.</p>
<p>接下来证明这个<span class="math inline">\(\rho\)</span>就是谱半径<span class="math inline">\(\rho ( A )\)</span>.由定义见到<span class="math inline">\(\rho\)</span>作为特征值应当满足<span class="math inline">\(\rho \leq \rho ( A )\)</span>,接下来只需证明<span class="math inline">\(\rho \geq \rho ( A )\)</span>即可.</p>
<p>对于所有的特征值<span class="math inline">\(\mu\)</span>和相应的特征向量<span class="math inline">\(\vec{ w } \ne 0\)</span>满足<span class="math inline">\(A \vec{ w } = \mu \vec{ w
}\)</span>,使用三角不等式,<span class="math inline">\(\forall 1 \leq i
\leq n\)</span>应当有:</p>
<p><span class="math display">\[
\begin{aligned}
| \mu | | w_i | &amp; = | ( A \vec{ w } )_i | \\
&amp; = | \sum_j a_{ i , j } w_j | \leq \sum_j a_{ i , j } | w_j |
\end{aligned}
\]</span></p>
<p>将<span class="math inline">\(\vec{ w } &#39; = ( | w_1 | , \cdots ,
| w_n | ) \in \mathbb{ R
}^n\)</span>,也就是将复向量强行转到实向量上,上式立刻给出<span class="math inline">\(A \vec{ w } &#39; \geq | \mu | \vec{ w }
&#39;\)</span>.伸缩该向量使得<span class="math inline">\(| \vec{ w }
&#39; | = 1\)</span>,于是上式给出<span class="math inline">\(\rho \geq L
( \vec{ w } &#39; ) \geq | \mu |\)</span>,这就给出了<span class="math inline">\(\rho ( A ) \leq \rho\)</span>.于是证毕.</p>
<h5><span id="perron定理">Perron定理</span></h5>
<p>对于实矩阵<span class="math inline">\(A &gt;
0\)</span>,我们接下来声明如下定理:</p>
<ol type="1">
<li><p><span class="math inline">\(\rho ( A ) &gt; 0\)</span>,<span class="math inline">\(\exists \vec{ v } \in \mathbb{ R }^n , \vec{ v }
&gt; 0 , A \vec{ v } = \rho ( A ) \vec{ v
}\)</span>.也即:谱半径的确是一个特征值.</p></li>
<li><p>如果<span class="math inline">\(\lambda \ne \rho ( A
)\)</span>,则<span class="math inline">\(| \lambda | &lt; \rho ( A
)\)</span>.也就是:谱半径只此实特征值能达到.</p></li>
<li><p>谱半径的代数重数和几何重数均为<span class="math inline">\(1\)</span>.</p></li>
</ol>
<p>(1)也就是Collatz-Wielandt公式.</p>
<p>(2)的话考虑对Collatz-Wielandt公式作一些补充.假使复特征值<span class="math inline">\(\mu\)</span>满足<span class="math inline">\(| \mu
| = \rho ( A )\)</span>,则不等式链<span class="math inline">\(\rho ( A )
= \max L ( \vec{ v } ) \geq L ( \vec{ w } &#39; ) \geq | \mu | = \rho (
A )\)</span>必然全部三角不等式取等,中间的每一项<span class="math inline">\(w_j\)</span>都必然落在复平面的同一条直线上,那就可以除去一个复数得到实向量<span class="math inline">\(\vec{ w } &#39; &#39;\)</span>亦然满足<span class="math inline">\(A \vec{ w } &#39; &#39; = \mu \vec{ w } &#39;
&#39;\)</span>,由于该式子中除了<span class="math inline">\(\mu\)</span>均为实数,因此<span class="math inline">\(\mu\)</span>也必然是实数.而且<span class="math inline">\(\mu\)</span>当然不可能是负数,这样就完成了(2)的证明.</p>
<p>(3)的话先考虑证明几何重数<span class="math inline">\(\dim V_{ \rho (
A ) } = 1\)</span>,考虑<span class="math inline">\(\vec{ v } , \vec{ v }
&#39;\)</span>都是<span class="math inline">\(\rho ( A
)\)</span>的特征向量,其中<span class="math inline">\(\vec{ v
}\)</span>由于上述讨论而满足<span class="math inline">\(\vec{ v } &gt;
0\)</span>,而<span class="math inline">\(\vec{ v }
&#39;\)</span>至少有一个分量为正数.既然如此,应当可以取足够小的<span class="math inline">\(\epsilon &gt; 0\)</span>使得<span class="math inline">\(\vec{ v } - \epsilon \vec{ v } &#39; \geq
0\)</span>,以至于可以取其中尽可能大的<span class="math inline">\(\epsilon\)</span>使得<span class="math inline">\(\vec{ v } - \epsilon \vec{ v }
&#39;\)</span>的某一个分量恰好为<span class="math inline">\(0\)</span>.我们接下来声明此时<span class="math inline">\(\vec{ v } - \epsilon \vec{ v } &#39; =
0\)</span>以说明<span class="math inline">\(\vec{ v }
&#39;\)</span>和<span class="math inline">\(\vec{ v
}\)</span>线性相关</p>
<p>为说明此进行反证,假设<span class="math inline">\(\vec{ v } - \epsilon
\vec{ v } &#39; \ne 0\)</span>,用平凡引理,考虑<span class="math inline">\(\vec{ v } - \epsilon \vec{ v } &#39; = \frac{ 1 }{
\rho ( A ) } A ( \vec{ v } - \epsilon \vec{ v } &#39; ) &gt;
0\)</span>,然而我们已经说明其有一个分量为<span class="math inline">\(0\)</span>,导出矛盾.</p>
<p>接下来考虑(3)的完全版本,利用<span class="math inline">\(\dim V_{ \rho
( A ) } =
1\)</span>,如果我们能将整个空间拆成两部分不变子空间,其中一部分是<span class="math inline">\(\langle \vec{ v }
\rangle\)</span>,那就可以完成上面的部分,原因是此时另一部分不变子空间中不能有<span class="math inline">\(\rho ( A )\)</span>作为根,否则与其维数为<span class="math inline">\(1\)</span>矛盾.另一方面,原本的特征多项式就是两个不变子空间的特征多项式的乘积,这就证明了单根的性质.</p>
<p>于此,考虑以下操作:考虑<span class="math inline">\(\text{ char } ( A )
= \text{ char } ( A^T )\)</span>,于是<span class="math inline">\(\rho (
A ) = \rho ( A^T )\)</span>,这就意味着<span class="math inline">\(\exists \vec{ u } &gt; 0\)</span>使得<span class="math inline">\(( A^T ) \vec{ u } = \rho ( A ) \vec{ u
}\)</span>.取出它的正交补空间<span class="math inline">\(\langle \vec{ u
} \rangle^\bot\)</span>,它应当是<span class="math inline">\(A\)</span>的不变子空间,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
( \vec{ u } )^T ( A \vec{ x } ) &amp; = ( A^T \vec{ u } )^T \vec{ x } \\
&amp; = \rho ( A ) ( \vec{ u } )^T \vec{ x } = 0
\end{aligned}
\]</span></p>
<p>同时注意到<span class="math inline">\(\vec{ v } &gt; 0 , \vec{ u }
&gt; 0\)</span>,所以<span class="math inline">\(\vec{ v } \notin \langle
\vec{ u } \rangle^\bot\)</span>,这就完成了直和分解,于是上述命题证毕.</p>
<h4><span id="实正交变换的标准型">实正交变换的标准型</span></h4>
<p>(ps:虽然这里放在实内积空间里,然而大部分性质实际上是转移自复内积空间的结构,应当先看下面的章节,回头再来观察此节.)</p>
<p>回忆到取定<span class="math inline">\(V\)</span>是实线性空间,并取上面的某种内积形式,对于<span class="math inline">\(T \in \text{ End } ( V )\)</span>,若其满足<span class="math inline">\(T^* = T^{ - 1
}\)</span>,则它是实正交变换.特别地,当取标准内积的时候,所对应的就是正交矩阵,则<span class="math inline">\(A^t = A^{ - 1 }\)</span>.</p>
<p>回忆到此时<span class="math inline">\(\det A = \pm 1\)</span>.</p>
<p>将正规算子的概念从复数域里面拿到实数域,即满足<span class="math inline">\(( A^t ) A = A ( A^t
)\)</span>.我们在下面做复数酉变换的时候证明过引理:<span class="math inline">\(\exists k \geq 0 , T^k = 0 \Rightarrow T =
0\)</span>.容易见到正交算子一定是正规的.</p>
<p>接下来来观察不同维度的正交变换,假设<span class="math inline">\(\dim_{
\mathbb{ R } } V = n\)</span>.</p>
<p>当<span class="math inline">\(n =
1\)</span>的时候,正交变换显然是长度为<span class="math inline">\(\pm
1\)</span>的伸缩变换,也就是<span class="math inline">\(\pm \text{ id
}_V\)</span>.</p>
<p>当<span class="math inline">\(n = 2\)</span>的时候,不妨设矩阵为<span class="math inline">\(\begin{bmatrix}\alpha &amp; \beta \\ \gamma &amp;
\delta\end{bmatrix}\)</span>,用正交性质就知道:</p>
<p><span class="math display">\[
\begin{cases}
\alpha^2 + \gamma^2 = 1 \\
\beta^2 + \delta^2 = 1 \\
\alpha^2 + \beta^2 = 1 \\
\gamma^2 + \delta^2 = 1
\end{cases}
\]</span></p>
<p>做三角换元后考虑到行列式为<span class="math inline">\(\pm
1\)</span>,在一些简单的确定后,立刻见到原矩阵要么是:<span class="math inline">\(\begin{bmatrix}\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta\end{bmatrix}\)</span>,要么是<span class="math inline">\(\begin{bmatrix}\cos \theta &amp; \sin \theta \\
\sin \theta &amp; - \cos
\theta\end{bmatrix}\)</span>,它们的行列式分别为<span class="math inline">\(\pm 1\)</span>.</p>
<p>拿出行列式恰好为<span class="math inline">\(+ 1\)</span>的前者:</p>
<p><span class="math display">\[
R ( \theta ) = \begin{bmatrix}
\cos \theta &amp; - \sin \theta \\
\sin \theta &amp; \cos \theta
\end{bmatrix}
\]</span></p>
<p>也就是通常所说的旋转矩阵.容易见到:</p>
<ol type="1">
<li><p><span class="math inline">\(R ( \theta ) R ( \psi ) = R ( \theta
+ \psi ) = R ( \psi ) R ( \theta )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(P\)</span>是一个正交算子,则<span class="math inline">\(P^{ - 1 } R ( \theta ) P = R ( ( \det P ) \theta
)\)</span>.</p></li>
</ol>
<p>(1)只需对<span class="math inline">\(\vec{ e }\)</span>验证即可.</p>
<p>(2)的话,当<span class="math inline">\(\det P =
1\)</span>的时候,当然有<span class="math inline">\(P = R ( \psi ) , P^{
- 1 } = R ( - \psi )\)</span>,那显然成立了;当<span class="math inline">\(\det P = - 1\)</span>的时候,只需在外面补一个<span class="math inline">\(\begin{bmatrix}1 &amp; 0 \\ 0 &amp; -
1\end{bmatrix}\)</span>即可转化.</p>
<p>于此之前,考虑如果<span class="math inline">\(T\)</span>是正交变换,它当然一定是正规的,那么它在复数上可正交对角化,特征值当然满足<span class="math inline">\(| \lambda | = 1\)</span>,那么当然<span class="math inline">\(T + T^{ - 1
}\)</span>自伴.而且它俩可以同步对角化,那<span class="math inline">\(T +
T^{ - 1 }\)</span>的特征值当然是<span class="math inline">\(| \mu | = |
\lambda + \lambda^{ - 1 } | \leq | \lambda | + | \lambda^{ - 1 } | =
2\)</span>.</p>
<p>接下来考虑一般的情况,我们声明,对于任意正交变换,都可以取基转化为下述形式:</p>
<p><span class="math display">\[
\begin{bmatrix}
I_{ a \times a } &amp; &amp; &amp; \\
&amp; - I_{ b \times b } &amp; &amp; &amp; \\
&amp; &amp; R ( \theta_1 ) &amp; &amp; \\
&amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; &amp; &amp; R ( \theta_k )
\end{bmatrix}
\]</span></p>
<p>其中<span class="math inline">\(\theta_1 , \cdots ,
\theta_k\)</span>都并非<span class="math inline">\(\pi\)</span>的整数倍.</p>
<p>证明考虑令<span class="math inline">\(S = T^{ - 1 } +
T\)</span>,容易见到其自伴,那原空间就可以拆成<span class="math inline">\(S\)</span>的若干特征子空间的直和,容易发现<span class="math inline">\(ST = TS\)</span>,这必然意味着<span class="math inline">\(V_\lambda\)</span>是<span class="math inline">\(T\)</span>不变的,于是下面可以只着眼于一个特征子空间,观测<span class="math inline">\(V = V_\lambda\)</span>的情形,且<span class="math inline">\(\lambda \in \mathbb{ R } , | \lambda | \leq
2\)</span>.</p>
<p>则此时观察此空间,应当有<span class="math inline">\(T + T^{ - 1 } =
\lambda I_V\)</span>.两边乘以<span class="math inline">\(T\)</span>,得到<span class="math inline">\(T^2 -
\lambda T + I = 0\)</span>.</p>
<p>下面我们开始讨论,当<span class="math inline">\(\lambda = \pm
2\)</span>的时候,则上述配方得到<span class="math inline">\(( T \mp I )^2
= 0\)</span>,由于<span class="math inline">\(T \mp
I\)</span>是正规算子,于是<span class="math inline">\(T \mp I =
0\)</span>,这就对应了上述矩阵中的<span class="math inline">\(\pm
1\)</span>的分块.</p>
<p>那如果<span class="math inline">\(\lambda \ne \pm
2\)</span>呢,那就必然有<span class="math inline">\(| \lambda | &lt;
2\)</span>,则<span class="math inline">\(x^2 - \lambda x +
1\)</span>无实根,不可约,但带入<span class="math inline">\(x =
T\)</span>会得到<span class="math inline">\(0\)</span>,因此它必然是<span class="math inline">\(T\)</span>在此空间下的极小多项式.又因为<span class="math inline">\(T\)</span>如果有实特征值,必然是<span class="math inline">\(\pm 1\)</span>,则此时<span class="math inline">\(\lambda = \pm 2\)</span>.因此,<span class="math inline">\(T\)</span>没有实特征值.既然如此,任取一个向量<span class="math inline">\(\vec{ v } \ne 0\)</span>,<span class="math inline">\(\vec{ v }\)</span>与<span class="math inline">\(T
\vec{ v }\)</span>必然线性无关.</p>
<p>既然如此,使他们张成子空间<span class="math inline">\(W = \langle
\vec{ v } , T \vec{ v } \rangle\)</span>并作直和分解<span class="math inline">\(V = W \oplus W^\bot\)</span>.由于<span class="math inline">\(T^2 = \lambda T - I\)</span>,因此注意到<span class="math inline">\(W\)</span>应当是<span class="math inline">\(T\)</span>不变的.那么,<span class="math inline">\(W^\bot\)</span>在<span class="math inline">\(T^* =
T^{ - 1 }\)</span>作用下当然也是不变的.然而,<span class="math inline">\(T = \lambda I - T^{ - 1 }\)</span>,所以<span class="math inline">\(T\)</span>是关于<span class="math inline">\(T^{ -
1 }\)</span>的多项式,于是<span class="math inline">\(W^\bot\)</span>在<span class="math inline">\(T\)</span>下也是不变的.这样,我们完全把空间归纳下去了,每次都可以扔出去一个<span class="math inline">\(\dim = 2\)</span>的空间.于是最后一步是检验<span class="math inline">\(T\)</span>在归纳下去的空间上的性质.对于<span class="math inline">\(\dim = 2\)</span>的空间,<span class="math inline">\(x^2 - \lambda x +
1\)</span>当然仍然不可约,而它必然就是特征多项式,那<span class="math inline">\(\det = 1\)</span>就自然成立.</p>
<p>最后应当简单解释上述形式是否由<span class="math inline">\(T\)</span>唯一确定.然而应属显然了,因为每一次拆出的特征多项式当然都是原本特征多项式的一个不可约因子.</p>
<h5><span id="欧拉角">欧拉角</span></h5>
<p>考虑三维空间中的旋转,我们通过上述对实正交矩阵的分类得知,三维空间中的旋转立刻统合为<span class="math inline">\(\begin{bmatrix}1 &amp; \\ &amp; R ( \theta
)\end{bmatrix}\)</span>.</p>
<p>那么就需要两个参数来描述此,旋转轴<span class="math inline">\(\vec{ u
} = \vec{ v }_1\)</span>的坐标用以描述转轴以及一个参数<span class="math inline">\(\theta\)</span>用来描述转角.不妨将这种旋转记作<span class="math inline">\(R_{ u } ( \theta
)\)</span>.然而于此之外,先要论证此旋转和另外两个单位正交基<span class="math inline">\(\vec{ v }_2 , \vec{ v
}_3\)</span>无关.然而容易见到不管如何选取这两个基,它们都会同样张成<span class="math inline">\(\langle \vec{ u }
\rangle^\bot\)</span>,因此它们都在同一个空间里,而且只差一个旋转.这个旋转前后当然可以抵消,这也是直觉所告知我们的.</p>
<p>由此就可以看到三维空间的及其好的性质,我们一般称呼二维空间中的旋转,它的转轴实际上是垂直于此平面的一个更高维的轴.而三维空间中的转轴一定落在三维空间中,不需要再到高维空间中找到转轴了.</p>
<p>综上,旋转总是将一个有序单位正交基转化为另一个有序单位正交基,三维空间中表现为<span class="math inline">\(( \vec{ e }_1 , \vec{ e }_2 , \vec{ e }_3 ) \to (
\vec{ u }_1 , \vec{ u }_2 , \vec{ u }_3 )\)</span>.</p>
<p>对于指定基的旋转,我们应当通过一定的交换基的操作见到:</p>
$$
<span class="math display">\[\begin{aligned}
R_{ e_1 } ( \theta ) &amp; = \begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \theta &amp; - \sin \theta \\
&amp; \sin \theta &amp; \cos \theta
\end{bmatrix} \\
R_{ e_2 } ( \theta ) &amp; = \begin{bmatrix}
\cos \theta &amp; &amp; \sin \theta \\
&amp; 1 &amp; \\
- \sin \theta &amp; &amp; \cos \theta
\end{bmatrix} \\
R_{ e_3 } ( \theta ) &amp; = \begin{bmatrix}
\cos \theta &amp; - \sin \theta &amp; \\
\sin \theta &amp; \cos \theta &amp; \\
&amp; &amp; 1
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
<p>为了表示使得任意基下的旋转,我们考虑先转好一个轴,然后再以此轴作旋转.那我们考虑构造一个<span class="math inline">\(\vec{ f }_2 = \begin{cases}\vec{ e }_2 &amp; \vec{
e }_3 / / \vec{ u }_3 \\ \vec{ e }_3 \times \vec{ u }_3 &amp;
otherwisse\end{cases}\)</span>.</p>
<p>换言之,此时我们选了一个轴<span class="math inline">\(\vec{ f
}_2\)</span>,它与<span class="math inline">\(\vec{ u }_3 , \vec{ e
}_3\)</span>均正交,那我们就可以这么转:</p>
<ol type="1">
<li><p>将<span class="math inline">\(( \vec{ e }_1 , \vec{ e }_2 , \vec{
e }_3 )\)</span>绕<span class="math inline">\(\vec{ e
}_3\)</span>转到<span class="math inline">\(( \vec{ f }_1 , \vec{ f }_2
, \vec{ e }_3 )\)</span>.</p></li>
<li><p>将<span class="math inline">\(( \vec{ f }_1 , \vec{ f }_2 , \vec{
e }_3 )\)</span>绕<span class="math inline">\(\vec{ f
}_2\)</span>转到<span class="math inline">\(( \vec{ g }_1 , \vec{ f }_2
, \vec{ u }_3 )\)</span>.</p></li>
<li><p>将<span class="math inline">\(( \vec{ g }_1 , \vec{ f }_2 , \vec{
u }_3 )\)</span>绕<span class="math inline">\(\vec{ u
}_3\)</span>转到<span class="math inline">\(( \vec{ u }_1 , \vec{ u }_2
, \vec{ u }_3 )\)</span>.</p></li>
</ol>
<p>综上,一个旋转矩阵总可以写成三个矩阵<span class="math inline">\(R_{
u_2 } ( \varphi ) R_{ f_2 } ( \theta ) R_{ e_3 } ( \psi
)\)</span>的乘积,我们称<span class="math inline">\(T\)</span>是由<strong>欧拉角</strong><span class="math inline">\(( \varphi , \theta , \psi )\)</span>所确定的.</p>
<p>不过,上述的转轴并非我们选定的有序正交基<span class="math inline">\((
\vec{ e }_1 , \vec{ e }_2 , \vec{ e }_3
)\)</span>,换言之,转轴不是以观察者视角的,而是以被旋转物体本身的视角而言的.可既然要转为矩阵表述,我们应当搞一个观察者版本的矩阵.这就要求转轴被控制为<span class="math inline">\(( \vec{ e }_1 , \vec{ e }_2 , \vec{ e }_3
)\)</span>.我们下面尝试证明<span class="math inline">\(R_{ u_2 } (
\varphi ) R_{ f_2 } ( \theta ) R_{ e_3 } ( \psi ) = R_{ e_3 } ( \psi )
R_{ e_2 } ( \theta ) R_{ e_3 } ( \varphi )\)</span>.</p>
<p>对于正交变换<span class="math inline">\(P\)</span>,并设<span class="math inline">\(\epsilon = \det P = \pm 1\)</span>,应当有<span class="math inline">\(R_{ Pu } ( \epsilon \theta ) = PR_u ( \theta ) P^{
- 1 }\)</span>.其实到这里只有这个<span class="math inline">\(\epsilon\)</span>的用法并非显然,但总之,用代数的语言可以看出<span class="math inline">\(P\)</span>将<span class="math inline">\(( \vec{ u
} , \vec{ v } , \vec{ w } ) \mapsto ( P \vec{ u } , P \vec{ v } , P
\vec{ w }
)\)</span>,这当然仍是一组有序正交基.但为了使其的方向为正,可以改为<span class="math inline">\(( P \vec{ u } , P \vec{ v } , \epsilon P \vec{ w }
)\)</span>以避免讨论,然后去检验<span class="math inline">\(PR_u ( \theta
)\)</span>和<span class="math inline">\(R_{ Pu } ( \epsilon \theta )
P\)</span>对基<span class="math inline">\(( \vec{ u } , \vec{ v } ,
\vec{ w } )\)</span>的作用.总之容易验证.</p>
<p>既然如此,考虑<span class="math inline">\(\vec{ f }_2 = R_{ e_3 } (
\psi ) \vec{ e }_2\)</span>,既然如此,<span class="math inline">\(R_{ f_2
} ( \theta ) = R_{ e_3 } ( \psi ) R_{ e_2 } ( \theta ) R_{ e_3 } ( \psi
)^{ - 1 }\)</span>.</p>
<p>同理,<span class="math inline">\(\vec{ u }_3 = R_{ f_2 } ( \theta )
\vec{ e }_3 = R_{ f_2 } ( \theta ) R_{ e_3 } ( \psi ) \vec{ e
}_3\)</span>,既然如此,得到<span class="math inline">\(R_{ u_3 } (
\varphi ) = R_{ e_3 } ( \psi ) R_{ e_2 } ( \theta ) R_{ e_3 } ( \varphi
) R_{ e_2 } ( \theta )^{ - 1 } R_{ e_3 } ( \psi )^{ - 1
}\)</span>.这就证明了上述结论.</p>
<p>更具体地说,它表为:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \psi &amp; - \sin \psi \\
&amp; \sin \psi &amp; \cos \psi
\end{bmatrix} \begin{bmatrix}
\cos \theta &amp; &amp; \sin \theta \\
&amp; 1 &amp; \\
- \sin \theta &amp; &amp; \cos \theta
\end{bmatrix} \begin{bmatrix}
1 &amp; &amp; \\
&amp; \cos \varphi &amp; - \sin \varphi \\
&amp; \sin \varphi &amp; \cos \varphi
\end{bmatrix}
\]</span></p>
<h5><span id="四元数">四元数</span></h5>
<p>试图搞一个以<span class="math inline">\(\mathbb{ R } \subsetneq
\mathbb{ C } \subsetneq \mathbb{ H }\)</span>的东西.其中<span class="math inline">\(\mathbb{ H
}\)</span>是一个除环,也就是在域的基础上丢掉了交换律.</p>
<p>具体如何构造呢?考虑在实线性空间的基础上引入乘法,那就先要构造它的一组基<span class="math inline">\(\{ 1 , i , j , k
\}\)</span>.现在就只需要定义乘法,当然是<span class="math inline">\(\mathbb{ H } \times \mathbb{ H } \to \mathbb{ H }
, ( x , y ) \mapsto x \cdot y\)</span>,并且要求它对于<span class="math inline">\(\mathbb{ R
}\)</span>是双线性的.同时要求以下规则:</p>
<ol type="1">
<li><p><span class="math inline">\(1 \cdot x = x\)</span>.</p></li>
<li><p><span class="math inline">\(i^2 = j^2 = k^2 = -
1\)</span>.</p></li>
<li><p><span class="math inline">\(ij = k = - ji\)</span>.</p></li>
<li><p><span class="math inline">\(jk = i = - kj\)</span>.</p></li>
<li><p><span class="math inline">\(ki = j = - ik\)</span>.</p></li>
</ol>
<p>那么双线性性质和上述约定当然搞定了一个乘法映射.为说明其是环,还应当验证以下性质:</p>
<ol type="1">
<li><p>分配律.由双线性形式显然.</p></li>
<li><p>结合律.只需验证上述四个元素<span class="math inline">\(1 , i , j
, k\)</span>的结合律即可.</p></li>
</ol>
<p>这就搞定了环的性质.可以看到<span class="math inline">\(\mathbb{ H
}\)</span>可以看作<span class="math inline">\(\mathbb{ R
}\)</span>或者<span class="math inline">\(\mathbb{ C
}\)</span>上的向量空间,对于前者是因为<span class="math inline">\(q = a +
bi + cj + dk\)</span>,对于后者是因为任何一个<span class="math inline">\(q\)</span>都可以写作<span class="math inline">\(q
= z + jw\)</span>,其中<span class="math inline">\(z , w \in \mathbb{ C
}\)</span>的形式,这里顺便一提此表述下<span class="math inline">\(jw =
\bar{ w } j\)</span>.这当然顺便也搞定了除环的性质.</p>
<p>回忆到环的中心<span class="math inline">\(Z ( \mathbb{ H } ) = \{ z
\in \mathbb{ H } \mid \forall q \in \mathbb{ H } , zq = qz
\}\)</span>.我们声称<span class="math inline">\(Z ( \mathbb{ H } ) =
\mathbb{ R }\)</span>.由于<span class="math inline">\(\mathbb{ H
}\)</span>的特殊性,我们知道只需要对<span class="math inline">\(\{ 1 , i
, j , k \}\)</span>检查交换性即可,会发现只有<span class="math inline">\(\mathbb{ R }\)</span>是合理的.</p>
<p>定义一个四元数<span class="math inline">\(q = a + bi + cj +
dk\)</span>的<strong>共轭</strong><span class="math inline">\(\bar{ q }
= a - bi - cj - dk\)</span>,定义其<strong>迹</strong><span class="math inline">\(\mathrm{ { Tr } } ( q ) = q + \bar{ q } = 2
a\)</span>,再定义其<strong>范数</strong><span class="math inline">\(N (
q ) = q \bar{ q }\)</span>.有以下性质:</p>
<ol type="1">
<li><p>共轭对<span class="math inline">\(\mathbb{ R
}\)</span>是线性映射.</p></li>
<li><p><span class="math inline">\(\overline{ ( \bar{ q } ) } =
q\)</span>.</p></li>
<li><p><span class="math inline">\(\overline{ q_1 + q_2 } = \bar{ q_1 }
+ \bar{ q_2 }\)</span>.</p></li>
<li><p><span class="math inline">\(\overline{ q_1 q_2 } = \bar{ q_2 }
\bar{ q_1 }\)</span>.</p></li>
<li><p>迹对<span class="math inline">\(\mathbb{ R
}\)</span>是线性映射.</p></li>
<li><p><span class="math inline">\(\bar{ N ( q ) } = N ( q ) = N ( \bar{
q } )\)</span>.</p></li>
<li><p><span class="math inline">\(N ( a + bi + cj + dk ) = a^2 + b^2 +
c^2 + d^2 \in \mathbb{ R }\)</span>.</p></li>
<li><p><span class="math inline">\(N ( q_1 q_2 ) = N ( q_1 ) N ( q_2
)\)</span>.</p></li>
<li><p>如若<span class="math inline">\(q \ne 0\)</span>,则<span class="math inline">\(q^{ - 1 } = ( N ( q ) )^{ - 1 } \bar{ q
}\)</span>.</p></li>
<li><p><span class="math inline">\(N ( q^{ - 1 } ) = N ( q )^{ - 1
}\)</span></p></li>
</ol>
<p>(1)(2)(3)是显然的.(4)的话由于乘法的双线性,只需验证<span class="math inline">\(q_1 , q_2 \in \{ 1 , i , j , k
\}\)</span>的情形.</p>
<p>(5)(6)是显然的.</p>
<p>(7)除了暴力验证以外,观察到(6),考虑<span class="math inline">\(N ( a +
bi + cj + dk ) = a^2 + b^2 + c^2 + d^2 + xi + yj + zk\)</span>,然而<span class="math inline">\(\bar{ N ( q ) } = N ( q
)\)</span>,这必然意味着后面均为<span class="math inline">\(0\)</span>.</p>
<p>(8)(9)(10)只需展开检验即可.这就详细描述了除环的结构.</p>
<p>我们还可以证明四元数已经到达极限了,有Frobenius定理:如果<span class="math inline">\(D\)</span>是一个除环且是一个<span class="math inline">\(\mathbb{ R
}\)</span>上的有限维线性空间,其乘法还对<span class="math inline">\(\mathbb{ R }\)</span>满足双线性,那么<span class="math inline">\(D\)</span>一定同构于<span class="math inline">\(\mathbb{ R } , \mathbb{ C } , \mathbb{ H
}\)</span>三者其一,再无别的情形.怎么证明?我不会,长大后再学习.</p>
<p>最后我们还可以验证<span class="math inline">\(\mathbb{ H
}\)</span>可以表为<span class="math inline">\(M_{ 2 \times 2 } (
\mathbb{ C } )\)</span>的一个子环,考虑仍取<span class="math inline">\(q
= z + jw\)</span>,然后将其改写为<span class="math inline">\(\begin{bmatrix}z &amp; - \bar{ w } \\ w &amp;
\bar{ z
}\end{bmatrix}\)</span>.这个矩阵结构可以符合加法,乘法,迹(对应到矩阵的迹),范数(对应到矩阵的行列式).这其实很像复数上把<span class="math inline">\(a + bi \mapsto \begin{bmatrix}a &amp; - b \\ b
&amp; a\end{bmatrix}\)</span>.那么我们可以:</p>
$$
<span class="math display">\[\begin{aligned}
1 &amp; \mapsto \begin{bmatrix}
1 &amp; \\
&amp; 1
\end{bmatrix} \\
i &amp; \mapsto \begin{bmatrix}
i &amp; \\
&amp; - i
\end{bmatrix} \\
j &amp; \mapsto \begin{bmatrix}
&amp; - 1 \\
1 &amp;
\end{bmatrix} \\
k &amp; \mapsto \begin{bmatrix}
&amp; - i \\
- i &amp;
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
<p>接下来考虑去掉环的性质,只看线性空间的性质,将目光着眼于<span class="math inline">\(\mathbb{ R }^3\)</span>上并只取出<span class="math inline">\(q = ai + bj + ck\)</span>,取这个子空间为<span class="math inline">\(\mathbb{ H }_0\)</span>,在上面挪用<span class="math inline">\(N ( q )\)</span>以刻画长度,具体而言只需取<span class="math inline">\(\Vert q \Vert^2 = N ( q )\)</span>.</p>
<p>接下来,让<span class="math inline">\(x \in \mathbb{ H
}^\times\)</span>,我们声明:</p>
<ol type="1">
<li><p><span class="math inline">\(\forall q \in \mathbb{ H
}\)</span>,<span class="math inline">\(N ( xqx^{ - 1 } ) = N ( q
)\)</span>.</p></li>
<li><p>设<span class="math inline">\(R_x \in \text{ End } ( \mathbb{ H
}_0 ) , q \mapsto xqx^{ - 1 }\)</span>,则这是个正交变换.</p></li>
<li><p><span class="math inline">\(\det R_x = 1\)</span>.</p></li>
<li><p><span class="math inline">\(R_{ tx } = R_x\)</span>,其中<span class="math inline">\(t \in \mathbb{ R }^\times\)</span>,且<span class="math inline">\(R_x R_y = R_{ xy } , R_{ x^{ - 1 } } = ( R_x )^{ -
1 }\)</span>.而且<span class="math inline">\(R_{ - 1 } = R_1 = \text{ id
}_{ \mathbb{ H }_0 }\)</span>.</p></li>
</ol>
<p>(1)是显然的.</p>
<p>(2)的话,不妨假设<span class="math inline">\(N ( x ) =
1\)</span>,此时<span class="math inline">\(x^{ - 1 } = \bar{ x
}\)</span>.首先要证明这个映射确实是<span class="math inline">\(\text{
End } ( \mathbb{ H }_0 )\)</span>里面的,观察<span class="math inline">\(\overline{ xqx^{ - 1 } } = \bar{ x^{ - 1 } } \bar{
q } \bar{ x } = x ( \bar{ q } ) x^{ - 1 } = - xqx^{ - 1
}\)</span>,这就说明<span class="math inline">\(xqx^{ - 1 } \in \mathbb{
H }_0\)</span>.</p>
<p>然后要检验它是线性映射,这里只需使用除环的性质简单验证.</p>
<p>最后由(1)说明其保距,这就说明了它是正交变换.</p>
<p>最后是(3),将<span class="math inline">\(\mathbb{ H } \cong \mathbb{ R
}^4\)</span>考虑映射<span class="math inline">\(\mathbb{ R }^4 \setminus
\{ 0 \} \to \{ \pm 1 \} , x \mapsto \det R_x\)</span>.这由于矩阵<span class="math inline">\(R_x\)</span>的每个元当然是关于<span class="math inline">\(x\)</span>的连续函数,因此整个映射都是连续的,而空间<span class="math inline">\(\mathbb{ R }^4 \setminus \{ 0
\}\)</span>是联通的,因此整个映射必然只射到常数,而<span class="math inline">\(\det R_1 = 1\)</span>,因此对于任意<span class="math inline">\(x \in \mathbb{ H }^\times\)</span>都有<span class="math inline">\(\det R_x = 1\)</span>.</p>
<p>(4)只需简单验证即可.</p>
<p>所以我们终于见到了,这个<span class="math inline">\(R_x\)</span>应当就是三维上的正交旋转.现在最后的问题在于是否所有的旋转都可以表示为<span class="math inline">\(R_x\)</span>.我们有下述定理:即对于任意在<span class="math inline">\(\mathbb{ H_0 }\)</span>上的旋转<span class="math inline">\(T\)</span>,<span class="math inline">\(\exists x
\in \mathbb{ H }\)</span>,<span class="math inline">\(N ( x ) =
1\)</span>,使得<span class="math inline">\(T = Rx\)</span>,并且<span class="math inline">\(x\)</span>精确到绝对值是唯一的,换言之,恰有两个<span class="math inline">\(x , - x\)</span>满足上述条件.</p>
<p>先证明存在性,回忆到欧拉角声明了<span class="math inline">\(T\)</span>可以由三个绕轴旋转完成.也就是说,只要我们能证明绕轴旋转<span class="math inline">\(R_{ e_l } ( \theta
)\)</span>可以用四元数表示,那么任意旋转都可以用四元数表示了.</p>
<p>不同轴类似只算一个,当绕着<span class="math inline">\(i\)</span>那条轴转的时候,取<span class="math inline">\(x = \cos \theta + i \sin \theta\)</span>,则<span class="math inline">\(x^{ - 1 } = \bar{ x } = \cos \theta - i \sin
\theta\)</span>,见到:</p>
<p><span class="math display">\[
\begin{aligned}
xix^{ - 1 } &amp; = i \\
xjx^{ - 1 } &amp; = \cos ( 2 \theta ) j + \sin ( 2 \theta ) k \\
xkx^{ - 1 } &amp; = - \sin ( 2 \theta ) j + \cos ( 2 \theta ) k
\end{aligned}
\]</span></p>
<p>综上见到<span class="math inline">\(R_x\)</span>是:<span class="math inline">\(\begin{bmatrix}1 &amp; \\ &amp; R ( 2 \theta
)\end{bmatrix}\)</span>,这样就实现了对第一个坐标轴转<span class="math inline">\(2 \theta\)</span>的情形.</p>
<p>类似的,就可以说明四元数可以表示所有的旋转.</p>
<p>最后要检验唯一性,如果<span class="math inline">\(R_x =
R_y\)</span>,其中<span class="math inline">\(N ( x ) = N ( y ) =
1\)</span>,那就有<span class="math inline">\(\text{ id }_{ \mathbb{ H
}_0 } = R_x ( R_y )^{ - 1 } = R_{ xy^{ - 1 } }\)</span>.</p>
<p>于是最后转化为说,要证明如果<span class="math inline">\(R_{ x } =
\text{ id }_{ \mathbb{ H }_0 }\)</span>,那么<span class="math inline">\(x = \pm 1\)</span>.那就说明<span class="math inline">\(\forall q , xqx^{ - 1 } = q\)</span>,也就是<span class="math inline">\(x \in Z ( \mathbb{ H } ) = \mathbb{ R
}\)</span>.又由于<span class="math inline">\(N ( x ) =
1\)</span>,所以<span class="math inline">\(x = \pm 1\)</span>.</p>
<p>更具体来说,绕着<span class="math inline">\(u\)</span>这条轴,且满足<span class="math inline">\(N ( u ) = 1\)</span>来说,那么<span class="math inline">\(R_u ( \theta ) = \cos \frac{ \theta }{ 2 } + u
\sin \frac{ \theta }{ 2 }\)</span>.</p>
<p>首先要验证<span class="math inline">\(x = \cos \frac{ \theta }{ 2 } +
u \sin \frac{ \theta }{ 2 }\)</span>满足<span class="math inline">\(N (
x ) = 1\)</span>,而:</p>
<p><span class="math display">\[
\begin{aligned}
N ( x ) &amp; = x \bar{ x } \\
&amp; = ( \cos \frac{ \theta }{ 2 } + u \sin \frac{ \theta }{ 2 } ) (
\cos \frac{ \theta }{ 2 } - u \sin \frac{ \theta }{ 2 } ) \\
&amp; = \cos^2 \frac{ \theta }{ 2 } - u^2 \sin^2 \frac{ \theta }{ 2 } \\
&amp; = \cos^2 \frac{ \theta }{ 2 } + N ( u ) \sin^2 \frac{ \theta }{ 2
} \\
&amp; = 1
\end{aligned}
\]</span></p>
<p>而考虑总存在一个旋转<span class="math inline">\(P =
R_y\)</span>,使得<span class="math inline">\(P ( i ) =
u\)</span>,此时我们可以知道:</p>
$$
<span class="math display">\[\begin{aligned}
R_u ( \theta ) &amp; = PR_i ( \theta ) P^{ - 1 } \\
&amp; = R_y R_i ( \theta ) R_{ y^{ - 1 } } \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设<span class="math inline">\(R_u ( \theta ) =
R_x\)</span>,则:</p>
<p><span class="math display">\[
\begin{aligned}
x &amp; = y ( \cos \frac{ \theta }{ 2 } + i \sin \frac{ \theta }{ 2 } )
y^{ - 1 } \\
&amp; = \cos \frac{ \theta }{ 2 } + \sin \frac{ \theta }{ 2 } yiy^{ - 1
} \\
&amp; = \cos \frac{ \theta }{ 2 } + \sin \frac{ \theta }{ 2 } u
\end{aligned}
\]</span></p>
<p>用欧拉公式的话,有<span class="math inline">\(R_u ( \theta ) = e^{
\frac{ \theta }{ 2 } u }\)</span>.</p>
<h3><span id="复内积空间">复内积空间</span></h3>
<h4><span id="共轭空间">共轭空间</span></h4>
<p>这应当带给我们思考,既然远在定义复数的时候,我们就声称过<span class="math inline">\(i\)</span>和<span class="math inline">\(-
i\)</span>无法区分,于是在此,应当研究一下共轭前后的两个空间分别的性质.</p>
<p>设<span class="math inline">\(V\)</span>是<span class="math inline">\(\mathbb{ C }\)</span>下的向量空间,它的复共轭<span class="math inline">\(\bar{ V }\)</span>是按照以下方式确定的<span class="math inline">\(\mathbb{ C }\)</span>向量空间:</p>
<ol type="1">
<li><p>集合<span class="math inline">\(V\)</span>与加法操作与原空间相同.</p></li>
<li><p>纯量乘法<span class="math inline">\(\odot : \mathbb{ C } \times V
\to V\)</span>定义为<span class="math inline">\(t \odot \vec{ v } =
\bar{ t } \vec{ v }\)</span>.</p></li>
</ol>
<p>显然<span class="math inline">\(\overline{ ( \bar{ V } ) } =
V\)</span>.半双线性映射无非是线性映射<span class="math inline">\(\bar{ V
} \to W\)</span>.当然,也可以等价说是<span class="math inline">\(V \to
\bar{ W }\)</span>.我们接下来验证复共轭的若干性质:</p>
<ol type="1">
<li><p>映射<span class="math inline">\(z \mapsto \bar{ z
}\)</span>给出向量空间的共轭<span class="math inline">\(\mathbb{ C }
\cong \bar{ \mathbb{ C } } : z \mapsto \bar{ z }\)</span>.</p></li>
<li><p><span class="math inline">\(\bar{ V }_1 \oplus \bar{ V }_2 =
\overline{ V_1 \oplus V_2 }\)</span>.</p></li>
<li><p><span class="math inline">\(\overline{ \text{ Hom } ( V_1 , V_2 )
} = \text{ Hom } ( \bar{ V }_1 , \bar{ V }_2 )\)</span>.</p></li>
<li><p><span class="math inline">\({ \bar{ W } }^\vee \cong \overline{
W^\vee }\)</span>,其实是(3)的另一种表示方式.</p></li>
</ol>
<p>应当检验上述映射,同构,甚至是完全挪移都是良定义的且半线性的,这里不做赘述.</p>
<p>相信对共轭空间最大的疑问在于,既然其改变了纯量乘法,原本的向量结构为什么不会被打乱呢?事实上,如果你考虑选定一组基的话,纯量乘法上的轻微改变只会使得将其它向量转化为基表示形式的过程中所提取出的纯量发生变化,然而共轭满足<span class="math inline">\(\overline{ z_1 z_2 } = \bar{ z_1 } \bar{ z_2
}\)</span>.虽然取定基的做法并非典范,然而不同基之间的转化仍然可以提取纯量.或者说,我们可以先取<span class="math inline">\(V \cong \mathbb{ C }^n \cong ( \bar{ \mathbb{ C }
} )^n \cong \bar{ V }\)</span>.</p>
<p>或直接从复数的几何意义来说,共轭无非是将逆时针旋转改为顺时针旋转,这应当仍是合理的.</p>
<h4><span id="复半双线性形式">(复)半双线性形式</span></h4>
<p>应当见到双线性形式在复空间中未必有很好的应用,原因是正定性难以得到满足.</p>
<p>定义<strong>半线性映射</strong>为<span class="math inline">\(T : V
\to W\)</span>满足:</p>
<ol type="1">
<li><p><span class="math inline">\(T ( \vec{ v }_1 + \vec{ v }_2 ) = T (
\vec{ v }_1 ) + T ( \vec{ v }_2 )\)</span>.</p></li>
<li><p><span class="math inline">\(T ( t \vec{ v } ) = \bar{ t } T (
\vec{ v } )\)</span>.</p></li>
</ol>
<p>定义<strong>半双线性映射</strong>为<span class="math inline">\(B : V
\times W \to X\)</span>满足:</p>
<ol type="1">
<li><p><span class="math inline">\(B ( \vec{ v }_1 + \vec{ v }_2 , \vec{
w } ) = B ( \vec{ v }_1 , \vec{ w } ) + B ( \vec{ v }_2 , \vec{ w }
)\)</span>.</p></li>
<li><p>对第一个变量半线性:<span class="math inline">\(B ( t \vec{ v } ,
\vec{ w } ) = \bar{ t } B ( \vec{ v } , \vec{ w } )\)</span>.</p></li>
<li><p><span class="math inline">\(B ( \vec{ v } , \vec{ w }_1 + \vec{ w
}_2 ) = B ( \vec{ v } , \vec{ w }_1 ) + B ( \vec{ v } , \vec{ w }_2
)\)</span>.</p></li>
<li><p>对第二个变量线性:<span class="math inline">\(B ( \vec{ v } , t
\vec{ w } ) = t B ( \vec{ v } , \vec{ w } )\)</span>.</p></li>
</ol>
<p>至于复伴随映射以及其余的东西,无非只是在实数上类似的定义的照抄.将上述记作<span class="math inline">\(\text{ Sesq } ( V , W ; X
)\)</span>.特别地,当<span class="math inline">\(X = \mathbb{ C
}\)</span>的时候,将此称作半双线性形式.应当立刻见到<span class="math inline">\(\text{ Sesq } ( V , W ; X ) = \text{ Bil } ( \bar{
V } , W ; X )\)</span>.</p>
<p>至于非退化等部分仍然是实数情况的照抄,对左右根,不妨设左根空间为<span class="math inline">\(L\)</span>,右根空间为<span class="math inline">\(R\)</span>,用柯里化过程见到该形式等价于<span class="math inline">\(\psi \in \text{ Hom } ( W ,{ \bar{ V } }^\vee
)\)</span>或者<span class="math inline">\(\varphi \in \text{ Hom } (
\bar{ V } , W^\vee )\)</span>,那么<span class="math inline">\(L = \ker
\varphi , R = \ker \psi\)</span>,我们应当见到<span class="math inline">\(B &#39; : ( V / L ) \times ( W / R ) \to F , (
\vec{ v } + L , \vec{ w } + R ) \mapsto B ( \vec{ v } , \vec{ w }
)\)</span>是非退化双线性形式.此时见到其实<span class="math inline">\(\dim V - \dim L = \dim W - \dim R\)</span>.</p>
<p>接下来要用矩阵形式予以表述,我们声称<span class="math inline">\(M_{ m
\times n } ( \mathbb{ C } ) \cong \text{ Sesq } ( \mathbb{ C }^m ,
\mathbb{ C }^n ) , A \mapsto B ( \vec{ v } , \vec{ w } ) = (^\dagger
\vec{ v } ) A \vec{ w }\)</span>,原因是标准基下<span class="math inline">\(\mathbb{ C
}\)</span>的对偶空间其实就是共轭转置后的结果.</p>
<h4><span id="伴随映射">伴随映射</span></h4>
<p>与实数情况毫无差异,我们在此复述一遍当时的图表即可:</p>
<p><span class="math display">\[
\xymatrix{ V_2 &#39; \ar[r]^{ T^* } \ar[d]_{ A_2 } &amp; V_1 &#39;
\ar[d]^{ A_1 } \\
\check{ V_2 } \ar[r]^{ ^\dagger T } &amp; \check{ V_1 } \\
V_2 \ar[u] &amp; V_1 \ar[u] \ar[l]_T }
\]</span></p>
<p>同样,我们可以定义<strong>自伴</strong>性质:<span class="math inline">\(T^* =
T\)</span>以及<strong>反自伴</strong>性质<span class="math inline">\(T^*
= - T\)</span>.此处出现了复数与实数不同的地方:假设<span class="math inline">\(c\)</span>是非零纯虚数,则<span class="math inline">\(T\)</span>自伴当且仅当<span class="math inline">\(cT\)</span>反自伴.这性质是容易验证的,也告知我们复数域上的反自伴并不需要像实数那样使用单独的辛空间来刻画.</p>
<p>类比实数,下面定理当然也是对的:</p>
<p>而注意到<span class="math inline">\(T^*
T\)</span>是自伴的,然而其还有更多的好性质:</p>
<ol type="1">
<li><p><span class="math inline">\(( \text{ im } T )^\bot = \ker ( T^*
)\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ im } \ ( T^* T ) = \text{ im }
\ ( T^* )\)</span>.</p></li>
<li><p><span class="math inline">\(\ker ( T^* T ) = \ker
T\)</span>.</p></li>
<li><p><span class="math inline">\(\text{ rk } \ ( T^* T ) = \text{ rk }
\ ( T ) = \text{ rk } ( T^* )\)</span>.</p></li>
</ol>
<p>证明与实数情形无差.</p>
<h4><span id="hermite形式">Hermite形式</span></h4>
<p>设<span class="math inline">\(V\)</span>是<span class="math inline">\(\mathbb{ C }\)</span>下的向量空间,<span class="math inline">\(\epsilon \in \{ - 1 , 1
\}\)</span>,若半双线性形式<span class="math inline">\(B : V \times V \to
\mathbb{ C }\)</span>满足<span class="math inline">\(B ( \vec{ v } ,
\vec{ w } ) = \epsilon \overline{ B ( \vec{ w } , \vec{ v } )
}\)</span>的话,我们就称<span class="math inline">\(B\)</span>是一个<span class="math inline">\(\epsilon -\)</span>Hermite形式.如果<span class="math inline">\(\epsilon =
1\)</span>,称这是一个<strong>Hermite形式</strong>;如果<span class="math inline">\(\epsilon = -
1\)</span>,则称其为<strong>反Hermite形式</strong>.容易验证,如果<span class="math inline">\(B\)</span>是Hermite的,那么<span class="math inline">\(iB\)</span>是反Hermite的.</p>
<p>此定义直接导致<span class="math inline">\(B\)</span>的左右根是一回事,我们后面会称其为<span class="math inline">\(B\)</span>的根基.并容易见到等价于其对应的矩阵满足<span class="math inline">\(A^\dagger = \epsilon
A\)</span>.也就是说,Hermite形式对应的矩阵自伴,而反Hermite形式对应的矩阵反自伴.</p>
<h5><span id="正规线性映射">正规线性映射</span></h5>
<p>给定某<span class="math inline">\(\epsilon -\)</span>Hermite形式<span class="math inline">\(B : V \times V \to \mathbb{ C
}\)</span>,我们称满足<span class="math inline">\(( T^* ) T = T ( T^*
)\)</span>的<span class="math inline">\(T\)</span>是<strong>正规线性映射</strong>.容易见到自伴和反自伴当然是正规的.事实上,取<span class="math inline">\(T &#39; = \frac{ 1 }{ 2 } ( T + T^* ) , T &#39;
&#39; = \frac{ 1 }{ 2 } ( T - T^* )\)</span>即可见到能将<span class="math inline">\(T = T &#39; + T &#39;
&#39;\)</span>拆成一个自伴形式和一个反自伴形式.这种分解还是唯一的,原因是如果有两组形式满足<span class="math inline">\(T_1 &#39; + T_1 &#39; &#39; = T_2 &#39; + T_2
&#39; &#39;\)</span>,移项后得到<span class="math inline">\(T_1 &#39; -
T_2 &#39; = T_2 &#39; &#39; - T_1 &#39;
&#39;\)</span>,左侧是自伴的,右侧是反自伴的,因此它们都是<span class="math inline">\(0\)</span>.</p>
<p>若进一步要求<span class="math inline">\(T\)</span>是正规的,也就是<span class="math inline">\(( T^* ) T = T ( T^* )\)</span>,还可以见到<span class="math inline">\(T &#39; T &#39; &#39; = T &#39; &#39; T
&#39;\)</span>,只需简单验证即可.</p>
<h5><span id="二次型">二次型</span></h5>
<p>定义复数上的半双线性版本的<strong>二次型</strong>为<span class="math inline">\(f ( x_1 , \cdots , x_n ) = \sum a_{ i , j } \bar{
x_i } x_j\)</span>.要证明其与<span class="math inline">\(\epsilon
-\)</span>Hermite形式同构,不妨先直接考虑<span class="math inline">\(f (
\vec{ v } + \vec{ w } ) = B ( \vec{ v } + \vec{ w } , \vec{ v } + \vec{
w } )\)</span>,那只需考虑配极化技巧,定义<span class="math inline">\(\Re\)</span>为提取实部,<span class="math inline">\(\Im\)</span>为提取虚部,立刻得到:</p>
<p><span class="math display">\[
f ( \vec{ v } + \vec{ w } ) = \begin{cases}
f ( \vec{ v } ) + f ( \vec{ w } ) + 2 \Re B ( \vec{ v } , \vec{ w } )
&amp; \epsilon = 1 \\
f ( \vec{ v } ) + f ( \vec{ w } ) + 2 i \Im B ( \vec{ v } , \vec{ w } )
&amp; \epsilon = - 1
\end{cases}
\]</span></p>
<p>考虑<span class="math inline">\(\Im B ( \vec{ v } , \vec{ w } ) = \Re
B ( i \vec{ v } , \vec{ w } )\)</span>,所以上述立刻确定了<span class="math inline">\(B\)</span>.</p>
<p>搬运实二次型上的性质即可看到<strong>合同</strong>在复数域上体现于<span class="math inline">\(A = (^\dagger C ) A &#39;
C\)</span>.对该多项式做对角化与实数情况无异.</p>
<p>至于复数上的<strong>惯性定理</strong>,证明与实数丝毫不差.</p>
<p>既然如此,我们下面会说明Hermite形式对应了标准内积下的自伴算子,其所有特征值均为实数.由此可以定义其<strong>正定性</strong>,当然也就是所有特征值均为正数.其余类似<strong>半正定性</strong>均可照搬原本性质.</p>
<p>于此,我们可以引出以下定理:</p>
<p><span class="math inline">\(T^* T\)</span>是半正定的.当<span class="math inline">\(T\)</span>是单射时,其是正定的.</p>
<p>证明无非仍然是<span class="math inline">\(( T^* T \vec{ v } \mid
\vec{ v } )_V = ( T \vec{ v } \mid T \vec{ v }
)_W\)</span>的直接结论.</p>
<h4><span id="复内积空间">复内积空间</span></h4>
<p>考虑正定Hermite形式<span class="math inline">\(( \_ \mid \_ ) : V
\times V \to \mathbb{ C }\)</span>,这样的资料<span class="math inline">\(( V , ( \_ \mid \_ )
)\)</span>称为<strong>复内积空间</strong>,又称作<strong>酉空间</strong>.特别地,在<span class="math inline">\(\mathbb{ C
}^n\)</span>上定义标准Hermite内积为<span class="math inline">\(( \vec{ x
} \mid \vec{ y } ) = \sum \bar{ x_i }
y_i\)</span>,应当见到其正定且是一个Hermite形式.</p>
<p>容易照搬大部分实内积空间的性质过来,这里简单列举:</p>
<ol type="1">
<li><p><span class="math inline">\(\Vert \vec{ v } \Vert = 0
\Leftrightarrow \vec{ v } = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\Vert t \vec{ v } \Vert = | t | \Vert
\vec{ v } \Vert^2\)</span>.</p></li>
<li><p><span class="math inline">\(\Im ( \vec{ v }_1 \mid \vec{ v }_2 )
= \Re ( i \vec{ v }_1 \mid \vec{ v }_2 )\)</span>.</p></li>
<li><p>配极化,即<span class="math inline">\(\Vert \vec{ v } + \vec{ w }
\Vert^2 = \Vert \vec{ v } \Vert^2 + \Vert \vec{ w } \Vert^2 + 2 \Re (
\vec{ v } \mid \vec{ w } )\)</span>.</p></li>
<li><p>正交单位向量,正交集合,单位正交基等概念原样照搬.</p></li>
<li><p>勾股定理,即<span class="math inline">\(\vec{ v } \bot \vec{ w
}\)</span>时,<span class="math inline">\(\Vert \vec{ v } + \vec{ w }
\Vert^2 = \Vert \vec{ v } \Vert^2 + \Vert \vec{ w }
\Vert^2\)</span>.</p></li>
<li><p>柯西不等式,即<span class="math inline">\(| ( \vec{ v } \mid \vec{
w } ) | \leq \Vert \vec{ v } \Vert \cdot \Vert \vec{ w }
\Vert\)</span>.</p></li>
<li><p>三角不等式,即<span class="math inline">\(\Vert \vec{ v } + \vec{
w } \Vert \leq \Vert \vec{ v } \Vert + \Vert \vec{ w }
\Vert\)</span>.</p></li>
<li><p>Gram-Schmidt正交化,策略仍是<span class="math inline">\(\vec{ w
}_k = \vec{ v }_k - \sum_{ i = 1 }^{ k - 1 } \frac{ ( \vec{ w }_i \mid
\vec{ v }_k ) }{ ( \vec{ w }_i \mid \vec{ w }_i ) } \vec{ w
}_i\)</span>.</p></li>
</ol>
<p>(1)(2)(3)(4)(5)(6)的证明是平凡的.</p>
<p>(7)的证明与实数情景略有差别,仍设<span class="math inline">\(t \in
\mathbb{ C }\)</span>,并观察:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp; \leq \Vert \vec{ v } + t \vec{ w } \Vert^2 \\
&amp; = \Vert \vec{ v } \Vert^2 + 2 \Re ( t ( \vec{ v } \mid \vec{ w } )
) + | t |^2 \Vert \vec{ w } \Vert^2 \\
&amp; \leq \Vert \vec{ v } \Vert^2 + 2 | t | \cdot | ( \vec{ v } \mid
\vec{ w } ) | + | t |^2 \Vert \vec{ w } \Vert^2
\end{aligned}
\]</span></p>
<p>对于(8),只需做一些微小的调整,具体为:</p>
<p><span class="math display">\[
\begin{aligned}
\Vert \vec{ v } + \vec{ w } \Vert^2 &amp; = \Vert \vec{ v } \Vert^2 + 2
\Re ( \vec{ v } \mid \vec{ w } ) + \Vert \vec{ w } \Vert^2 \\
&amp; \leq \Vert \vec{ v } \Vert^2 + 2 | ( \vec{ v } \mid \vec{ w } ) |
+ \Vert \vec{ w } \Vert^2 \\
&amp; \leq \Vert \vec{ v } \Vert^2 + 2 \Vert \vec{ v } \Vert \cdot \Vert
\vec{ w } \Vert + \Vert \vec{ w } \Vert^2 \\
&amp; = ( \Vert \vec{ v } \Vert + \Vert \vec{ w } \Vert )^2
\end{aligned}
\]</span></p>
<p>(9)的话,值得注意的是在左右两边对<span class="math inline">\(\vec{ w
}_i\)</span>做内积其实并非完全一致的.做<span class="math inline">\((
\vec{ w }_i \mid \_ )\)</span>当然显然是正确的,做<span class="math inline">\(( \_ \mid \vec{ w }_i
)\)</span>的话,由于是Hermite形式,当然也是对的.</p>
<h5><span id="酉变换">酉变换</span></h5>
<p>复内积空间到自身的同构称为<span class="math inline">\(V\)</span>上的<strong>酉变换</strong>.容易类比实数情况,以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(T\)</span>是酉变换.</p></li>
<li><p><span class="math inline">\(T^* = T^{ - 1
}\)</span>,特别地,取标准内积空间时,该条等价于<span class="math inline">\(T^\dagger = T^{ - 1 }\)</span>,如果<span class="math inline">\(T\)</span>是矩阵,我们称其是<strong>酉矩阵</strong>.</p></li>
<li><p><span class="math inline">\(\{ \vec{ v }_1 , \cdots , \vec{ v }_n
\}\)</span>是一组单位正交基,则<span class="math inline">\(\{ T \vec{ v
}_1 , \cdots , T \vec{ v }_n \}\)</span>也是一组单位正交基.</p></li>
</ol>
<h5><span id="正规算子的酉对角化谱定理">正规算子的酉对角化(谱定理)</span></h5>
<p>我们下面证明,只要<span class="math inline">\(T\)</span>是正规算子,那它就可以酉对角化.换言之<span class="math inline">\(T\)</span>如果对应矩阵<span class="math inline">\(A\)</span>,那么存在酉矩阵<span class="math inline">\(P\)</span>满足<span class="math inline">\(P^\dagger = P^{ - 1 }\)</span>而且<span class="math inline">\(P^{ - 1 } AP = \begin{bmatrix}\lambda_1 &amp;
&amp; \\ &amp; \ddots &amp; \\ &amp; &amp;
\lambda_n\end{bmatrix}\)</span>.容易见到其逆命题仍然成立,原因是<span class="math inline">\(P^{ - 1 } A ( A^\dagger ) P = P^{ - 1 } (
A^\dagger ) AP = \begin{bmatrix}| \lambda_1 |^2 &amp; &amp; \\ &amp;
\ddots &amp; \\ &amp; &amp; | \lambda_n |^2\end{bmatrix}\)</span>.</p>
<p>接下来要证明该定理正命题成立,其证明策略有若干种,下面选取两种进行说明.</p>
<p>第一种策略是,照搬实数域上的情形对空间进行数学归纳.已经可以将一个正规算子分解为<span class="math inline">\(T = T &#39; + T &#39; &#39;\)</span>,其中<span class="math inline">\(T &#39;\)</span>自伴而<span class="math inline">\(T &#39;
&#39;\)</span>反自伴.那我们可以类比实数域上对其进行归纳,从而说明<span class="math inline">\(T &#39; , T &#39;
&#39;\)</span>均可以对角化.又因为当<span class="math inline">\(T\)</span>正规的时候,<span class="math inline">\(T
&#39; T &#39; &#39; = T &#39; &#39; T
&#39;\)</span>,于是满足同步对角化的条件.</p>
<p>第二种策略较为麻烦,但能揭示更多正规算子的性质.假设<span class="math inline">\(N \in \text{ End } ( V
)\)</span>是正规算子,我们首先证明以下引理:</p>
<ol type="1">
<li><p>对于<span class="math inline">\(f \in \mathbb{ C } [ x
]\)</span>,<span class="math inline">\(f ( N ) \in \text{ End } ( V
)\)</span>也是正规的.</p></li>
<li><p>假设特征向量<span class="math inline">\(\vec{ v } \in
V\)</span>使得<span class="math inline">\(\exists \lambda \in \mathbb{ C
}\)</span>有<span class="math inline">\(N \vec{ v } = \lambda \vec{ v
}\)</span>,则<span class="math inline">\(N^* \vec{ v } = \bar{ \lambda }
\vec{ v }\)</span>.</p></li>
<li><p>若存在<span class="math inline">\(k \geq 1\)</span>使得<span class="math inline">\(N^k = 0\)</span>,那么<span class="math inline">\(N
= 0\)</span>.</p></li>
<li><p>对于其任意两个不同的特征子空间<span class="math inline">\(V_\lambda , V_\mu\)</span>,当<span class="math inline">\(\lambda \ne \mu\)</span>的时候,<span class="math inline">\(V_\lambda \bot V_\mu\)</span>.</p></li>
</ol>
<p>(1)的话,考虑<span class="math inline">\(( \sum a_i N^i )^* = \sum
\bar{ a_i } ( N^* )^i\)</span>,其与任意<span class="math inline">\(N\)</span>的多项式都交换.</p>
<p>(2)的话不妨直接取<span class="math inline">\(M = N - \lambda
I\)</span>,根据(1)这当然仍是正规的.取<span class="math inline">\(M^* =
N^* - \bar{ \lambda } I\)</span>,此时注意到<span class="math inline">\(\ker M\)</span>就是<span class="math inline">\(V_\lambda\)</span>这个特征子空间,然而见到<span class="math inline">\(\ker ( M ) = \ker ( M^* M ) = \ker ( MM^* ) = \ker
( M^*
)\)</span>,这就证毕了.当然这也意味着自伴算子的特征值一定都是实数,而反自伴算子的特征值一定都是纯虚数.</p>
<p>(3)考虑到<span class="math inline">\(( N^k )^* = ( N^*
)^k\)</span>,于是<span class="math inline">\(N\)</span>的任意次幂都是正规的.既然如此,考虑<span class="math inline">\(N^* N\)</span>当然是自伴的.要证<span class="math inline">\(N = 0\)</span>,只需证明<span class="math inline">\(\text{ rk } \ N = 0\)</span>,只需证明<span class="math inline">\(\text{ rk } \ ( N^* N ) =
0\)</span>,也就只需要证明<span class="math inline">\(N^* N =
0\)</span>即可.而如果<span class="math inline">\(N^k =
0\)</span>,那么立刻有<span class="math inline">\(( N^* N )^k =
0\)</span>,因此我们对<span class="math inline">\(N^*
N\)</span>,也就是自伴情形证明上述结论即可.</p>
<p>于是接下来不妨假设<span class="math inline">\(N\)</span>自伴,其任意次幂都自伴.考虑<span class="math inline">\(k = 1\)</span>显然成立,<span class="math inline">\(k = 2\)</span>的时候,回忆到<span class="math inline">\(\forall \vec{ v } , ( N \vec{ v } \mid N \vec{ v }
) = ( N^2 \vec{ v } \mid \vec{ v } ) = 0\)</span>,因此立刻有<span class="math inline">\(N = 0\)</span>.</p>
<p>然后使用数学归纳,对于一般的<span class="math inline">\(k &gt;
2\)</span>,如果<span class="math inline">\(k\)</span>是偶数,那<span class="math inline">\(( N^{ \frac{ k }{ 2 } } )^2 = N^k =
0\)</span>意味着<span class="math inline">\(N^{ \frac{ k }{ 2 } } =
0\)</span>,可以数学归纳;当<span class="math inline">\(k\)</span>是奇数的时候,<span class="math inline">\(N^{ k + 1 } = 0\)</span>,而<span class="math inline">\(\frac{ k + 1 }{ 2 } &lt;
k\)</span>,因此仍然可以数学归纳.</p>
<p>(4)只需要考虑(2),立刻有:</p>
<p><span class="math display">\[
\begin{aligned}
\mu ( \vec{ v } \mid \vec{ w } ) &amp; = ( \vec{ v } \mid \mu \vec{ w }
) = ( \vec{ v } \mid N \vec{ w } ) \\
&amp; = ( N^* \vec{ v } \mid \vec{ w } ) = ( \bar{ \lambda } \vec{ v }
\mid \vec{ w } ) = \lambda ( \vec{ v } \mid \vec{ w } )
\end{aligned}
\]</span></p>
<p>于是完事.</p>
<p>有了以上引理,我们就可以来揭示正规算子可对角化的性质.</p>
<p>使用复数域上分裂的性质,将其特征多项式<span class="math inline">\(\text{ Char }_T = \prod ( x - \mu_i )^{ a_i
}\)</span>.取<span class="math inline">\(m = \prod ( x - \mu_i
)\)</span>,只要我们能说明<span class="math inline">\(m\)</span>就是极小多项式,由于其无重根则立即完事.那就只需要验证<span class="math inline">\(m ( T ) = 0\)</span>,然而,<span class="math inline">\(m ( T )\)</span>由于(1)是正规的,又因为<span class="math inline">\(m ( T )^{ \max a_i } =
0\)</span>,用(3)立刻见到<span class="math inline">\(m ( T ) =
0\)</span>,再用(4)和Gram-Schmidt法得到正交基,这就证明了该结论.</p>
<p>回忆到实数域上可正交对角化当且仅当自伴,那是因为实数域上的反自伴性质很差.而复数域上二者差别不大,想要它们能够同步对角化就需要有交换性,而正规算子恰好保证了交换性.</p>
<p>但总之,我们由上可以立即见到以下结论成立,当<span class="math inline">\(T\)</span>是正规算子的时候:</p>
<ol type="1">
<li><p><span class="math inline">\(T\)</span>自伴当且仅当所有特征值都是实数.</p></li>
<li><p><span class="math inline">\(T\)</span>反自伴当且仅当所有特征值都是纯虚数.</p></li>
<li><p><span class="math inline">\(T\)</span>是酉变换当且仅当所有特征值都满足<span class="math inline">\(| \lambda | = 1\)</span>.</p></li>
</ol>
<p>原因是自伴性质是<span class="math inline">\(A^\dagger =
A\)</span>,反自伴性质是<span class="math inline">\(A^\dagger = -
A\)</span>,酉变换性质是<span class="math inline">\(A^\dagger = A^{ - 1
}\)</span>.而只需选取单位正交基,立刻就发现<span class="math inline">\(T\)</span>对应的<span class="math inline">\(A =
\begin{bmatrix}\lambda_1 &amp; &amp; \\ &amp; \ddots &amp; \\ &amp;
&amp; \lambda_n\end{bmatrix}\)</span>,<span class="math inline">\(T^*\)</span>对应的<span class="math inline">\(A^\dagger = \begin{bmatrix}\bar{ \lambda }_1 &amp;
&amp; \\ &amp; \ddots &amp; \\ &amp; &amp; \bar{ \lambda
}_n\end{bmatrix}\)</span>.</p>
<h5><span id="相关实内积空间定理推广">相关实内积空间定理推广</span></h5>
<p>我们声明以下操作在复内积空间上都能做:</p>
<ol type="1">
<li><p>二次根:设<span class="math inline">\(T \in \text{ End } ( V
)\)</span>正定(半正定),那么存在唯一的<span class="math inline">\(S \in
\text{ End } ( V )\)</span>使得<span class="math inline">\(S\)</span>也正定(半正定),并且<span class="math inline">\(S^2 = T\)</span>,将此<span class="math inline">\(S\)</span>记作<span class="math inline">\(\sqrt{ T
}\)</span>.</p></li>
<li><p>极分解:设<span class="math inline">\(T \in \text{ End } ( V
)\)</span>可逆,则存在唯一一对<span class="math inline">\(R , U \in
\text{ End } ( V )\)</span>使得<span class="math inline">\(R\)</span>正定,<span class="math inline">\(U\)</span>是酉变换,而且<span class="math inline">\(T = RU\)</span>.具体地,<span class="math inline">\(R = \sqrt{ TT^* }\)</span>.</p></li>
<li><p>奇异值分解:对于线性映射<span class="math inline">\(T : V \to
W\)</span>,存在<span class="math inline">\(V ,
W\)</span>分别的一组正交基和唯一一组<span class="math inline">\(\sigma_1
\geq \cdots \geq \sigma_p\)</span>使得<span class="math inline">\(T
\vec{ v }_i = \begin{cases}\sigma_i \vec{ w }_i &amp; 1 \leq i \leq p \\
0 &amp; i &gt; p\end{cases}\)</span>.或者写作<span class="math inline">\(A = Q \Sigma P^{ - 1 }\)</span>,其中<span class="math inline">\(\Sigma = \begin{bmatrix}\sigma_1 &amp; \\ &amp;
\ddots\end{bmatrix}\)</span>.</p></li>
<li><p>MP广义逆:对于<span class="math inline">\(T : V \to
W\)</span>,存在唯一的<span class="math inline">\(S : W \to
V\)</span>,使得其满足从前的广义逆结论.特别地,这里的<span class="math inline">\(S\)</span>实际上可以用奇异值分解唯一刻画.</p></li>
</ol>
<h5><span id="复矩阵范数实例">复矩阵范数实例</span></h5>
<p>考虑<span class="math inline">\(( A , B ) \to ( A \mid B )_{ HS } =
\text{ Tr } ( ( A^\dagger ) B )\)</span>,立刻使得<span class="math inline">\(M_{ m \times n } ( \mathbb{ C }
)\)</span>成为一个复内积空间.在此基础上定义<strong>Hilbert-Schmidt范数</strong>:<span class="math inline">\(\Vert T \Vert_{ HS } = \sqrt{ ( T \mid T )_{ HS }
}\)</span>.</p>
<p>这里还可以展现<span class="math inline">\(\text{ Tr
}\)</span>在空间上的体现.回忆到<span class="math inline">\(V\)</span>上的内积结构<span class="math inline">\(\vec{ v } \mapsto ( \vec{ v } \mid \_
)\)</span></p>
<p>另外,还可以定义所谓<strong>算子范数</strong>为<span class="math inline">\(\Vert T \Vert = \max_{ \Vert \vec{ v } \Vert_V = 1
} \Vert T \vec{ v } \Vert_W\)</span>.应当容易验证:</p>
<ol type="1">
<li><p><span class="math inline">\(\Vert tT \Vert = | t | \Vert T
\Vert\)</span>.</p></li>
<li><p><span class="math inline">\(\Vert T_1 + T_2 \Vert \leq \Vert T_1
\Vert + \Vert T_2 \Vert\)</span>.</p></li>
<li><p><span class="math inline">\(\Vert T \Vert = 0 \Leftrightarrow T =
0\)</span>.</p></li>
<li><p><span class="math inline">\(\Vert ST \Vert \leq \Vert S \Vert
\cdot \Vert T \Vert\)</span>.</p></li>
<li><p><span class="math inline">\(\Vert I \Vert = 1\)</span>.</p></li>
</ol>
<p>只需回忆极小化极大原理就知道<span class="math inline">\(\Vert T
\Vert^2\)</span>取到了<span class="math inline">\(T^*
T\)</span>的模长最大的特征值,而<span class="math inline">\(\Vert T
\Vert_{ HS }^2\)</span>取到了<span class="math inline">\(T^*
T\)</span>的特征值之和,考虑<span class="math inline">\(T : V \to
W\)</span>,见到:</p>
<p><span class="math display">\[
\frac{ 1 }{ \sqrt{ \dim V } } \Vert T \Vert_{ HS } \leq \Vert T \Vert
\leq \Vert T \Vert_{ HS }
\]</span></p>
<p>综上,就可以定义两种距离,容易验证它们的若干性质.</p>
<p>因此容易见到上面两种范数有互相等价的收敛性和极限概念,柯西列的概念也是等价的.</p>
<h3><span id="模">模</span></h3>
<p>考虑将线性空间的定义从域挪到环上,对于一个环<span class="math inline">\(R\)</span>,定义<strong>左模</strong>为一个资料<span class="math inline">\(M\)</span>,其中<span class="math inline">\(M\)</span>自带一个加法群(需要可交换)而其还有一个对环的左乘<span class="math inline">\(R \times M \to M\)</span>使得<span class="math inline">\(\forall x \in M , r_1 , r_2 \in
R\)</span>,以下性质成立:</p>
<ol type="1">
<li><p><span class="math inline">\(r ( x + y ) = rx +
ry\)</span>.</p></li>
<li><p><span class="math inline">\(( r_1 + r_2 ) x = r_1 x + r_2
x\)</span>.</p></li>
<li><p><span class="math inline">\(( r_1 r_2 ) x = r_1 ( r_2 x
)\)</span>.</p></li>
<li><p><span class="math inline">\(1_R x = x\)</span>.</p></li>
</ol>
<p>同理可以定义<strong>右模</strong>.这里可能又需要定义相反环<span class="math inline">\(R^{ op }\)</span>,相当于把乘法顺序调转.当<span class="math inline">\(R\)</span>是交换环的时候,<span class="math inline">\(R = R^{ op
}\)</span>,此时左模和右模无差别.下面无特殊说明默认为左模.</p>
<p>容易见到线性空间是模的特例.</p>
<p>还可以定义两个都定义在<span class="math inline">\(R\)</span>上的模<span class="math inline">\(M_1 ,
M_2\)</span>之间的同态<span class="math inline">\(f : M_1 \to
M_2\)</span>满足:</p>
<ol type="1">
<li><p><span class="math inline">\(f ( rx ) = rf ( x
)\)</span>.</p></li>
<li><p><span class="math inline">\(f ( x_1 + x_2 ) = f ( x_1 ) + f ( x_2
)\)</span>.</p></li>
</ol>
<p>容易见到<span class="math inline">\(( f_1 + f_2 ) ( x ) = f_1 ( x ) +
f_2 ( x )\)</span>成立并且<span class="math inline">\(( f_1 + f_2
)\)</span>当然也是同态,然而<span class="math inline">\(( rf ) ( x ) = rf
( x )\)</span>并不一定是同态,原因是:</p>
<p><span class="math display">\[
\begin{aligned}
rf ( r &#39; x ) &amp; = rf ( r &#39; x ) = rr &#39; f ( x ) \\
&amp; \ne r &#39; rf ( x ) = r &#39; ( rf ) ( x )
\end{aligned}
\]</span></p>
<p>因此并不一定能把里面的<span class="math inline">\(r
&#39;\)</span>提到外面来,这就出问题了.模的同态集合并非是模.然而同态对复合操作总是构成幺半群,容易见到:</p>
<ol type="1">
<li><p><span class="math inline">\(( f_1 + f_2 ) \circ g = ( f_1 \circ g
) + ( f_2 \circ g )\)</span>.</p></li>
<li><p><span class="math inline">\(f \circ ( g_1 + g_2 ) = ( f \circ g_1
) + ( f \circ g_2 )\)</span>.</p></li>
</ol>
<p>那也可以定义同构,就是存在逆映射.还可以定义子模.容易见到任何一组子模的交仍然是子模.</p>
<p>还可以定义商模.假设<span class="math inline">\(N\)</span>是<span class="math inline">\(M\)</span>的子模,在加法群意义下存在一个商群<span class="math inline">\(M /
N\)</span>(原因是此加法群可交换),现在我们想将其升级为<span class="math inline">\(R\)</span>的模.我们定义:<span class="math inline">\(R \times ( M / N ) \to ( M / N ) : ( r , x + N )
\mapsto rx + N\)</span>作为模上的标量乘法,我们试图证明:</p>
<ol type="1">
<li><p>此运算使得<span class="math inline">\(M /
N\)</span>成为模.</p></li>
<li><p><span class="math inline">\(q : M \to M /
N\)</span>构成模同态,而且<span class="math inline">\(\ker q =
N\)</span>.</p></li>
</ol>
<p>(1)只需要简单检验即可(由于<span class="math inline">\(N\)</span>对于标量乘法封闭显然).</p>
<p>(2)则是由于<span class="math inline">\(q\)</span>本身已经是加法群的同态,又有<span class="math inline">\(q ( rx ) = rx + N = rq ( x
)\)</span>,这就搞定.</p>
<p>然后定义直积,考虑一组定义在<span class="math inline">\(R\)</span>上的模<span class="math inline">\(( M_i
)_{ i \in I
}\)</span>,考虑它们本身都是一个加法群,因此先用加法群的定义拿到<span class="math inline">\(\prod_i M_i\)</span>,然后将它升级为一个<span class="math inline">\(R\)</span>模,方法是<span class="math inline">\(( r
, ( x_i )_{ i \in I } ) \mapsto ( rx_i )_{ i \in I
}\)</span>.同理把其至多有限多个分量非零的子集定义为直和.内直和亦然同理.设<span class="math inline">\(( M_i )_{ i \in I }\)</span>是<span class="math inline">\(M\)</span>的一组子模,以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(\sum_{ i \in I } M_i =
M\)</span>,而且<span class="math inline">\(\forall i \in I , M_i \cap
\sum_{ j \ne i } M_j = \{ 0 \}\)</span>.</p></li>
<li><p><span class="math inline">\(\forall x \in
M\)</span>都能唯一写作<span class="math inline">\(x = \sum_{ i \in I }
x_i\)</span>的形式.</p></li>
<li><p><span class="math inline">\(\sigma : \bigoplus_{ i \in I } M_i
\cong M\)</span>.</p></li>
</ol>
<p>验证上述命题是简单的.</p>
<p>最后,如果存在一个<span class="math inline">\(M\)</span>的子集<span class="math inline">\(S\)</span>使得<span class="math inline">\(M =
\langle S \rangle\)</span>,我们称<span class="math inline">\(M\)</span>是<strong>有限生成</strong>的.</p>
<h4><span id="自由模">自由模</span></h4>
<p>设<span class="math inline">\(X\)</span>为集合,其上的<strong>自由模</strong>定义为直和<span class="math inline">\(R^{ \oplus X }\)</span>,可以自然地将<span class="math inline">\(X\)</span>嵌入<span class="math inline">\(R^{
\oplus X }\)</span>,只需将<span class="math inline">\(x \mapsto ( r_y
)\)</span>,其中<span class="math inline">\(r_y = \begin{cases}1 &amp; x
= y \\ 0 &amp; x \ne y\end{cases}\)</span>.</p>
<p>对于任何一个<span class="math inline">\(R\)</span>上的模<span class="math inline">\(N\)</span>,我们可以将<span class="math inline">\(\mathrm{ Hom }_R ( R^{ \oplus X } , N
)\)</span>与<span class="math inline">\(X \to
N\)</span>的映射一一对应.从前者对应到后者只需将映射限制在<span class="math inline">\(X\)</span>上即可(上述已经给出将<span class="math inline">\(X\)</span>嵌入其中的策略),从后者到前者的对应只需逐分量映射亦可.</p>
<p>既然<span class="math inline">\(X\)</span>可以如上嵌入<span class="math inline">\(R^{ \oplus X }\)</span>,能否找到一个<span class="math inline">\(R\)</span>上的模<span class="math inline">\(M\)</span>,使得干脆使得<span class="math inline">\(X \subseteq M\)</span>并且<span class="math inline">\(M \cong R^{ \oplus X
}\)</span>呢.其实这里可以生添一个定义,假设<span class="math inline">\(X
\subseteq M\)</span>并且<span class="math inline">\(M\)</span>已经是<span class="math inline">\(R\)</span>模,以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(X\)</span>生成<span class="math inline">\(M\)</span>而且线性无关.</p></li>
<li><p>每个<span class="math inline">\(m \in
M\)</span>都能唯一表示成有限和<span class="math inline">\(m = \sum_{ x
\in X } r_x x\)</span>.</p></li>
<li><p><span class="math inline">\(\varphi : R^{ \oplus X } \cong
M\)</span>是同构.</p></li>
</ol>
<p>的确容易见到上面命题等价.此时称模<span class="math inline">\(M\)</span>是以<span class="math inline">\(X\)</span>为<strong>基</strong>的自由模.从而见到所有的向量空间其实都是自由模.并且只要我能找到一个模的一组基,那这个模自然成为了自由模.当然也存在非自由模,Example1给出了一个很平凡的非自由模实例.</p>
<p>回忆到线性空间上的基的定义,事实上当<span class="math inline">\(R\)</span>是交换环的时候,它的任意两组基<span class="math inline">\(X , Y\)</span>都满足<span class="math inline">\(|
X | = | Y |\)</span>,从而自然地引出其<strong>秩</strong>为<span class="math inline">\(\mathrm{ rk } ( M ) = | X
|\)</span>的定义.然而这个证明有点艰难,因此我们尝试去证明一个弱些的版本:整环上的有限生成自由模.</p>
<p>此时对于一组基<span class="math inline">\(X\)</span>,则<span class="math inline">\(M \cong R^{ \oplus X }\)</span>.注意到如果<span class="math inline">\(| X | = \infty\)</span>,则<span class="math inline">\(R^{ \oplus X
}\)</span>必然不是有限生成的.因此有限生成自由模的基一定满足<span class="math inline">\(| X | &lt; \infty\)</span>.</p>
<p>而之后的做法只需将<span class="math inline">\(R\)</span>通过分式域<span class="math inline">\(\mathrm{ Frac } ( R
)\)</span>嵌入进向量空间就可以了.</p>
<p>我们还想要像线性空间一样,将<span class="math inline">\(\mathrm{ Hom
}_R ( R^n , R^m ) \cong M_{ m \times n } ( R
)\)</span>,这里取右模是方便的(因为需要标量乘法),也就是:</p>
<p><span class="math display">\[
\begin{bmatrix}
x_1 \\
\vdots \\
x_n
\end{bmatrix} \mapsto A \begin{bmatrix}
x_1 \\
\vdots \\
x_n
\end{bmatrix}
\]</span></p>
<p>用右模的好处是标量乘法可以看作<span class="math inline">\(1 \times
1\)</span>的矩阵乘法:</p>
<p><span class="math display">\[
\begin{bmatrix}
x_1 t \\
\vdots \\
x_n t
\end{bmatrix} \mapsto A \begin{bmatrix}
x_1 t \\
\vdots \\
x_n t
\end{bmatrix} = A \begin{bmatrix}
x_1 \\
\vdots \\
x_n
\end{bmatrix} t
\]</span></p>
<p>至于证明只需要化到基上即可.</p>
<h6><span id="example1非自由模">Example1(非自由模)</span></h6>
<p>取<span class="math inline">\(R = \mathbb{ Z } , M = \mathbb{ Z } / n
\mathbb{ Z }\)</span>,其中<span class="math inline">\(n \ne 0 , \pm
1\)</span>.此时立刻见到<span class="math inline">\(M\)</span>必定不是自由的,因为不存在一个<span class="math inline">\(X\)</span>使得<span class="math inline">\(M \cong
\mathbb{ Z }^{ \oplus X }\)</span>,原因是左侧是有限的<span class="math inline">\(n\)</span>个元素,而右侧要么是单个元素,要么是无穷多元素.</p>
<h4><span id="线性映射和模结构">线性映射和模结构</span></h4>
<p>回忆到<span class="math inline">\(F [ x ]\)</span>是一个自然的<span class="math inline">\(F\)</span>向量空间.我们的问题是如若<span class="math inline">\(V\)</span>是<span class="math inline">\(F\)</span>上的向量空间,能否将其升级为一个<span class="math inline">\(F [ x ]\)</span>上的模.</p>
<p>我们先指定一个<span class="math inline">\(V\)</span>上的线性变换<span class="math inline">\(T \in \mathrm{ End } ( V )\)</span>,考虑<span class="math inline">\(\forall f \in F [ x ]\)</span>,<span class="math inline">\(f ( T ) \in \mathrm{ End } ( V
)\)</span>,直接将其作用在<span class="math inline">\(V\)</span>上就得到了一个<span class="math inline">\(F [ x ]\)</span>上的模.换言之就是将<span class="math inline">\(x \cdot v \mapsto T ( v
)\)</span>.我们现在想要证明所有可以使得<span class="math inline">\(V\)</span>升级为<span class="math inline">\(F [ x
]\)</span>模的办法,均可以转化为指定一个映射<span class="math inline">\(T
\in \mathrm{ End } ( V )\)</span>.</p>
<p>对此进行说明,将<span class="math inline">\(F\)</span>上的向量空间<span class="math inline">\(V\)</span>升级为<span class="math inline">\(F [ x
]\)</span>上的模等价于说对所有<span class="math inline">\(f \in F [ x
]\)</span>指定对应于纯量乘法的映射<span class="math inline">\(\rho_f : V
\to V\)</span>,使得:</p>
<ol type="1">
<li><p><span class="math inline">\(\rho_f ( v_1 + v_2 ) = \rho_f ( v_1 )
+ \rho_f ( v_2 )\)</span>.</p></li>
<li><p><span class="math inline">\(\rho_{ f + g } ( v ) = \rho_f ( v ) +
\rho_g ( v )\)</span>.</p></li>
<li><p><span class="math inline">\(\rho_{ fg } ( v ) = \rho_f ( \rho_g (
v ) )\)</span>.</p></li>
<li><p>当<span class="math inline">\(c \in F\)</span>的时候,应该有<span class="math inline">\(\rho_c ( v ) =
cv\)</span>,以保证原本的向量空间结构.</p></li>
</ol>
<p>容易检验当我们指定映射<span class="math inline">\(T\)</span>后的确能使其升级为<span class="math inline">\(F [ x ]\)</span>上的模.下面我们说明将<span class="math inline">\(V\)</span>升级为<span class="math inline">\(F [ x
]\)</span>上的模的过程一定对应了一个映射<span class="math inline">\(T
\in \mathrm{ End }\)</span>.</p>
<p>假设<span class="math inline">\(V\)</span>已经升级为<span class="math inline">\(F [ x ]\)</span>模,那么考虑证明<span class="math inline">\(\rho_x\)</span>必须是个线性变换即可.而由上面我们说的,<span class="math inline">\(\rho_x ( v_1 + v_2 ) = \rho_x ( v_1 ) + \rho_x (
v_2 )\)</span>,并且有<span class="math inline">\(\rho_x ( cv ) = \rho_{
xc } ( v ) = c \rho_x ( v )\)</span>,这就搞定了.</p>
<p>而如果考虑模之间的映射<span class="math inline">\(\varphi : V \to V
&#39;\)</span>,则<span class="math inline">\(\varphi\)</span>是模同态等价于:</p>
<ol type="1">
<li><p><span class="math inline">\(\varphi ( c_1 v_1 + c_2 v_2 ) = c_1
\varphi ( v_1 ) + c_2 \varphi ( v_2 )\)</span>.</p></li>
<li><p><span class="math inline">\(\varphi f ( T ) = f ( T &#39; )
\varphi\)</span>.</p></li>
</ol>
<p>(1)使得<span class="math inline">\(\varphi\)</span>必须为一个线性映射,既然如此(2)中就可以拆开<span class="math inline">\(f ( T )\)</span>,也就变成了要求<span class="math inline">\(\forall n \geq 0\)</span>,都有<span class="math inline">\(( T &#39; )^n \circ \varphi = \varphi \circ
T^n\)</span>.容易见到只需满足<span class="math inline">\(T &#39; \varphi
= \varphi
T\)</span>即可数学归纳满足上面的性质.乍一看可能觉得这个等式比较奇怪,但我们可以将其写作交换图表:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^\varphi \ar[d]_T &amp; V &#39; \ar[d]^{ T &#39; } \\
V \ar[r]_\varphi &amp; V &#39; \\
}
\]</span></p>
<p>如果<span class="math inline">\(\varphi\)</span>是同构,那这当然等价于<span class="math inline">\(T &#39; = \varphi T \varphi^{ - 1 }\)</span>.</p>
<p>我们现在想要做一些更深的操作,能不能干脆对所有<span class="math inline">\(F [ x ]\)</span>上的模结构<span class="math inline">\(( V , T )\)</span>进行分类呢?不妨设<span class="math inline">\(\dim_F V = n &lt;
\infty\)</span>,既然如此就有<span class="math inline">\(V \cong
F^n\)</span>.既然如此指定<span class="math inline">\(T\)</span>无非是指定矩阵<span class="math inline">\(F^{ n \times n
}\)</span>,因此在同构意义下分类<span class="math inline">\(F [ x
]\)</span>上的模结构等价于分类共轭的<span class="math inline">\(n \times
n\)</span>的矩阵.换言之分类共轭的<span class="math inline">\(n \times
n\)</span>的矩阵也就相当于同构意义下分类<span class="math inline">\(F [
x ]\)</span>上的模结构.回忆到<span class="math inline">\(F [ x
]\)</span>是PID(主理想环),而<span class="math inline">\(\dim V &lt;
\infty\)</span>导出<span class="math inline">\(V\)</span>是有限生成的.</p>
<h4><span id="主理想环上的有限生成模">主理想环上的有限生成模</span></h4>
<p>考虑<span class="math inline">\(R\)</span>是一个交换环,<span class="math inline">\(I \subseteq R\)</span>是一个理想,考虑一个<span class="math inline">\(R\)</span>上的模<span class="math inline">\(M\)</span>,现在考虑定义<span class="math inline">\(M [ I ] = \{ x \in M | \forall a \in I , ax = 0
\}\)</span>为<span class="math inline">\(I\)</span>所零化的子模(容易检验封闭性).当<span class="math inline">\(I = ( h ) = \{ hr | r \in R
\}\)</span>的时候,我们记作<span class="math inline">\(M [ I ] = M [ h
]\)</span>,原因是显然此时只需要<span class="math inline">\(h\)</span>零化即可.进一步地,留意到<span class="math inline">\(M [ I ] = \bigcap_{ h \in I } M [ h
]\)</span>.</p>
<p>考虑当<span class="math inline">\(R\)</span>是整环的时候,如果<span class="math inline">\(x \in M , \exists h \in R \setminus \{ 0 \} , x
\in M [ h ]\)</span>,我们称<span class="math inline">\(x\)</span>是一个<strong>挠元</strong>.容易见到自由模无挠.</p>
<p>接下来考虑所有挠元组成的集合称为<strong>挠子模</strong><span class="math inline">\(M_{ tors
}\)</span>,我们下面来证明它是一个子模.</p>
<p>如若<span class="math inline">\(x , y \in M_{ tors
}\)</span>,则存在<span class="math inline">\(r , s \in R \setminus \{ 0
\}\)</span>,<span class="math inline">\(rx = sy =
0\)</span>,由于此时我们在看整环,所以<span class="math inline">\(rs \ne
0\)</span>.留神到:<span class="math inline">\(rs ( ax + by ) = 0 ,
\forall a , b \in R\)</span>.于是就拿到了封闭性.</p>
<p>定义<strong>无挠商</strong>为<span class="math inline">\(M_{ tf } = M
/ M_{ tors }\)</span>.下面我们来证明其中的确没有挠元.</p>
<p>考虑<span class="math inline">\(\bar{ x } \in M_{ tf } , \bar{ x } =
x + M_{ tors }\)</span>.如若<span class="math inline">\(\exists r \in R
\setminus \{ 0 \}\)</span>使得<span class="math inline">\(r \bar{ x } =
0\)</span>,意味着<span class="math inline">\(rx + M_{ tors } = M_{ tors
}\)</span>,这意味着<span class="math inline">\(rx \in M_{ tors
}\)</span>,既如此则<span class="math inline">\(\exists s \in R \setminus
\{ 0 \}\)</span>使得<span class="math inline">\(s ( rx ) = ( sr ) x = 0
\Rightarrow x \in M_{ tors }\)</span>,所以我们这个的确是无挠的.</p>
<p>接下来看<span class="math inline">\(R\)</span>是PID的情形,此时考虑任何一个<span class="math inline">\(t\)</span>都可以被分解为<span class="math inline">\(t \sim p_1^{ a_1 } \cdots p_m^{ a_m } , a_i \geq
0\)</span>.我们下面来证明此时<span class="math inline">\(M [ t ] =
\bigoplus_{ i = 1 }^m M [ p_i^{ a_i } ]\)</span>.</p>
<p>其实只需要证明<span class="math inline">\(t = ab\)</span>,其中<span class="math inline">\(a , b\)</span>互素就可以推出<span class="math inline">\(M [ t ] = M [ a ] \oplus M [ b
]\)</span>就行了对吧.和我们之前证明极小多项式的结论时的策略完全一致:</p>
<p>先证明<span class="math inline">\(M [ t ] = M [ a ] + M [ b
]\)</span>,考虑<span class="math inline">\(x \in M [ t
]\)</span>,留意到存在<span class="math inline">\(u , v\)</span>使得<span class="math inline">\(au + bv = 1\)</span>,所以<span class="math inline">\(\forall x \in t\)</span>,<span class="math inline">\(x = aux + bvx \in M [ b ] + M [ a ]\)</span>.</p>
<p>在证明<span class="math inline">\(M [ a ] \cap M [ b ] = \{ 0
\}\)</span>,设<span class="math inline">\(x \in M [ a ] \cap M [ b
]\)</span>,则<span class="math inline">\(x = aux + bvx = 0\)</span>.</p>
<p>接下来我们证明<span class="math inline">\(M [ a ] \cap M [ b ] = M [
\gcd ( a , b ) ]\)</span>.裴蜀定理告诉我们存在一对<span class="math inline">\(u , v\)</span>使得<span class="math inline">\(\gcd
( a , b ) = au + bv\)</span>,因此<span class="math inline">\(M [ \gcd (
a , b ) ] \supseteq M [ a ] \cap M [ b ]\)</span>,反之如若<span class="math inline">\(x \in M [ \gcd ( a , b ) ]\)</span>,则<span class="math inline">\(x \in M [ a ] , x \in M [ b
]\)</span>,这就搞定了.</p>
<p>接下来考虑<span class="math inline">\(p\)</span>是PID里的一个素元,容易见到<span class="math inline">\(M [ p ] \subseteq M [ p^2 ]
\cdots\)</span>,定义<span class="math inline">\(M [ p^\infty ] =
\bigcup_{ i \geq 1 } M [ p^i ]\)</span>.如果<span class="math inline">\(\exists t \in R , t \ne 0 , M = M [ t
]\)</span>.此时考虑对<span class="math inline">\(t\)</span>作分解,应该得到<span class="math inline">\(M = \oplus M [ p_i^{ a_i }
]\)</span>.事实上此时我们可以直接说<span class="math inline">\(M =
\oplus_{ p } M [ p^\infty ]\)</span>,原因是考虑当<span class="math inline">\(n \geq p^{ a_p }\)</span>时候,有<span class="math inline">\(M [ p^n ] = M [ p^n ] \cap M [ t ] = M [ p^{ a_p }
]\)</span>.</p>
<p>下面干脆假设<span class="math inline">\(M = R / ( t )\)</span>,<span class="math inline">\(p\)</span>是<span class="math inline">\(R\)</span>中的素元,我们有以下结论:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(p^a | t\)</span>,则<span class="math inline">\(( R / ( t ) ) [ p^a ] \cong R / ( p^a
)\)</span>.</p></li>
<li><p>如果<span class="math inline">\(p^a | t , p^{ a + 1 } \nmid
t\)</span>,则<span class="math inline">\(( R / ( t ) ) [ p^\infty ]
\cong R / ( p^a )\)</span>.</p></li>
</ol>
<p>对于(1),如若<span class="math inline">\(p^a | t\)</span>,考虑<span class="math inline">\(\bar{ x } = x + ( t ) \in R / ( t
)\)</span>,如若满足<span class="math inline">\(p^a \bar{ x } = 0
\Leftrightarrow \exists y , p^a x = ty\)</span>,此时取<span class="math inline">\(s = \frac{ t }{ p^a
}\)</span>,于是上述条件立刻等价于<span class="math inline">\(x \in ( s
)\)</span>.所以<span class="math inline">\(( R / ( t ) ) [ p^a ] = ( s )
/ ( t )\)</span>.然而我们有一个满射<span class="math inline">\(R \to ( s
) / ( t ) : y \mapsto sy + ( t )\)</span>,观察其<span class="math inline">\(\ker = \{ y \in R : t | sy \} = ( p^a
)\)</span>,由同态定理知道<span class="math inline">\(( R / ( t ) ) [ p^a
] \cong R / ( p^a )\)</span>.</p>
<p>对于(2),我们已经说过了<span class="math inline">\(M [ p^\infty ] = M
[ p^a ]\)</span>,于是由(1)就做完了.</p>
<h5><span id="自由模与其子模">自由模与其子模</span></h5>
<p>回忆到Noether性质:任何一个理想链最终都会稳定.那同理可以定义一个<span class="math inline">\(R\)</span>上的模<span class="math inline">\(M\)</span>是有Noether性质的,当它的任何一个子模链都会趋于稳定.回忆到如果<span class="math inline">\(R\)</span>是一个PID,则它当然有Noether性质,同时它作为自己的模也具有Noether性质(它的子模其实就是子理想).</p>
<p>下面我们来证明,如果一个模<span class="math inline">\(M\)</span>具有Noether性质,那它是有限生成的.</p>
<p>证明非常简单,考虑反证,如果其不是有限生成的,那我们考虑任意<span class="math inline">\(x_1\)</span>,<span class="math inline">\(Rx_1\)</span>不能生成<span class="math inline">\(M\)</span>,取<span class="math inline">\(x_2 \in M
\setminus ( Rx_1 )\)</span>,则<span class="math inline">\(Rx_1 +
Rx_2\)</span>也不能生成<span class="math inline">\(M\)</span>,以此类推,这就得到了一个无穷增大的子模链,不符合Noether性质.</p>
<p>接下来引入一个引理:设<span class="math inline">\(R\)</span>是一个交换环,<span class="math inline">\(M\)</span>是<span class="math inline">\(R\)</span>上的一个模,而且<span class="math inline">\(M &#39;\)</span>是<span class="math inline">\(M\)</span>的一个子模,如果<span class="math inline">\(M &#39; &#39; = M / M &#39;\)</span>,那么<span class="math inline">\(M\)</span>有Noether性质等价于<span class="math inline">\(M &#39;\)</span>和<span class="math inline">\(M
&#39; &#39;\)</span>都有Noether性质.</p>
<p>先来看必要性,假设<span class="math inline">\(M\)</span>有Noether性质,则其子模<span class="math inline">\(M &#39;\)</span>的子模列当然也是<span class="math inline">\(M\)</span>中的子模列,所以<span class="math inline">\(M &#39;\)</span>必定有Noether性质.而反之<span class="math inline">\(M &#39;
&#39;\)</span>中的子模列当然可以取原像回到<span class="math inline">\(M\)</span>中,必定也是Noetherian的.</p>
<p>再来看充分性,考虑<span class="math inline">\(M\)</span>中的一列子模<span class="math inline">\(M_1 \subseteq M_2 \subseteq
\cdots\)</span>.取<span class="math inline">\(M_i &#39; = M_i \cap M
&#39;\)</span>,<span class="math inline">\(M_i &#39; &#39; = ( M_i + M
&#39; ) / M &#39;\)</span>.它们当然分别是<span class="math inline">\(M
&#39;\)</span>和<span class="math inline">\(M &#39;
&#39;\)</span>中的子模列,所以存在一个<span class="math inline">\(i_0 ,
\forall i \geq i_0\)</span>,<span class="math inline">\(M_i &#39; = M_{
i + 1 } &#39; , M_i &#39; &#39; = M_{ i + 1 } &#39;
&#39;\)</span>.下面我们试图证明当<span class="math inline">\(i \geq
i_0\)</span>的时候此时也有<span class="math inline">\(M_i = M_{ i + 1
}\)</span>,这只需证明<span class="math inline">\(M_i \supseteq M_{ i + 1
}\)</span>.</p>
<p>考虑<span class="math inline">\(\forall x \in M_{ i + 1 } , x + M
&#39; \in M_{ i + 1 } &#39; &#39; = M_i &#39;
&#39;\)</span>,从而我们知道一定存在一个<span class="math inline">\(y \in
M_i\)</span>使得<span class="math inline">\(x + M &#39; = y + M
&#39;\)</span>,意味着<span class="math inline">\(x - y \in M
&#39;\)</span>,而<span class="math inline">\(x \in M_{ i } \subseteq M_{
i + 1 }\)</span>,所以<span class="math inline">\(x - y \in M &#39; \cap
M_{ i + 1 } = M_{ i + 1 } &#39; = M_i &#39; \subseteq
M_i\)</span>,由于<span class="math inline">\(y \in
M_i\)</span>,自然导出<span class="math inline">\(x \in
M_i\)</span>.从而证毕.</p>
<p>其实用第二同构定理见到<span class="math inline">\(M_i &#39; &#39;
\cong M_i / M_i &#39;\)</span>也就搞定了.</p>
<p>现在我们有了如上引理,我们可以得知以下推论:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(M_1 ,
M_2\)</span>都是Noether模,则<span class="math inline">\(M_1 \oplus
M_2\)</span>也是Noether模.</p></li>
<li><p>作为(1)的推论,如果<span class="math inline">\(R\)</span>是一个PID,<span class="math inline">\(E\)</span>是一个<span class="math inline">\(R\)</span>上的自由模,如果<span class="math inline">\(E\)</span>是有限生成的,则<span class="math inline">\(E\)</span>是Noether模.</p></li>
<li><p>作为(2)的推论,有限生成自由模的子模总是有限生成的.</p></li>
</ol>
<h5><span id="smith标准型">Smith标准型</span></h5>
<p>最后要做的是在模上引入矩阵符号,对于交换环<span class="math inline">\(R\)</span>上的模<span class="math inline">\(M\)</span>,假设<span class="math inline">\(e_1 ,
\cdots , e_n \in M\)</span>且<span class="math inline">\(x_1 , \cdots ,
x_m \in M\)</span>,取矩阵<span class="math inline">\(A \in M_{ n \times
m } ( R )\)</span>,此时记<span class="math inline">\(( x_1 , \cdots ,
x_m ) = ( e_1 , \cdots , e_n ) A\)</span>,当且仅当<span class="math inline">\(x_j = \sum_{ i = 1 }^n e_i a_{ i , j
}\)</span>.容易检查以下结论:</p>
<ol type="1">
<li><p><span class="math inline">\(( e_1 , \cdots , e_n ) AB = ( e_1 ,
\cdots , e_n ) ( AB )\)</span>.</p></li>
<li><p><span class="math inline">\(( e_1 , \cdots , e_n ) I = ( e_1 ,
\cdots , e_n )\)</span>.</p></li>
<li><p>如果<span class="math inline">\(e_1 , \cdots ,
e_n\)</span>线性无关,则<span class="math inline">\(A\)</span>若存在则唯一确定.</p></li>
</ol>
<p>同时Cramer法则告诉我们,当<span class="math inline">\(\det A \in
R^\times\)</span>的时候,<span class="math inline">\(A\)</span>一定存在逆矩阵<span class="math inline">\(B\)</span>使得<span class="math inline">\(AB = BA
= I\)</span>,这也很显然是<span class="math inline">\(A\)</span>存在逆矩阵的充要条件,因为<span class="math inline">\(\det B = \frac{ 1 }{ \det A
}\)</span>.还可以检查如下结论:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(( y_1 &#39; , \cdots , y_n &#39;
) = ( y_1 , \cdots , y_n ) P\)</span>,其中<span class="math inline">\(P\)</span>可逆,则<span class="math inline">\(\sum
Ry_i = \sum R y_i &#39;\)</span>.</p></li>
<li><p>设<span class="math inline">\(( e_1 , \cdots , e_n
)\)</span>为基,则<span class="math inline">\(( e_1 &#39; , \cdots , e_n
&#39; ) = ( e_1 , \cdots , e_n ) A\)</span>是另一组基,当且仅当<span class="math inline">\(A\)</span>可逆.</p></li>
</ol>
<p>现在考虑自由模<span class="math inline">\(E\)</span>,其基为<span class="math inline">\(e_1 , \cdots , e_n\)</span>,其有一个子模<span class="math inline">\(N\)</span>,可以被<span class="math inline">\(x_1 ,
\cdots , x_m\)</span>生成.考虑取一个唯一的矩阵<span class="math inline">\(A\)</span>满足<span class="math inline">\(( x_1 ,
\cdots , x_m ) = ( e_1 , \cdots , e_m ) A\)</span>,此时发现如果将<span class="math inline">\(A\)</span>换成<span class="math inline">\(AP\)</span>,其中<span class="math inline">\(P\)</span>是一个可逆矩阵,则<span class="math inline">\(( x_1 , \cdots , x_m
)\)</span>会被改变.如果将<span class="math inline">\(A\)</span>换成<span class="math inline">\(QA\)</span>,则<span class="math inline">\(( e_1 ,
\cdots , e_n )\)</span>会被改变.</p>
<p>由此我们有<strong>Smith标准型</strong>:当<span class="math inline">\(R\)</span>是PID的时候,对于矩阵<span class="math inline">\(A \in M_{ n \times m
}\)</span>,总存在两个可逆矩阵<span class="math inline">\(P ,
Q\)</span>,使得<span class="math inline">\(d_1 | d_2 | \cdots \in
R\)</span>使得<span class="math inline">\(A = Q \begin{bmatrix}d_1 &amp;
&amp; \\ &amp; d_2 &amp; \\ &amp; &amp; \ddots\end{bmatrix}
P\)</span>.</p>
<p>上述结论对欧几里得整环是平凡结论,而且还可以计算.</p>
<p>那么对于PID怎么办呢?难点当然在于现在我们没有办法任意做欧几里得算法了,也许唯一的工具只有裴蜀定理.</p>
<p>考虑数学归纳,如果<span class="math inline">\(A =
0\)</span>那当然已经搞定了对吧,否则我们总可以做点初等变换使得<span class="math inline">\(A\)</span>的左上角元素不为<span class="math inline">\(0\)</span>.</p>
<p>现在假设第一列第一行元素为<span class="math inline">\(a \ne
0\)</span>,第一列第二行元素为<span class="math inline">\(b \ne
0\)</span>,取<span class="math inline">\(d = \gcd ( a , b ) , u = -
\frac{ b }{ d } , v = \frac{ a }{ d }\)</span>,用裴蜀定理拿到<span class="math inline">\(sa + tb = d\)</span>,然后用下述矩阵左乘:</p>
<p><span class="math display">\[
\begin{bmatrix}
s &amp; t &amp; &amp; &amp; \\
u &amp; v &amp; &amp; &amp; \\
&amp; &amp; 1 &amp; &amp; \\
&amp; &amp; &amp; \ddots &amp; \\
&amp; &amp; &amp; &amp; 1
\end{bmatrix}
\]</span></p>
<p>就可以让第一列第二行的元素变成<span class="math inline">\(0\)</span>.不断做此过程,矩阵变为:</p>
<p><span class="math display">\[
\begin{bmatrix}
d_1 &#39; &amp; \\
&amp; A_1
\end{bmatrix}
\]</span></p>
<p>其中<span class="math inline">\(d_1 &#39;\)</span>是<span class="math inline">\(A\)</span>的第一行第一列所有元素的<span class="math inline">\(\gcd\)</span>,继续做此操作得到:</p>
<p><span class="math display">\[
\begin{bmatrix}
d_1 &#39; &amp; &amp; \\
&amp; d_2 &#39; &amp; \\
&amp; &amp; A_1
\end{bmatrix}
\]</span></p>
<p>如果<span class="math inline">\(d_1 &#39; \nmid d_2
&#39;\)</span>,那我们就把第二列加到第一列上,然后重复以上操作,从而使得左上角变成<span class="math inline">\(\gcd ( d_1 &#39; , d_2 &#39;
)\)</span>.这样我们就搞定了.</p>
<h5><span id="结构定理">结构定理</span></h5>
<p>扔出一个<strong>结构定理</strong>:<span class="math inline">\(R\)</span>是一个PID,<span class="math inline">\(M\)</span>是一个<span class="math inline">\(R\)</span>模,我们都可以将<span class="math inline">\(M\)</span>拆成:</p>
<p><span class="math display">\[
M \cong ( R / I_1 ) \oplus \cdots \oplus ( R / I_k ) \oplus E
\]</span></p>
<p>其中<span class="math inline">\(I_1 \supseteq \cdots \supseteq I_k
\ne \{ 0 \}\)</span>是<span class="math inline">\(R\)</span>上的一列真理想,而<span class="math inline">\(E\)</span>是一个<span class="math inline">\(R\)</span>上的自由模.</p>
<p>并且上述拆法是有唯一性的,也就是如果还存在另一组拆法:</p>
<p><span class="math display">\[
M \cong ( R / J_1 ) \oplus \cdots \oplus ( R / J_{ k &#39; } ) \oplus E
&#39;
\]</span></p>
<p>则<span class="math inline">\(k = k &#39; , I_1 = J_1 , \cdots , I_k
= J_{ k &#39; } , E \cong E &#39;\)</span>.</p>
<p>回忆到<span class="math inline">\(E\)</span>既然是整环上的有限生成自由模,那它可以同构于<span class="math inline">\(R^{ rk ( E )
}\)</span>.因此我们可以在上述一列理想后面补<span class="math inline">\(\mathrm{ rk } ( E )\)</span>个<span class="math inline">\(\{ 0 \}\)</span>.这样就可以简写作:</p>
<p><span class="math display">\[
M \cong ( R / I_1 ) \oplus \cdots \oplus ( R / I_k )
\]</span></p>
<p>这组<span class="math inline">\(I_1 \supseteq \cdots \supseteq I_k
\supseteq \{ 0 \} \cdots\)</span>被称为<span class="math inline">\(M\)</span>的一组<strong>不变因子</strong>.</p>
<p>此时我们回忆到PID中的自由模不能有挠元,而前面商掉的部分全是挠元,因此结构定理会给出<span class="math inline">\(( R / I_1 ) \oplus \cdots \oplus ( R / I_k ) \cong
M_{ tors } = M [ I_k ] = M [ f_k ]\)</span>.</p>
<p>其实这也可以写成结构定理的第二种形式:</p>
<p><span class="math display">\[
M_{ tors } \cong \bigoplus_p M_{ tors } [ p^\infty ] \cong \bigoplus_{ p
| f_k , p \in \mathrm{ prime } } \bigoplus_i R / ( p^{ b_i ( p ) } )
\]</span></p>
<p>其中<span class="math inline">\(\forall p , 0 \leq b_1 ( p ) \leq
\cdots \leq b_k ( p
)\)</span>.我们将这一列称为<strong>初等因子</strong>.</p>
<p>现在我们着手证明结构定理,首先给出如下引理:</p>
<p>设<span class="math inline">\(E\)</span>为主理想环<span class="math inline">\(R\)</span>上的自由模,秩为<span class="math inline">\(n\)</span>,而<span class="math inline">\(N\)</span>是其子模,我们下面证明存在<span class="math inline">\(E\)</span>的一组基<span class="math inline">\(f_1
, \cdots , f_n\)</span>以及<span class="math inline">\(R\)</span>的一列元素<span class="math inline">\(d_1 | \cdots | d_n\)</span>,令<span class="math inline">\(r = \max \{ i | d_i \ne 0 \}\)</span>,则<span class="math inline">\(d_1 f_1 , \cdots , d_r f_r\)</span>构成<span class="math inline">\(N\)</span>的基.</p>
<p>回忆到自由模的子模一定是有限生成的而且秩不超过<span class="math inline">\(n\)</span>,此时取<span class="math inline">\(x_1 ,
\cdots , x_m\)</span>是<span class="math inline">\(N\)</span>的一组生成元,则存在一个唯一的<span class="math inline">\(A\)</span>使得<span class="math inline">\(( x_1 ,
\cdots , x_m ) = ( e_1 , \cdots , e_n )
A\)</span>,由Smith标准型,式子变成:</p>
<p><span class="math display">\[
( x_1 , \cdots , x_m ) P^{ - 1 } = ( e_1 , \cdots , e_n ) Q
\begin{bmatrix}
d_1 &amp; &amp; \\
&amp; d_2 &amp; \\
&amp; &amp; \ddots
\end{bmatrix}
\]</span></p>
<p>此时观察左侧的确给出了一组<span class="math inline">\(N\)</span>的一组生成元,而右侧的<span class="math inline">\(( e_1 , \cdots , e_n )
Q\)</span>给出了另一组基<span class="math inline">\(( f_1 , \cdots , f_n
)\)</span>.这就完事了.</p>
<p>此时我们有了如上引理,来证明结构定理的存在性.对于有限生成模<span class="math inline">\(M\)</span>,由定义知道存在一组元素<span class="math inline">\(\langle x_1 , \cdots , x_n \rangle =
M\)</span>.既然如此考虑取<span class="math inline">\(E = R^{ \otimes n
}\)</span>,考虑模同态<span class="math inline">\(E \to M , ( r_i )_{ i =
1 }^n \mapsto \sum_{ i = 1 }^n r_i
x_i\)</span>,容易见到这显然是个满同态,因此取其<span class="math inline">\(\ker = N\)</span>,自然有<span class="math inline">\(M \cong E / N\)</span>.根据引理,可以拿到<span class="math inline">\(N\)</span>的一组基<span class="math inline">\(d_1
f_1 , \cdots , d_r f_r\)</span>,此时见到:</p>
<p><span class="math display">\[
M \cong \cfrac{ Rf_1 \oplus \cdots \oplus R f_n }{ Rd_1 f_1 \oplus
\cdots Rd_r f_r }
\]</span></p>
<p>然而对于单个的<span class="math inline">\(f_n\)</span>来说,自然有<span class="math inline">\(Rf_n \cong R\)</span>,而且如果<span class="math inline">\(N_1\)</span>是<span class="math inline">\(M_1\)</span>的子模,<span class="math inline">\(N_2\)</span>是<span class="math inline">\(M_2\)</span>的子模,并且<span class="math inline">\(M_1 \cap M_2 = \{ 0 \}\)</span>,容易检验<span class="math inline">\(( M_1 \oplus M_2 ) / ( N_1 \oplus N_2 ) \cong (
M_1 / N_1 ) \oplus ( M_2 / N_2 )\)</span>,而<span class="math inline">\(( Rf_i ) / ( Rd_i f_i ) \cong R / ( d_i
)\)</span>,这就搞定了存在性的部分.</p>
<p>接下来来证明唯一性,假设:</p>
<p><span class="math display">\[
M \cong ( R / I_1 ) \oplus \cdots \oplus ( R / I_k ) \oplus E \cong ( R
/ J_1 ) \oplus \cdots \oplus ( R / J_{ k &#39; } ) \oplus E &#39;
\]</span></p>
<p>然而我们已经知道<span class="math inline">\(E \cong M_{ tf
}\)</span>而且<span class="math inline">\(E &#39; \cong M_{ tf
}\)</span>,因此有<span class="math inline">\(E \cong E
&#39;\)</span>.因此我们将问题化约到没有自由部分的特例.于此使用初等因子形式的证明,考虑<span class="math inline">\(M [ p^\infty ]\)</span>自然是其中所有的<span class="math inline">\(R / ( p^j
)\)</span>结构,因此必然只涉及它们的部分会同构,此时化约到已知为:</p>
<p><span class="math display">\[
R / ( p^{ b_1 } ) \oplus \cdots \oplus R / ( p^{ b_k } ) \cong R / ( p^{
b_1 &#39; } ) \oplus \cdots \oplus R / ( p^{ b_{ k &#39; } &#39; } )
\]</span></p>
<p>为证明这些项对应相同,需要将这些东西等同于某种空间上的结构,我们先来着手证明<span class="math inline">\(k = k &#39;\)</span>.回忆到<span class="math inline">\(M [ p ] = \bigoplus_{ i } ( R / ( p^{ b_i } ) ) [
p ] = \bigoplus_{ i } R / ( p )\)</span>,此时见到<span class="math inline">\(M [ p ]\)</span>实际上也可以表示为<span class="math inline">\(R / ( p
)\)</span>上的向量空间(回忆到主理想环商掉素理想后得到了一个域),而且<span class="math inline">\(\dim_{ R / ( p ) } M [ p ] =
k\)</span>,因此必然有<span class="math inline">\(k = k
&#39;\)</span>.</p>
<p>类似上面,考虑对于一个固定的<span class="math inline">\(a \geq
1\)</span>,考察<span class="math inline">\(p^c M = \bigoplus_{ i , b_i
&gt; c } p^c R / p^{ b_i } R = \bigoplus_{ i , b_i &gt; c } R / p^{ b_i
- c } R\)</span>,此时观察<span class="math inline">\(( p^c M ) [ p
]\)</span>,它的维度就是满足<span class="math inline">\(b_i &gt;
c\)</span>的<span class="math inline">\(i\)</span>的个数,即可继续见到两遍逐个相同.</p>
<h5><span id="有限生成交换群的分类">有限生成交换群的分类</span></h5>
<p>我们先将交换群<span class="math inline">\(A\)</span>等同于<span class="math inline">\(\mathbb{ Z
}\)</span>上的模.下述用加法群,则上面有自然的倍数运算<span class="math inline">\(\mathbb{ Z } \times A \to A : na \mapsto a + a +
\cdots + a\)</span>.因此交换群立刻等价于<span class="math inline">\(\mathbb{ Z }\)</span>模.</p>
<p>然而模上的结构定理立刻给出:</p>
<p><span class="math display">\[
A \cong \mathbb{ Z } / d_1 \mathbb{ Z } \oplus \cdots \oplus \mathbb{ Z
} / d_k \mathbb{ Z } \oplus \mathbb{ Z }^{ \oplus m }
\]</span></p>
<p>其中<span class="math inline">\(d_1 | \cdots |
d_k\)</span>,这就搞定.</p>
<h4><span id="有理标准型">有理标准型</span></h4>
<p>取定<span class="math inline">\(R = F [ x
]\)</span>,我们可以将一个真理想写作<span class="math inline">\(I_i = (
f_i )\)</span>,其中<span class="math inline">\(f_i \in F [ x ] \setminus
F\)</span>,并且如果进一步要求其首项为一则<span class="math inline">\(f_i\)</span>唯一.</p>
<p>现在来看对于一个固定的多项式<span class="math inline">\(f\)</span>,此时<span class="math inline">\(F [ x ]
/ ( f )\)</span>必然也是一个<span class="math inline">\(F [ x
]\)</span>模,那在上面的<span class="math inline">\(x\)</span>必然也对应了一个矩阵,设<span class="math inline">\(\deg f = n , f = x^n + c_{ n - 1 } x^{ n - 1 } +
\cdots + c_0\)</span>,取其有序基为<span class="math inline">\(\{ 1 + ( f
) , x + ( f ) , \cdots , x^{ n - 1 } + ( f ) \}\)</span>.容易见到<span class="math inline">\(x\)</span>对应的矩阵应该形如:</p>
$$ C_f =
<span class="math display">\[\begin{bmatrix}
0 &amp; 0 &amp; \cdots &amp; 0 &amp; - c_0 \\
1 &amp; 0 &amp; \cdots &amp; 0 &amp; - c_1 \\
0 &amp; 1 &amp; \cdots &amp; 0 &amp; - c_2 \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; 1 &amp; - c_{ n - 1 } \\

\end{bmatrix}\]</span>
<p>$$</p>
<p>这个被称为<strong>友矩阵</strong>.按照最后一列展开见到其特征多项式就是<span class="math inline">\(f\)</span>.</p>
<p>结构定理告诉我们,对于上述的一个模(我们之前说过可以唯一对应一个矩阵<span class="math inline">\(A\)</span>),可以找到唯一的一组首项为一的多项式<span class="math inline">\(f_1 | \cdots | f_k , k \geq 1\)</span>,其中<span class="math inline">\(\sum \deg f_i = n\)</span>,则<span class="math inline">\(A\)</span>可以对应于它们所对应的友矩阵所构成的分块对角矩阵,称为<strong>有理标准型</strong>.</p>
<p>上述的具体细节是次数相关的讨论.对于<span class="math inline">\(A\)</span>对应的<span class="math inline">\(F [ x
]\)</span>上的模<span class="math inline">\(M\)</span>,我们之前已经用结构定理搞定说:</p>
<p><span class="math display">\[
M \cong F [ x ] / ( f_1 ) \oplus \cdots \oplus F [ x ] / ( f_k ) \oplus
E
\]</span></p>
<p>然而回忆到<span class="math inline">\(\dim_F M = n , \dim_F F [ x ] =
+ \infty\)</span>,所以必然有<span class="math inline">\(E = \{ 0
\}\)</span>.既然如此<span class="math inline">\(\sum \dim_F ( F [ x ] /
( f_i ) ) = \sum \deg f_i = n\)</span>.</p>
<p>有理标准型的强大之处在于蕴含了我们之前讲过的很多事情,并且给出了更加简单的描述:我们下面证明:</p>
<ol type="1">
<li><p>极小多项式有<span class="math inline">\(\mathrm{ Min }_A =
f_k\)</span>.</p></li>
<li><p>特征多项式有<span class="math inline">\(\mathrm{ Char }_A =
\prod_{ i = 1 }^k f_i\)</span>.</p></li>
</ol>
<p>先证明(1):如果多项式<span class="math inline">\(h\)</span>满足<span class="math inline">\(h ( A ) = 0\)</span>,由于我们此时已经将<span class="math inline">\(A\)</span>的作用等价于<span class="math inline">\(x\)</span>的作用,因此<span class="math inline">\(h
( x )\)</span>必然作用于每个商模上都是<span class="math inline">\(0\)</span>,那就必然意味着<span class="math inline">\(\forall i , f_i | h \Leftrightarrow f_k |
h\)</span>.</p>
<p>再证明(2):首先我们知道友矩阵的特征多项式满足<span class="math inline">\(\mathrm{ Char }_{ C_f } =
f\)</span>,此时发现证完了,因为直和直接就是每一分模的特征多项式乘积.</p>
<p>回忆到结构定理存在第二种表示方法,我们考虑将<span class="math inline">\(\mathrm{ Min }_A = f_k = p_1^{ a_1 } \cdots p_k^{
a_k }\)</span>,那我们就可以将<span class="math inline">\(A\)</span>同构于若干分块对角矩阵<span class="math inline">\(A_1 , \cdots ,
A_m\)</span>组成的分块对角矩阵,其中每一个<span class="math inline">\(A_i\)</span>亦然可以分解为若干友矩阵<span class="math inline">\(C_{ p_j^{ b } }\)</span>之类的东西.</p>
<p>接下来看如何计算一个有理标准型,考虑<span class="math inline">\(V\)</span>是一个<span class="math inline">\(F\)</span>向量空间,而<span class="math inline">\(T
\in \mathrm{ End } ( V )\)</span>,从而使得<span class="math inline">\(V\)</span>从一个<span class="math inline">\(F\)</span>向量空间升级为一个<span class="math inline">\(F [ x ]\)</span>模.</p>
<p>如果我们能拿到一个满射<span class="math inline">\(\varphi : F [ x ]^{
\oplus n } \to V\)</span>,那考虑<span class="math inline">\(\ker
\varphi\)</span>当然是<span class="math inline">\(F [ x ]^{ \oplus n
}\)</span>的一个子模,既然如此,存在<span class="math inline">\(F [ x ]^{
\oplus n }\)</span>的一组基<span class="math inline">\(f_1 , \cdots ,
f_n\)</span>,以及一组非零多项式<span class="math inline">\(d_1 | \cdots
| d_n\)</span>,使得<span class="math inline">\(\ker \varphi =
\bigoplus_i F [ x ] d_i f_i\)</span>,从而使得<span class="math inline">\(V \cong \bigoplus_i F [ x ] / ( d_i
)\)</span>.</p>
<p>策略当然是简单的,考虑<span class="math inline">\(F [ x ]^{ \oplus n
}\)</span>的一组基<span class="math inline">\(e_1 , \cdots ,
e_n\)</span>,以及<span class="math inline">\(V\)</span>作为向量空间的一组基<span class="math inline">\(v_1 , \cdots , v_n\)</span>,我们要求<span class="math inline">\(\varphi ( e_i ) = v_i , \varphi ( x ) =
T\)</span>,从而<span class="math inline">\(\varphi ( \sum_i r_i e_i ) =
\sum_i r_i ( T )
v_i\)</span>,立刻见到这的确是满射,疑问只在于如何求其<span class="math inline">\(\ker\)</span>.</p>
<p>定义<span class="math inline">\(y_j = xe_j - \sum_{ i = 1 }^n a_{ i ,
j } e_i\)</span>.取<span class="math inline">\(N = \sum_{ j = 1 }^n F [
x ] y_j\)</span>,其中<span class="math inline">\(a_{ i , j
}\)</span>是<span class="math inline">\(T\)</span>再这组基下对应的矩阵元素.此时立刻见到<span class="math inline">\(\varphi ( y_j ) = Tv_j - \sum_{ i } a_{ i , j }
v_i = 0\)</span>,因此<span class="math inline">\(\ker \varphi \supseteq
N\)</span>.</p>
<p>反之,观察到<span class="math inline">\(xe_j = \sum_i a_{ i , j } e_i
+ y_j \in \sum_i a_{ i , j } e_i + N\)</span>,反复做此操作,得知<span class="math inline">\(\forall w \in F [ x ]^{ \bigoplus n } , w \in
\sum_{ i } c_i e_i + N\)</span>,于此做<span class="math inline">\(\varphi\)</span>得到<span class="math inline">\(\varphi ( w ) = 0 \Leftrightarrow \sum_i c_i v_i =
0\)</span>,从而得知所有的<span class="math inline">\(c_i =
0\)</span>.这就证明了<span class="math inline">\(\ker \varphi =
N\)</span>.</p>
<p>观察到<span class="math inline">\(( x_1 , \cdots , x_n ) = ( e_1 ,
\cdots , e_n ) ( xI - A )\)</span>,而<span class="math inline">\(( xI -
A )\)</span>的确是一个定义在<span class="math inline">\(F [ x
]\)</span>上的矩阵,对此用Smith标准型得到<span class="math inline">\((
e_1 , \cdots , e_n ) Q \begin{bmatrix}d_1 &amp; &amp; \\ &amp; \ddots
&amp; \\ &amp; &amp; d_n\end{bmatrix} P\)</span>,这就搞定了.</p>
<h6><span id="example1">Example1</span></h6>
<p>考虑<span class="math inline">\(V = F^3\)</span>,<span class="math inline">\(T = A = \begin{bmatrix}- 1 &amp; - 2 &amp; 6 \\ -
1 &amp; 0 &amp; 3 \\ - 1 &amp; - 1 &amp; 4\end{bmatrix}\)</span>.</p>
<p>首先要做的是计算<span class="math inline">\(xI - A\)</span>,对此:</p>
$$
<span class="math display">\[\begin{aligned}
xI - A &amp; = \begin{bmatrix}
x + 1 &amp; 2 &amp; - 6 \\
1 &amp; x &amp; - 3 \\
1 &amp; 1 &amp; x - 4
\end{bmatrix} \\
&amp; \to \begin{bmatrix}
0 &amp; - x + 1 &amp; - x^2 + 3 x - 2 \\
0 &amp; x - 1 &amp; - x + 1 \\
1 &amp; 1 &amp; x - 4
\end{bmatrix} \\
&amp; \to \begin{bmatrix}
1 &amp; 1 &amp; x - 4 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; - x + 1 &amp; - ( x - 1 ) ( x - 2 )
\end{bmatrix} \\
&amp; \to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; - x + 1 &amp; - ( x - 1 ) ( x - 2 )
\end{bmatrix} \\
&amp; \to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; - x + 1 \\
0 &amp; 0 &amp; - ( x - 1 )^2
\end{bmatrix} \\
&amp; \to \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; x - 1 &amp; 0 \\
0 &amp; 0 &amp; - ( x - 1 )^2
\end{bmatrix} \\

\end{aligned}\]</span>
<p>$$</p>
<p>这样我们就得到了不变因子,得到<span class="math inline">\(T \sim
\begin{bmatrix}1 &amp; &amp; \\ &amp; 0 &amp; - 1 \\ &amp; 1 &amp;
2\end{bmatrix}\)</span>.</p>
<h4><span id="jordan标准型">Jordan标准型</span></h4>
<p>对环上元素<span class="math inline">\(r \in R\)</span>,如果<span class="math inline">\(\exists d \geq 1 , r^d =
0\)</span>,我们称它是<strong>幂零的</strong>.而最小的<span class="math inline">\(d \geq 1\)</span>满足<span class="math inline">\(r^d\)</span>称为<span class="math inline">\(r\)</span>的<strong>幂零指数</strong>.回忆到我们定义过广义特征子空间<span class="math inline">\(V_{ [ \lambda ] } = \ker ( T - \lambda
)^\infty\)</span>.回忆到<span class="math inline">\(\mathrm{ End } ( V
)\)</span>是一个环,<span class="math inline">\(T \in \mathrm{ End } ( V
)\)</span>是其中的一个元素,我们说以下命题等价:</p>
<ol type="1">
<li><p><span class="math inline">\(T \in \mathrm{ End } ( V
)\)</span>是幂零的.</p></li>
<li><p><span class="math inline">\(\exists k , \mathrm{ Min }_T =
x^k\)</span>.</p></li>
<li><p><span class="math inline">\(\mathrm{ Char }_T =
x^n\)</span>.</p></li>
<li><p><span class="math inline">\(V = V_{ [ 0 ] }\)</span>.</p></li>
</ol>
<p>(1)<span class="math inline">\(\Rightarrow\)</span>(2)只需考虑如果<span class="math inline">\(T^k = 0\)</span>,则<span class="math inline">\(\mathrm{ Min }_T | x^k\)</span>.</p>
<p>(2)<span class="math inline">\(\Rightarrow\)</span>(3)是显然的,因为极小多项式和特征多项式共根.</p>
<p>(3)<span class="math inline">\(\Rightarrow\)</span>(4)直接是定义.</p>
<p>(4)<span class="math inline">\(\Rightarrow\)</span>(1),考虑<span class="math inline">\(V_{ [ 0 ]
}\)</span>作为子空间,扩张一定是有限次的,所以也就搞定.</p>
<p>接下来我们定义上三角块<span class="math inline">\(J_d ( \lambda ) =
\begin{bmatrix}\lambda &amp; 1 &amp; &amp; \\ &amp; \ddots &amp; \ddots
&amp; \\ &amp; &amp; \lambda &amp; 1 \\ &amp; &amp; &amp;
\lambda\end{bmatrix}\)</span>以及下三角块<span class="math inline">\((
J_d )^t ( \lambda )\)</span>.容易见到<span class="math inline">\(J_d (
\lambda ) = \lambda I + J_d ( 0 )\)</span>,我们还可以发现下三角块<span class="math inline">\(( J_d )^t ( 0 )\)</span>恰好是多项式<span class="math inline">\(x^d\)</span>的友矩阵.并且容易见到对于<span class="math inline">\(( J_d )^t ( \lambda )\)</span>而言,其<span class="math inline">\(\mathrm{ Min } = \mathrm{ Char } = ( x - \lambda
)^d\)</span>.同理取其转置可以知道<span class="math inline">\(J_d (
\lambda )\)</span>亦然有<span class="math inline">\(\mathrm{ Min } =
\mathrm{ Char } = ( x - \lambda )^d\)</span>.</p>
<p>接下来我们证明,如果<span class="math inline">\(A\)</span>幂零,则存在唯一的正整数列<span class="math inline">\(1 \leq b_1 \leq \cdots \leq b_r\)</span>使得<span class="math inline">\(\sum_{ i = 1 }^r b_i = n\)</span>而<span class="math inline">\(A\)</span>共轭于分块对角矩阵<span class="math inline">\(\begin{bmatrix}J_{ b_1 } ( 0 ) &amp; &amp; \\
&amp; \ddots &amp; \\ &amp; &amp; J_{ b_r } ( 0
)\end{bmatrix}\)</span>,并且如果上述陈述中的<span class="math inline">\(J_{ b_i }\)</span>全换成下三角<span class="math inline">\(( J_{ b_i } )^t\)</span>,结论亦然成立.</p>
<p>这个其实是显然的,因为此时直接取其有理标准型满足<span class="math inline">\(f_1 | \cdots | f_r\)</span>,并且<span class="math inline">\(f_r = x^d\)</span>,设<span class="math inline">\(f_i = x^{ b_i
}\)</span>,自然得到下三角的结论,转置后得到上三角的结论.</p>
<p>接下来假设特征多项式在<span class="math inline">\(F\)</span>上分裂(这当然是必要的,因为Jordan标准型是上三角矩阵,而一个矩阵可上三角化的充要条件是特征多项式在<span class="math inline">\(F\)</span>上分裂),我们设其相异根为<span class="math inline">\(\lambda_1 , \cdots , \lambda_m \in
F\)</span>,存在<span class="math inline">\(V\)</span>的有序基,使得<span class="math inline">\(T\)</span>表为分块对角矩阵<span class="math inline">\(diag ( A_1 , \cdots , A_m )\)</span>,其中<span class="math inline">\(A_j = \begin{bmatrix}J_{ b_1 , j } ( \lambda_j )
&amp; &amp; \\ &amp; \ddots &amp; \\ &amp; &amp; J_{ b_{ r_j } , j } (
\lambda_j )\end{bmatrix}\)</span>.而且每个<span class="math inline">\(j\)</span>对应地正整数数列由<span class="math inline">\(T\)</span>唯一确定,上述矩阵被称为<span class="math inline">\(T\)</span>的Jordan标准型.</p>
<p>证法呼之欲出,取对<span class="math inline">\(T\)</span>的广义特征子空间分解<span class="math inline">\(V = V_{ [ \lambda_1 ] } \oplus \cdots \oplus V_{ [
\lambda_m ] }\)</span>,限制在<span class="math inline">\(V_{ \lambda_j
}\)</span>上,<span class="math inline">\(T_j -
\lambda_j\)</span>幂零,根据上面的结论就做完了.</p>
<p>现在的问题可能在于如何计算Jordan标准型,一种方法是途径有理标准型,另一种方法是依赖于秩的计算.让我们依旧从幂零情形入手,假设<span class="math inline">\(T\)</span>幂零,我们断言:</p>
<ol type="1">
<li><p>在<span class="math inline">\(T\)</span>的Jordan标准型中,Jordan块的总数为<span class="math inline">\(n - \mathrm{ rk } ( T )\)</span>个.</p></li>
<li><p>对于每个<span class="math inline">\(d \geq
1\)</span>,标准型中的<span class="math inline">\(d \times
d\)</span>Jordan块的个数<span class="math inline">\(N ( d
)\)</span>满足:<span class="math inline">\(N ( d ) = \mathrm{ rk } ( T^{
d + 1 } ) + \mathrm{ rk } ( T^{ d - 1 } ) - 2 \mathrm{ rk } ( T^d
)\)</span>.</p></li>
</ol>
<p>(1)是显然的,因为一个<span class="math inline">\(d \times
d\)</span>的Jordan块的秩为<span class="math inline">\(d -
1\)</span>.</p>
<p>而容易见到<span class="math inline">\(\mathrm{ rk } ( J_b ( 0 )^k ) =
\max ( 0 , b - k )\)</span>,从而:</p>
$$
<span class="math display">\[\begin{aligned}
\mathrm{ rk } ( T^{ d + 1 } ) - \mathrm{ rk } ( T^d ) &amp; = \sum_{ j :
b_j \geq d + 1 } ( - 1 ) \\
\mathrm{ rk } ( T^{ d } ) - \mathrm{ rk } ( T^{ d - 1 } ) &amp; = \sum_{
j : b_j \geq d } ( - 1 ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>两式相减即可得到答案.</p>
<p>至于对其余情形,只需观察到当<span class="math inline">\(\lambda_i \ne
\lambda_j\)</span>的时候,<span class="math inline">\(A_i - \lambda_j
I\)</span>肯定可逆,因此:</p>
<p><span class="math display">\[
N_j ( d ) = \mathrm{ rk } ( T - \lambda_j I )^{ d + 1 } + \mathrm{ rk }
( T - \lambda_j I )^{ d - 1 } - 2 \mathrm{ rk } ( T - \lambda_j I )^d
\]</span></p>
<p>便数平凡.</p>
<p>可以见到Jordan标准型的每一个块,如果特征值为<span class="math inline">\(0\)</span>,实际上是把基向前挪动.</p>
<h5><span id="加性jordan-chevalley分解">加性Jordan-Chevalley分解</span></h5>
<p>由上述可以见到,对于一个特征多项式可分裂的矩阵<span class="math inline">\(T\)</span>,存在唯一一个可对角化矩阵<span class="math inline">\(S\)</span>和一个幂零矩阵<span class="math inline">\(N\)</span>使得<span class="math inline">\(T = S +
N\)</span>而且<span class="math inline">\(SN = NS\)</span>.</p>
<p>由Jordan标准型知道的确存在解(因为每一个分块对角上的对角矩阵都是<span class="math inline">\(\lambda I\)</span>的形式),现在问题在于唯一性.</p>
<p>既然<span class="math inline">\(S\)</span>可对角化,我们取其相异的特征值<span class="math inline">\(\mu_1 , \cdots ,
\mu_l\)</span>.对其做特征子空间分解<span class="math inline">\(V = V_{
\mu_1 } \oplus \cdots \oplus V_{ \mu_l }\)</span>,回忆到<span class="math inline">\(NS = SN\)</span>导出<span class="math inline">\(ST
= TS\)</span>,这意味着每一个特征子空间都是<span class="math inline">\(T\)</span>不变的.</p>
<p>此时观察<span class="math inline">\(T |_{ V_j
}\)</span>,观察到此时<span class="math inline">\(( T - \mu_j I ) |_{ V_j
} = N |_{ V_j }\)</span>是幂零的,所以<span class="math inline">\(V_j\)</span>被包含于<span class="math inline">\(T\)</span>的广义特征子空间<span class="math inline">\(V &#39; [ \mu_j
]\)</span>,然而广义特征子空间必然也给出了一个空间的分解,因此它们也不可能再往外扩张了,这必然意味着<span class="math inline">\(S\)</span>的特征空间<span class="math inline">\(V_j\)</span>恰好就是<span class="math inline">\(T\)</span>的广义特征子空间<span class="math inline">\(V &#39; [ \mu_j ]\)</span>.所以<span class="math inline">\(S\)</span>限定在<span class="math inline">\(V
&#39; [ \mu_j ]\)</span>上就是<span class="math inline">\(\mu_j
I\)</span>,这就保证了<span class="math inline">\(S\)</span>是唯一的,从而<span class="math inline">\(N\)</span>也就唯一.</p>
<p>此外,我们还可以证明存在多项式<span class="math inline">\(f ,
g\)</span>使得<span class="math inline">\(S = f ( T ) , N = g ( T
)\)</span>.首先可以取<span class="math inline">\(g = x -
f\)</span>,下面来搞定<span class="math inline">\(f\)</span>是如何取定的.</p>
<p>考虑用中国剩余定理拿到一个<span class="math inline">\(f\)</span>满足<span class="math inline">\(f \equiv
\mu_i \pmod{ ( x - \mu_i )^n }\)</span>,留神到<span class="math inline">\(f ( T ) |_{ V_j } = \mu_j\)</span>,原因是<span class="math inline">\(( T - \mu_j )^n |_{ V_j } =
0\)</span>,那按照我们刚才对唯一性的论证,这必然说明了<span class="math inline">\(f ( T ) = S\)</span>.</p>
<h5><span id="乘性jordan-chevalley分解">乘性Jordan-Chevalley分解</span></h5>
<p>对于一个特征多项式可分裂的可逆(等价于特征多项式无零根)的<span class="math inline">\(T \in \mathrm{ End } ( V
)\)</span>,则存在唯一一对可逆的<span class="math inline">\(S ,
U\)</span>使得:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>可对角化.</p></li>
<li><p><span class="math inline">\(U - I\)</span>幂零.</p></li>
<li><p><span class="math inline">\(SU = T = US\)</span>.</p></li>
<li><p>存在多项式<span class="math inline">\(f , g\)</span>,<span class="math inline">\(S = f ( T ) , U = g ( T )\)</span>.</p></li>
</ol>
<p>对于存在性,取道加性分解,设<span class="math inline">\(T = S + N = S (
I + S^{ - 1 } N )\)</span>,直接取<span class="math inline">\(U = I + S^{
- 1 } N\)</span>,由于<span class="math inline">\(SN =
NS\)</span>,则<span class="math inline">\(U - I = S^{ - 1 }
N\)</span>因为<span class="math inline">\(N\)</span>幂零而幂零,同时<span class="math inline">\(SU = T = US\)</span>也满足了.</p>
<p>对于唯一性,假设存在<span class="math inline">\(T = SU = S + S ( U - I
)\)</span>,由于<span class="math inline">\(SU = US\)</span>,所以<span class="math inline">\(S ( U - I
)\)</span>幂零,这就给出了一个加性分解,从而导出了唯一性.</p>
<p>最后来看如何取多项式.加性版本给出了<span class="math inline">\(S = f
( T )\)</span>.要求出<span class="math inline">\(g\)</span>的话需要满足<span class="math inline">\(g ( T ) f ( T ) = T\)</span>.</p>
<p>于此考虑证明<span class="math inline">\(f\)</span>和<span class="math inline">\(\mathrm{ char
}_T\)</span>是互素的,原因是反证法:如果不互素,则存在<span class="math inline">\(T\)</span>的特征值<span class="math inline">\(\lambda\)</span>使得<span class="math inline">\((
x - \lambda ) | f\)</span>,则对于对应的特征向量<span class="math inline">\(\vec{ v }\)</span>总有<span class="math inline">\(S \vec{ v } = f ( T ) \vec{ v } =
0\)</span>,可是<span class="math inline">\(S\)</span>可对角化而且特征值无<span class="math inline">\(0\)</span>,这就矛盾了.</p>
<p>既然如此,用裴蜀定理立刻拿到一对<span class="math inline">\(g , h \in
F [ x ]\)</span>使得<span class="math inline">\(gf + h \mathrm{ char }_T
= x\)</span>,带入<span class="math inline">\(T\)</span>得到<span class="math inline">\(g ( T ) f ( T ) = T\)</span>,这个<span class="math inline">\(g ( T ) = TS^{ - 1 } = U\)</span>.</p>
<h3><span id="张量积">张量积</span></h3>
<p>给定两个<span class="math inline">\(F\)</span>上的向量空间<span class="math inline">\(V ,
W\)</span>,我们想要通过它们构造新的向量空间<span class="math inline">\(V
\otimes
W\)</span>(这里并非直积,只是用这个符号).我们希望这个配对满足:</p>
<ol type="1">
<li><p><span class="math inline">\(V \times W \to V \otimes
W\)</span>是双线性的.</p></li>
<li><p>构造应该是自然的:不依赖基的选取.</p></li>
</ol>
<p>此外,我们希望其满足一些更好的泛性质,考虑资料<span class="math inline">\(( L , B )\)</span>,其中<span class="math inline">\(L\)</span>是一个向量空间,<span class="math inline">\(B\)</span>是一个<span class="math inline">\(V
\times W \to
L\)</span>的一个双线性映射,我们希望有一个尽可能泛的资料<span class="math inline">\(( L_{ \mathrm{ univ } } , B_{ \mathrm{ univ } }
)\)</span>,使得对于任何满足条件的<span class="math inline">\(( L , B
)\)</span>,存在唯一的<span class="math inline">\(\varphi\)</span>以下图表交换:</p>
<p><span class="math display">\[
\xymatrix{ V \times W \ar[r]^{ B_{ \mathrm{ univ } } } \ar[dr]_B &amp;
L_{ \mathrm{ univ } } \ar[d]^\varphi \\
&amp; L }
\]</span></p>
<p>此外我们还希望上述资料<span class="math inline">\(( L_{ \mathrm{ univ
} } , B_{ \mathrm{ univ } } )\)</span>是唯一的,我们希望将其记作<span class="math inline">\(V \otimes W\)</span>.</p>
<p>我们可以先尝试构造一下,用最粗暴的方法,干脆定义<span class="math inline">\(E = F^{ \oplus ( V \times W )
}\)</span>,其元素表为有限线性组合<span class="math inline">\(\sum_i c_i
( v_i , w_i )\)</span>,考虑以下元素生成的子空间<span class="math inline">\(N\)</span>:</p>
<ol type="1">
<li><p><span class="math inline">\(( v + v &#39; , w ) - ( v , w ) - ( v
&#39; , w )\)</span>.</p></li>
<li><p><span class="math inline">\(( v , w + w &#39; ) - ( v , w ) - ( v
, w &#39; )\)</span>.</p></li>
<li><p><span class="math inline">\(( tv , w ) - t ( v , w
)\)</span>.</p></li>
<li><p><span class="math inline">\(( v , tw ) - t ( v , w
)\)</span>.</p></li>
</ol>
<p>接下来取<span class="math inline">\(L_{ \mathrm{ univ } } = E /
N\)</span>,连同映射<span class="math inline">\(B_{ \mathrm{ univ } } : (
v , w ) \mapsto ( v , w ) +
N\)</span>,容易见到我们的确强行定义了双线性形式的性质.</p>
<p>接下来考虑其泛性质,对双线性映射<span class="math inline">\(B : V
\times W \to L\)</span>,其可以确定唯一的线性映射<span class="math inline">\(\Phi : E \to L , \sum_i c_i ( v_i , w_i ) \mapsto
\sum_i c_i B ( v_i , w_i )\)</span>.</p>
<p>然而由于<span class="math inline">\(B\)</span>的双线性性,立刻得到<span class="math inline">\(B ( N ) = \{ 0 \}\)</span>,从而可以导出唯一的<span class="math inline">\(\varphi : L_{ \mathrm{ univ } } \to L , x + N
\mapsto \Phi ( x )\)</span>.这立刻得到了<span class="math inline">\(\varphi\)</span>的唯一性,原因是<span class="math inline">\(\varphi ( ( v , w ) + N ) = B ( v , w
)\)</span>是总有的.</p>
<p>唯一性应当是显然的,只需见到如果有两个<span class="math inline">\(L_{
\mathrm{ univ } }\)</span>和<span class="math inline">\(L_{ \mathrm{
univ } } &#39;\)</span>,则应当有:</p>
<p><span class="math display">\[
\xymatrix{ &amp; L_{ \mathrm{ univ } } \ar[d]^\varphi \\
V \times W \ar[ru]^{ B_{ \mathrm{ univ } } } \ar[r]^{ B_{ \mathrm{ univ
} } &#39; } \ar[dr]_{ B_{ \mathrm{ univ } } } &amp; L_{ \mathrm{ univ }
} &#39; \ar[d]^\psi \\
&amp; L_{ \mathrm{ univ } } }
\]</span></p>
<p>外圈当然也是交换的,然而取<span class="math inline">\(id\)</span>也必然导出外圈交换,由图表唯一性立刻得到<span class="math inline">\(\varphi \psi = id\)</span>,对称性得出<span class="math inline">\(\psi \varphi = id\)</span>,这就搞定了<span class="math inline">\(L_{ \mathrm{ univ } } \cong L_{ \mathrm{ univ } }
&#39;\)</span>.</p>
<p>容易见到上述性质保证了同构:<span class="math inline">\(\mathrm{ Hom }
( V \otimes W , L ) \cong \mathrm{ Bil } ( V , W ; L ) , \varphi \mapsto
\varphi B_{ \mathrm{ univ } }\)</span>.</p>
<p>容易将上述结论推广到多重线性映射的情形.还可以将张量积的符号推广到线性映射上,我们断言总存在唯一的<span class="math inline">\(\varphi\)</span>使得下图交换:</p>
<p><span class="math display">\[
\xymatrix{ V_1 \times \cdots \times V_n \ar[r]^{ ( f_1 , \cdots , f_n )
} \ar[d] &amp; W_1 \times \cdots \times W_n \ar[d] \\
V_1 \otimes \cdots \otimes V_n \ar[r]_{ \varphi } &amp; W_1 \otimes
\cdots \otimes W_n \\
}
\]</span></p>
<p>从而可以自然地将<span class="math inline">\(\varphi\)</span>记作<span class="math inline">\(f_1 \otimes \cdots \otimes f_n\)</span>.</p>
<p>于此只需考虑上半部分,我们知道<span class="math inline">\(( v_1 ,
\cdots , v_n ) \mapsto f_1 ( v_1 ) \otimes \cdots \otimes f_n ( v_n
)\)</span>是一个多重线性映射,所以当然存在唯一一个映射打过来.从而得到:</p>
<p><span class="math display">\[
( f_1 \otimes \cdots \otimes f_n ) ( v_1 \otimes \cdots \otimes v_n ) =
f_1 ( v_1 ) \otimes \cdots \otimes f_n ( v_n )
\]</span></p>
<p>其实我们上面证明的就是下面这个同构<span class="math inline">\(\bigotimes_{ i = 1 }^n \mathrm{ Hom } ( V_i , W_i
) \cong \mathrm{ Hom } ( \bigotimes_i V_i , \bigotimes_i W_i
)\)</span>,好吧起码这个有限维情况下是同构,无穷维的话lww好像也有点不确定.</p>
<p>有以下性质自然成立(另一种看法是,线性映射也在一个线性空间里,所以上面也会自带一种张量积,恰为这个):</p>
<ol type="1">
<li><p><span class="math inline">\(id_{ V_1 } \otimes \cdots \otimes
id_{ V_n } = id_{ V_1 \otimes \cdots \otimes V_n }\)</span>.</p></li>
<li><p><span class="math inline">\(( f_1 \otimes \cdots \otimes f_n ) (
g_1 \otimes \cdots \otimes g_n ) = f_1 g_1 \otimes \cdots \otimes f_n
g_n\)</span>.</p></li>
<li><p><span class="math inline">\(( ( \alpha f_1 + \alpha &#39; f_1
&#39; ) \otimes \cdots \otimes f_n ) = \alpha ( f_1 \otimes \cdots
\otimes f_n ) + \alpha &#39; ( f_1 &#39; \otimes \cdots \otimes f_n
)\)</span>.</p></li>
</ol>
<p>而考虑多重线性映射的<span class="math inline">\(\mathrm{ Mul } ( V_1
, \cdots , V_n ; M )\)</span>,如果<span class="math inline">\(V_1 ,
\cdots ,
V_n\)</span>中任意一个是零空间,那由于多重线性性质,立刻导出这个映射只有零映射(原因是此时<span class="math inline">\(a = a + a\)</span>),从而使得<span class="math inline">\(\mathrm{ Hom } ( V_1 \otimes \cdots \otimes V_n ;
M )\)</span>中只有零映射(对所有<span class="math inline">\(M\)</span>),那其<span class="math inline">\(id\)</span>映射也是零映射,自然意味着<span class="math inline">\(V_1 \otimes \cdots \otimes
V_n\)</span>是零空间.</p>
<p>于此之外,如果想要跳过张量积的构造而直接探究张量积的性质,可能需要先判断<span class="math inline">\(\{ v_1 \otimes \cdots \otimes v_n
\}\)</span>集合是否的确生成了<span class="math inline">\(V_1 \otimes
\cdots \otimes V_n\)</span>.于此只需要取<span class="math inline">\(K =
\langle v_1 \otimes \cdots \otimes v_n | \forall v_i \in V_i
\rangle\)</span>,然后判断<span class="math inline">\(M = ( V_1 \otimes
\cdots \otimes V_n ) / K\)</span>是否为零空间即可.此时<span class="math inline">\(\forall \varphi\)</span>作为商映射,当然都有<span class="math inline">\(\varphi ( v_1 \otimes \cdots \otimes v_n ) =
0\)</span>,我们想说明<span class="math inline">\(\varphi\)</span>的确是零映射,这首先需要保证即使只有<span class="math inline">\(v_1 \otimes \cdots \otimes
v_n\)</span>上的限制也可以有类似外延公理的结论.</p>
<p>换言之,如果两个在<span class="math inline">\(V_1 \otimes \cdots
\otimes V_n\)</span>映射<span class="math inline">\(f ,
g\)</span>满足<span class="math inline">\(\forall v_i , f ( v_1 \otimes
\cdots \otimes v_n ) = g ( v_1 \otimes \cdots \otimes v_n
)\)</span>则<span class="math inline">\(f \equiv
g\)</span>,只需回忆到这上面的映射与多重线性映射一一对应,而多重线性映射上用外延公理就搞定了.</p>
<p>这就看到,用与多重线性映射一一对应的性质同样是张量积的某种泛性质.</p>
<p>我们还可以看到,如果<span class="math inline">\(f_1 , \cdots ,
f_n\)</span>都是满的,则<span class="math inline">\(f_1 \otimes \cdots
\otimes f_n\)</span>亦然,这是显然的.</p>
<p>可能稍不显然的是如果<span class="math inline">\(f_1 , \cdots ,
f_n\)</span>都是单的,则<span class="math inline">\(f_1 \otimes \cdots
\otimes f_n\)</span>也是单的.此时<span class="math inline">\(W_i\)</span>可以分解出一个与<span class="math inline">\(V_i\)</span>同构的<span class="math inline">\(\mathrm{ im } f_i\)</span>部分,干脆记作<span class="math inline">\(W_i \cong V_i \oplus V_i
&#39;\)</span>,并假设<span class="math inline">\(f_i : V_i \to
W_i\)</span>是自然的嵌入映射.回忆到张量积在同构下有交换律和对直和的分配律(下面会证),见到<span class="math inline">\(W_1 \otimes \cdots \otimes W_n \cong ( V_1 \otimes
\cdots \otimes V_n ) \oplus V &#39;\)</span>,此时<span class="math inline">\(f_1 \otimes \cdots \otimes
f_n\)</span>就是自然的嵌入映射.你可能会想欸,不对啊,<span class="math inline">\(V &#39;\)</span>里也会有一些<span class="math inline">\(V_i\)</span>项啊.可是,回忆到如果某一分量为零,则其在张量积中拿到的结果就是<span class="math inline">\(0\)</span>,所以<span class="math inline">\(f_1
\otimes \cdots \otimes f_n\)</span>只会对前面有意义.</p>
<h4><span id="张量积与直和">张量积与直和</span></h4>
<p>接下来考虑证明以下结论:</p>
<ol type="1">
<li><p>结合律:<span class="math inline">\(V_1 \otimes ( V_2 \otimes V_3
) \cong V_1 \otimes V_2 \otimes V_3 \cong ( V_1 \otimes V_2 ) \otimes
V_3\)</span>.</p></li>
<li><p>幺元:<span class="math inline">\(F \otimes V \cong V \cong V
\otimes F\)</span>.</p></li>
<li><p>交换律:<span class="math inline">\(V \otimes W \cong W \otimes
V\)</span>.</p></li>
<li><p>零元:<span class="math inline">\(\{ 0 \} \otimes V \cong \{ 0 \}
\cong V \otimes \{ 0 \}\)</span>.</p></li>
<li><p>分配律:设<span class="math inline">\(V\)</span>带有直和分解<span class="math inline">\(V = \bigoplus_{ i \in I } V_i\)</span>,则<span class="math inline">\(V \otimes W \cong \bigoplus_{ i \in I } ( V_i
\otimes W )\)</span>.</p></li>
</ol>
<p>考虑(1),下面证明<span class="math inline">\(V_1 \otimes ( V_2 \otimes
V_3 ) \cong V_1 \otimes V_2 \otimes
V_3\)</span>,其关键是构造以下线性映射:</p>
<p><span class="math display">\[
\xymatrix{ V_1 \otimes ( V_2 \otimes V_3 ) \ar[r]^{ \alpha } &amp; V_1
\otimes V_2 \otimes V_3 \ar[r]^{ \beta } &amp; V_1 \otimes ( V_2 \otimes
V_3 ) \\
v_1 \otimes ( v_2 \otimes v_3 ) \ar @{|-&gt;}[r] &amp; v_1 \otimes v_2
\otimes v_3 \ar @{|-&gt;}[r] &amp; v_1 \otimes ( v_2 \otimes v_3 ) }
\]</span></p>
<p>如果我们的确造出了这个映射,由于我们有外延公理,这必然意味着<span class="math inline">\(\alpha \circ \beta = id\)</span>,从而导出<span class="math inline">\(V_1 \otimes ( V_2 \otimes V_3 ) \cong V_1 \otimes
V_2 \otimes V_3\)</span>.</p>
<p>对于<span class="math inline">\(\beta\)</span>,立刻就能看出<span class="math inline">\(V_1 \times V_2 \times V_3 \to V_1 \otimes ( V_2
\otimes V_3 )\)</span>是三重线性的.因此泛性质诱导出<span class="math inline">\(\beta\)</span>映射.</p>
<p>至于<span class="math inline">\(\alpha\)</span>映射,只需先做<span class="math inline">\(V_1 \times ( V_2 \times V_3 ) \cong V_1 \times V_2
\times V_3\)</span>就行.</p>
<p>考虑(2),和(1)一样,我们想要搞一个映射链<span class="math inline">\(V
\to F \otimes V \to V\)</span>,对于前者只需要取映射<span class="math inline">\(\lambda_V : F \otimes V \to V , t \otimes v
\mapsto tv\)</span>,对于后者只需要取<span class="math inline">\(\tau_V :
V \to F \otimes V , v \mapsto 1 \otimes v\)</span>.回忆到<span class="math inline">\(1 \otimes tv = t \otimes
v\)</span>,因此上述映射均是合理的,而且复合之后是<span class="math inline">\(id\)</span>.</p>
<p>考虑(3),我想答案呼之欲出:<span class="math inline">\(V \otimes
W\)</span>和<span class="math inline">\(W \otimes V\)</span>都是<span class="math inline">\(V \times W\)</span>诱导出来的,而<span class="math inline">\(V \times W \cong W \times V\)</span>.</p>
<p>(4)我们之前已经证明了.</p>
<p>考虑(5),回忆到如果<span class="math inline">\(V = \bigoplus_{ i \in I
} V_i\)</span>,则<span class="math inline">\(V^\vee = \prod_{ i \in I }
( V_i )^\vee\)</span>.同理应该能拿到<span class="math inline">\(\mathrm{
Hom } ( V , L ) = \prod_{ i \in I } \mathrm{ Hom } ( V_i , L
)\)</span>,进一步地有:</p>
<p><span class="math display">\[
\mathrm{ Bil } ( V , W ; L ) \cong \prod_{ i \in I } \mathrm{ Bil } (
V_i , W ; L ) \cong \prod_{ i \in I } \mathrm{ Hom } ( V_i \otimes W , L
) \cong \mathrm{ Hom } \left ( \bigoplus_{ i \in I } ( V_i \otimes W ) ,
L \right )
\]</span></p>
<p>从而可以使我们诱导出原本的同构.</p>
<p>基于(5),我们可以知道如果<span class="math inline">\(V\)</span>有基<span class="math inline">\(( v_i
)_{ i \in I }\)</span>而<span class="math inline">\(W\)</span>有基<span class="math inline">\(( w_j )_{ j \in J }\)</span>,则<span class="math inline">\(( v_i \otimes w_j )_{ ( i , j ) \in I \times J
}\)</span>也是<span class="math inline">\(V \otimes
W\)</span>的基,从而得到<span class="math inline">\(\dim ( V \otimes W )
= ( \dim V ) \times ( \dim W
)\)</span>.这给出了张量积的Kronecker基形式.</p>
<p>最后我们还可以引入张量幂<span class="math inline">\(V^{ \otimes n
}\)</span>,从上面的讨论我们可以知道<span class="math inline">\(( V^{
\otimes a } )^{ \otimes b } \cong V^{ \otimes ab }\)</span>以及<span class="math inline">\(V^{ \otimes a } \otimes V^{ \otimes b } \cong V^{
\otimes ( a + b ) }\)</span>.</p>
<h4><span id="kronecker积">Kronecker积</span></h4>
<p>对于矩阵<span class="math inline">\(X \in F^{ n \times m } , Y \in
F^{ p \times q }\)</span>,我们定义它们的克罗内多积为:</p>
<p><span class="math display">\[
X \otimes Y = \begin{bmatrix}
x_{ 1 , 1 } Y &amp; x_{ 1 , 2 } Y &amp; \cdots &amp; x_{ 1 , m } Y \\
x_{ 2 , 1 } Y &amp; x_{ 2 , 2 } Y &amp; \cdots &amp; x_{ 2 , m } Y \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{ n , 1 } Y &amp; x_{ n , 2 } Y &amp; \cdots &amp; x_{ n , m } Y
\end{bmatrix} \in F^{ ( np ) \times ( mq ) }
\]</span></p>
<p>克罗内多积显然不满足交换律.</p>
<p>事实上,设<span class="math inline">\(X , Y ,
Z\)</span>在下列运算中有意义,克罗内多积满足以下性质:</p>
<ol type="1">
<li><p>结合律:<span class="math inline">\(X \otimes Y \otimes Z = X
\otimes ( Y \otimes Z )\)</span>.</p></li>
<li><p>左分配律:<span class="math inline">\(X \otimes ( Y + Z ) = X
\otimes Y + X \otimes Z\)</span>.</p></li>
<li><p>右分配律:<span class="math inline">\(( X + Y ) \otimes Z = X
\otimes Z + Y \otimes Z\)</span>.</p></li>
<li><p><span class="math inline">\(( X \otimes Y )^T = X^T \otimes
Y^T\)</span>.</p></li>
<li><p><span class="math inline">\(( X \otimes Y ) ( U \otimes V ) = (
XU ) \otimes ( YV )\)</span>.</p></li>
<li><p><span class="math inline">\(X^{ - 1 } \otimes Y^{ - 1 } = ( X
\otimes Y )^{ - 1 }\)</span>.</p></li>
<li><p><span class="math inline">\(\det ( X \otimes Y ) = \det ( X )^m
\det ( Y )^n , X \in F^{ n \times n } , Y \in F^{ m \times m
}\)</span>.</p></li>
<li><p><span class="math inline">\(rank ( X \otimes Y ) = rank ( X )
\times rank ( Y )\)</span>.</p></li>
</ol>
<p>上述命题稍不显然的是(4),我们将在下面讨论对偶空间的时候得出它.</p>
<p>克罗内多积的性质有一个很有用的特例是:</p>
<p><span class="math display">\[
\begin{aligned}
A \otimes B \otimes C &amp; = ( A \otimes I_n \otimes I_n ) ( I_n
\otimes B \otimes I_n ) ( I_n \otimes I_n \otimes C ) \\
A , B , C &amp; \in F^{ n \times n }
\end{aligned}
\]</span></p>
<h4><span id="张量积与对偶空间">张量积与对偶空间</span></h4>
<p>回忆到典范配对,如今我们可以用张量积将其表示为线性映射<span class="math inline">\(V^\vee \otimes V \to F , \lambda \otimes v \mapsto
\langle \lambda , v \rangle = \lambda ( v
)\)</span>,这被称为<strong>缩并</strong>映射.</p>
<p>考虑映射<span class="math inline">\(\Theta : V^\vee \otimes W \to
\mathrm{ Hom } ( V , W ) , \sum_i \lambda_i \otimes w_i \mapsto \sum_i
\langle \lambda_i , \_ \rangle
w_i\)</span>.这个映射总是单射,当维数是有限维的时候则是满的.</p>
<p>也许还该简单验证此结论,首先检查<span class="math inline">\(V^\vee
\times W \to \mathrm{ Hom } ( V , W
)\)</span>,这的确是一个双线性映射,于是由泛性质立刻诱导出映射<span class="math inline">\(V^\vee \otimes W \to \mathrm{ Hom } ( V , W
)\)</span>.</p>
<p>接下来证明其是单射,只需要证明其<span class="math inline">\(\ker = \{
0 \}\)</span>即可.而其<span class="math inline">\(\ker\)</span>中的元素总形如<span class="math inline">\(\sum_{ i = 1 }^k \lambda_i \otimes
w_i\)</span>,不妨假设<span class="math inline">\(w_1 , \cdots ,
w_k\)</span>是线性无关的(可以把相关的项整理到<span class="math inline">\(\lambda_i\)</span>里面).</p>
<p>此时由于其在<span class="math inline">\(\ker\)</span>里,所以<span class="math inline">\(\forall v \in V\)</span>,总有<span class="math inline">\(\sum_{ i = 1 }^k \langle \lambda_i , v \rangle w_i
= 0\)</span>,然而<span class="math inline">\(w_i\)</span>线性无关,所以<span class="math inline">\(\langle \lambda_i , v \rangle \equiv
0\)</span>,可是<span class="math inline">\(v\)</span>是任取的,这必然意味着<span class="math inline">\(\lambda_i \equiv 0\)</span>.</p>
<p>接下来考虑证明当<span class="math inline">\(V ,
W\)</span>其一是有限维的时候上述映射是满的,容易发现<span class="math inline">\(\Theta\)</span>的像总是有限维的(因为左边是有限求和).当<span class="math inline">\(V , W\)</span>其一是有限维的,<span class="math inline">\(T \in \mathrm{ Hom } ( V , W
)\)</span>就是有限秩的,此时就可以取其像的基<span class="math inline">\(w_1 , \cdots , w_n\)</span>,对所有<span class="math inline">\(v \in V\)</span>,<span class="math inline">\(T ( v
)\)</span>都可以唯一表述为<span class="math inline">\(c_1 w_1 + \cdots +
c_n w_n\)</span>,然而这里面每一个<span class="math inline">\(c_i\)</span>对<span class="math inline">\(v\)</span>都是线性的,从而它们都可以表示为<span class="math inline">\(V^\vee\)</span>中的元素而与<span class="math inline">\(v\)</span>的选取无关,这就搞定了.</p>
<p>万事俱备,再看<span class="math inline">\(\mathrm{ End } ( V
)\)</span>上,既然<span class="math inline">\(V^\vee \otimes
V\)</span>带有一个典范的缩并映射,在有限维的情况下,那与之同构的<span class="math inline">\(\mathrm{ End } ( V )\)</span>也该带有一个到<span class="math inline">\(F\)</span>的映射.我们断言这个映射就是<span class="math inline">\(\mathrm{ Tr }\)</span>映射.有下述图表:</p>
<p><span class="math display">\[
\xymatrix{ V^\vee \otimes V \ar[rd]_{ \text{ contraction } } \ar[rr]^{
\sim } &amp; &amp; \mathrm{ End ( V ) } \ar[ld]^{ \mathrm{ Trace } } \\
&amp; F &amp; }
\]</span></p>
<p>如何检验这个结论,我们之前刻画Trace的办法只有取对偶基<span class="math inline">\(\check{ v }_1 , \cdots , \check{ v
}_n\)</span>,然后将<span class="math inline">\(v = \sum c_i
v_i\)</span>和<span class="math inline">\(\lambda = d_i \check{ v
}_i\)</span>,那典范配对<span class="math inline">\(\Theta ( \lambda
\otimes v ) = \sum_{ i , j } \langle \check{ v }_i , \_ \rangle
v_j\)</span>,也就是说其将基向量<span class="math inline">\(v_i\)</span>映射到了<span class="math inline">\(\sum_j c_j d_i\)</span>,从而见到其<span class="math inline">\(\mathrm{ Tr } = \sum_i c_i d_i = \langle \lambda ,
v \rangle\)</span>.</p>
<p>如果写成矩阵形式的话,<span class="math inline">\(\lambda \in
V^\vee\)</span>可以写成一个<span class="math inline">\(1 \times
n\)</span>的矩阵,<span class="math inline">\(w \in
W\)</span>可以写成一个<span class="math inline">\(m \times
1\)</span>的矩阵,那其实<span class="math inline">\(\Theta ( \lambda
\otimes w )\)</span>就是<span class="math inline">\(w
\lambda\)</span>这个<span class="math inline">\(m \times
n\)</span>的矩阵.</p>
<p>最后来看曾经想要拿到的那个结论,下面我们引入一个典范的同构<span class="math inline">\(\Psi : V_1^\vee \otimes \cdots \otimes V_n^\vee
\to ( V_1 \otimes \cdots \otimes V_n )^\vee\)</span>,策略是观察<span class="math inline">\(V_1^\vee \times \cdots \times V_n^\vee \to ( V_1
\otimes \cdots \otimes V_n
)^\vee\)</span>自然是一个线性映射,其映射自然是:</p>
<p><span class="math display">\[
( \check{ v }_1 , \cdots , \check{ v }_n ) \mapsto \left [ v_1 \otimes
\cdots \otimes v_n \mapsto \prod_{ i = 1 }^n \langle \check{ v }_i , v_i
\rangle \right ]
\]</span></p>
<p>我们希望当每个<span class="math inline">\(V_i\)</span>都是有限维的时候,上述映射是同构.由于两遍维数相同,所以单性蕴含着满性.而其单性只要取左侧<span class="math inline">\(V_1^\vee \otimes \cdots \otimes
V_n^\vee\)</span>的基<span class="math inline">\(\check{ v_{ 1 , i_1 } }
\otimes \cdots \otimes \check{ v_{ n , i_n } }\)</span>,将每个<span class="math inline">\(\lambda\)</span>按照这组基展开,<span class="math inline">\(\psi ( \lambda )\)</span>在<span class="math inline">\(v_{ 1 , i_1 } \otimes \cdots \otimes v_{ n , i_n
}\)</span>处的值就是该基在<span class="math inline">\(\lambda\)</span>中的系数.因此<span class="math inline">\(\ker = \{ 0 \}\)</span>导出单性.</p>
<h4><span id="张量代数">张量代数</span></h4>
<p>设<span class="math inline">\(F\)</span>是一个域,一个<span class="math inline">\(F\)</span>上的<strong>代数</strong>需要以下资料:</p>
<ol type="1">
<li><p>一个环<span class="math inline">\(A\)</span>,其需要带有<span class="math inline">\(F\)</span>向量空间的结构,使得环的加法等价于向量空间的加法.</p></li>
<li><p>环的乘法<span class="math inline">\(A \times A \to
A\)</span>需要是双线性的.</p></li>
</ol>
<p>请沿之前引入代数结构的常规讨论把代数的结构一块搞定,其实大部分在环那里已经做完了,代数结构更强,因此只需要限定同态必须也态射到代数就行.也许还需要检验理想对标量乘法封闭,只需要观察到<span class="math inline">\(tI = ( t 1_A ) I \subseteq I\)</span>就行.</p>
<p>对于<span class="math inline">\(F\)</span>向量空间<span class="math inline">\(V\)</span>,下面定义<span class="math inline">\(T (
V ) = \bigoplus_{ n \geq 0 } V^{ \otimes n
}\)</span>,其自然带有向量空间的结构,只需加上双线性乘法就能构成一个代数,策略是:</p>
<p><span class="math display">\[
\begin{aligned}
V^{ \otimes a } \otimes V^{ \otimes b } &amp; \to V^{ \otimes ( a + b )
} \\
( v_1 \otimes \cdots \otimes v_a ) \otimes ( v_1 &#39; \otimes \cdots
\otimes v_b &#39; ) &amp; \mapsto v_1 \otimes \cdots \otimes v_a \otimes
v_1 &#39; \otimes \cdots \otimes v_b &#39;
\end{aligned}
\]</span></p>
<p>它的幺元自然选作<span class="math inline">\(1 \in F = V^{ \otimes 0
}\)</span>.我们还可以自然地在上面定义<span class="math inline">\(\psi^{
\otimes a }\)</span>之类的结构,不再赘述.</p>
<p>来进入对称代数与外代数,考虑<span class="math inline">\(C \in \mathrm{
Mul } ( V , \cdots , V ; M )\)</span>,任意置换<span class="math inline">\(\sigma\)</span>,定义:</p>
<ol type="1">
<li><p>如果<span class="math inline">\(C ( \cdots , x , y , \cdots ) = C
( \cdots , y , x , \cdots
)\)</span>,则称其为<strong>对称的</strong>.对称性等价于说<span class="math inline">\(C ( v_1 , \cdots , v_n ) = C ( v_{ \sigma ( 1 ) }
, \cdots , v_{ \sigma ( n ) } )\)</span>.</p></li>
<li><p>如果说<span class="math inline">\(C ( v_1 , \cdots , v_n ) =
\mathrm{ sgn } ( \sigma ) C ( v_{ \sigma ( 1 ) } , \cdots , v_{ \sigma (
n ) } )\)</span>,则称其为<strong>反对称的</strong>.</p></li>
<li><p>如果<span class="math inline">\(C ( \cdots , x , x , \cdots ) =
0\)</span>,则称其为<strong>交错的</strong>.</p></li>
</ol>
<p>当<span class="math inline">\(\mathrm{ char } F \ne
2\)</span>的时候,交错和反对称是等价的.不然,起码交错的一定是反对称的.下面定义:</p>
<ol type="1">
<li><p><span class="math inline">\(I_{ Sym }\)</span>为形如<span class="math inline">\(x \otimes y - y \otimes
x\)</span>的元素生成的理想.</p></li>
<li><p><span class="math inline">\(I_{ \wedge }\)</span>为形如<span class="math inline">\(x \otimes x\)</span>生成的理想.</p></li>
</ol>
<p>这样就可以定义相应的<strong>对称代数</strong><span class="math inline">\(Sym ( V ) = T ( V ) / I_{ Sym
}\)</span>,<strong>外代数</strong><span class="math inline">\(\bigwedge
( V ) = T ( V ) / I_\wedge\)</span>.还可以定义<span class="math inline">\(Sym^m ( V ) = V^{ \otimes m } / I_{ \mathrm{ sym }
}^m\)</span>,同理定义<span class="math inline">\(\bigwedge^m ( V
)\)</span>,容易发现<span class="math inline">\(Sym^0 ( V ) = F =
\bigwedge^0 ( V ) , Sym^1 ( V ) = V = \bigwedge^1 ( V )\)</span>.</p>
<p>在其中的<span class="math inline">\(\otimes\)</span>运算被自然变成了新的运算,设前者仍是通常的乘法符号,而后者符号采取<span class="math inline">\(\wedge\)</span>.</p>
<p>外代数里一个重要的性质是如果<span class="math inline">\(\omega \in
\bigwedge^p ( V ) , \eta \in \bigwedge^q ( V )\)</span>,则<span class="math inline">\(\omega \eta = ( - 1 )^{ pq } \eta
\omega\)</span>,原因是只需要假设<span class="math inline">\(\omega = x_1
\wedge \cdots \wedge x_p , \eta = y_1 \wedge \cdots \wedge
y_q\)</span>,其中<span class="math inline">\(x_i , y_i \in
V\)</span>,而外代数的定义已经给出<span class="math inline">\(x \wedge y
= - y \wedge x\)</span>,这就完事了.</p>
<p>既然我们可以将一个对称代数或者外代数分成若干层,那考虑对于任意线性映射<span class="math inline">\(\psi : V \to
W\)</span>,我们都可以通过在各个分量上诱导从而拿到:<span class="math inline">\(Sym ( \psi ) : Sym ( V ) \to Sym ( W ) , x_1
\cdots x_m \mapsto \psi ( x_1 ) \cdots \psi ( x_m )\)</span>,其中<span class="math inline">\(\psi ( x_m )\)</span>是限制在<span class="math inline">\(V^{ \otimes m }\)</span>上的.这应该是平凡的.</p>
<p>最后我们想要说明对称代数与外代数确实对应着我们的多重线性映射.也就是<span class="math inline">\(\mathrm{ Hom } ( Sym^m , M
)\)</span>同构于所有的对称<span class="math inline">\(m\)</span>重线性映射.外代数类似.而这些依照理想的定义的确如此.</p>
<p>接下来来展现二者的结构,不妨设<span class="math inline">\(\dim V =
n\)</span>,取其一组基<span class="math inline">\(v_1 , \cdots
v_n\)</span>,我们说:</p>
<ol type="1">
<li><p>当<span class="math inline">\(m &gt; n\)</span>的时候,<span class="math inline">\(\bigwedge^m ( V ) = \{ 0 \}\)</span>.</p></li>
<li><p>当<span class="math inline">\(0 \leq m \leq
n\)</span>的时候,<span class="math inline">\(\dim \bigwedge^m ( V ) =
\binom{ n }{ m }\)</span>.更确切地说,任意一组下标<span class="math inline">\(1 \leq i_1 &lt; \cdots &lt; i_m \leq
n\)</span>,<span class="math inline">\(v_{ i_1 } \wedge \cdots \wedge
v_{ i_m }\)</span>构成<span class="math inline">\(\bigwedge^m ( V
)\)</span>的基.</p></li>
<li><p>作为(2)的推论,<span class="math inline">\(\dim \bigwedge ( V ) =
2^n\)</span>.</p></li>
</ol>
<p>(1)比较显然,因为当<span class="math inline">\(m &gt;
n\)</span>的时候,任何一个元素被生成的方式<span class="math inline">\(v
&#39;_{ 1 } \wedge \cdots \wedge v &#39;_{ m
}\)</span>一定线性相关,所以自然为<span class="math inline">\(0\)</span>.</p>
<p>接下来看(2),我们早在行列式的讨论处就证明过了当<span class="math inline">\(m =
n\)</span>的时候,交错形式是一维的,那当然导出<span class="math inline">\(\dim ( \bigwedge^n ( V ) ) =
1\)</span>.而且若<span class="math inline">\(\psi \in \mathrm{ End } ( V
)\)</span>,则当然有<span class="math inline">\(\bigwedge^n ( \psi ) =
det ( \psi ) \mathrm{ id }_{ \wedge^n ( V ) }\)</span>.</p>
<p>而由之前张量积的结论,<span class="math inline">\(v_{ i_1 } \wedge
\cdots \wedge v_{ i_m
}\)</span>这些元素肯定构成了一组生成元,只需要证明它们的确线性无关即可.只需证明:</p>
<p><span class="math display">\[
\sum_{ 1 \leq j_1 &lt; \cdots &lt; j_m \leq n } c_{ j_1 , \cdots , j_m }
( v_{ j_1 } \wedge \cdots \wedge v_{ j_m } ) = 0 \Rightarrow c_{ j_1 ,
\cdots , j_m } \equiv 0
\]</span></p>
<p>做法呼之欲出,取<span class="math inline">\(V &#39; = \langle v_{ i_1
, } , \cdots , v_{ i_m } \rangle\)</span>,定义<span class="math inline">\(\psi : V \to V &#39;\)</span>,方法是<span class="math inline">\(\psi ( v_j ) = \begin{cases}v_j &amp; j \in \{ i_1
, \cdots , i_m \} \\ 0 &amp; \text{ otherwise
}\end{cases}\)</span>.此时其诱导出了<span class="math inline">\(\bigwedge^m ( \psi ) : \bigwedge^m ( V ) \to
\bigwedge^m ( V &#39; )\)</span>.然后两边做映射.如果<span class="math inline">\(\{ j_1 , \cdots , j_m \} \ne \{ i_1 , \cdots , i_m
\}\)</span>那就会变成零,最后就会导出<span class="math inline">\(c_{ i_1
, \cdots , i_m } ( v_{ i_1 } \wedge \cdots \wedge v_{ i_m } ) =
0\)</span>,然而左边是在<span class="math inline">\(\bigwedge^m ( V &#39;
)\)</span>这个<span class="math inline">\(\dim =
1\)</span>的空间中,所以一定能导出<span class="math inline">\(c_{ i_1 ,
\cdots , i_m } = 0\)</span>.</p>
<p>上述是外代数的结构,我们还可以刻画对称代数的结构,可以证明如果<span class="math inline">\(\dim V = n\)</span>,取定<span class="math inline">\(V\)</span>的基<span class="math inline">\(v_1 ,
\cdots , v_n\)</span>,可以将<span class="math inline">\(Sym ( V ) \cong
F [ X_1 , \cdots , X_n
]\)</span>.其实就是二次型理论对吧,应该比较简单.</p>
<p>最后我们可以来定义交错矩阵:<span class="math inline">\(A \in M_{ n
\times n } ( R )\)</span>,若<span class="math inline">\(a_{ i , j } = -
a_{ j , i }\)</span>而且<span class="math inline">\(a_{ i , i } =
0\)</span>.在<span class="math inline">\(2 \in
R^\times\)</span>的交换环上,这等价于<span class="math inline">\(A^t = -
A\)</span>.</p>
<p>可以证明当<span class="math inline">\(A \in M_{ n \times n } ( F
)\)</span>,对应了双线性形式<span class="math inline">\(B \in \mathrm{
Bil } ( F^n , F^n ; F )\)</span>为<span class="math inline">\(B ( \vec{
x } , \vec{ y } ) = ( \vec{ x } )^t A \vec{ y }\)</span>.则<span class="math inline">\(B\)</span>是交错形式当且仅当<span class="math inline">\(A\)</span>是交错矩阵.必要性很显然,只需带入<span class="math inline">\(a_{ i , j } = ( \vec{ e }_i )^t A \vec{ e }_j = B
( \vec{ e }_i , \vec{ e }_j )\)</span>;充分性也很显然,考察<span class="math inline">\(B ( \vec{ x } , \vec{ x } ) = ( \vec{ x } )^t A
\vec{ x } = 0\)</span>即可.</p>
<p>最后来看特征多项式如何表为外代数形式.考虑<span class="math inline">\(V\)</span>是域<span class="math inline">\(F\)</span>上的<span class="math inline">\(n\)</span>维向量空间,<span class="math inline">\(T
\in \mathrm{ End } ( V )\)</span>,则我们断言:</p>
<p><span class="math display">\[
\det ( \lambda I - T ) = \sum_{ k = 0 }^n ( - 1 )^k \mathrm{ Tr } (
\bigwedge_k T ) \lambda^{ n - k }
\]</span></p>
<p>我们之前已经解释过了:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \det ( \lambda I - T ) e_1 \wedge \cdots \wedge e_n \\
= &amp; ( \lambda I - T ) e_1 \wedge \cdots \wedge ( \lambda I - T ) e_n
\\
= &amp; \sum_{ k = 0 }^n ( - 1 )^k \lambda^{ n - k } \sum_{ | I | = k }
e_1 \wedge \cdots Te_{ i_1 } \cdots \wedge e_n
\end{aligned}
\]</span></p>
<p>也就是设只有<span class="math inline">\(i_k \in
I\)</span>这个指标集选到了<span class="math inline">\(Te\)</span>而其它的还是<span class="math inline">\(e\)</span>,不妨设<span class="math inline">\(J =
\{ 1 , \cdots , n \} \setminus I\)</span>.现在考虑<span class="math inline">\(\{ e_{ i_1 } \wedge \cdots \wedge e_{ i_k } \}_{ I
}\)</span>会构成<span class="math inline">\(\bigwedge^k ( V
)\)</span>的一组基,<span class="math inline">\(T\)</span>施加到上面得到:</p>
$$
<span class="math display">\[\begin{aligned}
( \bigwedge^k T ) ( e_{ i_1 } \wedge \cdots \wedge e_{ i_k } ) &amp; =
Te_{ i_1 } \wedge \cdots \wedge T e_{ i_k } \\

\end{aligned}\]</span>
<p>$$</p>
<p>对上面这个式子两边做<span class="math inline">\(\wedge ( e_{ j_1 }
\wedge \cdots \wedge e_{ j_{ n - k } } )\)</span>,现在看右侧,如果<span class="math inline">\(Te_{ i_1 }\)</span>变出了一些带有<span class="math inline">\(e_{ j }\)</span>的项,就会变成<span class="math inline">\(0\)</span>.因此右边最后剩下来的只会是形如<span class="math inline">\(a_I ( e_{ i_1 } \wedge \cdots \wedge e_{ i_k } )
\wedge ( e_{ j_1 } \wedge \cdots \wedge e_{ j_{ n - k } }
)\)</span>的东西.两边再换回去,得到:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; \det ( \lambda I - T ) e_1 \wedge \cdots \wedge e_n \\
= &amp; \sum_{ k = 0 }^n ( - 1 )^k \lambda^{ n - k } \sum_{ | I | = k }
a_I
\end{aligned}
\]</span></p>
<p>而最后那个东西恰好是<span class="math inline">\(\mathrm{ Tr } (
\bigwedge^k T )\)</span>.</p>
<h5><span id="另一种构造">另一种构造</span></h5>
<p>当<span class="math inline">\(\mathrm{ char } ( F ) =
0\)</span>的时候,我们可以脱离商空间的结构,而直接将对称代数与外代数定义在<span class="math inline">\(T ( V )\)</span>的子空间上.</p>
<p>对称代数与外代数(此时已经等价于反对称代数)都依赖于交换导出的结果,因此首要要做的就是让置换群<span class="math inline">\(S_n\)</span>作用域<span class="math inline">\(V^{
\otimes n
}\)</span>,为了保证左作用,下面的设计可能略有一些不合理,但好在我们后面也不会涉及具体的运算.假设<span class="math inline">\(\sigma \in S_n\)</span>,保持:</p>
<ol type="1">
<li><p><span class="math inline">\(\sigma ( ax + by ) = a ( \sigma x ) +
b ( \sigma y )\)</span>.</p></li>
<li><p><span class="math inline">\(\sigma ( v_1 \otimes \cdots \otimes
v_n ) = v_{ \sigma^{ - 1 } ( 1 ) } \otimes \cdots \otimes v_{ \sigma^{ -
1 } ( n ) }\)</span>.</p></li>
<li><p><span class="math inline">\(( \sigma \tau ) ( x ) = \sigma ( \tau
x )\)</span>.</p></li>
</ol>
<p>(2)的奇异设计是为了让(3)合理.这个时候你肯定要问:wcnmd,这个为啥不对啊.你别急,我们设<span class="math inline">\(w_i = v_{ \tau_{ - 1 } ( i )
}\)</span>,则最后得到的结果是<span class="math inline">\(w_{ \sigma^{ -
1 } ( i ) } = w_{ \tau^{ - 1 } \sigma^{ - 1 } ( i ) } = w_{ ( \sigma
\tau )^{ - 1 } ( i ) }\)</span>.</p>
<p>原因很简单,因为对于<span class="math inline">\(v_i\)</span>这个东西,我们想要把它送到<span class="math inline">\(v_{ \sigma ( i )
}\)</span>那里去,这样看就合理了.</p>
<p>现在我们着手取子空间,拿出<span class="math inline">\(V_{ Sym }^{
\otimes n } = \{ x \in V^{ \otimes n } | \forall \sigma \in S_n , \sigma
x = x \}\)</span>以及<span class="math inline">\(V_{ \wedge }^{ \otimes
n } = \{ x \in V^{ \otimes n } | \forall \sigma \in S_n , \sigma x =
\mathrm{ sgn } ( \sigma ) x \}\)</span>.同理可以施加<span class="math inline">\(\bigoplus_n\)</span>从而拿到<span class="math inline">\(T ( V )\)</span>的子空间<span class="math inline">\(V_{ Sym }\)</span>和<span class="math inline">\(V_\wedge\)</span>.</p>
<p>回忆到我们之前定义过商映射<span class="math inline">\(q_{ \mathrm{
sym } } : T ( V ) \to Sym ( V )\)</span>和<span class="math inline">\(q_\wedge : T ( V ) \to \bigwedge ( V
)\)</span>.我们下面断言,如果<span class="math inline">\(n ! \in
F^\times\)</span>(当<span class="math inline">\(\mathrm{ char } F =
0\)</span>的时候自动满足),则上述映射限制在子空间上变为同构<span class="math inline">\(( V^{ \otimes n } )_{ Sym } \cong Sym^n ( V
)\)</span>和<span class="math inline">\(( V^{ \otimes n } )_{ \wedge }
\cong \bigwedge^n ( V )\)</span>.</p>
<p>上述两条类似,我们下面只证明<span class="math inline">\(Sym\)</span>的情形.定义映射<span class="math inline">\(Avg \in \mathrm{ End } ( V^{ \otimes n } ) , x
\mapsto \frac{ 1 }{ n ! } \sum_{ \sigma \in S_n } \sigma
x\)</span>.留神到<span class="math inline">\(Avg |_{ V_{ \mathrm{ sym }
}^{ \otimes n } } = id\)</span>,而<span class="math inline">\(\mathrm{
im } ( Avg ) = V_{ \mathrm{ sym } }^{ \otimes n
}\)</span>.从而我们知道<span class="math inline">\(Avg\)</span>事实上给出了一个<span class="math inline">\(V^{ \otimes n } \to V_{ \mathrm{ sym } }^{ \otimes
n }\)</span>的映射,有同构<span class="math inline">\(V^{ \otimes n } /
\ker ( Avg ) \cong V_{ \mathrm{ sym } }^{ \otimes n }\)</span>.</p>
<p>来考虑<span class="math inline">\(q_{ \mathrm{ sym }
}^n\)</span>限制在<span class="math inline">\(V_{ \mathrm{ sym } }^{
\otimes n }\)</span>上的结果,记作<span class="math inline">\(\pi\)</span>.如果我们想证明<span class="math inline">\(\pi\)</span>是满射,其实就是要证明<span class="math inline">\(\ker Avg \subseteq \ker q_{ \mathrm{ sym }
}^n\)</span>.可是<span class="math inline">\(q_{ \mathrm{ sym }
}^n\)</span>的定义保证了<span class="math inline">\(q_{ \mathrm{ sym }
}^n ( \sigma x ) = q_{ \mathrm{ sym } }^n ( x )\)</span>,因此<span class="math inline">\(q_{ \mathrm{ sym } }^n \circ Avg = q_{ \mathrm{
sym } }^n\)</span>,导出<span class="math inline">\(\ker Avg \subseteq
\ker q_{ \mathrm{ sym } }^n\)</span>.</p>
<p>要证明单射则只需要证明<span class="math inline">\(V_{ Sym }^{ \otimes
n } \cap \ker q_{ \mathrm{ sym } }^n = \{ 0
\}\)</span>.我想这应该是显然的,假设它们的交不为<span class="math inline">\(0\)</span>,取出其中之一,由于其在<span class="math inline">\(\ker q_{ \mathrm{ sym }
}^n\)</span>中,所以它必然可以写成若干个<span class="math inline">\(\cdots ( x \otimes y ) - ( y \otimes x )
\cdots\)</span>的组合,而这些都会在<span class="math inline">\(Avg\)</span>作用下变成<span class="math inline">\(0\)</span>.从而我们证明了上述结论.</p>
<p>不过还没有完,我们想要刻画它的代数结构,还差一个乘法.</p>
<p>考虑取上述映射的逆映射,定义<span class="math inline">\(p_\mathrm{ sym
}^n : Sym^n ( V ) \cong V\)</span>,我们想要研究一下乘法,断言当<span class="math inline">\(( a + b ) ! \in
F^\times\)</span>的时候,对所有<span class="math inline">\(x \in ( V^{
\otimes a } )_\mathrm{ sym } , y \in ( V^{ \otimes b } )_\mathrm{ sym
}\)</span>:</p>
<p><span class="math display">\[
p_\mathrm{ sym }^{ a + b } ( q_\mathrm{ sym }^{ a } ( x ) q_\mathrm{ sym
}^{ b } ( y ) ) = \frac{ a ! b ! }{ ( a + b ) ! } \sum_{ \sigma \in S_{
a + b } / ( S_a \times S_b ) } \sigma ( x \otimes y )
\]</span></p>
<p>对于<span class="math inline">\(\bigwedge\)</span>有类似的版本,有:</p>
<p><span class="math display">\[
p_{ \wedge }^{ a + b } ( q_{ \wedge }^{ a } ( x ) q_{ \wedge }^{ b } ( y
) ) = \frac{ a ! b ! }{ ( a + b ) ! } \sum_{ \sigma \in S_{ a + b } / (
S_a \times S_b ) } \mathrm{ sgn } ( \sigma ) \sigma ( x \wedge y )
\]</span></p>
<p>考虑上述断言的证明,选取<span class="math inline">\(\bigwedge\)</span>版本进行证明,首先应该有:</p>
<p><span class="math display">\[
\begin{aligned}
q_{ \wedge }^{ a } ( x ) q_{ \wedge }^{ b } ( y ) &amp; = q_{ \wedge }^{
ab } ( x \wedge y ) \\
&amp; = q_{ \wedge }^{ ab } \left ( \frac{ 1 }{ ( a + b ) ! } \sum_{
\sigma \in S_{ a + b } } \mathrm{ sgn } ( \sigma ) \sigma ( x \wedge y )
\right )
\end{aligned}
\]</span></p>
<p>考虑<span class="math inline">\(\sigma ( x \wedge y
)\)</span>,其对于<span class="math inline">\(( \tau , \eta ) \in S_a
\times S_b\)</span>的时候,考虑:</p>
<p><span class="math display">\[
\begin{aligned}
( \tau , \eta ) ( x \wedge y ) &amp; = \tau ( x ) \wedge \eta ( y ) \\
&amp; = \mathrm{ sgn } ( \tau ) \mathrm{ sgn } ( \eta ) x \wedge y \\
&amp; = \mathrm{ sgn } ( ( \tau , \eta ) ) ( x \wedge y )
\end{aligned}
\]</span></p>
<p>这就会和前面抵消.所以<span class="math inline">\(S_a \times
S_b\)</span>可以被商掉,这些元素的数量是<span class="math inline">\(a ! b
!\)</span>个,从而我们确实知道了它的乘法结构.</p>
<p>至于<span class="math inline">\(S_{ a + b } / ( S_a \times S_b
)\)</span>,其实就是选出<span class="math inline">\(a +
b\)</span>中的<span class="math inline">\(a\)</span>个元素扔到前面,把剩下的<span class="math inline">\(b\)</span>个元素扔到后面,而且不在意它们的顺序.这就是为什么它的大小为<span class="math inline">\(\binom{ a + b }{ a }\)</span>.</p>
<h5><span id="又看对偶空间">又看对偶空间</span></h5>
<p>假设<span class="math inline">\(\dim V = n &lt; \infty\)</span>,<span class="math inline">\(n ! \in
F^\times\)</span>.我们断言有以下典范(从左到右)同构成立:</p>
<ol type="1">
<li><p><span class="math inline">\(\mathrm{ Sym }^n ( V^\vee ) \cong
\mathrm{ Sym }^n ( V )^\vee\)</span>.</p></li>
<li><p><span class="math inline">\({ \bigwedge }^n ( V^\vee ) \cong{
\bigwedge }^n ( V )^\vee\)</span>.</p></li>
</ol>
<p>原因是以下同构:</p>
<p><span class="math display">\[
\xymatrix{ ( V^\vee )^{ \otimes n } \ar[r]^{ \cong }_{ \Psi } &amp; (
V^{ \otimes n } )^\vee \ar[r]^{ \cong }_{ \Phi } &amp; \mathrm{ Mul } (
V , \cdots , V ; F ) \\
\lambda_1 \otimes \cdots \otimes \lambda_n \ar @{|-&gt;}[rr] &amp; &amp;
[ C ( x_1 , \cdots , x_n ) = \prod_{ i = 1 }^n \langle \lambda_i , x_i
\rangle ] }
\]</span></p>
<p>如果我们在左侧施加<span class="math inline">\(\sigma\)</span>后,右侧会如何改变呢?当然是会变成<span class="math inline">\(C ( x_{ \sigma ( 1 ) } , \cdots , x_{ \sigma ( n )
} )\)</span>.如果左侧是<span class="math inline">\(( V^\vee )^{ \otimes
n }_\mathrm{ sym }\)</span>,那右侧就会对应到<span class="math inline">\(\mathrm{ Mul }_\mathrm{ sym } ( V , \cdots , V ; F
) = ( V^{ \otimes n } )^\vee_\mathrm{ sym }\)</span>.</p>
<h6><span id="example1">Example1</span></h6>
<p>设<span class="math inline">\(U , W\)</span>分别是<span class="math inline">\(V\)</span>的<span class="math inline">\(p\)</span>维子空间,<span class="math inline">\(U\)</span>有基<span class="math inline">\(x_1 ,
\cdots , x_p\)</span>,<span class="math inline">\(V\)</span>有基<span class="math inline">\(y_1 , \cdots , y_p\)</span>,求证:<span class="math inline">\(U = V\)</span>当且仅当<span class="math inline">\(x_1 \wedge \cdots \wedge x_p\)</span>和<span class="math inline">\(y_1 \wedge \cdots \wedge y_p\)</span>成比例.</p>
<p>必要性显然,只需要把其中一组基用令一组基表示即可.</p>
<p>对于充分性,考虑反证,如果<span class="math inline">\(U \ne
W\)</span>,取<span class="math inline">\(w \in U \setminus
V\)</span>,两边对<span class="math inline">\(\wedge
w\)</span>操作.则<span class="math inline">\(x_1 \wedge \cdots \wedge
x_p\)</span>会变成<span class="math inline">\(0\)</span>可<span class="math inline">\(y_1 \wedge \cdots \wedge
y_p\)</span>不会,这就矛盾了.</p>
<h6><span id="example2">Example2</span></h6>
<p>对于<span class="math inline">\(\omega \in \bigwedge^p ( V )
\setminus \{ 0 \}\)</span>,我们定义如果存在<span class="math inline">\(v_1 , \cdots , v_p \in V\)</span>,使得<span class="math inline">\(\omega = v_1 \wedge \cdots , \wedge
v_p\)</span>,则称<span class="math inline">\(\omega\)</span>可<strong>分解</strong>.这当然是我们关注的一个重点,下面我们尝试去推导出关于可分解的部分结论.</p>
<p>设<span class="math inline">\(\omega \in \bigwedge^p ( V ) \setminus
\{ 0 \}\)</span>,其中<span class="math inline">\(p \leq n = \dim
V\)</span>.</p>
<p>考虑如果<span class="math inline">\(\omega \wedge v =
0\)</span>,我们断言<span class="math inline">\(\omega\)</span>一定可以写作<span class="math inline">\(v \wedge \eta\)</span>的形式.策略是将<span class="math inline">\(\{ v \}\)</span>扩展成一组基<span class="math inline">\(e_1 = v , e_2 \cdots , e_n\)</span>.此时<span class="math inline">\(\omega = \sum_{ | I | = p } a_I e_{ i_1 } \wedge
\cdots \wedge e_{ i_k }\)</span>.如果<span class="math inline">\(\omega
\wedge v = 0\)</span>,必然意味着如果<span class="math inline">\(1 \notin
I \Rightarrow a_I = 0\)</span>.从而导出上述结论.</p>
<p>定义<span class="math inline">\(\mathrm{ ann } ( \omega ) = \{ v \in
V | \omega \wedge v = 0 \}\)</span>,容易发现这的确是<span class="math inline">\(V\)</span>的一个子空间.以数学归纳的策略可以证明其<span class="math inline">\(r = \dim \leq p\)</span>,策略是取其一组基<span class="math inline">\(e_1 , \cdots , e_r\)</span>.必然有<span class="math inline">\(\omega \wedge e_1 = 0\)</span>,从而导出<span class="math inline">\(\exists \eta \in \bigwedge^{ p - 1 } ( V )
\setminus \{ 0 \}\)</span>,<span class="math inline">\(\omega = e_1
\wedge \eta\)</span>.从而导出<span class="math inline">\(e_1 \wedge e_2
\wedge \eta = 0\)</span>.因为<span class="math inline">\(e_1 \wedge \eta
\ne 0\)</span>并且<span class="math inline">\(e_1 \wedge e_2 \ne
0\)</span>,这意味着<span class="math inline">\(e_2 \wedge \eta = 0 ,
\cdots e_n \wedge \eta = 0\)</span>,从而可以数学归纳.</p>
<p>现在我们尝试断言:<span class="math inline">\(\omega\)</span>可分解的充要条件是<span class="math inline">\(\dim \mathrm{ ann } ( \omega ) = p\)</span>.</p>
<p>先来看必要性,如果<span class="math inline">\(\omega = x_1 \wedge
\cdots \wedge x_p\)</span>,因为<span class="math inline">\(\omega \ne
0\)</span>,所以<span class="math inline">\(x_1 , \cdots ,
x_p\)</span>线性无关.显然<span class="math inline">\(\langle x_1 ,
\cdots , x_p \rangle \subseteq \mathrm{ ann } ( \omega
)\)</span>,然而左侧维数是<span class="math inline">\(p\)</span>,右侧维数<span class="math inline">\(\leq p\)</span>.比较维数知道两边相等.</p>
<p>再看充分性,假设<span class="math inline">\(\mathrm{ ann } ( \omega
)\)</span>的基是<span class="math inline">\(e_1 , \cdots ,
e_r\)</span>,我们已经断言过存在<span class="math inline">\(\eta \in
\bigwedge^{ p - r } ( V )\)</span>使得<span class="math inline">\(\omega
= t ( e_1 \wedge \cdots \wedge e_r \wedge \eta )\)</span>,当<span class="math inline">\(p = r\)</span>的时候得到<span class="math inline">\(\omega\)</span>可分解.</p>
<p>还可以证明以下两个结论:</p>
<ol type="1">
<li><p>所有的<span class="math inline">\(\omega \in \bigwedge^{ n - 1 }
( V )\)</span>都是可分解的.</p></li>
<li><p>设<span class="math inline">\(\mathrm{ char } ( F ) \ne 2 , n
\geq 2\)</span>,则<span class="math inline">\(\omega \in \bigwedge^2 ( V
)\)</span>可分解当且仅当<span class="math inline">\(\omega \wedge \omega
= 0\)</span>.</p></li>
</ol>
<p>对于(1),考虑选取一组基<span class="math inline">\(v_1 , \cdots ,
v_n\)</span>,则<span class="math inline">\(\omega \wedge v = c ( v ) v_1
\wedge \cdots \wedge v_n\)</span>,其中<span class="math inline">\(c : V
\to F\)</span>显然是线性映射.既然如此,<span class="math inline">\(\dim
\ker c = n - 1\)</span>,从而导出<span class="math inline">\(\mathrm{ ann
} ( \omega ) = \ker c\)</span>的维数也是<span class="math inline">\(n -
1\)</span>,这就搞定了.</p>
<p>对于(2),首先必要性显然.对于充分性,一个朴素的证明是基于归纳法的:</p>
<p>对<span class="math inline">\(\dim
V\)</span>的大小进行归纳,取一组基<span class="math inline">\(e_1 ,
\cdots e_n\)</span>,令<span class="math inline">\(V_1 = \langle e_2 ,
\cdots , e_n \rangle\)</span>则<span class="math inline">\(\omega = e_1
\wedge v + \eta\)</span>的形式,其中<span class="math inline">\(v \in V_1
, \eta \in \bigwedge^2 ( V_1 )\)</span>,根据归纳假设其可分解,设<span class="math inline">\(\eta = x \wedge y\)</span>.</p>
<p>考虑:</p>
$$
<span class="math display">\[\begin{aligned}
0 &amp; = \omega \wedge \omega \\
0 &amp; = ( e_1 \wedge v + x \wedge y ) \wedge ( e_1 \wedge v + x \wedge
y ) \\
0 &amp; = e_1 \wedge v \wedge x \wedge y \\
0 &amp; = v \wedge x \wedge y \\

\end{aligned}\]</span>
<p>$$</p>
<p>既然如此,说明<span class="math inline">\(v , x ,
y\)</span>线性相关.如果<span class="math inline">\(x =
0\)</span>或者<span class="math inline">\(y =
0\)</span>当然就做完了,反之必有<span class="math inline">\(v = ax +
by\)</span>.那么:</p>
<p><span class="math display">\[
\begin{aligned}
\omega &amp; = e_1 \wedge ( ax + by ) + x \wedge y \\
&amp; = ( x + be_1 ) \wedge ( y - ae_1 )
\end{aligned}
\]</span></p>
<p>另一个策略是考虑<span class="math inline">\(\bigwedge^2 ( V ) \cong
\mathrm{ Bil } ( V^\vee , V^\vee ; F
)\)</span>,而且右侧是反对称的.然而我们对辛形式早有研究,回忆到取基使得<span class="math inline">\(B ( p_i , q_i ) = 1\)</span>而当<span class="math inline">\(i \ne j\)</span>的时候<span class="math inline">\(B ( p_i , q_j ) =
0\)</span>.用辛形式的分类得知存在一组基<span class="math inline">\(u_1 ,
\cdots , u_r , v_1 , \cdots v_r\)</span>,其中<span class="math inline">\(2 r \leq n\)</span>使得<span class="math inline">\(\omega = \sum_{ i = 1 }^r u_i \wedge
v_i\)</span>.立刻见到<span class="math inline">\(\omega \wedge \omega =
0 \Rightarrow r \in \{ 0 , 1 \}\)</span>.</p>
<h5><span id="简单应用">简单应用</span></h5>
<p>对于外代数来说,其最显然的应用是考虑<span class="math inline">\(V =
\mathbb{ R }^3\)</span>的情形,此时<span class="math inline">\(\bigwedge^2 ( V )\)</span>有<span class="math inline">\(\vec{ e }_1 \wedge \vec{ e }_2 , \vec{ e }_1
\wedge \vec{ e }_3 , \vec{ e }_2 \wedge \vec{ e
}_3\)</span>三个基,并且:</p>
<p><span class="math display">\[
\begin{aligned}
&amp; ( x \vec{ e }_1 + y \vec{ e }_2 + z \vec{ e }_3 ) \wedge ( x &#39;
\vec{ e }_1 + y &#39; \vec{ e }_2 + z &#39; \vec{ e }_3 ) \\
= &amp; ( xy &#39; - x &#39; y ) ( \vec{ e }_1 \wedge \vec{ e }_2 ) + (
yz &#39; - y &#39; z ) ( \vec{ e }_2 \wedge \vec{ e }_3 ) + ( zx &#39; -
z &#39; x ) ( \vec{ e }_3 \wedge \vec{ e }_1 )
\end{aligned}
\]</span></p>
<p>这其实就是叉积对吧.</p>
<h4><span id="域的变换">域的变换</span></h4>
<p>对于域<span class="math inline">\(F \subseteq
E\)</span>,如果我们有一个定义在<span class="math inline">\(F\)</span>上的向量空间<span class="math inline">\(V\)</span>,我们想要一种策略将其典范地推广到<span class="math inline">\(E\)</span>上的向量空间<span class="math inline">\(V_E\)</span>.</p>
<p>将<span class="math inline">\(E\)</span>视作一个<span class="math inline">\(F\)</span>向量空间.乘法映射<span class="math inline">\(E \times E \to
E\)</span>当然是双线性映射,从而诱导出<span class="math inline">\(E
\otimes E \to E , x \otimes y \mapsto xy\)</span>的映射.</p>
<p>考虑一个<span class="math inline">\(F\)</span>向量空间<span class="math inline">\(V\)</span>,考虑下述线性映射:</p>
<p><span class="math display">\[
\begin{aligned}
E \times ( E \otimes_F V ) &amp; \to E \otimes_F ( E \otimes_F V ) \cong
( E \otimes_F E ) \otimes_F V \to E \otimes_F V \\
( x , y \otimes_F v ) &amp; \mapsto x \otimes_F ( y \otimes v ) \mapsto
( x \otimes_F y ) \otimes_F v \mapsto ( xy ) \otimes_F v
\end{aligned}
\]</span></p>
<p>于是<span class="math inline">\(E \otimes_F V\)</span>成为了一个<span class="math inline">\(E\)</span>线性空间.</p>
<p>另一个重要的是检验如果<span class="math inline">\(V ,
W\)</span>都是<span class="math inline">\(F\)</span>向量空间,则上述拓展后<span class="math inline">\(\mathrm{ Hom } ( V_E , W_E )\)</span>亦然构成<span class="math inline">\(E\)</span>向量空间.而且我们还要检验如果原本的<span class="math inline">\(f : V \cong W\)</span>,则<span class="math inline">\(f_E : V_E \cong W_E\)</span>.</p>
<p>取<span class="math inline">\(V\)</span>的一组基<span class="math inline">\(\{ v_i \}_{ i \in I }\)</span>,则:</p>
<p><span class="math display">\[
V_E = E \otimes_F ( \bigoplus_{ i \in I } F v_i ) \cong \bigoplus_{ i
\in I } ( E \otimes_F F ) \cong E^{ \oplus I }
\]</span></p>
<p>从而我们知道<span class="math inline">\(V_E\)</span>有一组基:<span class="math inline">\(\{ \tilde{ v }_i = 1_E \otimes v_i \}_{ i \in I
}\)</span>,推论是<span class="math inline">\(\dim_F V = \dim_E
V_E\)</span>.</p>
<p>接下来将<span class="math inline">\(\mathrm{ Hom }_F ( F^n , F^m
)\)</span>等同于矩阵<span class="math inline">\(A \in M_{ m \times n } (
F )\)</span>,我们下面验证<span class="math inline">\(A_E = 1_E \otimes
A\)</span>.只需发现:</p>
<p><span class="math display">\[
\begin{aligned}
A_E ( \tilde{ e }_i ) &amp; = ( 1_E \otimes A ) ( 1_E \otimes e_i ) \\
&amp; = 1_E \otimes ( Ae_i ) \\
&amp; = 1_e \otimes ( \sum_{ k = 1 }^n a_{ k , i } e_k ) \\
&amp; = \sum_{ k = 1 }^n a_{ k , i } ( 1_E \otimes e_k ) \\
&amp; = \sum_{ k = 1 }^n a_{ k , i } \tilde{ e_k }
\end{aligned}
\]</span></p>
<p>考虑<span class="math inline">\(i : V \to V_E , v \mapsto 1_E \otimes
v\)</span>可以作为一个<span class="math inline">\(F\)</span>线性映射,方法是将<span class="math inline">\(V_E\)</span>限制成一个<span class="math inline">\(F\)</span>向量空间.这显然是一个单射.</p>
<p>下面假设<span class="math inline">\(V\)</span>是一个<span class="math inline">\(F\)</span>向量空间,<span class="math inline">\(\tilde{ V }\)</span>是一个<span class="math inline">\(E\)</span>向量空间,则我们下面来证明最后的结论:</p>
<p><span class="math display">\[
\begin{aligned}
\mathrm{ Hom }_E ( V_E , \tilde{ V } ) &amp; \cong \mathrm{ Hom }_F ( V
, \tilde{ V } ) \\
\tilde{ f } &amp; \mapsto \tilde{ f } \circ i
\end{aligned}
\]</span></p>
<p>先证明这的确是一个单射,考虑:</p>
<p><span class="math display">\[
\tilde{ f } ( t \otimes v ) = \tilde{ f } ( t \cdot i ( v ) ) = t \cdot
( \tilde{ f } \circ i ) ( v )
\]</span></p>
<p>由于<span class="math inline">\(i\)</span>是一个单射,所以这里如果非单,则存在两个<span class="math inline">\(\tilde{ f }_1 , \tilde{ f_2 }\)</span>满足<span class="math inline">\(\forall v\)</span>,<span class="math inline">\((
\tilde{ f }_1 \circ i ) ( v ) = ( \tilde{ f }_2 \circ i ) ( v
)\)</span>,必然导出<span class="math inline">\(\forall t \otimes v ,
\tilde{ f }_1 ( t \otimes v ) = \tilde{ f }_2 ( t \otimes v
)\)</span>.</p>
<p>接下来考虑其满射,对于<span class="math inline">\(f \in \mathrm{ Hom
}_F ( V , \tilde{ V } )\)</span>,考虑<span class="math inline">\(E
\times V \to \tilde{ V } , ( t , v ) \mapsto t f ( v
)\)</span>当然是一个<span class="math inline">\(F\)</span>上的双线性映射,其对应了一个<span class="math inline">\(\tilde{ f } : E \otimes_F V \to \tilde{ V } , t
\otimes v \mapsto tf ( v )\)</span>.这就论证了满性.</p>
<p>好吧,我们上面论证的一切都太过无趣,但请来总结,我们实际上是想要这么做:假设我有<span class="math inline">\(F\)</span>上的向量空间<span class="math inline">\(V\)</span>,<span class="math inline">\(E\)</span>上的向量空间<span class="math inline">\(\tilde{ V }\)</span>以及它们之间的<span class="math inline">\(F\)</span>线性映射<span class="math inline">\(f\)</span>.关于这个<span class="math inline">\(f\)</span>的看法,如果我们将<span class="math inline">\(\tilde{ V }\)</span>拉到<span class="math inline">\(F\)</span>上当然是可以的对吧,那能不能将<span class="math inline">\(V\)</span>升上<span class="math inline">\(E\)</span>呢?我们想要一个资料<span class="math inline">\(( \tilde{ V }_{ \mathrm{ univ } } , f_{ \mathrm{
univ } } )\)</span>使得下述图表交换:</p>
<p><span class="math display">\[
\xymatrix{ V \ar[r]^{ f_{ \mathrm{ univ } } } \ar[rd]_{ f } &amp;
\tilde{ V }_{ \mathrm{ univ } } \ar[d]^{ \tilde{ f } } \\
&amp; \tilde{ V } }
\]</span></p>
<p>我们上面所证明的就是这个资料<span class="math inline">\(( \tilde{ V
}_{ \mathrm{ univ } } , f_{ \mathrm{ univ } } )\)</span>可以取作<span class="math inline">\(( E \otimes_F V , i )\)</span>.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_telegram"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" rel="prev" title="递归式与和式">
                  <i class="fa fa-angle-left"></i> 递归式与和式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/23/%E6%96%87%E5%8C%96%E8%AF%BE-%E6%96%87%E5%8C%96%E8%AF%BE%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/" rel="next" title="文化课数学导论">
                  文化课数学导论 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2025/06/23/%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
