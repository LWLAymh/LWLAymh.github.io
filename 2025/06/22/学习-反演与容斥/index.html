<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="反演 假设有两个函数$f \(和\)g \(满足:\)f ( n ) &#x3D; { k } a { n , k } g ( k ) $,已知f求g的过程称为反演. 一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法. 子集反演 一般形式: \[ \begin{aligned} f ( S ) &amp; &#x3D; \sum _{ T \subseteq S  } g ( T )">
<meta property="og:type" content="article">
<meta property="og:title" content="反演与容斥">
<meta property="og:url" content="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="反演 假设有两个函数$f \(和\)g \(满足:\)f ( n ) &#x3D; { k } a { n , k } g ( k ) $,已知f求g的过程称为反演. 一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法. 子集反演 一般形式: \[ \begin{aligned} f ( S ) &amp; &#x3D; \sum _{ T \subseteq S  } g ( T )">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-22T08:57:48.207Z">
<meta property="article:modified_time" content="2025-06-22T08:57:48.207Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/","path":"2025/06/22/学习-反演与容斥/","title":"反演与容斥"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>反演与容斥 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">反演</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">子集反演</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">Example1(2019zrpzt七连day1D)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">Example2(有标号DAG计数)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">二项式反演</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Example1(错排问题)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Example2(CF1750G)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">Example3(CF1228E)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">斯特林反演</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">莫比乌斯反演</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.2.</span> <span class="nav-text">Example2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">增加枚举量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">交换枚举顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">分离无关变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.3.</span> <span class="nav-text">Example3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.4.</span> <span class="nav-text">Example4</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">换元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.5.</span> <span class="nav-text">Example5([UR #5]怎样跑得更快)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.6.</span> <span class="nav-text">Example6([CF1566H]Xor-quiz)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.5.</span> <span class="nav-text">多重子集反演</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">单位根反演(离散傅里叶变换)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">一般情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">容斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.1.</span> <span class="nav-text">一般形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">Example1(不定方程非负整数解计数)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.2.</span> <span class="nav-text">Example2(错排问题)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.3.</span> <span class="nav-text">Example3(bzoj3622已经没有什么好害怕的了)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.4.</span> <span class="nav-text">Example4(HAOI2008硬币购物)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.5.</span> <span class="nav-text">Example5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.6.</span> <span class="nav-text">Example6</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.7.</span> <span class="nav-text">Example7(AGC058D)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.8.</span> <span class="nav-text">Example8(AGC035F)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.9.</span> <span class="nav-text">Example9</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.10.</span> <span class="nav-text">Example10([AGC036F] Square
Constraints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.11.</span> <span class="nav-text">Example11([23省选第一轮集训day4]C带劲的旅行)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.1.12.</span> <span class="nav-text">Example12</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.2.</span> <span class="nav-text">Min-Max容斥</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">Example1([23省选10连测 day6]A)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">2.0.3.</span> <span class="nav-text">反射容斥</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="反演与容斥 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          反演与容斥
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 16:57:48" itemprop="dateCreated datePublished" datetime="2025-06-22T16:57:48+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%85%B7%E4%BD%93%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">具体数学</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>
<h2><span id="反演">反演</span></h2>
<p>假设有两个函数$f <span class="math inline">\(和\)</span>g <span class="math inline">\(满足:\)</span>f ( n ) = <em>{ k } a </em>{ n , k }
g ( k ) $,已知f求g的过程称为反演.</p>
<p>一般情况下,求反演只能高斯消元,但是有一些形式的反演有巧妙解法.</p>
<h3><span id="子集反演">子集反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f ( T ) \\
f ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } g ( T )
\Leftrightarrow g ( S ) &amp; = \sum _{ S \subseteq T \subseteq U  } ( -
1 ) ^{ | T | - | S |  } f ( T )
\end{aligned}
\]</span></p>
<p>证明:</p>
<p><span class="math display">\[
\begin{aligned}
g ( S ) &amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } f (
T ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ T \subseteq S  } ( - 1 ) ^{ | T |  }
\sum _{ P \subseteq T  } g ( P ) \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) \sum _{ T
\subseteq S / P  } ( - 1 ) ^{ | T | + | P |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) ( - 1 ) ^{
| P |  } \sum _{ T \subseteq S / P  } ( - 1 ) ^{ | T |  } \\
&amp; = ( - 1 ) ^{ | S |  } \sum _{ P \subseteq S  } g ( P ) [ S &amp; =
P ] ( - 1 ) ^{ | P |  } \\
&amp; = g ( S )
\end{aligned}
\]</span></p>
<p>不难发现,这个子集反演也就相当于在做高维前后缀和.</p>
<h5><span id="example12019zrpzt七连day1d">Example1(2019zrpzt七连day1D)</span></h5>
<p>根据子集反演,设$cnt <em>S <span class="math inline">\(为集合为\)</span>S <span class="math inline">\(的数量,然后设\)</span>f <em>S = </em>{ S ’ S } cnt
</em>{ S ’ } <span class="math inline">\(,有:\)</span>ans = _{ S } 2 ^{
f _S } ( - 1 ) ^{ n - | S | } $.</p>
<p>做一遍高维前缀和就好,复杂度$O ( n 2 ^n ) <span class="math inline">\(,应该也可以用分治FMT无脑做到\)</span>O ( n ^2 2 ^n
) $.</p>
<h5><span id="example2有标号dag计数">Example2(有标号DAG计数)</span></h5>
<p>设$f _{ i , j } <span class="math inline">\(表示\)</span>i <span class="math inline">\(个点,其中有\)</span>j $个点的入度数为$0
$的方案数.(等一下,为撒子想到要记度数为$0
$的点咧?因为你要一层一层转移,而在DAG中一层一层的就是零度点.而且说到底,你注意到有编号这个事实其实是很烦的,因为考虑如果一个一个点放上去,就有可能出现放的地方是等价的.而这么一层一层是绝对不会出现等价点的问题的.再说的仔细一点,如果我们把位置空着,然后选出一些放上来,是会出现等价点的问题的.但如果我们先选出来,然后再把边连上就不会.于是我们必须要枚举一些点然后再连到上面去)</p>
<p>这样我们每次枚举删去这$j <span class="math inline">\(个点后,还剩下\)</span>k $个零度点.于是自然有:</p>
<p><span class="math display">\[
f _{ i , j  } = \binom { i  } { j  } \sum _{ k = 1  } ^{ i - j  } ( 2 ^j
- 1 ) ^k 2 ^{ j ( i - j - k )  } f _{ i - j , k  }
\]</span></p>
<p>等一下咧,这复杂度$O ( n ^3 ) $了,这咋办啊?</p>
<p>好像转移优化不太了,因为$k
$很难省去(在指数上).但我们注意到我们定义的时候说:$0 <span class="math inline">\(度点的数量恰好为\)</span>k
$,这个条件好像太强了<del>果然OI就是发现限制太强了就弱一点,发现太弱了就强一点</del>,所以我们想办法把它放弱一点.</p>
<p>一个经典的方法是:我们把定义改为至少$k
$个零度点.但是这样转移好像还是不太行:零度点的情况太多了.那我们不妨考虑容斥,因为推导容斥的过程中,永远不害怕情况太多:我们直接考虑所有情况的集合.<del>当然能不能推到最后是另一回事</del>.</p>
<p>我们设$f ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,其中只有\)</span>S $中的点的入度为$0 <span class="math inline">\(;类似定义\)</span>g ( n , S ) <span class="math inline">\(表示\)</span>n <span class="math inline">\(个点,至少\)</span>S $中的点的入度为$0 <span class="math inline">\(.显然我们所求也就是\)</span>g ( n , )
$,注意到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n , S ) &amp; = 2 ^{ | S | ( n - | S | )  } g ( n - | S | ,
\emptyset ) \\
g ( n , S ) &amp; = \sum _{ S \subseteq T  } f ( n , T )
\end{aligned}
\]</span></p>
<p>对第二个式子用子集反演,有:</p>
<p><span class="math display">\[
f ( n , S ) = \sum _{ S \subseteq T  } ( - 1 ) ^{ | T | - | S |  } g ( n
, T )
\]</span></p>
<p>接下来使用反复带入大法:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n , \emptyset ) &amp; = \sum _{ \emptyset \ne T  } f ( n , T ) \\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } g ( n , S )
\\
&amp; = \sum _{ T \subseteq S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S |
( n - | S | )  } g ( n - | S | , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ | T | = m  } \sum _{ T \subseteq
S  } ( - 1 ) ^{ | S | - | T |  } 2 ^{ | S | ( n - | S | )  } g ( n - | S
| , \emptyset ) \\
&amp; = \sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>可以发现:我们在推式子的过程中,将和集合本身有关的性质转化为了只和集合大小有关的式子,于是就简化了大量运算.</p>
<p>接下来我们继续化简:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ m = 1  } ^n \binom { n  } { m  } \sum _{ k = m  } ^n \binom { n
- m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g ( n - k ,
\emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \sum _{ m = 1  } ^k \binom { n  } { m  }
\binom { n - m  } { k - m  } ( - 1 ) ^{ k - m  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) \sum _{ m = 1  } ^k \binom { k  } { m  } ( - 1 ) ^{
k - m  } \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( ( 1 - 1 ) ^k - ( - 1 ) ^k ) \\
&amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } 2 ^{ k ( n - k )  } g (
n - k , \emptyset ) ( - 1 ) ^{ k - 1  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到复杂度已经降到$O ( n ^2 ) $了.</p>
<p>上面是从集合的角度一步步分析得到的.但如果你直接从容斥的角度考虑,忽略掉那个$(
- 1 ) ^{ k - 1 }
$,把它当成一个可以数学归纳出来的容斥系数,那么这个式子会得到一个很简单的理解方式:</p>
$$
<span class="math display">\[\begin{aligned}
f _n &amp; = \sum _{ k = 1  } ^n \binom { n  } { k  } ( - 1 ) ^{ k -
1  } 2 ^{ k ( n - k )  } f _{ n - k  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>也就是直接设,然后钦定其有至少$j $个,然后配容斥系数.</p>
<h3><span id="二项式反演">二项式反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k \binom { n  } { k  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k
\binom { n  } { k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N C _k ^n g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _k ^n f ( k ) \\
f ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k \binom { k  } { n  } g (
k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^k
\binom { k  } { n  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>显然以$( - 1 ) ^n g ( n ) <span class="math inline">\(代替\)</span>g
( n ) $即可从第一个式子推导第二个式子,下面证明第一个式子:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k )
\\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^{ n - m  } ( - 1 ) ^k C _{
n - m  } ^k C _n ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k \sum _{ m = 0  } ^{ n -
k  } C _{ n - k  } ^m g ( m ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^k C _n ^k f ( n - k ) \\
&amp; = \sum _{ k = 0  } ^n ( - 1 ) ^{ n - k  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example1错排问题">Example1(错排问题)</span></h5>
<p>$n
$个有编号的人站成一排,求他们都没有站到自己编号对应位置的方案数.</p>
<p>设$f ( n ) <span class="math inline">\(为\)</span>n <span class="math inline">\(个人随便站的方案数,\)</span>g ( n ) <span class="math inline">\(为\)</span>n $个人都站错的方案数.</p>
<p>如果知道$g <span class="math inline">\(的表达式,我们可以通过枚举有多少人站错位置来得到\)</span>f
<span class="math inline">\(,即:\)</span>f ( n ) = _{ k = 0 } ^n C _n ^k
g ( k ) $.</p>
<p>显然就是一个二项式反演,$g ( n ) = _{ k = 0 } ^n ( - 1 ) ^{ n - k } C
<em>n ^k f ( k ) = </em>{ k = 0 } ^n ( - 1 ) ^{ n - k } C _n ^k k !
$.</p>
<p>值得一提的是,我们再观察一下最后得到的错排公式并进行一定的化简,可以得到:$g
( n ) = n ! _{ 0 k n } { k ! } \ $.</p>
<p>不难发现$n ! <span class="math inline">\(的后面形如\)</span>e ^{ - 1
} $的泰勒展开,我们考虑直接将泰勒展开的公式带入,可以得到:</p>
<p><span class="math display">\[
\begin{aligned}
g ( n ) &amp; = \cfrac { n !  } { e  } - n ! \sum _{ k &gt; n  } \cfrac
{ ( - 1 ) ^k  } { k !  } \\
&amp; = \cfrac { n !  } { e  } - \cfrac { ( - 1 ) ^{ n + 1  }  } { n +
1  } \sum _{ 0 \leq k  } ( - 1 ) ^k \cfrac { ( n + 1 ) !  } { ( k + n +
1 ) !  }
\end{aligned}
\]</span></p>
<p>用一些我不会的方法分析误差,会发现后面的项所能带来的误差很小,于是有$g
( n ) = { e } + { 2 } + [ n = 0 ] $.</p>
<p>另外,观察$g <span class="math inline">\(关于\)</span>f <span class="math inline">\(的表达式,不难求出\)</span>g <span class="math inline">\(的递推式:\)</span>g ( n ) = ng ( n - 1 ) + ( - 1 )
^n $.</p>
<p>下面证明$g <em>n = ( n - 1 ) ( g </em>{ n - 1 } + g _{ n - 2 } )
$,事实上,右边等于:</p>
$$
<span class="math display">\[\begin{aligned}
( n - 1 ) ( g _{ n - 1  } + g _{ n - 2  } ) \\
&amp; = ( - 1 ) ^{ n - 1  } ( n - 1 ) + ( n - 1 ) \sum _{ k = 0  } ^{ n
- 2  } ( ( n - 1 ) ! \frac { ( - 1 ) ^k  } { k !  } + ( n - 2 ) ! \frac
{ ( - 1 ) ^k  } { k !  } ) \\
&amp; = n ! \sum _{ k = 0  } ^{ n - 2  } \frac { ( - 1 ) ^k  } { k !  }
- ( n - 1 ) ( - 1 ) ^n \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="example2cf1750g">Example2(CF1750G)</span></h5>
<p>如果没有字典序限制就是经典的二项式反演:考虑能被分为$k <span class="math inline">\(段,说明有\)</span>n - k
$个位置和前一个位置是大一的关系.我们钦定这些位置即可.</p>
<p>而有字典序限制也很经典,枚举LCP,枚举下一个位置,这个时候值域被分为若干个区间,假设剩了$x
<span class="math inline">\(个数字,\)</span>y <span class="math inline">\(个区间,那么钦定\)</span>j <span class="math inline">\(对的方案是\)</span> { j } ( x - j ) ! <span class="math inline">\(.然后要乘上前面已经有了的,也就是乘上形如\)</span>(
1 + z ) ^k <span class="math inline">\(.这样复杂度\)</span>O ( n ^4 )
$.</p>
<p>这种问题通常LCP后的下一个位置都可以规避,这里你发现不同的取值只会让后面的$x
, y , k <span class="math inline">\(有\)</span>O ( 1 ) <span class="math inline">\(种不同的取值,因此不用枚举.这样就是\)</span>O ( n
^3 ) <span class="math inline">\(.但是那个多项式乘法也可以规避,考虑最后的答案形如\)</span>(
1 + z ) ^k P <em>k ( x ) <span class="math inline">\(,我们考虑写成\)</span>P </em>{ n - 1 } ( z ) + = (
1 + z ) P _n ( z ) <span class="math inline">\(,然后不断这么做,就只需要\)</span>O ( n ^2 ) $.</p>
<h5><span id="example3cf1228e">Example3(CF1228E)</span></h5>
<p>不妨设至多有$i <span class="math inline">\(行\)</span>j $列最小值为$1
<span class="math inline">\(的答案是\)</span>f <em>{ i , j } <span class="math inline">\(,恰好有\)</span>i <span class="math inline">\(行\)</span>j $列最小值为$1 <span class="math inline">\(的答案是\)</span>g </em>{ i , j } $,注意到:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>令$h <em>{ n , m } = </em>{ j = 0 } ^m { j } g <em>{ n , j } \ <span class="math inline">\(,则\)</span>f </em>{ n , m } = <em>{ i = 0 } ^n {
i } h </em>{ i , m } \ <span class="math inline">\(,而\)</span>f _{ n ,
m } = k ^{ nm } ( k - 1 ) ^{ NM - nm } <span class="math inline">\(.做两次二项式反演得到\)</span>g $.</p>
<p>写到这里发现一个问题(其实是我发现问题后把上面原本写错的给改了),为啥$f
_{ n , m } { n } { m } k ^{ nm } ( k - 1 ) ^{ NM - nm }
$呢?我们写成子集反演形式看看:</p>
$$
<span class="math display">\[\begin{aligned}
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } \sum _{ t \subseteq T  }
g _{ s , t  } \\
f _{ S , T  } &amp; = \sum _{ s \subseteq S  } h _{ s , T  } \\
h _{ S , T  } &amp; = \sum _{ t \subseteq T  } g _{ S , t  } \\

\end{aligned}\]</span>
<p>$$</p>
<p>做子集反演:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ S , T  } &amp; = k ^{ | S | \times | T |  } ( k - 1 ) ^{ NM - | S |
| T |  } \\
h _{ s , T  } &amp; = \sum _{ S \subseteq s  } ( - 1 ) ^{ | s | - | S
|  } f _{ S , T  } \\
g _{ s , t  } &amp; = \sum _{ T \subseteq t  } ( - 1 ) ^{ | t | - | T
|  } h _{ s , T  }
\end{aligned}
\]</span></p>
<p>把集合改成集合大小就可以发现问题所在:</p>
<p>换句话说,$g <em>{ n , m } <span class="math inline">\(本身就包含了所有\)</span>| S | = n , | T | = m
<span class="math inline">\(的情况的和,并且在组合数\)</span> { j } <span class="math inline">\(那里就找到了唯一确定的\)</span>f </em>{ s , t }
<span class="math inline">\(,因此\)</span>f _{ n , m } <span class="math inline">\(是唯一确定的.这意味着这里\)</span>f <span class="math inline">\(的\)</span>n , m
$并非集合之和,而是已经确定的集合的大小.</p>
<p>啥?这和我平常接触的二项式反演不一样啊?不说别的,第四题(BZOJ2839)的式子是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _i &amp; = 2 ^{ 2 ^{ n - i  }  } \binom { n  } { i  } \\
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\
g _k &amp; = \sum _{ i = k  } ^n ( - 1 ) ^{ i - k  } \binom { i  } {
k  } f _i
\end{aligned}
\]</span></p>
<p>冷静一下,二项式反演的公式肯定没错,那也就一定是下面这几句出现了问题:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个问题其实非常显然,我们的$g _{ i , j } <span class="math inline">\(定义为所有\)</span>| S | = i , | T | = j <span class="math inline">\(的答案之和.\)</span>f
$也是这么定义的,那这个式子就是错的,应该写成:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { N - i  } { n - i  } \sum _{
j = 0  } ^m \binom { M - j  } { m - j  } g _{ i , j  }
\]</span></p>
<p>这样才是在不确定的那些行列中选择组合数,而不是在确定的那些行列中选.</p>
<p>但这样又有一个问题,就是这个题的特殊性,这个题要求$g _{ N , M } <span class="math inline">\(,那此时\)</span>g $怎么定义不应该是一样的吗?</p>
<p>当然不一样,二项式反演讲究统一性,所有的定义必须遵循一个统一的原则,不然如果什么样子的函数都能反演,那一般的反演就不是一个需要解方程才能完成的东西了.</p>
<p>回到第四题,再看一遍这个式子:</p>
$$
<span class="math display">\[\begin{aligned}
f _k &amp; = \sum _{ i = k  } ^n \binom { i  } { k  } g _i \\

\end{aligned}\]</span>
<p>$$</p>
<p>这个定义式就非常良性,$g <span class="math inline">\(是已知的集合,\)</span>f <span class="math inline">\(是未知的集合.我们乘上组合数就可以得到对于\)</span>f
$来说已知的集合.因此这个就非常正确.</p>
<p>回到这个题上,为什么我们最后把$f <span class="math inline">\(的定义改成\)</span>f _{ n , m } = k ^{ nm } ( k -
1 ) ^{ NM - nm } $就对了呢?</p>
<p>再看看这个式子:</p>
<p><span class="math display">\[
f _{ n , m  } = \sum _{ i = 0  } ^n \binom { n  } { i  } \sum _{ j =
0  } ^m \binom { m  } { j  } g _{ i , j  }
\]</span></p>
<p>这个式子的右边在干这样一件事:那就是在已知$n <span class="math inline">\(行\)</span>m <span class="math inline">\(列的集合的前提下,从中选出\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列并求\)</span>g <span class="math inline">\(.那么你从哪知道的\)</span>n <span class="math inline">\(行\)</span>m $列呢?你得组合数啊!</p>
<p>所以,实际上的$f $是这样的:</p>
<p><span class="math display">\[
\begin{aligned}
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } \sum _{
i = 0  } ^n \binom { n  } { i  } \sum _{ j = 0  } ^m \binom { m  } {
j  } g _{ i , j  } \\
f _{ n , m  } &amp; = \binom { N  } { n  } \binom { M  } { m  } k ^{
nm  } ( k - 1 ) ^{ NM - nm  }
\end{aligned}
\]</span></p>
<p>好麻烦啊,能不能避免这种需要进一步思考集合意义的问题呢?</p>
<p>考虑二项式反演的第二个形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = n  } ^N C _n ^k g ( k ) \Leftrightarrow g (
n ) &amp; = \sum _{ k = n  } ^N ( - 1 ) ^{ k - n  } C _n ^k f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不难发现这个式子无论怎么写,前后都一定是从已知集合中选东西.绝对不会出现上面的问题.</p>
<p>因此,我们重新写一下这个题的相关式子,考虑直接正难则反,设$f ’ <em>{ i ,
j } <span class="math inline">\(为至少有\)</span>i <span class="math inline">\(行\)</span>j <span class="math inline">\(列不满足条件的方案数,自然有\)</span>f ’ </em>{ i ,
j } = f _{ N - i , M - j } $.你发现此时一定有:</p>
<p><span class="math display">\[
f &#39; _{ n , m  } = \sum _{ i = n  } ^N \binom { i  } { n  } \sum _{ j
= m  } ^M \binom { j  } { m  } g &#39; _{ i , j  }
\]</span></p>
<p>最后答案就是$g ’ _{ 0 , 0 } $.</p>
<h3><span id="斯特林反演">斯特林反演</span></h3>
<p>一般形式:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k
= 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\
f ( n ) &amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] g ( k ) \Leftrightarrow g ( n ) &amp; = \sum _{ k =
0  } ^n \left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} ( - 1 ) ^{ n - k  } f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left [
\begin{array}
{ c  } n \\
m
\end{array} \right ] g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k =
0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\
f ( m ) &amp; = \sum _{ n = m  } ^M ( - 1 ) ^{ m - n  } \left \{
\begin{array}
{ c  } n \\
m
\end{array} \right \} g ( n ) \Leftrightarrow g ( m ) &amp; = \sum _{ k
= 0  } ^M \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑第一类斯特林数和第二类斯特林数的对称性,只需证明第一个和第三个式子即可.</p>
<p>反转公式:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } &amp; = \sum _{ k = 0  } ^n
\left \{ \begin{array}
{ c  } n \\
k
\end{array} \right \} \left [ \begin{array}
{ c  } k \\
m
\end{array} \right ] ( - 1 ) ^{ n - k  } &amp; = [ m &amp; = n ] \\

\end{aligned}\]</span>
<p>$$</p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 0  } ^n [ m &amp; = n ] g ( m ) \\
&amp; = \sum _{ m = 0  } ^n \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( m ) \\
&amp; = \sum _{ k = 0  } ^n \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } \sum _{ m = 0  } ^k \left \{
\begin{array}
{ c  } k \\
m
\end{array} \right \} g ( m ) &amp; = \sum _{ k = 0  } ^n \left [
\begin{array}
{ c  } n \\
k
\end{array} \right ] ( - 1 ) ^{ n - k  } f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( m ) &amp; = \sum _{ n = m  } ^M [ n &amp; = m ] g ( n ) \\
&amp; = \sum _{ n = m  } ^M \sum _{ k = 0  } ^M \left [ \begin{array}
{ c  } n \\
k
\end{array} \right ] \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} ( - 1 ) ^{ n - k  } g ( n ) \\
&amp; = \sum _{ k = 0  } ^M \left \{ \begin{array}
{ c  } k \\
m
\end{array} \right \} f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<h3><span id="莫比乌斯反演">莫比乌斯反演</span></h3>
<p>一般形式:</p>
<p><span class="math display">\[
\begin{aligned}
f ( n ) &amp; = \sum _{ d | n  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\
f ( n ) &amp; = \sum _{ n | d  } g ( d ) \Leftrightarrow g ( n ) &amp; =
\sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\
f ( x ) &amp; = \sum _{ 1 \leq d  } g ( d ) \Leftrightarrow g ( x )
&amp; = \sum _{ 1 \leq d  } f ( \cfrac { x  } { d  } ) \mu ( d )
\end{aligned}
\]</span></p>
<p>第一个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m | n  } [ \frac { n  } { m  } &amp; = 1 ] g ( m
) \\
&amp; = \sum _{ m | n  } \sum _{ d | \frac { n  } { m  }  } \mu ( d ) g
( m ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$[ d | { m } ] = [ md | n ] = [ m | { d } ] \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ d | n  } \mu ( d ) \sum _{ m | \frac { n  } {
d  }  } g ( m ) \\
&amp; = \sum _{ d | n  } \mu ( d ) f ( \frac { n  } { d  } ) \\
&amp; = \sum _{ d | n  } \mu ( \frac { n  } { d  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第二个式子的证明:</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ n | d  } [ \frac { d  } { n  } &amp; = 1 ] g ( d
) \\
&amp; = \sum _{ n | d  } \sum _{ c | \frac { d  } { n  }  } \mu ( c ) g
( d ) \\
&amp; = \sum _{ c | d  } \sum _{ nc | d  } \mu ( c ) g ( d ) \\
&amp; = \sum _{ c  } \mu ( c ) f ( nc ) \\
&amp; = \sum _{ n | d  } \mu ( \frac { d  } { n  } ) f ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>第三个式子的证明:</p>
<p><span class="math display">\[
\begin{aligned}
\sum _{ 1 \leq d  } g ( \cfrac { x  } { d  } ) \mu ( d ) &amp; = \sum _{
d \geq 1  } \mu ( d ) \sum _{ k \geq 1  } f ( \cfrac { x  } { kd  } ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d , k
\geq 1  } [ m &amp; = dk ] \mu ( d ) \\
&amp; = \sum _{ m \geq 1  } f ( \cfrac { x  } { m  } ) \sum _{ d | m  }
\mu ( d ) \\
&amp; = f ( x )
\end{aligned}
\]</span></p>
<h4><span id="example1">Example1</span></h4>
<p>求长度为$n <span class="math inline">\(且仅包含小写英文字母且循环节长度恰为\)</span>n
$的字符串个数.</p>
<p>不妨设$f ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(的字符串个数,\)</span>g ( n ) <span class="math inline">\(表示长度为\)</span>n <span class="math inline">\(且循环节长度恰为\)</span>n $的字符串个数.</p>
<p>有$f ( n ) = <em>{ d | n } g ( d ) <span class="math inline">\(,根据莫比乌斯反演,\)</span>g ( n ) = </em>{ d | n
} ( { d } ) f ( d ) $.</p>
<h4><span id="example2">Example2</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m gcd ( i , j ) \ $.</p>
<p>我们通过这个题来讲一下推导技巧.</p>
<h5><span id="增加枚举量">增加枚举量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m gcd ( i , j ) &amp; = \sum
_{ i = 1  } ^n \sum _{ j = 1  } ^m id [ gcd ( i , j ) ] \\
&amp; = \sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j
)  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="交换枚举顺序">交换枚举顺序</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^n \sum _{ j = 1  } ^m \sum _{ d | gcd ( i , j )  }
\varphi ( d ) &amp; = \sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{
\lfloor \frac { n  } { d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac
{ m  } { d  } \rfloor  } _{ j = 1  } \varphi ( d ) \\

\end{aligned}\]</span>
<p>$$</p>
<h5><span id="分离无关变量">分离无关变量</span></h5>
$$
<span class="math display">\[\begin{aligned}
\sum _{ d = 1  } ^{ \min ( n , m )  } \sum ^{ \lfloor \frac { n  } {
d  } \rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  }
\rfloor  } _{ j = 1  } \varphi ( d ) &amp; = \sum ^{ \min ( n , m )  }
_{ d = 1  } \varphi ( d ) \times \lfloor \cfrac { n  } { d  } \rfloor
\times \lfloor \cfrac { m  } { d  } \rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>考虑使用数论分块,只需处理出$( d ) <span class="math inline">\(的前缀和即可在\)</span>O ( + )
$的复杂度解决此问题.</p>
<h4><span id="example3">Example3</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) = 1 ] \
$.</p>
<p>和上一道题几乎没区别,唯一不同的是需要处理的函数从$id <span class="math inline">\(变为了\)</span>$.</p>
<h4><span id="example4">Example4</span></h4>
<p>求$<em>{ i = 1 } ^{ n } </em>{ j = 1 } ^m [ gcd ( i , j ) prime ] \
$.</p>
<p>考虑增加枚举量,则:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m [ gcd ( i , j ) \in prime ]
&amp; = \sum _{ i = 1  } ^{ n  } \sum _{ j = 1  } ^m \sum _{ p \in
prime  } [ gcd ( i , j ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { d  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { d  } \rfloor  } _{
j = 1  } [ gcd ( pi , pj ) &amp; = p ] \\
&amp; = \sum _{ p \in prime  } \sum ^{ \lfloor \frac { n  } { p  }
\rfloor  } _{ i = 1  } \sum ^{ \lfloor \frac { m  } { p  } \rfloor  } _{
j = 1  } [ gcd ( i , j ) &amp; = 1 ] \\
&amp; = \sum _{ p \in prime  } \sum _{ d = 1  } ^{ \min ( \lfloor \frac
{ m  } { p  } \rfloor , \lfloor \frac { n  } { p  } \rfloor )  } \mu ( d
) \lfloor \cfrac { n  } { pd  } \rfloor \lfloor \cfrac { m  } { pd  }
\rfloor \\

\end{aligned}\]</span>
<p>$$</p>
<p>于是转化为上一道题,但复杂度仍不可接受.</p>
<h5><span id="换元">换元</span></h5>
<p>考虑设$x = pd <span class="math inline">\(,则变为\)</span><em>{ x = 1
} ^{ ( n , m ) } </em>{ p prime p | x } ( { p } ) { x } { x } \ $.</p>
<h4><span id="example5ur-5怎样跑得更快">Example5([UR #5]怎样跑得更快)</span></h4>
<p>首先先考虑去掉$lcm <span class="math inline">\(使得式子中只有\)</span>i , j , ( i , j ) $.</p>
<p>显然可以构造函数$f ( x ) = x ^{ c - d } , g ( x ) = x ^d , h ( x ) =
x ^d \ <span class="math inline">\(,然后将题目转化为\)</span>_{ j = 1 }
^n f ( gcd ( i , j ) ) g ( i ) h ( j ) x _j b _i ( p ) \ $.</p>
<p>$( i , j ) $很难处理,于是考虑用莫比乌斯反演消掉.</p>
<p>可以求出$f <em>r ( n ) <span class="math inline">\(使得\)</span>f ( n
) = </em>{ d | n } f _r ( d ) \ <span class="math inline">\(,也即\)</span>f <em>r ( n ) = </em>{ d | n } ( { d
} ) f ( d ) $.</p>
<p>则原式即:</p>
$$
<span class="math display">\[\begin{aligned}
\sum _{ j = 1  } ^n \sum _{ d  } [ d | i ] [ d | j ] f _r ( d ) g ( i )
h ( j ) x _j &amp; \equiv b _i ( \mod p ) \\
\sum _{ d | i  } f _r ( d ) \sum _{ j = 1  } ^n [ d | j ] h ( j ) x _j
&amp; \equiv \frac { b _i  } { g ( i )  } ( \mod p ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>令$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j \ <span class="math inline">\(,有\)</span></em>{ d | i } f _r ( d ) z _d { g ( i
) } ( p ) \ $.</p>
<p>这个也是一个莫比乌斯反演的形式,我们可以求出左边,进而求出$z _d $.</p>
<p>而$z <em>d = </em>{ j = 1 } ^n [ d | j ] h ( j ) x <em>j = </em>{ d |
j } ^n h ( j ) x _j <span class="math inline">\(,可以再次使用莫比乌斯反演求出\)</span>h ( j ) x _j
<span class="math inline">\(,进而求\)</span>x _j $.</p>
<p>无解条件显然是$g _i = 0 x _i $.</p>
<p>简而言之,这个题的步骤就是:</p>
<ol type="1">
<li><p>通过增加枚举量消掉$lcm <span class="math inline">\(以及\)</span>$这些难以处理的项.</p></li>
<li><p>将$i <span class="math inline">\(与\)</span>j
$尽量分到式子两边.</p></li>
<li><p>先通过莫比乌斯反演求出一些值,再通过这些值反推.</p></li>
</ol>
<h4><span id="example6cf1566hxor-quiz">Example6([CF1566H]Xor-quiz)</span></h4>
<p>首先注意到一个重要的事实:我们只需要询问所有$( x ) <span class="math inline">\(的\)</span>x <span class="math inline">\(,就可以得到全部信息,而这些\)</span>x
$的数量是完全足够我们全部询问一遍的.</p>
<p>注意到一个事实是,异或是模意义下的按位加减法,这意味着我们可以对异或做莫比乌斯反演.事实上,我们有:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \bigoplus _{ i \in A  } i [ \gcd ( i , n ) &amp; = 1 ]
\\
&amp; = \bigoplus _{ i \in A  } ^c i \sum _{ d | i , d | n  } \mu ( d )
\\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到$<em>{ d | i } ( d ) = </em>{ d | i } | ( d ) | $,于是:</p>
<p><span class="math display">\[
f ( n ) = \bigoplus _{ d | n  } | \mu ( d ) | \bigoplus _{ d | i , i \in
A  } i
\]</span></p>
<p>接下来只要我们形式上写作$n <span class="math inline">\(,我们就默认\)</span>( n ) <span class="math inline">\(,又令\)</span>g ( n ) = <em>{ n | i , i A } i
<span class="math inline">\(,此时自然有\)</span>f ( n ) = </em>{ d | n }
g ( d ) \ <span class="math inline">\(.这是一个经典的莫反形式,我们再反演回去就可以得到\)</span>g
( n ) = <em>{ d | n } ( { d } ) f ( d ) = </em>{ d | n } f ( d ) <span class="math inline">\(,也就是说我们可以求得所有的\)</span>g ( n ) <span class="math inline">\(,也就是这个集合中所有是\)</span>n
$的倍数的异或值.</p>
<p>注意一个事实:如果我们设$w ( m ) = <em>{ p prime , p | m } p <span class="math inline">\(,那么我们就可以按照\)</span>w <span class="math inline">\(的不同将所有数划分为若干个集合,每个集合在每次查询的时候要么都不被异或要么都被异或.这也告诉我们:我们只能求出每个集合中被选进\)</span>A
<span class="math inline">\(的这些数的异或值,而不能分开得知它们.接下来考虑如何知道这个,不妨设\)</span>S
( n ) = { x | w ( x ) = n } <span class="math inline">\(,又设\)</span>h
( n ) = </em>{ i A , i S ( n ) } i <span class="math inline">\(.考虑用\)</span>g ( n ) <span class="math inline">\(表示\)</span>h ( n ) $,我们有:</p>
<p><span class="math display">\[
g ( n ) = \bigoplus _{ n | d  } | \mu ( \frac { d  } { n  } ) | h ( d )
\]</span></p>
<p>反演,有$h ( n ) = _{ n | d } g ( d ) \ <span class="math inline">\(.于是我们可以求得所有的\)</span>h ( n ) $了.</p>
<p>现在的问题在于:对于数$n , ( n ) <span class="math inline">\(,我们要在\)</span>S ( n ) <span class="math inline">\(中选出若干个数,使得它们的异或和为\)</span>h ( n )
<span class="math inline">\(,并且选出的数字总共有\)</span>| A | $个.</p>
<p>然后是根据数据随机,拿每个集合的线性基随机一下自由元,然后对着构造.多随机几次,最后做背包.</p>
<h3><span id="多重子集反演">多重子集反演</span></h3>
<p>设$S $为可重集合.</p>
<p>一般形式:定义$( S ) <span class="math inline">\(,若\)</span>S
$包含重复元素则为$0 <span class="math inline">\(,否则为\)</span>( - 1 )
^{ | S | } $.</p>
$$
<span class="math display">\[\begin{aligned}
f ( S ) &amp; = \sum _{ T \subseteq S  } g ( T ) \Leftrightarrow g ( S )
&amp; = \sum _{ T \subseteq S  } \mu ( S - T ) f ( T ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>证明:</p>
<p>根据莫比乌斯反演,这个是显然的.</p>
<h3><span id="单位根反演离散傅里叶变换">单位根反演(离散傅里叶变换)</span></h3>
<p>一般形式($_n = e ^{ { n } } $):</p>
<p><span class="math display">\[
f _m = \sum _{ k = 0  } ^{ n - 1  } \omega _n ^{ mk  } g _k
\Leftrightarrow g _m = \frac { 1  } { n  } \sum _{ k = 0  } ^{ n - 1  }
\omega _n ^{ - mk  } f _k
\]</span></p>
<p>可以发现这个式子其实就是FFT时所做的DFT与IDFT.</p>
<h3><span id="一般情况">一般情况</span></h3>
<p>考虑莫比乌斯反演的过程,我们实际上使用的是$[ m | n ] _{ d | { m } } (
d ) = [ n = m ] \ $.</p>
<p>令$c = md <span class="math inline">\(,左边\)</span>= _{ c | n } [ m
| c ] ( { m } ) = ( [ c | n ] ) ( [ m | c ] ( { m } ) ) \ $.</p>
<p>令$A <em>{ c , n } = [ c | n ] <span class="math inline">\(,\)</span>B </em>{ m , c } = [ m | c ] ( { m } ) \
<span class="math inline">\(,那我们有\)</span>BA = I $.</p>
<p>刚才的过程相当于:</p>
$$
<span class="math display">\[\begin{aligned}
Ax &amp; = b \\
x &amp; = Ix \\
x &amp; = ( BA ) x \\
x &amp; = B ( Ax ) \\
x &amp; = Bb \\

\end{aligned}\]</span>
<p>$$</p>
<p>无论是二项式反演还是莫比乌斯反演,他们都满足$f ( n ) <span class="math inline">\(所依赖的\)</span>g ( k ) <span class="math inline">\(有\)</span>k n \ $.</p>
<p>根据上面的情况,我们发现$A <span class="math inline">\(是一个下三角矩阵,\)</span>B <span class="math inline">\(是\)</span>A ^{ - 1 } $.</p>
<p>现在来推导满足$k n $的一般情况反演:</p>
$$
<span class="math display">\[\begin{aligned}
f ( n ) &amp; = \sum _{ k = 1  } ^n a _{ n , k  } g ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>不妨设算子$( n , m ) <span class="math inline">\(,满足\)</span><em>{
k = 1 } ^n a </em>{ n , k } ( k , m ) = <em>{ k = 1 } ^n ( n , k ) a
</em>{ k , m } = [ n = m ] \ $.</p>
<p>即$AB = BA = I \ $.</p>
$$
<span class="math display">\[\begin{aligned}
g ( n ) &amp; = \sum _{ m = 1  } ^n [ n &amp; = m ] g ( m ) \\
&amp; = \sum _{ m = 1  } ^n \sum _{ k = 1  } ^n \mu ( n , k ) a _{ k ,
m  } g ( m ) \\
&amp; = \sum _{ k = 1  } ^n \mu ( n , k ) f ( k ) \\

\end{aligned}\]</span>
<p>$$</p>
<p>由上我们发现,反演解决了一些在下标上的二元运算卷积:</p>
$$
<span class="math display">\[\begin{aligned}
c _r &amp; = \sum _{ p , q  } [ f ( p , q ) &amp; = r ] a _p b _q \\

\end{aligned}\]</span>
<p>$$</p>
<p>而我们需要把$f
$分成两个独立的部分,通常正变换一下,处理一下,逆变换回来.</p>
<h2><span id="容斥">容斥</span></h2>
<h4><span id="一般形式">一般形式</span></h4>
<p>即:将求并集中元素个数转化成了求交集中元素个数.</p>
<p>我们有:$<em>{ i = 1 } ^n S <em>i = </em>{ T { 1 , . . . , n } } ( - 1
) ^{ | T - 1 | } </em>{ p T } S _p $.</p>
<p>证明:我们考虑对于每个元素,看它对最终答案的贡献.假设它所属$m <span class="math inline">\(个集合\)</span>T _1 , . . . , T _m
$,而除了这些集合以外的集合,</p>
<p><span class="math display">\[
\begin{aligned}
cnt &amp; = \sum _{ i = 1  } ^m ( - 1 ) ^{ i - 1  } \binom { m  } { i  }
\\
&amp; = \binom { m  } { 0  } - \sum _{ i = 0  } ^m ( - 1 ) ^i \binom {
m  } { i  } \\
&amp; = 1 - [ m &amp; = 0 ]
\end{aligned}
\]</span></p>
<p>显然,当这个元素被包含的时候,贡献为$1 $,反之贡献为$0 $.</p>
<p>如果我们定义一类在集合上的函数$F ( S ) = _{ p S } F ( p )
$,那么自然也有:</p>
<p><span class="math display">\[
F ( \bigcup _{ i = 1  } ^n S _i ) = \sum _{ T \subseteq \{ 1 , . . . , n
\}  } ( - 1 ) ^{ | T | - 1  } F ( \bigcap _{ p \in T  } S _p )
\]</span></p>
<p>另外,我们上面的做法是:当交集好求时求并集.我们还可以使用一步补集转化:</p>
<p><span class="math display">\[
\mid \bigcap _{ i = 1  } ^n S _i \mid = | U | - \mid \bigcup _{ i = 1  }
^n \overline { S _i  } \mid
\]</span></p>
<p>这样我们同样可以在并集好求的时候求交集.</p>
<p>会发现容斥和二项式反演是很像的.但是不一样的是,容斥是从集合的角度考虑,更注重单个元素的贡献;二项式反演是从函数的角度考虑,更关注函数之间的转化.</p>
<h5><span id="example1不定方程非负整数解计数">Example1(不定方程非负整数解计数)</span></h5>
<p>考虑不定方程$_{ i = 1 } ^n x _i = m <span class="math inline">\(,和\)</span>n <span class="math inline">\(个限制条件\)</span>x _i b _i <span class="math inline">\(,其中\)</span>m <span class="math inline">\(和\)</span>b _i
$都是非负整数,求该方程的非负整数解的数目.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是满足\)</span>_{ i = 1 } ^n x _i
= m $的所有非负整数解;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ x _i b _i ] $.</p></li>
</ol>
<p>设所有满足$P <em>i <span class="math inline">\(的解构成集合\)</span>S
<em>i <span class="math inline">\(,那么我们需要求解的值就是\)</span></em>{ i = 1 }
^n S <em>i <span class="math inline">\(.而\)</span>U <span class="math inline">\(显然是\)</span> { n - 1 } <span class="math inline">\(.我们有:\)</span></em>{ i = 1 } ^n S <em>i = | U |
- </em>{ i = 1 } ^n <span class="math inline">\(.考虑对\)</span></em>{ i
= 1 } ^n <span class="math inline">\(使用容斥原理,注意到\)</span> <span class="math inline">\(的意义是满足\)</span>x <em>{ i } b </em>{ i } + 1
$的解的数目.换句话说也就是部分变量有下界限制,那直接左右两边同时减去下界即可.于是枚举子集即可实现.</p>
<p>欸,等一下,咋想到的补集转化,又是咋想到要用容斥的捏?</p>
<p>我们冷静一下,首先补集转化和容斥都是一个思想:正难则反.我们要求满足条件的个数,就先想一下能不能求不满足条件的个数,然后拿总的个数减去.然后注意到不满足条件的意义是:有至少一个不满足,这样就很可以容斥了.</p>
<h5><span id="example2错排问题">Example2(错排问题)</span></h5>
<p>我们考虑从容斥的角度再次认识一下错排.</p>
<p>首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件):</p>
<ol type="1">
<li><p>$U <span class="math inline">\(是长度为\)</span>n
$的所有排列;</p></li>
<li><p>对于每个变量$i <span class="math inline">\(,都对应一个\)</span>P
_i = [ p _i i ] $.</p></li>
</ol>
<p>注意到所求仍然是$<em>{ i = 1 } ^n S <em>i <span class="math inline">\(.于是我们仍然试图\)</span>| </em>{ k = 1 } ^m |
<span class="math inline">\(.考虑其意义,也即:有\)</span>m <span class="math inline">\(个位置被确定了,而其它位置没有限制,于是\)</span>|
</em>{ k = 1 } ^m | = { m } ( n - m ) ! <span class="math inline">\(.根据容斥,自然有:\)</span>d <em>n = n ! - </em>{ m
= 1 } ^n ( - 1 ) ^{ m - 1 } { m } ( n - m ) ! = n ! _{ m = 0 } ^n { m !
} $.</p>
<h5><span id="example3bzoj3622已经没有什么好害怕的了">Example3(bzoj3622已经没有什么好害怕的了)</span></h5>
<p>首先可以用dp+双指针得到$f _i <span class="math inline">\(表示勒令\)</span>i <span class="math inline">\(对满足条件的方案数.把\)</span>k <span class="math inline">\(的定义改为恰好\)</span>k
$对满足条件的显然是同强度的.</p>
<p>我们接下来仍然考虑容斥,首先,我们需要找出全集$U <span class="math inline">\(,以及刻画\)</span>U <span class="math inline">\(中元素的\)</span>P _i $(条件).</p>
<p>等一下,这个好像不好刻画?</p>
<p>我们先回归一下容斥的本质:考虑每个元素的贡献.注意到恰好$a <span class="math inline">\(对的方案会被恰好\)</span>b <span class="math inline">\(对的方案计算\)</span> { a } <span class="math inline">\(次.我们再考虑一种方式理解容斥:我们一步一步把正确的答案消出来:简单来说,我第一步让所有恰好为\)</span>k
$的方案贡献为$1 <span class="math inline">\(,其它的可能也有贡献,但我们忽略他们.第二步让所有恰好为\)</span>k
+ 1 $的方案贡献为$0 <span class="math inline">\(,第三步以此类推.于是这个题,我们考虑也这么做:这样第一步令\)</span>ans
= f <em>k <span class="math inline">\(,第二步除去其中被多算的\)</span>k
+ 1 <span class="math inline">\(,这一步令\)</span>ans - = { k } f </em>{
k + 1 } <span class="math inline">\(.这个时候,我们再考虑\)</span>k + 2
<span class="math inline">\(的贡献:它将在\)</span>f <em>k <span class="math inline">\(时贡献\)</span> { k } <span class="math inline">\(次,在\)</span>f </em>{ k + 1 } <span class="math inline">\(时贡献\)</span>- { k + 1 } { k } = - { k } { 1 }
<span class="math inline">\(次,那它现在的贡献还有:\)</span>- { k } <span class="math inline">\(次.以此类推,可以得到\)</span>ans = _{ i = k } ^n f
_i ( - 1 ) ^{ i - k } { k } $.</p>
<p>等一下,这也太麻烦了,就不能从集合的角度分析嘛?</p>
<p>冷静一下,如果我们要做容斥,我们必须考虑每个元素<strong>单独</strong>的贡献,但是在这个题中,每个元素并没有单独的贡献,而是整个集合需要满足性质才能贡献.也就是说,我们无法分析每个$P
_i $.而考虑集合就需要将集合分类,从而使用二项式反演.</p>
<p>换句话说,这个定义在集合上的函数并不满足可加性.</p>
<p>换句话说,我们要用容斥,就一定要刻画$P _i <span class="math inline">\(,因为只有这个时候,我们才能通过分析满不满足\)</span>P
_i $的解集的交并来实现.</p>
<p>再换句话说,大部分的所谓的容斥其实都和集合<strong>没啥关系</strong>,我们做容斥就是需要逐个考虑贡献,把它们贡献全都杀成$1
/ 0 $就行.</p>
<h5><span id="example4haoi2008硬币购物">Example4(HAOI2008硬币购物)</span></h5>
<p>如果直接对于每次询问暴力做,复杂度显然是$O ( 4 ns )
$,无法接受.于是考虑预处理来降低单词询问复杂度.</p>
<p>注意到硬币数量很少,并且每个硬币的贡献可以独立计算.我们完全可以刻画$P
_i = [ use _i d _i ] <span class="math inline">\(,从而可以用容斥做.复杂度\)</span>O ( 4 m + n 2 ^4
) $.</p>
<h5><span id="example5">Example5</span></h5>
<p>Alice和Bob在玩游戏,他们有一个$n <span class="math inline">\(个点的无向完全图,设所有的边组成了集合\)</span>E
<span class="math inline">\(,他们想取遍\)</span>E <span class="math inline">\(的所有非空子集,对某个集合\)</span>S <span class="math inline">\(有一个估价\)</span>f ( S ) <span class="math inline">\(:考虑\)</span>n <span class="math inline">\(个点与\)</span>S <span class="math inline">\(中的边组成的图,我们用\)</span>m <span class="math inline">\(种颜色对所有点染色,其中同一个连通块的点必须染成一种颜色,那么\)</span>f
( S ) <span class="math inline">\(等于这个图的染色方案数.同时,Alice喜欢奇数,所以当\)</span>|
S | <span class="math inline">\(为奇数时,Alice的分值加上\)</span>f ( S )
<span class="math inline">\(,否则Alice的分值减去\)</span>f ( S ) <span class="math inline">\(,求最后的分值.\)</span>( n , m ^6 ) $.</p>
<p>一开始抄题的时候没有写染色而是直接写”设$k <span class="math inline">\(为连通块个数,则\)</span>f ( S ) = m ^k <span class="math inline">\(.&quot;然后发现做不了,因为\)</span>| S | <span class="math inline">\(相同的\)</span>f ( S ) <span class="math inline">\(不尽相同,而且可能情况还蛮多的.冷静一下,注意到连通块这个性质太强了:如果我们把它放到指数上,那应该会做得很痛苦.所以我们考虑每有一个连通块就乘上一个\)</span>m
$,这个看上去就简单一些.</p>
<p>但是这样好像还是不太好做,毕竟现在我们面对的还是一个难以转化为计数问题的图论问题,只是把问题的单位元素从图变成了连通块.那我们能不能再进一步:把单位元素换成单点呢?</p>
<p>考虑由于连通块要染一种颜色,那$x y col _x = col _y <span class="math inline">\(.注意到这是一个单位元素更小的限制条件!并且我们发现我们将与\)</span>-
1 <span class="math inline">\(有关的单位元素(从一开始就是点)和与\)</span>f
$有关的单位元素统一起来了.这也提示我们做计数的时候,尤其是做容斥的计数的时候,最好先将单位元统一,这样后面才可能更容易做.</p>
<p>接下来就可以写式子了,令$F ( C ) <span class="math inline">\(表示在\)</span>C <span class="math inline">\(情况下的染色方案,\)</span>T _{ ( i , j ) } <span class="math inline">\(表示满足边\)</span>( i , j ) $限制的解集:</p>
<p><span class="math display">\[
ans = \sum _{ \emptyset \ne S \subseteq E  } ( - 1 ) ^{ | S | - 1  } F (
\bigcap _{ ( i , j ) \in S  } T _{ ( i , j )  } )
\]</span></p>
<p>冷静一下!这个东西和容斥长得那叫一个一模一样啊.我们看看能不能逆向分析出$ans
<span class="math inline">\(的意义:显然是\)</span>F ( _{ i = 1 } ^{ m }
P _i ) <span class="math inline">\(.也就是完全图中至少有两个点颜色相同的染色数.根据补集转化,我们只需求出两两点不相同的染色数即可.所以最后的答案就是\)</span>m
^n - m ^{ } $.</p>
<h5><span id="example6">Example6</span></h5>
<p>求$( n ) $.</p>
<p>考虑这么一个事实:假设$n = p _i ^{ q _i } <span class="math inline">\(,注意到令\)</span>P <em>i = [ ( i , n ) = 1 ]
<span class="math inline">\(,我们所求也就是\)</span></em>{ i = 1 } ^n S
_i $.于是可以用上面的方法做.另外,这里的做法引出莫比乌斯反演.</p>
<h5><span id="example7agc058d">Example7(AGC058D)</span></h5>
<p>直接容斥好像不太可做,我们把容斥中的条件改为有多少个极长的形如$ABCABCAB
. . . $这样的串.</p>
<p>乍一看这个极长的条件好像巨难满足,但实际上我们冷静一下,我们只需要满足这个串长度大于等于$3
$并且开头不能往前延申就可以了,后面其实是没啥必要管的.</p>
<p>拿组合数算一算.</p>
<h5><span id="example8agc035f">Example8(AGC035F)</span></h5>
<p>显然问题只在于重复计算的问题.我们先将所有状态做一个双射:对于一个网格,唯一可能被重复计算的只可能是一个拐角的$1
$,我们让这种情况下的行尽可能长.</p>
<p>然后捏?注意到这样的话一个拐角的角一定是行了,是列就一定不合法,我们考虑把不合法的列杀了.</p>
<p>于是做一下容斥,答案是$_{ i = 0 } ^{ ( n , m ) } ( - 1 ) ^i { i } { i
} i ! ( m + 1 ) ^{ n - i } ( n + 1 ) ^{ m - i } $.</p>
<h5><span id="example9">Example9</span></h5>
<p>给定若干个限制条件$( x , y ) <span class="math inline">\(,表示\)</span>a _x = y <span class="math inline">\(和\)</span>a _y = x
$必须满足至少一个,求排列方案数.</p>
<p>首先$i p _i
$把排列转化成图,这样上面的限制条件也就是有一些无向的链和环,最后定向.一开始以为随便做做,思考一下注意到如果有长度为$2
<span class="math inline">\(的链,它自己成环的话是不用\)</span> $的.</p>
<p>这咋办.一个办法是:我们考虑容斥,先随便放进去,最后再钦定若干个自己成环.诶等一下为啥这个容斥是对的?因为系数是$
$,所以一个有$1
$个单独成环的状态会被随便放的情况恰好多算一次.类似可以做容斥.</p>
<p>当然,也可以考虑先把其它的合并,最后做长度为$2
$的链,但是!一开始一定要钦定有序,最后再用组合数统一算答案.因为一开始带着顺序做很难做.</p>
<h5><span id="example10agc036f-squareconstraints">Example10([AGC036F] Square
Constraints)</span></h5>
<p>由题意得:$n ^2 - i ^2 P _i ^2 ( 2 n ) ^2 - i ^2 $.</p>
<p>当一个东西有上界又有下界的时候可以想到容斥.问题转化为只有上界.假设最后所有的上界为$l
<em>i <span class="math inline">\(,那么只有上界的答案应该是什么呢?将\)</span>l <span class="math inline">\(从小到大排序,答案就是\)</span></em>{ i = 0 } ^{ 2
n - 1 } ( l <em>i - i ) <span class="math inline">\(.(注意到必须满足\)</span>l </em>{ 2 n - 1 } = 2 n
- 1 $.)</p>
<p>但是这个东西和容斥怎么结合起来呢?我们将限制放到二维平面上,注意到上下界的限制其实是两个$
{ 4 } <span class="math inline">\(的圆弧.而通过圆弧的性质不难看出:最终的\)</span>l
<span class="math inline">\(分为三部分:在下半部分圆弧上的,在上半部分圆弧后面的,在上半部分圆弧前面的.而如果想知道\)</span>l
<span class="math inline">\(按照顺序排序,我们只需要对前两部分做归并,然后将最后一部分直接放到后面即可.于是我们考虑按照\)</span>l
<span class="math inline">\(的大小为顺序进行一个类似归并的东西,每次判断当前下半部分圆弧是否要往上加点即可.这样我们可以处理前两部分对答案的贡献,但问题在于第三部分对答案的贡献怎么做,我们需要找到第三部分上的点在排序后的位置.我们预先枚举容斥集合的大小即可,这样就可以快速算出这个东西,于是复杂度\)</span>O
( n ^3 ) $.</p>
<h5><span id="example1123省选第一轮集训day4c带劲的旅行">Example11([23省选第一轮集训day4]C带劲的旅行)</span></h5>
<p>(下面将$n <span class="math inline">\(和\)</span>m $反着写)</p>
<p>设$p = { n } , q = n - p $.</p>
<p>首先注意到期望$= P [ len ] + P [ len ] + $.</p>
<p>考虑如何计算$P [ len x ] <span class="math inline">\(,如果我们设\)</span>a _i <span class="math inline">\(表示以\)</span>i <span class="math inline">\(作为开头的极长的带劲的长度大于等于\)</span>x <span class="math inline">\(的序列的集合,那么最后无非是要求所有\)</span>a
<span class="math inline">\(的并.考虑用容斥做到求所有\)</span>a
$的交.不过要注意讨论一下是不是第一个点.</p>
<h5><span id="example12">Example12</span></h5>
<p>给定$n , k <span class="math inline">\(和\)</span>n <span class="math inline">\(个点各自的颜色,对有编号无根树计数,要求相同颜色组成的连通块大小不超过\)</span>k
<span class="math inline">\(.\)</span>n $.</p>
<p>著名结论:$n <span class="math inline">\(个点\)</span>m <span class="math inline">\(个连通块任意连边成树的方案数是\)</span>n ^{ m - 2
} s <span class="math inline">\(,其中\)</span>s <span class="math inline">\(是每个连通块的大小.但是,如果我们强行对每种颜色分成若干连通块,我们要防止它们之间有边.这就是我一开始没做出来的原因:要容斥的根本不是树的大小不能超过\)</span>k
<span class="math inline">\(,由于树的形态多变,这个是不能维护的!正确的做法是找到若干个相同颜色的大小小于等于\)</span>k
<span class="math inline">\(的连通块,要求它们两两无边.甚至根本就不是它们可以连边但是大小不能超过\)</span>k
$,我们要容斥的东西一定要好算,简单.</p>
<p>然后就做完了,每次暴力合并若干个颜色相同的块,容斥系数$( - 1 ) ^{ 块 数
- 1 } $.</p>
<p>容斥是一个层层递进的东西,我们每一步都是基于上一步的限制:它本身就是一个求解集的东西.</p>
<h4><span id="min-max容斥">Min-Max容斥</span></h4>
<p>对于:</p>
<p><span class="math display">\[
\mid \bigcup _{ i = 1  } ^n S _i \mid = \sum _{ T \subseteq \{ 1 , . . .
, n \}  } ( - 1 ) ^{ | T - 1 |  } \mid \bigcap _{ p \in T  } S _p \mid
\]</span></p>
<p>考虑一个特例:$S _i = { 1 , 2 , , a _i } <span class="math inline">\(,那么上面的式子导出min-max容斥(我们设\)</span>S =
{ a _1 , a _2 , , a _n } $)(第二个式子可以把前缀改成后缀):</p>
<p><span class="math display">\[
\begin{aligned}
\max ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \min ( T ) \\
\min ( S ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( - 1 ) ^{
| T | - 1  } \max ( T )
\end{aligned}
\]</span></p>
<p>由于是集合,这个式子在期望意义下同样成立:</p>
<p><span class="math display">\[
\begin{aligned}
E ( \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \min \{ S \} ) \\
E ( \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } (
- 1 ) ^{ | T | - 1  } E ( \max \{ S \} )
\end{aligned}
\]</span></p>
<p>进一步,这个式子可不止能求min-max的转化,它可以求出集合中第k大的数字:</p>
<p><span class="math display">\[
\begin{aligned}
kth \max \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \min \{ T \} \\
kth \min \{ S \} &amp; = \sum _{ T \subseteq S , T \ne \emptyset  } ( -
1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } \max \{ T \} \\
E ( kth \max \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \min \{ T \} ) \\
E ( kth \min \{ S \} ) &amp; = \sum _{ T \subseteq S , T \ne
\emptyset  } ( - 1 ) ^{ | T | - k  } \binom { | T | - 1  } { k - 1  } E
( \max \{ T \} )
\end{aligned}
\]</span></p>
<p>原理是消掉前$k - 1 $大的数字,让他们的贡献为$0
$,剩下的配一下容斥系数.</p>
<h5><span id="example123省选10连测-day6a">Example1([23省选10连测 day6]A)</span></h5>
<p>不妨设$tim _i <span class="math inline">\(为\)</span>[ i , i + 1 ]
$第一次被覆盖的时间,答案就是:</p>
<p><span class="math display">\[
E ( \max _{ i = 1  } ^{ n - 1  } \{ tim _i \} ) = \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset  } ( - 1 ) ^{ | T | - 1  } E
( \min _{ j \in T  } \{ tim _j \} )
\]</span></p>
<p>设$f ( S ) <span class="math inline">\(为有多少个区间能覆盖至少一个\)</span>[ i , i + 1 ]
, i S <span class="math inline">\(,考虑\)</span>E = p <em>{ [ t ] } + p
</em>{ [ t ] } + p <em>{ [ t ] } + <span class="math inline">\(,于是\)</span>E ( </em>{ j S } { tim _j } ) = { f
( S ) } $.</p>
<p>于是:</p>
<p><span class="math display">\[
\begin{aligned}
ans &amp; = \sum _{ T \subseteq \{ 1 , 2 , \cdots , n - 1 \} , T \ne
\emptyset  } ( - 1 ) ^{ | T | - 1  } f ( T ) \\
&amp; = \sum _{ k = 0  } ^m \frac { m  } { k  } \sum _{ T \subseteq \{ 1
, 2 , \cdots , n - 1 \} , T \ne \emptyset , f ( T ) = k  } ( - 1 ) ^{ |
T | - 1  }
\end{aligned}
\]</span></p>
<p>注意到$f ( S ) <span class="math inline">\(可能不那么好求,我们求\)</span>g ( S ) = m - f ( S
) <span class="math inline">\(,也就是不包含任何一个\)</span>[ i , i + 1
] , i S $的区间个数,我们有:</p>
<p><span class="math display">\[
ans = \sum _{ k = 0  } ^m \frac { m  } { m - k  } \sum _{ T \subseteq \{
1 , 2 , \cdots , n - 1 \} , T \ne \emptyset , g ( T ) = k  } ( - 1 ) ^{
| T | - 1  }
\]</span></p>
<p>这里已经不难写出$O ( n ^3 ) $的dp了.</p>
<p>那么怎么优化呢?设$dp <em>{ i , j } <span class="math inline">\(表示只考虑\)</span>[ 1 , i ] <span class="math inline">\(时(\)</span>[ i - 1 , i ] <span class="math inline">\(必选),\)</span></em>{ g ( T ) = j } ( - 1 ) ^{ | T
| - 1 } <span class="math inline">\(的答案,不难发现每次加入一个区间\)</span>[ l , r ]
<span class="math inline">\(就会让\)</span>dp <em>{ i , j } , i &lt; = l
<span class="math inline">\(对\)</span>dp </em>{ r , j + 1 }
$的贡献乘一个$1 $.</p>
<p>如何处理这个事情?我们用类似多项式的东西,前者相当于平移多项式系数,后者相当于标量乘法,然后拿线段树维护和,复杂度$O
( nm n ) $.</p>
<h4><span id="反射容斥">反射容斥</span></h4>
<p>一般形式:给定二维平面上两个点$S <span class="math inline">\(和\)</span>T <span class="math inline">\(,其中\)</span>T <span class="math inline">\(在\)</span>S <span class="math inline">\(的右方,给定两条线\)</span>y = a <span class="math inline">\(和\)</span>y = b <span class="math inline">\(,每次可以向右上或者右下走一步,求不碰线的从\)</span>S
<span class="math inline">\(到\)</span>T $的方案数.</p>
<p>我们不妨设$A <span class="math inline">\(表示一定碰了一次上界的方案数,\)</span>B <span class="math inline">\(表示一定碰了一次下界的方案数,\)</span>AB
$表示一定碰了一次上界后碰了一次下界的方案数……</p>
<p>最后的答案就是随便走$- A - B + AB + BA - ABA - BAB . . . $.</p>
<p>考虑设步数为$n <span class="math inline">\(,那显然长度最多为\)</span>
{ a - b } $.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag"># 数学</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_telegram"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="prev" title="博弈论">
                  <i class="fa fa-angle-left"></i> 博弈论
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" rel="next" title="多项式与生成函数">
                  多项式与生成函数 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2025/06/22/%E5%AD%A6%E4%B9%A0-%E5%8F%8D%E6%BC%94%E4%B8%8E%E5%AE%B9%E6%96%A5/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
