<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <link rel="mask-icon" href="/images/%E5%A4%B4%E5%83%8F1.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lwlaymh.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="贪心 排除不优策略 Example1(CF1612E) 先把期望写开,我们发现如果选择了\(t\)个消息\(a_1 , a_2 , . . . , a_t\),那么答案就是\(\sum [ \exists j , m_i &#x3D; a_j ] \cfrac{ \min ( t , k_i ) }{ t }\).显然如果\(t\)固定,那么每个\(a_j\)的贡献是独立的.于是只需要枚举\">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心与构造">
<meta property="og:url" content="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/index.html">
<meta property="og:site_name" content="LWLAymh的备忘录">
<meta property="og:description" content="贪心 排除不优策略 Example1(CF1612E) 先把期望写开,我们发现如果选择了\(t\)个消息\(a_1 , a_2 , . . . , a_t\),那么答案就是\(\sum [ \exists j , m_i &#x3D; a_j ] \cfrac{ \min ( t , k_i ) }{ t }\).显然如果\(t\)固定,那么每个\(a_j\)的贡献是独立的.于是只需要枚举\">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-22T15:04:13.659Z">
<meta property="article:modified_time" content="2025-06-22T15:04:13.659Z">
<meta property="article:author" content="LWLAymh">
<meta property="article:tag" content="OI">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/","path":"2025/06/22/学习-贪心与构造/","title":"贪心与构造"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>贪心与构造 | LWLAymh的备忘录</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>






  <script src="/js/third-party/addtoany.js" defer></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<link rel="dns-prefetch" href="my-repository-jade-beta-79.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LWLAymh的备忘录</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">混乱节拍拼凑出血肉喧嚷</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.</span> <span class="nav-text">排除不优策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">Example1(CF1612E)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">Example2(CF1592F1)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">Example3(CF1592F2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">Example4(CF1666E)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">Example5(2022zrtg十连测day7
Palindrome)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">Example6(23省选10连测 day9 C)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">Example7(异或粽子)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">Example8()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.2.</span> <span class="nav-text">带悔贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Example2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.3.</span> <span class="nav-text">寻找下界并证明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">Example1([EER1]代价)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">Example2(loj3318)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">Example3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">Example4([UOJ280]题目难度排序)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.5.</span> <span class="nav-text">Example5([CF1098D]Eels)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.6.</span> <span class="nav-text">Example6(称球游戏)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.1.</span> <span class="nav-text">信息论</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.2.</span> <span class="nav-text">判定树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.3.</span> <span class="nav-text">子问题1(已知次品重量)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.4.</span> <span class="nav-text">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.5.</span> <span class="nav-text">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">1.3.0.6.6.</span> <span class="nav-text">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.3.0.7.</span> <span class="nav-text">Example7(Ucup 3rd Stage 8 H)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.4.</span> <span class="nav-text">Exchange Arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.1.</span> <span class="nav-text">模型1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Example1(国王游戏)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">模型通解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Example2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Example3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.4.2.</span> <span class="nav-text">模型2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Example</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.1.</span> <span class="nav-text">增量构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">Example1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">Example2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">Example3(CF1770H)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">Example4(ABC232H)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">2.2.</span> <span class="nav-text">找中间状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">Example1</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LWLAymh"
      src="/images/%E5%A4%B4%E5%83%8F1.jpg">
  <p class="site-author-name" itemprop="name">LWLAymh</p>
  <div class="site-description" itemprop="description">不过是白日梦里一瞬息</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LWLAymh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LWLAymh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lwlaymh@outlook.com" title="E-Mail → mailto:lwlaymh@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/LWLAymh" title="WeChat → LWLAymh" rel="noopener me"><i class="fab fa-skype fa-fw"></i>WeChat</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://minyuchengmin.github.io/" title="https:&#x2F;&#x2F;minyuchengmin.github.io" rel="noopener" target="_blank">ycm的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://shanlunjiajian.github.io/" title="http:&#x2F;&#x2F;shanlunjiajian.github.io" rel="noopener" target="_blank">qyc的blog</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.cnblogs.com/do-while-true" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;do-while-true" rel="noopener" target="_blank">dwt的blog</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lwlaymh.github.io/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%A4%B4%E5%83%8F1.jpg">
      <meta itemprop="name" content="LWLAymh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LWLAymh的备忘录">
      <meta itemprop="description" content="不过是白日梦里一瞬息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="贪心与构造 | LWLAymh的备忘录">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          贪心与构造
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-22 23:04:13" itemprop="dateCreated datePublished" datetime="2025-06-22T23:04:13+08:00">2025-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>
<h2><span id="贪心">贪心</span></h2>
<h3><span id="排除不优策略">排除不优策略</span></h3>
<h5><span id="example1cf1612e">Example1(CF1612E)</span></h5>
<p>先把期望写开,我们发现如果选择了<span class="math inline">\(t\)</span>个消息<span class="math inline">\(a_1 ,
a_2 , . . . , a_t\)</span>,那么答案就是<span class="math inline">\(\sum
[ \exists j , m_i = a_j ] \cfrac{ \min ( t , k_i ) }{ t
}\)</span>.显然如果<span class="math inline">\(t\)</span>固定,那么每个<span class="math inline">\(a_j\)</span>的贡献是独立的.于是只需要枚举<span class="math inline">\(t\)</span>然后取贡献最大的.</p>
<p>但是,如果<span class="math inline">\(t &gt; \max \{ k_i
\}\)</span>,这个时候<span class="math inline">\(t -
1\)</span>的答案是<span class="math inline">\(t -
1\)</span>个数之和除以<span class="math inline">\(t - 1\)</span>,<span class="math inline">\(t\)</span>的答案是这<span class="math inline">\(t
- 1\)</span>个数之和加上另一个更小的数除以<span class="math inline">\(t\)</span>,而前者肯定比后者大,于是不用再进一步枚举.</p>
<p>于是复杂度<span class="math inline">\(O ( n \max \{ k_i \}
)\)</span>.</p>
<h5><span id="example2cf1592f1">Example2(CF1592F1)</span></h5>
<p>首先,二操作和三操作一定没有用,因为它们都可以用两次一操作代替.</p>
<p>再注意到四操作是可能有用的,因为我们拿一操作模拟四操作需要四金币的代价,而用一个四操作只需要三个金币.但是,由于拿一操作模拟四操作的时候,需要全局做一遍一操作,所以如果有两个四操作,模拟的时候两遍全局操作就可以抵消.因此,我们模拟两次四操作只需要六个金币的代价.换句话说,我们如果要用到四操作,只会使用一次或零次.</p>
<p>首先区间异或可以差分(<span class="math inline">\(b_{ i , j } = a_{ i
, j } \oplus a_{ i + 1 , j } \oplus a_{ i , j + 1 } \oplus a_{ i + 1 , j
+ 1
}\)</span>)后转化为四个点的异或操作,而由于一操作操作了左上角的矩阵,所以它实际上是对三个在原矩阵外的点和一个在矩阵内的点操作.我们注意到如果矩阵内已经全都是<span class="math inline">\(0\)</span>了,那么矩阵外不可能是<span class="math inline">\(1\)</span>,也就是原矩阵也全都是<span class="math inline">\(0\)</span>了.</p>
<p>枚举一下最后的操作是啥即可,另外注意到这一步操作必须把四个点全部变成<span class="math inline">\(0\)</span>才有用,不然还需要拿一操作去补,就不如直接用一操作.</p>
<h5><span id="example3cf1592f2">Example3(CF1592F2)</span></h5>
<p>首先注意到,如果我们对<span class="math inline">\(( x , y
)\)</span>使用操作四,那我们不可能再对一个<span class="math inline">\(( x
, i )\)</span>使用操作四,不然我们就可以用四次操作一代替这两次操作四.</p>
<p>再通过上面的分析,注意到只有<span class="math inline">\(b_{ x , y } ,
b_{ n , y } , b_{ x , m }\)</span>都是<span class="math inline">\(1\)</span>的时候才会使用四操作,不然,如果我们使用四操作,必然会再需要一个一操作来补,这样就是至少三个金币的代价.而由于这四个点中最多只有三个<span class="math inline">\(1\)</span>,所以一定不如直接用一操作来的划算.不然,如果三个都是<span class="math inline">\(1\)</span>,那么用了就一定不亏,因为无论如何也需要三次一操作,而就算我们用完后<span class="math inline">\(b_{ n , m }\)</span>变成<span class="math inline">\(1\)</span>了,再不行也可以使用一次<span class="math inline">\(1\)</span>操作来补全.</p>
<p>因此我们现在想要选尽可能多的三操作,满足两两操作不在同一行或同一列,这显然是一个二分图匹配问题.换句话说,如果<span class="math inline">\(b_{ x , y } , b_{ n , y } , b_{ x , m
}\)</span>都是<span class="math inline">\(1\)</span>,我们就把<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>连一条边,然后做二分图匹配,显然是最优的.</p>
<h5><span id="example4cf1666e">Example4(CF1666E)</span></h5>
<p>先想一下别的东西怎么求.</p>
<p>如果我们要求最大值最小或者最小值最大怎么办?我们可以二分后贪心,而显然它们的差就是一个答案的下界,问题在于这个下界是否可以取到.</p>
<p>我们冷静一下,发现在可能的方案中,第<span class="math inline">\(i\)</span>条线段的右端点的位置一定是一段连续的区间.</p>
<p>设<span class="math inline">\(f_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最小值,<span class="math inline">\(g_i\)</span>表示第<span class="math inline">\(i\)</span>个分界点可能的最大值.假设我们目前二分的最大值要小于等于<span class="math inline">\(mx\)</span>,最小值要大于等于<span class="math inline">\(mn\)</span>,那么我们有转移:</p>
$$
<span class="math display">\[\begin{aligned}
f_{ i + 1 } &amp; = \max \{ a_{ i + 1 } , f_i + mn \} \\
g_{ i + 1 } &amp; = \min \{ a_{ i + 2 } , g_i + mx \} \\

\end{aligned}\]</span>
<p>$$</p>
<p>注意到<span class="math inline">\(f\)</span>与<span class="math inline">\(g\)</span>的转移是无关的,而显然对于第<span class="math inline">\(i\)</span>个分界点,它可以取<span class="math inline">\([ f_i , g_i
]\)</span>中一个数,一定存在一个取法使得答案能取到下界.</p>
<p>为啥呢?只需让<span class="math inline">\(ans_{ i
}\)</span>表示第<span class="math inline">\(i\)</span>条分界线是啥,那么我们<span class="math inline">\(ans_i\)</span>是可以取<span class="math inline">\([ ans_{ i + 1 } - mx , ans_{ i + 1 } - mn
]\)</span>中的任何一个数字的,我们将其和上面求出的<span class="math inline">\([ f_i , g_i
]\)</span>求一下交集.如果交集为空,说明要么<span class="math inline">\(ans_{ i + 1 } - mn &lt; f_i , f_{ i + 1 } &lt;
ans_{ i + 1 } &lt; f_i +
mn\)</span>,这是不可能的.另一种情况同理不可能,这就保证了一定可以取到答案.一定能使极差<span class="math inline">\(\leq mx - mn\)</span>.</p>
<h5><span id="example52022zrtg十连测day7palindrome">Example5(2022zrtg十连测day7
Palindrome)</span></h5>
<p>首先注意到同种字符的相对顺序不可能改变.于是最后的回文串是哪个字符对应哪个字符就可以确定.</p>
<p>这样我们的问题转化为现在有若干个点对<span class="math inline">\(( l ,
r )\)</span>,我们想给每一个点对赋值:<span class="math inline">\(a_l = i
, a_r = n - i + 1\)</span>(注意如果<span class="math inline">\(n\)</span>是奇数,那么中心点应该是<span class="math inline">\(a_{ mid } = \frac{ n + 1 }{ 2
}\)</span>),然后使整个序列逆序对数尽可能小.</p>
<p>接下来讨论一下两个点对<span class="math inline">\(( l_1 , r_1
)\)</span>,<span class="math inline">\(( l_2 , r_2
)\)</span>之间的三种可能的关系:不交,包含,相交且不包含.会发现若<span class="math inline">\(l\)</span>小则让<span class="math inline">\(a_l\)</span>尽可能小就是最优的.</p>
<h5><span id="example623省选10连测-day9-c">Example6(23省选10连测 day9 C)</span></h5>
<p>强强题.</p>
<p>首先发现这个<span class="math inline">\(\pm
1\)</span>操作很奇怪.我们不妨这么考虑:设最后的答案序列为<span class="math inline">\(b\)</span>,那么答案其实就是<span class="math inline">\(\sum | b_i - a_i
|\)</span>.这实际上是什么呢?实际上是数轴上<span class="math inline">\(a_i\)</span>和<span class="math inline">\(b_i\)</span>之间的距离.既然这样,那么我们同时反转<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,这等价于翻转数轴,答案应该是不变的.这说明什么呢?如果我挑一个<span class="math inline">\(a\)</span>,将它和<span class="math inline">\(x\)</span>同时反转,那么答案不变.这么做后我们可以直接清空所有<span class="math inline">\(a\)</span>的最高位,只剩下<span class="math inline">\(x\)</span>可能有最高位.</p>
<p>那<span class="math inline">\(x\)</span>的最高位一定会让若干<span class="math inline">\(a\)</span>往上变成它.注意到最多只会有一个<span class="math inline">\(a\)</span>会向上满足<span class="math inline">\(x\)</span>的最高位.证明的话同样考虑取反,如果有两个<span class="math inline">\(a\)</span>满足<span class="math inline">\(a_i
\oplus b_i\)</span>和<span class="math inline">\(a_j \oplus
b_j\)</span>这一位是<span class="math inline">\(1\)</span>,我们仍然考虑数轴,有<span class="math inline">\(| not ( b_i ) - a_i | \leq | a_i - b_i
|\)</span>,这由<span class="math inline">\(a_i \oplus
b_i\)</span>最高位是<span class="math inline">\(1\)</span>导出.因此两个都取反一定不劣.</p>
<p>再考虑,我们会让哪个<span class="math inline">\(a\)</span>上去满足呢?自然的想法是取代价最小的那个,因为就算它不是,这里自然地有一个待悔贪心:其它的<span class="math inline">\(a\)</span>可以再变成它.</p>
<p>于是就做完了.</p>
<h5><span id="example7异或粽子">Example7(异或粽子)</span></h5>
<h5><span id="example8">Example8()</span></h5>
<h3><span id="带悔贪心">带悔贪心</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>给定一个数组,给出若干次操作<span class="math inline">\([ l , r , k
]\)</span>表示可以将<span class="math inline">\(a [ l \cdots r
]\)</span>减一进行至多<span class="math inline">\(k\)</span>次,要求操作过程中数组时刻非负,求最大能做出的操作次数.</p>
<p>这题的做法是,我们每次遇到一个左端点,就将所有以它为左端点的区间全部操作,并把这些区间按照右端点为关键字扔进堆里.每次遇到一个地方的值变成了负的,就从堆中找右端点最大的区间杀掉.容易发现这样是正确的.</p>
<p>为啥能想到带悔贪心呢?主要是因为我们发现不同的区间会彼此影响,而且有一个限制性的长期条件.因此先不管这个条件,最后再通过调整堆将这个条件调整至合法.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定一个序列,每次可以选择相邻的两个数,使其中一个<span class="math inline">\(- 1\)</span>,另一个<span class="math inline">\(-
2\)</span>,求使得整个序列都小于等于<span class="math inline">\(0\)</span>的最小操作次数.</p>
<p>我们明确一下带悔贪心的基本条件:</p>
<ol type="1">
<li><p>首先,贪心是需要保证局部最优性的,并且需要保证不考虑全局的前提下,求局部最优解就是全局最优解的一部分.按我的理解,贪心是和dp一样需要有无后效性的,你前面的决策做了就是做了,带悔贪心只能改变后面的决策的形态,而不能改变前面的决策.</p></li>
<li><p>不同的操作之间会彼此影响,并且我们在不看全局的状态的前提下,无法第一时间确定当前对后面最优影响的操作是啥.通常情况下,感觉带悔贪心的每个操作会影响的操作是有限的.</p></li>
<li><p>感觉能做带悔贪心的好像很多都可以设计一个复杂度更高的dp.不过这个似乎很合理,因为(2)告诉我们它能影响的操作大概率是不多的.</p></li>
</ol>
<p>我们看这个题,第一点基本随便编个贪心都可以满足:就是先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.而第二点呢?显然每个地方的操作只会影响前后两个位置接下来的操作(当然,被影响到的位置有可能继续影响别人).</p>
<p>那么为什么能想到带悔贪心呢?其实只要发现有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀就自然能引到带悔贪心了.</p>
<p>好,现在我们仍然是做那个看上去就不太对的贪心:先不断做<span class="math inline">\(( - 2 , - 1 )\)</span>,最后不够了再加个<span class="math inline">\(( - 1 , - 2
)\)</span>补一下.我们通过样例以及其它栗子发现:有的时候<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2 )\)</span>比<span class="math inline">\(( - 2 , - 1
)\)</span>更优秀,这启发我们:能不能在做后面位置的时候将前面的<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>呢?注意这里我们不能直接换:带悔贪心要求我们不能改变前面操作的状态.因此我们引入一个操作:如果当前前面存在一个<span class="math inline">\(( - 2 , - 1
)\)</span>操作,那么我可以在这个位置进行一个<span class="math inline">\((
0 , - 3 )\)</span>操作.显然<span class="math inline">\(( 0 , - 3 ) + ( -
2 , - 1 ) = ( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>.我们完成了反悔的操作!</p>
<p>但是,我们直接认为<span class="math inline">\(( - 1 , - 2
)\)</span>不可能反悔的原因是:它是一个补位操作,一个位置只有可能进行一次,这玩意不可能能反悔.可现在不一样了,我们的操作序列中有了两个<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>,怎么办呢?你当然可以对着这个操作再观察怎么反悔,但事实上有更高效的思路:我们直接考虑<span class="math inline">\(( - 3 , 0
)\)</span>怎么反悔.这个看上去很疑惑:我们为了使<span class="math inline">\(( - 2 , - 1 )\)</span>变成<span class="math inline">\(( - 1 , - 2 ) + ( - 1 , - 2
)\)</span>而引入了一个新操作,这个新操作在原序列中是不存在的:它甚至有个很奇怪的限制条件:必须在前面存在<span class="math inline">\(( - 2 , - 1
)\)</span>的时候才可以发动.那为什么我们可以直接考虑它如何反悔呢?</p>
<p>先看第一个问题:<span class="math inline">\(( - 3 , 0
)\)</span>这个技能的发动是有前提条件的:前面必须有<span class="math inline">\(( - 2 , - 1
)\)</span>才可以.但你注意我们是在贪心啊,我们很清楚每个地方用了几个<span class="math inline">\(( - 2 , - 1
)\)</span>,也很清楚每个地方用了几个<span class="math inline">\(( - 3 , 0
)\)</span>.</p>
<p>再看第二个问题:这个新操作为何能反悔呢?其实第一个问题解决这个问题也就解决了,由于贪心,我们知道了巨大多的信息,这个信息量是dp不能比的.因此这个条件如果dp的话看上去需要多记一维,但是贪心完全不用.</p>
<p>我们可以根据类似上面的操作迅速编出它怎么反悔:<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 2 , -
1 ) = ( - 3 , 0 ) + ( 0 , - 3 )\)</span>,或者<span class="math inline">\(( - 3 , 0 ) \rightarrow ( - 1 , - 2 ) + ( - 1 , -
2 ) + ( - 1 , - 2 ) = ( - 3 , 0 ) + ( 0 , - 3 ) + ( 0 , - 3
)\)</span>.</p>
<p>最后遇到一个点,能用<span class="math inline">\(( 0 , - 3
)\)</span>就用<span class="math inline">\(( 0 , - 3
)\)</span>,不够用的再补齐.这个原因也很简单:如果我们在这里不用<span class="math inline">\(( - 3 , 0
)\)</span>而用其它的代替的话,你会发现无论如何都等价于<span class="math inline">\(( - 3 , 0 )\)</span>然后后面再反悔.</p>
<p>再总结一下这个题中包含的带悔贪心:</p>
<p>这个带悔贪心包含若干个操作,这些操作之间可以<strong>互相转化</strong>,使得在前面进行的一个操作可以和在后面进行的一个操作一起,等价于前面进行了另一个操作.如同最经典的带悔贪心的模型,我们每次进行一个操作后,都会加入若干个可以进行的操作(在这个题中,一开始就在每个位置加入了无穷多的<span class="math inline">\(( - 2 , - 1 )\)</span>和<span class="math inline">\(( - 1 , - 2
)\)</span>的操作)(写一下代码就会发现,我们其实记录下了每个位置插入了多少个可行的<span class="math inline">\(( - 3 , 0
)\)</span>操作).这些操作构成一个封闭的东西,使得反悔任意一个操作的反悔操作本身都可以使用若干操作表示出来.</p>
<h3><span id="寻找下界并证明">寻找下界并证明</span></h3>
<h5><span id="example1eer1代价">Example1([EER1]代价)</span></h5>
<p>给你一个长度为<span class="math inline">\(n\)</span>的序列<span class="math inline">\(a\)</span>,保证<span class="math inline">\(a_1 =
a_n = 1\)</span>.每次你可以选择一个<span class="math inline">\(i ( 1
&lt; i &lt; n )\)</span>将<span class="math inline">\(a_i\)</span>删去并付出<span class="math inline">\(a_{ i - 1 } a_i a_{ i + 1
}\)</span>的代价.删去<span class="math inline">\(a_i\)</span>后序列两端会接起来,求删成两个<span class="math inline">\(1\)</span>的最小代价.</p>
<p>首先注意到,如果有一个<span class="math inline">\(1 &lt; i &lt;
n\)</span>满足<span class="math inline">\(a_i =
1\)</span>,那这个点最后删显然更优秀:如果我们把它删了,不仅肯定比最后删它劣(最后删它只需要<span class="math inline">\(1\)</span>的代价),还有可能使原本能和它相邻的点这次和一个更大的数相邻了,显然不优秀.因此整个序列被若干个<span class="math inline">\(1\)</span>所划分.接下来我们只考虑中间所有数<span class="math inline">\(\geq 2\)</span>的情况.</p>
<p>再思考一个事实:当<span class="math inline">\(a , b \geq
2\)</span>时,一定有<span class="math inline">\(ab \geq a +
b\)</span>.而考虑每两个相邻的点一定会被乘起来扔进答案,也就是说答案下界一定是<span class="math inline">\(\sum_{ i = 2 }^{ n - 2 } a_i a_{ i + 1 } + \min_{
i = 2 }^{ n - 1 }{ a_i
}\)</span>.注意到这个下界是可以构造出来的:找到每一段最小的点然后从左/右挨个删点即可.</p>
<h5><span id="example2loj3318">Example2(loj3318)</span></h5>
<p>首先考虑:给出一个排列,从原排列换到它的最小步数一定是它的逆序对数.因为我们可以每次找到应当被放到边界的点,然后不断把它换过去.</p>
<p>考虑现在构造<span class="math inline">\(a\)</span>数组,每次对于还没选的最大值,显然要扔到尽可能靠后的位置,然后不断递归处理.</p>
<h5><span id="example3">Example3</span></h5>
<p>给定一张图,每个点上有一个权值<span class="math inline">\(a_i\)</span>,我们每次可以删掉一个点以及其所有连边,代价是所有相邻的点的权值和.求删光图的最小代价.</p>
<p>首先注意到答案一共要更新边数次,不妨考虑边.</p>
<p>一条边可能对答案有两种贡献,也就是与它相邻的两个点的点权.它会对答案贡献后删的那个点的点权.显然所有边取最小值时是一个下界.这个下界是可以构造出来的:我们按照点权从大往小删即可.</p>
<h5><span id="example4uoj280题目难度排序">Example4([UOJ280]题目难度排序)</span></h5>
<p>先考虑<span class="math inline">\(a_i\)</span>互不相同,那可以每次选一个最大的数,满足它加进去后整个集合的中位数<span class="math inline">\(\leq\)</span>还没选的数的最小的数.注意到这里一定能构造出合法解,且如果选了另一个数一定更劣.</p>
<p>那如果可能存在<span class="math inline">\(a_i\)</span>相同呢,我们先按照大小排序,然后选出一对小于等于所有数的中位数的<span class="math inline">\(( a_i , a_{ i + 1 } )\)</span>,然后这么选:<span class="math inline">\(a_i , a_{ i + 1 } , a_n , a_{ i - 1 } , a_{ n - 1
} , a_{ i - 2 } . .
.\)</span>,一直到左边全部被填完,然后按照互不相同的方法填.</p>
<p>首先这么做一定是合法解,因为中位数会在<span class="math inline">\(a_i\)</span>上震荡.其次这么做为什么是最优解呢?我们考虑一开始如果选了另一对大于中位数的相等的数,那一定不合法,因为最后会剩一些小数,会把这些东西震荡到一个更小的中位数.而如果一开始选了一个单点,接下来一定要不断选更大的点,这样比它小的数就没法加进去了.而等左边全部被填完后,由于这个时候中位数已经没有办法保持不变了,所以必定接下来要增大,而中位数不断增大只能按照互不相同的方法填.</p>
<h5><span id="example5cf1098deels">Example5([CF1098D]Eels)</span></h5>
<p>首先,我们猜测:我们一开始先让最小的两个互相吃,可能是最优秀的.接下来我们尝试证明这个猜测.</p>
<p>首先,对于一个不危险的操作来说,假设这次操作的两个数是<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>,其中<span class="math inline">\(2 a
&lt;
b\)</span>.我们尝试判断一下这个操作满足什么条件.这个时候,注意到如果<span class="math inline">\(b\)</span>之前吃过别的鱼,假设是<span class="math inline">\(c\)</span>和<span class="math inline">\(d\)</span>(不妨假设<span class="math inline">\(d
\geq c\)</span>),有<span class="math inline">\(b = c +
d\)</span>,由鸽笼原理,发现<span class="math inline">\(d &gt;
a\)</span>.这意味着:如果<span class="math inline">\(a\)</span>都没被操作掉,那么<span class="math inline">\(d\)</span>必不可能被操作掉,这也就是说<span class="math inline">\(b\)</span>不可能出现.因此<span class="math inline">\(b\)</span>在这次操作前一定没有吃过别的鱼.那互相残杀的鱼的重量就都一定小于<span class="math inline">\(b\)</span>,且<span class="math inline">\(a\)</span>就是所有一开始小于<span class="math inline">\(b\)</span>的鱼的和.</p>
<p>我们按照鱼的重量从小到大排序,你会发现一次不危险操作涉及到的鱼一定是一条满足自己大于比自己小的所有鱼的重量和的两倍的鱼,我们称其为大鱼,也就是<span class="math inline">\(w_i &gt; 2 \sum_{ j = 1 }^{ i - 1 }
w_j\)</span>,我们对此计数就可以完成一次操作.</p>
<p>那么问题又来了,这个东西一定是最小的吗?</p>
<p>我们考虑一个事实:我们要最小化不危险操作的数量,但很明显的一点是:每只大鱼都必须经过一次不危险操作才能变成一只更大的鱼,当然,如果它选择自杀,那么吃掉它的那只鱼会继承它的地位,在不死的情况下仍然要进行至少一次不危险操作才能变成更大的鱼,因此这显然是一个下界.而又可以构造出答案.</p>
<p>那么如何多组询问呢?首先发现大鱼不会很多,最多<span class="math inline">\(\log
w\)</span>个,我们考虑一下这个两倍的用处,我们按照值域<span class="math inline">\([ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 4 ] , [ 5 , 8 ] , .
. . , [ 2^{ k - 1 } + 1 , 2^k
]\)</span>将鱼分成若干组,不难发现大鱼只有可能是每个区间中最小的数字,因为不然,那么这个区间中最小的数字乘以二一定比它自己大.这个东西就很好维护了.</p>
<h5><span id="example6称球游戏">Example6(称球游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个球(其中有一个次品球,重量和其它球不一样)和一架天平,求最少通过多少次操作才能找到这个球.</p>
<p>我们通过这个游戏来引入信息论和判定树作为一个构造下界的工具.</p>
<p>首先引入一套语言体系来简化文字:</p>
<ol type="1">
<li><p><span class="math inline">\(S\)</span>表示标准球.</p></li>
<li><p><span class="math inline">\(&lt; A , B
&gt;\)</span>表示称量集合<span class="math inline">\(A\)</span>和集合<span class="math inline">\(B\)</span>,<span class="math inline">\(&lt; A , B
&gt; = 0\)</span>表示平衡,<span class="math inline">\(&lt; A , B &gt; =
A\)</span>表示<span class="math inline">\(A\)</span>较重,<span class="math inline">\(&lt; A , B &gt; = B\)</span>表示<span class="math inline">\(B\)</span>较重.</p></li>
</ol>
<h6><span id="信息论">信息论</span></h6>
<p>如果一个随机变量<span class="math inline">\(x\)</span>有<span class="math inline">\(n\)</span>种取值,出现概率分别为<span class="math inline">\(p_1 , p_2 , \cdots , p_n\)</span>,则其熵为<span class="math inline">\(H ( x ) = f ( p_1 , p_2 , \cdots , p_n ) = \sum{ C
p_i \ln \frac{ 1 }{ p_i } }\)</span>,<span class="math inline">\(C\)</span>为正整数,通常取<span class="math inline">\(1\)</span>.(事实上这里的定义与真正的信息论的定义有一定的差别,不过原理是类似的,这里简化了一些.)</p>
<p>定理1:在得到关于随机变量<span class="math inline">\(x\)</span>的一个熵为<span class="math inline">\(h\)</span>的信息后,<span class="math inline">\(x\)</span>的熵会减少<span class="math inline">\(h\)</span>.</p>
<p>定理2:当一个随机变量的各种取值概率相等时,它的熵最大.</p>
<p>用信息论估计一下称球游戏的上界,如果我们已知次品轻重,由于一共有<span class="math inline">\(n\)</span>个球,每个球等概率成为次品,因此总熵是<span class="math inline">\(\ln
n\)</span>,每称一次能得到的信息有三种:平衡,左边重,右边重,因此称一次能得到的熵是<span class="math inline">\(\ln 3\)</span>,也就是说我们至少要猜<span class="math inline">\(\frac{ \ln n }{ \ln 3 } = \log_3
n\)</span>次.如果我们不知道次品的轻重,那么至少要猜<span class="math inline">\(\frac{ \ln 2 n }{ \ln 3 } = \log_3 2
n\)</span>次.</p>
<p>这就是称球游戏的信息论下界,接下来我们要做的无非就是证明这个下界能否取得到.</p>
<h6><span id="判定树">判定树</span></h6>
<p>我们考虑将称量的决策树建立出来,每个叶子节点表示我们得到的答案,每个非叶子节点代表一次称量,每个非叶子节点有三个儿子,分别表示如果称量的结果是左偏/右偏/平衡时,接下来的策略.显然判定树的深度就是最坏情况下称量的次数.</p>
<p><span class="math inline">\(n\)</span>个叶子的树的最小深度是<span class="math inline">\(\lceil \log_3 n
\rceil\)</span>,这得出和信息论一样的下界估计(信息论的结论好像就是拿哈夫曼树证明的,不太懂).</p>
<h6><span id="子问题1已知次品重量">子问题1(已知次品重量)</span></h6>
<p>不妨假设<span class="math inline">\(f ( n )\)</span>表示有<span class="math inline">\(n\)</span>个球的最少次数,注意到<span class="math inline">\(f ( 3 ) = 1\)</span>.</p>
<p>根据信息论,<span class="math inline">\(f ( n ) \geq \lceil \log_3 n
\rceil\)</span>,下面证明等号成立:</p>
<p>首先考虑证明<span class="math inline">\(f ( 3^m ) = m\)</span>,<span class="math inline">\(m = 1\)</span>时已经得证.<span class="math inline">\(m &gt;
1\)</span>时,考虑将所有球分成等数量的三份,称量其中两份.由于已知次品重量,这一次就可以找到次品在哪一份中,因此<span class="math inline">\(f ( 3^m ) \leq f ( 3^{ m - 1 } ) +
1\)</span>.综合信息论下界<span class="math inline">\(f ( 3^m ) \geq
m\)</span>,我们不难得出以上结论.至于<span class="math inline">\(n \ne
3^m\)</span>的情况,我们类似这个过程按照<span class="math inline">\(n
\bmod 3\)</span>的值讨论一下即可,于是有<span class="math inline">\(f ( n
) \leq f ( \lceil \frac{ n }{ 3 } \rceil ) + 1\)</span>.</p>
<h6><span id="子问题2不知次品轻重已有一个标准球需知道次品轻重">子问题2(不知次品轻重,已有一个标准球,需知道次品轻重)</span></h6>
<p>根据信息论下界,<span class="math inline">\(f ( n ) \geq \lceil \log_3
2 n \rceil\)</span>.</p>
<p>比起上面的问题,这个问题在于:如果我们称量不平衡,是不知道次品球在两堆中的哪一堆的.但我们思考到:虽然我们不知道在哪一堆,但我们得到了一个额外的信息:如果它在哪一堆,它的重量我们也就知道了.</p>
<p>下面证明引理:</p>
<p><strong>引理</strong></p>
<p>有两堆球,第一堆有<span class="math inline">\(n\)</span>个球,第二堆有<span class="math inline">\(m\)</span>个,已知其中有一个次品,并且次品如果在第一堆中只可能是重球,在第二堆中只可能是轻球.设此时的称量次数是<span class="math inline">\(g ( n , m )\)</span>,则<span class="math inline">\(g ( n , m ) = \lceil \log_3 ( n + m )
\rceil\)</span>.</p>
<p>先证明信息论下界,不难发现仍然是<span class="math inline">\(g ( n , m
) = \lceil \log_3 ( n + m ) \rceil\)</span>.</p>
<p>首先不难发现,<span class="math inline">\(g ( 1 , 0 ) = g ( 0 , 1 ) =
0 , g ( 1 , 1 ) = g ( 2 , 0 ) = g ( 0 , 2 ) = 1\)</span>.</p>
<p>仍然使用数学归纳,假设<span class="math inline">\(n + m &lt; k ( k
\geq 3 )\)</span>的时候成立,我们接下来证明<span class="math inline">\(n
+ m = k\)</span>的时候仍然成立.</p>
<p><strong>情况1</strong></p>
<p>若<span class="math inline">\(n = 3 p , m = 3 q\)</span>,我们将<span class="math inline">\(n\)</span>分成等数量的三堆:<span class="math inline">\(A_1 , B_1 , C_1\)</span>,将<span class="math inline">\(m\)</span>分成等质量的三堆<span class="math inline">\(A_2 , B_2 , C_2\)</span>.</p>
<p>接下来称量<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>.</p>
<ol type="1">
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = 0\)</span>,那么答案在<span class="math inline">\(C_1 \cup
C_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g (
\frac{ n }{ 3 } , \frac{ m }{ 3 } ) + 1\)</span>.</p></li>
<li><p>如果<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle = A_1 + A_2\)</span>,由于若次品在<span class="math inline">\(A_2\)</span>中,那么它不可能是重球,因此次品不可能在<span class="math inline">\(A_2\)</span>中,同理不可能在<span class="math inline">\(B_1\)</span>中,只可能在<span class="math inline">\(A_1 \cup B_2\)</span>中,此时有<span class="math inline">\(g ( n , m ) = g ( \frac{ n }{ 3 } , \frac{ m }{ 3
} ) + 1\)</span>.</p></li>
<li><p><span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2 \rangle
= B_1 + B_2\)</span>,同理.</p></li>
</ol>
<p>此时数学归纳成立.</p>
<p><strong>情况2</strong></p>
<p><span class="math inline">\(n = 3 p + 1 , m = 3 q +
2\)</span>.此时我们将第一堆分成<span class="math inline">\(A_1 ( p ) ,
B_1 ( p ) , C_1 ( p + 1 )\)</span>,将第二堆分成<span class="math inline">\(A_2 ( q + 1 ) , B_2 ( q + 1 ) , C_2 ( q
)\)</span>,然后<span class="math inline">\(\langle A_1 + A_2 , B_1 + B_2
\rangle\)</span>,接下来和情况1一样,于是有<span class="math inline">\(g (
n , m ) = \max \{ g ( p , q + 1 ) , g ( p + 1 , q ) \} = \lceil \log_3
\frac{ n + m }{ 3 } \rceil + 1\)</span>.</p>
<p>同理,当<span class="math inline">\(n , m \bmod
3\)</span>的值是其它组合的时候,也都可以类似操作.引理得证.</p>
<p>由此引理得证.</p>
<p>回到原问题,进行数学归纳,我们继续来讨论<span class="math inline">\(n
\bmod 3\)</span>的值.</p>
<p><strong>情况1</strong></p>
<p>当<span class="math inline">\(n = 3 p\)</span>时,直接分成<span class="math inline">\(A ( p ) , B ( p ) , C ( p )\)</span>,然后<span class="math inline">\(\langle A , B
\rangle\)</span>.如果平衡则接下来需要<span class="math inline">\(f ( p )
= \lceil \log_3 2 p \rceil\)</span>次,不然根据引理,需要<span class="math inline">\(\lceil \log_3 ( p + p )
\rceil\)</span>次,因此<span class="math inline">\(f ( n ) = \lceil
\log_3 2 p \rceil + 1 = \lceil \log_3 6 p \rceil = \lceil \log_3 2 n
\rceil\)</span>.</p>
<p><strong>情况2</strong></p>
<p>当<span class="math inline">\(n = 3 p +
1\)</span>时,一种自然的想法是分成<span class="math inline">\(A ( p + 1 )
, B ( p ) , C ( p
)\)</span>,但是这种想法是错误的!我们考虑判定树,这种情况下,所有的叶子被分成了<span class="math inline">\(2 p + 2 , 2 p , 2
p\)</span>,这显然是不优秀的.正确的做法是分成<span class="math inline">\(A = \{ S , 1 , \cdots p \} , B = \{ p + 1 , \cdots
2 p + 1 \} , C = \{ 2 p + 2 , \cdots 3 p + 1
\}\)</span>.由于存在标准球,此时如果<span class="math inline">\(\langle A
, B \rangle = A \ or \ B\)</span>,那么转化成<span class="math inline">\(g ( p , p + 1 ) = \lceil \log_3 ( 2 p + 1 )
\rceil\)</span>,不然转化成<span class="math inline">\(f ( p ) = \lceil
\log_3 2 p \rceil\)</span>.</p>
<p>剩下的情况也都类似,该问题解决.</p>
<h6><span id="子问题3不知次品轻重无标准球需知道次品轻重">子问题3(不知次品轻重,无标准球,需知道次品轻重)</span></h6>
<p>考虑在第一次称量后,无论结果如何都会得到一个标准球,因此后面的问题都等价于子问题2,只需考虑第一次操作.再思考一下不难发现,在子问题2中,只有<span class="math inline">\(n \bmod 3 =
1\)</span>的时候才会需要用到标准球,因此只有这里需要多一步.拟合一下函数,可以得到该问题<span class="math inline">\(f ( n ) = \lceil \log_3 ( 2 n + 2 )
\rceil\)</span>.</p>
<h6><span id="子问题4不知次品轻重已有一个标准球无需知道次品轻重">子问题4(不知次品轻重,已有一个标准球,无需知道次品轻重)</span></h6>
<p>这个问题复杂一些,而且难以估计下界.但我们可以用一下最优化dp来估计下界.</p>
<p>首先假设有无穷个标准球,我们每次将<span class="math inline">\(a\)</span>个球放左边,<span class="math inline">\(b\)</span>个球放右边,<span class="math inline">\(a
\leq b\)</span>,在左边补上<span class="math inline">\(b -
a\)</span>个标准球.</p>
<ol type="1">
<li><p>如果天平不平衡,转化为引理问题(因为此时找到次品是谁必然知道它的轻重),因此需要<span class="math inline">\(\lceil \log_3 ( a + b ) \rceil +
1\)</span>步.</p></li>
<li><p>如果天平平衡,需要<span class="math inline">\(f ( n - a - b ) +
1\)</span>步.</p></li>
</ol>
<p>我们有<span class="math inline">\(f ( n ) = \min_{ a , b } \{ \max \{
f ( n - a - b ) , \lceil \log_3 ( a + b ) \rceil \} \} + 1\)</span>.</p>
<p>注意到接下来的步数只与<span class="math inline">\(a +
b\)</span>有关,取<span class="math inline">\(b - a \leq
1\)</span>,于是一个标准球已经够用了.</p>
<p>构造方程后手算几项,注意到<span class="math inline">\(f ( n ) = \lceil
\log_3 ( 2 n - 1 ) \rceil\)</span>.</p>
<p>接下来归纳法就简单了,只需要对于<span class="math inline">\(n \bmod
3\)</span>的余数讨论一下,然后再讨论一下<span class="math inline">\(a\)</span>的取值即可.</p>
<h5><span id="example7ucup-3rd-stage-8-h">Example7(Ucup 3rd Stage 8 H)</span></h5>
<p>每次可以询问一个区间,交互库返回这个区间中的次大元素所在位置,求<span class="math inline">\(n\)</span>所在位置.要求询问次数<span class="math inline">\(\leq \lceil 1 . 5 \log_2 n
\rceil\)</span>,询问区间总长度<span class="math inline">\(\leq 3
n\)</span>.</p>
<p>一个自然的想法是先问一下全局次大值,然后二分,但这样询问区间总长度就会爆掉.</p>
<p>因此考虑设<span class="math inline">\(T ( n )\)</span>表示长度为<span class="math inline">\(n\)</span>的,已知次大值(并且次大值)的最小次数.我们考虑每次判断一下最大值在哪边,因此把这个区间拆成两半,然后询问一下次大值所在的那一半,这样就可以判断最大值在不在那一半.</p>
<p>那么我们当然有方程<span class="math inline">\(T ( n ) = \min_{ m &lt;
n } \{ \max \{ T ( m ) + 1 , T ( n - m ) + 2 \} \}\)</span>.</p>
<p>当然有<span class="math inline">\(m_n \leq m_{ n + 1
}\)</span>,于是直接dp即可.</p>
<h3><span id="exchange-arguments">Exchange Arguments</span></h3>
<h4><span id="模型1">模型1</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,定义域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,表达式<span class="math inline">\(F (
\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_n } \} )\)</span>最小值.</p>
<p>事实上会发现一些NPC问题也可以直接转化为这个模型,但是并无贪心解.我们接下来考虑这个模型内哪些问题是有贪心解的.</p>
<h5><span id="example1国王游戏">Example1(国王游戏)</span></h5>
<p>给定<span class="math inline">\(n\)</span>个二元正整数对<span class="math inline">\(( a_i , b_i
)\)</span>,将它们按照任意顺序排成一列.定义排成一列的代价为每个二元组的<span class="math inline">\(a\)</span>乘上序列中这个二元组之后的所有二元组的<span class="math inline">\(b\)</span>之和的总和,求最小代价.<span class="math inline">\(n , a_i , b_i \leq 10^6\)</span>.</p>
<p>转化为上面的形式,也即:<span class="math inline">\(F ( \{ ( a_1 , b_1
) , . . . , ( a_n , b_n ) \} ) = \sum_{ 1 \leq i &lt; j \leq k } a_i
b_j\)</span>.</p>
<p>考虑调整法,令排列<span class="math inline">\(( q_1 , . . . , q_n ) =
( p_1 , . . . , p_{ i - 1 } , p_{ i + 1 } , p_i , p_{ i + 2 } , . . . ,
p_n )\)</span>.则:</p>
<p><span class="math display">\[
F ( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \}
) - F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n } )
\} ) = a_{ p_i } b_{ p_{ i + 1 } } - a_{ p_{ i + 1 } } b_{ p_i }
\]</span></p>
<p>因而如果<span class="math inline">\(a_{ p_i } b_{ p_{ i + 1 } } - a_{
p_{ i + 1 } } b_{ p_i } &gt; 0\)</span>,则<span class="math inline">\(F
( \{ ( a_{ p_1 } , b_{ p_1 } ) , . . . , ( a_{ p_n } , b_{ p_n } ) \} )
&gt; F ( \{ ( a_{ q_1 } , b_{ q_1 } ) , . . . , ( a_{ q_n } , b_{ q_n }
) \} )\)</span>,也就是说<span class="math inline">\(( p_1 , . . . , p_n
)\)</span>不是最优解.因此只有满足<span class="math inline">\(\forall 1
\leq i &lt; n\)</span>,<span class="math inline">\(\cfrac{ a_{ p_i } }{
b_{ p_i } } \leq \cfrac{ a_{ p_{ i + 1 } } }{ b_{ p_{ i + 1 } }
}\)</span>可能是最优解.</p>
<p>如果一个<span class="math inline">\(p\)</span>满足这样的性质,则所有<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的数在排列中一定是连续的一段.而根据式子,这样的排列交换<span class="math inline">\(\cfrac{ a }{ b
}\)</span>相等的两个位置,是不会使答案改变的.因此直接按照<span class="math inline">\(\cfrac{ a }{ b }\)</span>排序即可.</p>
<p>我以前所使用的调整法大概是先构造一个贪心策略,然后证明这个策略改变后一定不优秀或更劣.但是这样对于多峰函数会卡在一个局部最优解上而找不到全局最优解.但是,如果我们说不满足这个条件的一定不是最优解(可以使用调整得到更优解),我们再证明满足这个条件(即调整过程DAG的终止点)的都是最优解,继续做下去,就是很严谨的.</p>
<p>换句话说,我们要用调整法,就一定要证明调整过程中的DAG的零出度点是最优解.</p>
<h5><span id="模型通解">模型通解</span></h5>
<p>设给出的元素的集合为<span class="math inline">\(S\)</span>,定义<span class="math inline">\(S\)</span>上的一种二元比较关系<span class="math inline">\(\leq\)</span>,将所有元素按照比较关系排序.在上一个问题中,不难发现以下性质:</p>
<ol type="1">
<li><p>强完全性:<span class="math inline">\(\forall a , b \in
S\)</span>,<span class="math inline">\(a \leq b \lor b \leq a =
1\)</span>.</p></li>
<li><p>传递性:<span class="math inline">\(\forall a , b , c \in
S\)</span>,<span class="math inline">\(a \leq b , b \leq c \Rightarrow a
\leq c\)</span>.</p></li>
<li><p><span class="math inline">\(\forall a , b \in
S\)</span>,如果<span class="math inline">\(a \leq
b\)</span>,则对于任意一个包含<span class="math inline">\(\{ a , b
\}\)</span>作为子段的元素序列<span class="math inline">\(\{ s_1 , . . .
, s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \}\)</span>和<span class="math inline">\(\{ s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 }
, . . . , s_n \}\)</span>都有:<span class="math inline">\(F ( \{ s_1 , .
. . , s_{ k - 1 } , a , b , s_{ k + 2 } , . . . , s_n \} ) \leq F ( \{
s_1 , . . . , s_{ k - 1 } , b , a , s_{ k + 2 } , . . . , s_n \}
)\)</span>.</p></li>
</ol>
<p>问题满足以上性质,那么我们按照这种二元比较关系对元素排序后的答案一定是最优的.原因在于,首先这种操作构成DAG,而定义<span class="math inline">\(\leq\)</span>后自然也就定义了<span class="math inline">\(=\)</span>,所以DAG的零出度点自然是最优解点.</p>
<p>分析题目时,应该先分析第三条性质得到<span class="math inline">\(\leq\)</span>的定义,然后判断是否符合前两条性质.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定<span class="math inline">\(n\)</span>个包含小写字符的字符串<span class="math inline">\(s_1 , . . . , s_n\)</span>,找到一个<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>,将<span class="math inline">\(s_{ p_1 }
, s_{ p_2 } , . . . , s_{ p_n }\)</span>顺序拼接得到<span class="math inline">\(S\)</span>,使<span class="math inline">\(S\)</span>的字典序最小.</p>
<p>令<span class="math inline">\(s \leq t\)</span>当且仅当<span class="math inline">\(s + t\)</span>的字典序<span class="math inline">\(\leq\)</span>t+s</p>
<p>此时我们注意到:<span class="math inline">\(s +
t\)</span>的字典序小于等于<span class="math inline">\(t +
s\)</span>的字典序当且仅当<span class="math inline">\(s^{ \infty } \leq
t^{ \infty }\)</span>.原因是:不妨设<span class="math inline">\(s\)</span>的长度<span class="math inline">\(\leq
t\)</span>的长度.若<span class="math inline">\(s\)</span>不是<span class="math inline">\(t\)</span>的前缀,那显然只需比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(s\)</span>的字典序即可,此时上面两个条件等价;若<span class="math inline">\(s\)</span>是<span class="math inline">\(t\)</span>的前缀,则我们需要比较<span class="math inline">\(t\)</span>的前缀和<span class="math inline">\(t\)</span>的后缀,注意到<span class="math inline">\(t\)</span>的前缀还是<span class="math inline">\(s\)</span>,于是需要比较<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的后缀.类似可得.</p>
<p>于是这题可以使用后缀数组求任意两个字符串的后缀的最长公共前缀实现.</p>
<h5><span id="example3">Example3</span></h5>
<p>有<span class="math inline">\(n\)</span>个箱子,第<span class="math inline">\(i\)</span>个箱子有重量<span class="math inline">\(w_i\)</span>和承载量<span class="math inline">\(v_i\)</span>,<span class="math inline">\(( w_i ,
v_i &gt; 0
)\)</span>,将它们堆成一列使得每一个箱子上面的箱子总重量都不大于它的承载量.</p>
<p>考虑最大化<span class="math inline">\(\min_{ i = 1 }^n \{ v_i -
\sum_{ j = 1 }^{ i - 1 } w_j \}\)</span>,并判断是否<span class="math inline">\(\geq 0\)</span>.</p>
<p>我们令<span class="math inline">\(b_i = - ( v_i + w_i ) , a_i = -
v_i\)</span>,则我们要最大化<span class="math inline">\(\min \{ \sum_{ j
= 1 }^{ i - 1 } b_i - \sum_{ j = 1 }^i a_i \}\)</span>.</p>
<p>我们接下来将证明所有形如这样的题的通法.</p>
<p>首先,定义<span class="math inline">\(x \leq y\)</span>当且仅当<span class="math inline">\(F ( \{ x , y \} ) \leq F ( \{ y , x \}
)\)</span>,那么对于两个元素<span class="math inline">\(( a_1 , b_1 ) , (
a_2 , b_2 )\)</span>,显然<span class="math inline">\(( a_1 , b_1 ) \leq
( a_2 , b_2 )\)</span>当且仅当<span class="math inline">\(\min \{ - a_1
, b_1 - a_1 - a_2 \} \geq \min \{ - a_2 , b_2 - a_1 - a_2
\}\)</span>.接下来我们证明这样的定义是满足性质的.</p>
<p>对于性质(3),显然成立,因为交换两个相邻位置不会对前面或后面产生影响,而前后对于这两个位置的影响也都可以抵消.</p>
<p>性质(1)显然成立.</p>
<p>再分析一下这个式子,这相当于不等式左边的两个元素都大于等于右边的最小值.我们讨论一下两种情况:</p>
<ol type="1">
<li><p>都大于等于第一个元素,则相当于<span class="math inline">\(a_1 \leq
a_2 \land b_1 - a_1 \geq 0\)</span>.</p></li>
<li><p>都大于等于第二个元素,则相当于<span class="math inline">\(b_1 \geq
b_2 \land b_2 - a_2 \leq 0\)</span>.</p></li>
</ol>
<p>可能这里后面和<span class="math inline">\(0\)</span>比较没有移项来得简洁.但是,相减的两项是同一个元素的两项,我们显然把它俩放在一类是更优秀的.</p>
<p>注意到需要对<span class="math inline">\(b -
a\)</span>的符号进行讨论:</p>
<ol type="1">
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) &gt; sgn ( b_2 -
a_2 )\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 1\)</span>,则不等式成立当且仅当<span class="math inline">\(a_1 \leq
a_2\)</span>.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = 0\)</span>,则不等式成立.</p></li>
<li><p>若<span class="math inline">\(sgn ( b_1 - a_1 ) = sgn ( b_2 - a_2
) = - 1\)</span>,则不等式成立当且仅当<span class="math inline">\(b_1
\geq b_2\)</span>.</p></li>
</ol>
<p>这四条中(2)和(4)的证明是显然的,(3)则是因为此时<span class="math inline">\(b_1 = a_1\)</span>,<span class="math inline">\(b_2
= a_2\)</span>,两条件必有一真.(1)则是因为此时满足<span class="math inline">\(b_1 - a_1 &gt; b_2 - a_2 \land sgn ( b_1 - a_1 )
\geq 0 \land sgn ( b_2 - a_2 ) \leq 0\)</span>.也就有<span class="math inline">\(a_2 - a_1 &gt; b_2 - b_1 \land b_1 \geq a_1 \land
b_2 \leq a_2\)</span>.怎么着都能成立.</p>
<p>由此发现,对于<span class="math inline">\(sgn ( b - a
)\)</span>相同的类,内部排序是一定满足传递性的.</p>
<p>但是不同类之间并没有满足传递性,因此我们把排序条件修正为:</p>
<p><span class="math display">\[
\begin{aligned}
( a_1 , b_1 ) &amp; \leq ( a_2 , b_2 ) \\
\Updownarrow \\
( sgn ( b_1 - a_1 ) &amp; &gt; sgn ( b_2 - a_2 ) ) \\
\lor ( sgn ( b_1 - a_1 ) &amp; = sgn ( b_2 - a_2 ) \land F ( \{ 1 , 2 \}
) &amp; \leq F ( \{ 2 , 1 \} )
\end{aligned}
\]</span></p>
<h4><span id="模型2">模型2</span></h4>
<p>给定<span class="math inline">\(n\)</span>个元素<span class="math inline">\(x_1 , . . . ,
x_n\)</span>,以及一个定义域为这些元素的序列,值域为有序集合的函数<span class="math inline">\(F\)</span>.求出对于给定整数<span class="math inline">\(k\)</span>,所有的<span class="math inline">\(n\)</span>阶排列<span class="math inline">\(p\)</span>的长度为<span class="math inline">\(k\)</span>的子序列,表达式<span class="math inline">\(F ( \{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\} )\)</span>最小值.</p>
<p>如果<span class="math inline">\(k =
n\)</span>,则就是模型1.不然,我们考虑先选出一个大小为<span class="math inline">\(k\)</span>的子集,然后使用模型1.不难发现,我们最后取出的<span class="math inline">\(\{ x_{ p_1 } , x_{ p_2 } , . . . , x_{ p_k }
\}\)</span>一定是<span class="math inline">\(n =
k\)</span>时最优解的一个子序列.这在一些情况下可以降低问题的难度.</p>
<h5><span id="example">Example</span></h5>
<p>有<span class="math inline">\(n\)</span>个物品,第<span class="math inline">\(i\)</span>个物品有非负费用<span class="math inline">\(c_i\)</span>和价值<span class="math inline">\(v_i\)</span>,两个人进行如下博弈:</p>
<ol type="1">
<li><p>第一个人要么选择一个物品,付出<span class="math inline">\(c_i\)</span>的代价;要么选择结束游戏.</p></li>
<li><p>第二个人可以选择删除这个物品,这会使博弈回到第一步,且第一个人付出的代价不会消失(这个操作最多可以进行<span class="math inline">\(k\)</span>次);也可以选择不操作,此时第一个人获得<span class="math inline">\(v_i\)</span>的收益,博弈结束.</p></li>
<li><p>第一个人的总收益为收益减去付出的所有代价,第一个人希望最大化收益,第二个人希望最小化收益.<span class="math inline">\(( n \leq 1 . 5 \times 10^5 , k \leq 9
)\)</span></p></li>
</ol>
<p>注意到第一个人要么一开始就结束游戏,要么连续选择<span class="math inline">\(k + 1\)</span>个,然后收益为<span class="math inline">\(\min_{ i = 1 }^{ k - 1 } \{ v_{ x_i } - \sum_{ j =
1 }^i c_{ x_j }
\}\)</span>(如果第一个人把一个收益很大的放在最后选,那第二个人可以直接结束游戏防止他选到).注意到这和模型1的Example3是类似的,于是我们可以先排序,然后dp出子序列,复杂度<span class="math inline">\(O ( n \log n + nk )\)</span>.</p>
<h2><span id="构造">构造</span></h2>
<h3><span id="增量构造">增量构造</span></h3>
<h5><span id="example1">Example1</span></h5>
<p>平面上有<span class="math inline">\(n\)</span>条直线,将整个平面划分成若干部分.求证:这些部分可以黑白染色使得两个边相邻的部分颜色不相同,并给出构造方案.</p>
<p>考虑数学归纳,现在已经有<span class="math inline">\(n\)</span>条直线的答案,求<span class="math inline">\(n +
1\)</span>条直线的答案.我们将直线加到这个平面上,并将在这条直线其中一边的部分颜色全部取反.</p>
<h5><span id="example2">Example2</span></h5>
<p>给定若干个角度<span class="math inline">\(a_1 , \cdots , a_n \in \{
90 \degree , 270 \degree \}\)</span>,要求构造一个<span class="math inline">\(n\)</span>边形(边必须平行于坐标轴),使得其内角依次是<span class="math inline">\(a_1 , \cdots , a_n\)</span>.</p>
<p>首先有解条件显然是判定它们的和是否是<span class="math inline">\(180
\degree ( n - 2 )\)</span>.</p>
<p>注意到相邻的<span class="math inline">\(90 \degree\)</span>和<span class="math inline">\(270
\degree\)</span>无非是在原序列上修修改改,这个可以一起合并起来.不断合并就做完了.</p>
<h5><span id="example3cf1770h">Example3(CF1770H)</span></h5>
<p>呃,简单来说就是把边界往里缩,每次找左上和右上的四个点做匹配,然后剩下的缩进去.</p>
<p>原题解的那个图特别清晰.</p>
<h5><span id="example4abc232h">Example4(ABC232H)</span></h5>
<p>放在这个模块下就好想了,剥一行一列就行.最后可能会剩个边界情况,简单讨论.</p>
<h3><span id="找中间状态">找中间状态</span></h3>
<p>常见于操作可逆,想要让<span class="math inline">\(S \rightarrow
T\)</span>.这个时候可以找一个中间状态<span class="math inline">\(A\)</span>,让<span class="math inline">\(S
\rightarrow A , T \rightarrow A\)</span>.</p>
<h5><span id="example1">Example1</span></h5>
<p>坐标系上每个整点有个灯,初始只有<span class="math inline">\(( X , 0
)\)</span>亮着,每次把<span class="math inline">\(( x , y
)\)</span>,<span class="math inline">\(( x , y + 1 )\)</span>,<span class="math inline">\(( x + 1 , y
)\)</span>状态反转,给出终止状态,求初始亮的点的坐标,保证有解且唯一解.</p>
<p><span class="math inline">\(n \leq 10^5\)</span>,坐标的绝对值均<span class="math inline">\(\leq 10^{ 17 }\)</span>.</p>
<p>首先我们发现,如果我们上面有若干个亮点,我们一定能把他们全杀了,变到下面,但下面的亮点没办法处理.怎么办呢?</p>
<p>一个想法是,我们将所有的亮点全都推到一条直线<span class="math inline">\(y = - inf\)</span>,然后比对.我们注意到<span class="math inline">\(( X , 0
)\)</span>向下推的过程类似一个组合数递推的过程,由经典公式<span class="math inline">\(\binom{ S }{ T } \equiv [ T \subseteq S ] \bmod
2\)</span>可知,我们取<span class="math inline">\(inf = 2^{ 63 } -
1\)</span>即可.然后最后在这条线上一定是有一个区间是<span class="math inline">\(1\)</span>,我们需要找到区间左端点,我们选择在直线上随便找到一个<span class="math inline">\(1\)</span>,由于<span class="math inline">\(inf\)</span>很大,大于<span class="math inline">\(10^{ 17
}\)</span>,因此这一步是好找的.然后最后二分+算贡献就可以找到左端点.</p>
<p>这个题有个改版,<span class="math inline">\(n \leq
10^4\)</span>,但是初始点可能是<span class="math inline">\(( X , Y
)\)</span>.</p>
<p>这个题怎么做呢?类似上面的,我们考虑找到两个点<span class="math inline">\(( j , - inf )\)</span>和<span class="math inline">\(( k , - inf
)\)</span>是亮的,并且他们分别是最靠左的和最靠右的,然后我们就能反解出<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>.而上述条件满足当且仅当<span class="math inline">\([ j - X \subseteq Y + inf ]\)</span>.</p>
<p>如果我们随便找一个点<span class="math inline">\(( p , - inf
)\)</span>满足条件,那我们接下来只需要枚举<span class="math inline">\(w\)</span>,判断<span class="math inline">\(( p -
2^w , - inf
)\)</span>是否是亮的,这样就能找到最靠左的,同理可以找到最靠右的.</p>
<p>那么怎么找到这个点呢?我们二分,每次判断一个区间<span class="math inline">\([ l , r
]\)</span>中是否有亮的.这个是难以判断的,但是好判断的是,这个区间中亮的灯的数量是奇数还是偶数.因此我们拿这个判断就行,有奇数就去奇数,两个都是偶数随便去一个.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OI/" rel="tag"># OI</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
      <a class="a2a_button_telegram"></a>
      <a class="a2a_button_wechat"></a>
      <a class="a2a_button_qzone"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="prev" title="计算几何">
                  <i class="fa fa-angle-left"></i> 计算几何
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/22/%E5%AD%A6%E4%B9%A0-%E9%80%92%E5%BD%92%E5%BC%8F%E4%B8%8E%E5%92%8C%E5%BC%8F/" rel="next" title="递归式与和式">
                  递归式与和式 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">LWLAymh</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"my-repository-jade-beta-79.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"有什么想法?","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2025/06/22/%E5%AD%A6%E4%B9%A0-%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%9E%84%E9%80%A0/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

  <!-- 音乐播放器 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.js"></script>
  <div id="aplayer" class="aplayer" data-id="7637648380" data-server="netease" data-type="playlist" data-fixed="true" data-listfolded="true" data-order="random" data-theme="#F58EA8"></div>
  <script src="https://unpkg.com/meting@1.2/dist/Meting.min.js"></script>
  <!-- 音乐播放器 end -->
</body>
</html>
