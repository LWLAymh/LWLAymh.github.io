<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LWLAymh的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="多项式基础">
<meta property="og:type" content="article">
<meta property="og:title" content="LWLAymh的博客">
<meta property="og:url" content="http://lwlaymh.github.io/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="LWLAymh的博客">
<meta property="og:description" content="多项式基础">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-03T03:11:08.326Z">
<meta property="article:modified_time" content="2022-09-03T03:11:32.450Z">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LWLAymh的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LWLAymh的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://LWLAymh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-多项式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2022-09-03T03:11:08.326Z" itemprop="datePublished">2022-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="多项式基础"><a href="#多项式基础" class="headerlink" title="多项式基础"></a>多项式基础</h2><span id="more"></span>
<h3 id="复数相关"><a href="#复数相关" class="headerlink" title="复数相关"></a>复数相关</h3><p>欧拉公式:$e^{i\pi}=-1$.</p>
<p>也就是$e^{2i\pi}=1$,同时又有$e^{i\theta}=cos\theta+i·sin\theta$,证明使用复平面的单位圆.</p>
<p>单位根:对于$x^n=1$,我们会有$n$个根,设第$k$个根为$\omega_n^k$.那么我们有:$\omega_n^k=e^{2\pi\frac k ni}=cos(2\pi\frac kn)+i·sin(2\pi\frac kn)$.</p>
<p>单位根有以下性质:</p>
<ol>
<li>折半引理:$\omega_{2n}^{2k}=\omega_n^k\\$,由我们上面推导的通项公式即可证明.</li>
<li>消去引理:$\omega_n^{k+\frac n 2}=-\omega_n^k\\$,同样使用通项，运用三角恒等变换可证明.</li>
</ol>
<h3 id="点值表示法和系数表示法"><a href="#点值表示法和系数表示法" class="headerlink" title="点值表示法和系数表示法"></a>点值表示法和系数表示法</h3><script type="math/tex; mode=display">
代数基本定理：一个n-1次多项式在复数域上有且只有n-1个根\\
多项式有点值表示法和系数表示法两种\\
系数表示法：A(x)=\sum_{i=0}^{n-1}a_ix^i\\
点值表示法：y_i=\sum_{j=0}^{n-1}a_jx_i^j\\
\\
定理：一个n-1次多项式在n个不同点的取值唯一确定了该多项式\\
证明：\\
考虑反证法，假设命题不成立，则存在两个n-1次多项式A(x)和B(x)\\
且\forall i\in[0,n-1],A(x_i)=B(x_i)\\
令C(x)=A(x)-B(x)，那么C(x)至多是一个n-1次多项式\\
且\forall i\in[0,n-1]，C(x_i)=0\\
也就是C(x)有n个根，与代数基本定理不符合\\
\\
已知多项式点值表示法求系数表示法的过程被称为插值\\</script><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><script type="math/tex; mode=display">
构造多项式\sum_{i=0}^{n-1}y_i(\prod_{j=0且j\ne i}^{n-1}\frac {x-x_j}{x_i-x_j})\\
显然当x=x_i时，该多项式的答案为y_i</script><h2 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h2><script type="math/tex; mode=display">
考虑两个多项式相乘，如果我们已知他们的点值表示法，显然可以直接相乘\\
这为我们提供了一种思路：先将系数表示法转化为点值表示法，进行相乘之后再转化回系数表示法\\</script><h3 id="多项式乘法-FFT"><a href="#多项式乘法-FFT" class="headerlink" title="多项式乘法(FFT)"></a>多项式乘法(FFT)</h3><h4 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h4><script type="math/tex; mode=display">
将n次单位根（n=2^w）分别带入A(x)得到点值向量A(\omega_n^k)\\
如果朴素带入，复杂度显然不可接受\\
考虑A(x)=\sum_{i=0}^{n-1}a_ix^i=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^i+\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^i\\
=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{2k}+x\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{2k}\\
令A_1(x)=\sum_{i=2k,k\in\mathbb{N}}^{n-2}a_ix^{k}\\
A_2(x)=\sum_{i=2k+1,k\in\mathbb{N}}^{n-1}a_ix^{k}\\
那么A(x)=A_1(x^2)+xA_2(x^2)\\
接下来分类讨论：\\
\forall 0\leq k\leq \frac n 2-1，k\in\mathbb{N}\\
我们有A(\omega_n^k)=A_1(\omega_n^{2k})+\omega_n^kA_2(\omega_n^{2k})\\
根据折半引理，
A(\omega_n^k)=A_1(\omega_{\frac n 2}^k)+\omega_n^kA_2(\omega^k_{\frac n 2})\\
\forall \frac n 2\leq k+\frac n 2\leq n-1\\
A(\omega_n^{k+\frac n 2})=A_1(\omega_n^{2k+n})+\omega_n^{k+\frac n 2}A_2(\omega_n^{2k+n})\\
根据消去引理，A(\omega_n^{k+\frac n 2})=A_1(\omega_{\frac n 2}^k)-\omega_n^kA_2(\omega_{\frac n 2}^k)\\
以上，我们可以递归处理A_1和A_2，然后合并得到A的答案，可以分治</script><h4 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h4><script type="math/tex; mode=display">
设A(\omega_n^k)=d_k\\
构造多项式F(x)=\sum_{i=0}^{n-1}d_ix^i\\
我们求出F(x)的点值表示，设c_k=F(\omega_n^{-k})\\
也即c_k=\sum_{i=0}^{n-1}d_i(\omega_n^{-k})^i=\sum_{i=0}^{n-1}(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j)(\omega_n^{-k})^i\\
=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}\\
当j=k时，显然\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n\\
否则根据等比数列求和公式，\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=\frac{\omega^0_n[(\omega_n^{j-k})^n-1]}{\omega_n^{j-k}-1}=0\\
所以，\sum_{i=0}^{n-1}(\omega_n^i)^{j-k}=n[j=k]\\
那么我们有c_k=a_kn\\
a_k=\frac{c_k}{n}</script><h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><script type="math/tex; mode=display">
递归写法显然\\
递归过程中，第k层相当于在根据数在第k位的二进制数是1还是0来分类\\
那显然可以求出最后一层的数组，然后向上合并\\
合并的过程被称为蝴蝶操作\\
假设A_1(\omega_{\frac n 2}^k)和A_2(\omega_{\frac n 2}^k)分别存在a[k]和a[\frac n 2+k]中，我们设t=\omega_n^ka[k+\frac n 2]\\
那么可以写出合并：\\
a[k+\frac n 2]:=a[k]-t\\
a[k]:=a[k]+t</script><h3 id="快速数论变换-NTT"><a href="#快速数论变换-NTT" class="headerlink" title="快速数论变换(NTT)"></a>快速数论变换(NTT)</h3><script type="math/tex; mode=display">
由于FFT中的单位根会产生精度误差，因此在膜意义下，通常会选择NTT来进行多项式乘法\\</script><script type="math/tex; mode=display">
NTT与FFT的运算过程基本相同，证明过程基本相同，唯一不同的是将单位根改为了原根\\
根据上面FFT的证明过程，我们知道：只需要证明原根满足以下条件，就可以进行变换\\
设原根为g，g_n=g^{\frac {p-1}n}\\
那需要满足：\\
1. g_n^n=g_n^0=1，证明显然\\
2. 折半引理，g_{2n}^{2k}=g_{n}^k，证明显然\\
3. 消去引理，g_{n}^{k+\frac n 2}=-g^k_n\\
由于g^{\frac {p-1}2}=-1，该结论显然成立\\
由上我们证明了，我们完全可以使用g_n代替\omega_n进行变换\\
ps：注意到998244352=2^{23}\times 7\times 17\\
而2^{23}\approx 8\times 10^6\\
因而，当n\leq 8\times 10^6的时候，g_n可以直接求出\\
（这也是为什么大部分ntt题目都使用998244353作为模数的原因</script><h3 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a>分治FFT</h3><script type="math/tex; mode=display">
给定g(x)，求f(x)=\sum_{y=1}^xf(x-y)g(y)，答案对998244353取膜\\</script><script type="math/tex; mode=display">
假如我们已经知道了f(x)，x\in[1,\frac n 2]\\
那我们可以计算出这段部分对f(y)，y\in[\frac n 2+1,n]的贡献\\
这显然是一个卷积的形式，我们直接计算f和g的乘积并贡献上去</script><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>对于多项式$P(x)$,找到$Q(x)$使得$Q(x)P(x)\equiv 1(\mod x^n)\\$.显然$Q(x)$是唯一的.</p>
<p>首先不妨设$n=2^k\\$.</p>
<p>如果我们已知$P(x)Q_{k-1}(x)\equiv 1(\mod x^{2^{k-1}})\\$,同时肯定有$P(x)Q_{k}(x)\equiv 1(\mod x^{2^{k-1}})\\$,相减得到$Q_k(x)-Q_{k-1}(x)\equiv 0(\mod x^{2^{k-1}})\\$.</p>
<p>两边平方:</p>
<script type="math/tex; mode=display">
Q_k^2(x)+Q^2_{k-1}(x)-2Q_k(x)Q_{k-1}(x)\equiv 0(\mod x^{2^k})\\</script><p>两边乘一下$P(x)$:</p>
<script type="math/tex; mode=display">
Q_k(x)-2Q_{k-1}(x)+P(x)Q_{k-1}^2(x)\equiv 0(\mod x^n)\\
Q_k(x)\equiv 2Q_{k-1}(x)-P(x)Q_{k-1}^2(x)(\mod x^n)\\</script><p>根据主定理，这么做复杂度是$O(n\log_2n)$的.</p>
<h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>对于$n$次多项式$F(x)$和$m$次多项式$G(x)$,找到$Q(x),R(x)$使得$F(x)=G(x)Q(x)+R(x)\\$.</p>
<p>考虑对于$n$次多项式$F(x)$,令$F_R(x)=x^n F(\cfrac{1}{x})$,如果设$f_i$为其$x^i$项前的系数,不难发现$f_R(i)=f(n-i)$.</p>
<p>那么我们有:</p>
<script type="math/tex; mode=display">
F(x)=G(x)Q(x)+R(x)\\
F(\cfrac{1}{x})=G(\cfrac{1}{x})Q(\cfrac{1}{x})+R(\cfrac{1}x)\\
x^nF(\cfrac{1}{x})=x^mG(\cfrac{1}{x})x^{n-m}Q(\cfrac{1}{x})+x^{n-m+1}x^{m-1}R(\cfrac{1}{x})\\
F_R(x)=G_R(x)Q_R(x)+x^{n-m+1}R_R(x)\\
F_R(x)\equiv G_R(x)Q_R(x)\pmod {x^{n-m+1}}\\
Q_R(x)\equiv F_R(x)G_R^{-1}(x)\pmod {x^{n-m+1}}</script><p>于是只要做一遍多项式求逆即可求得$Q(x)$,再做一遍相减既可以得到$R(x)$.</p>
<h2 id="集合幂级数"><a href="#集合幂级数" class="headerlink" title="集合幂级数"></a>集合幂级数</h2><script type="math/tex; mode=display">
形如\sum_{i=0}^{2^n-1}a_ix^i，其中二进制数i表示\{1,2,...,n\}的一个子集，用|i|表示该子集大小\\
下述级数如无特别说明均为集合幂级数</script><script type="math/tex; mode=display">
高维前缀和：
c_i=\sum_{j\subseteq i}a_j\\
高维后缀和：
c_i=\sum_{j\supseteq i}a_j\\
上述过程又称快速莫比乌斯变换（FMT）</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j]+=a[j^(<span class="number">1</span>&lt;&lt;i)];<span class="comment">//高维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;n);j++)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i)) a[j^(<span class="number">1</span>&lt;&lt;i)]+=a[j];<span class="comment">//高维后缀和</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="与-或卷积"><a href="#与-或卷积" class="headerlink" title="与/或卷积"></a>与/或卷积</h3><script type="math/tex; mode=display">
或卷积：c_i=\sum_{j}\sum_{k}[j \or k=i]a_jb_k\\
与卷积：c_i=\sum_{j}\sum_{k}[j\and k=i]a_jb_k\\
考虑如何求a和b的或卷积：\\
引理：\\
若j,k\subseteq i,则j\or k\subseteq i，逆命题同样成立\\
若j,k\supseteq i,则j\and k\supseteq i，逆命题同样成立\\
\\
设a，b，c的高维前缀和分别为A，B，C\\
A_iB_i=(\sum_{j\subseteq i}a_j)(\sum_{k\subseteq i}b_k)=\sum_{j,k\subseteq i}a_ib_k=\sum_{k\or j\subseteq i}a_ib_k=C_i\\
现在考虑已知C求c，本质上是一个反演\\
注意到\sum_{r\subseteq p}(-1)^{|r|}=\sum_{k=0}^{|p|}C_{|p|}^k(-1)^k=[p=0]\\
c(p)=\sum_{q\subseteq p}[p-q=0]c(q)=\sum_{q\subseteq p}\sum_{r\subseteq (p-q)}(-1)^{|r|}c(q)\\
=\sum_{r\subseteq p}(-1)^{|r|}\sum_{q\subseteq (p-r)}c(q)=\sum_{r\subseteq p}(-1)^{r}f(p-r)=\sum_{r\subseteq p}(-1)^{|p|-|r|}C(r)\\
于是C(S)=\sum_{T\subseteq S}c(T)\\
c(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}C(T)\\
\\
因而做两遍高维前缀和再反推回去即可\\
复杂度O(2^nn)\\
与卷积即改为高维后缀和</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k]+=t*a[j+k+mid]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				a[j+k+mid]+=t*a[j+k]%mod;</span><br><span class="line">				<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异或卷积"><a href="#异或卷积" class="headerlink" title="异或卷积"></a>异或卷积</h3><script type="math/tex; mode=display">
c_i=\sum_j\sum_k[j\oplus k=i]a_jb_k\\
快速沃尔什变换（FWT）：\\
定义集合幂级数FWT(a)，满足FWT(a)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}a_j\\
那么有：FWT(c)_i=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}c_j=\sum_{j=0}^{2^n-1}(-1)^{|i\and j|}\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}[k\oplus l=j]a_kb_l\\
=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|(k\oplus l)\and i|}a_kb_l=\sum_{k=0}^{2^n-1}\sum_{l=0}^{2^n-1}(-1)^{|k\and i|}a_k(-1)^{|l\and i|}b_l\\
=FWT(a)_iFWT(b)_i\\
时间复杂度O(2^nn)\\
FMT可以看作是FWT在解决或卷积，与卷积时的特例</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll t,<span class="type">int</span> limit)</span></span>&#123;<span class="comment">//FWT:t=1;IFWT:t=mpow(2,mod-2)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;limit;mid=mid&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> n=mid&lt;&lt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;limit;j+=n)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">				ll x=a[j+k],y=a[j+k+mid];</span><br><span class="line">				a[j+k]=t*(x+y)%mod;<span class="built_in">Mod</span>(a[j+k]);</span><br><span class="line">				a[j+k+mid]=t*(x-y+mod)%mod;<span class="built_in">Mod</span>(a[j+k+mid]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a>子集卷积</h3><script type="math/tex; mode=display">
c_i=\sum_{j}\sum_{k}[j\and k=\phi,j\or k=i]a_jb_k\\
意识到该卷积与或卷积的差别在于，或卷积会多累加一些[j\and k\ne \phi]的答案\\
而[j\and k=\phi,j\or k=i]=[|j|+|k|=|i|,j\or k=i]\\
因而可以将原集合按照元素个数分组，做FMT，然后再n^2次结合，并做IFMT，最终将结果累计\\
复杂度O(2^nn^2)</script><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们定义一个幂级数形如$A(z)=\sum_{k\geq 0}a_kz^k$,并使$[z^n]A(z)=a_n$.则称$A(z)$是$\langle a_0,a_1,…\rangle$的生成函数.</p>
<h3 id="生成函数的运算"><a href="#生成函数的运算" class="headerlink" title="生成函数的运算"></a>生成函数的运算</h3><ol>
<li>$\alpha A(z)+\beta B(z)=\sum_{n\geq 0}(\alpha f_n+\beta g_n)z^n$.</li>
<li>$z^mA(z)=\sum_{n\geq 0}g_{n}z^{n+m}=\sum_{n\geq m}g_{n-m}z^n$.</li>
<li>$A(cz)=\sum_{n\geq 0}c^nf_nz^n$.</li>
<li>$A’(z)=\sum_{n\geq 1}ig_iz^{i-1}$.</li>
<li>$\int A(z)dz=\sum_{n\geq 0}\cfrac{1}{n+1}g_nz^{n+1}$.</li>
<li>$A(z)B(z)=\sum_{n\geq 0}(\sum_{k=0}^nf_kg_{n-k})z^n$.</li>
<li>$\cfrac{1}{1-z}A(z)=\sum_{n\geq 0}(\sum_{k=0}^ng_k)z^n$.</li>
</ol>
<h3 id="常见序列生成函数"><a href="#常见序列生成函数" class="headerlink" title="常见序列生成函数"></a>常见序列生成函数</h3><ol>
<li>$\cfrac{1}{1-z}=\sum_{k\geq 0}z^k\\$,$\cfrac{1}{1-cz}=\sum_{k\geq 0}c^kz^k\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$(1+z)^r=\sum_{k\geq 0}\binom{r}{k}z^k\\$,$(1-z)^r=\sum_{k\geq 0}(-1)^k\binom{r}{k}z^k\\$.</li>
</ol>
<p>证明根据二项式定理.</p>
<ol>
<li>$\cfrac{1}{1-z^m}=\sum_{n\geq 0}[n|m]z^n\\$.</li>
</ol>
<p>证明显然.</p>
<ol>
<li>$\cfrac{1}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{n+k}{n}z^k,n\in\mathbb{N}\\$,$\cfrac{z^n}{(1-z)^{n+1}}=\sum_{k\geq 0}\binom{k}{n}z^k,n\in\mathbb{N}\\$</li>
</ol>
<p>直接使用二项式定理展开$(1-z)^{-n-1}$,可以得到:</p>
<script type="math/tex; mode=display">
(1-z)^{-n-1}=\sum_{k\geq 0}(-1)^k\binom{-n-1}{k}z^k</script><p>反转上指标并使用对称恒等式得到上式.此外上式还有两个特殊形式:</p>
<script type="math/tex; mode=display">
\cfrac{1}{(1-z)^2}=\sum_{n\geq 0}(n+1)z^n\\\cfrac{z}{(1-z)^2}=\sum_{n\geq 0}nz^n</script><p>根据$(1)$求导即可得到此式.</p>
<ol>
<li>$e^z=\sum_{k\geq 0}\cfrac{z^k}{k!}\\$.</li>
<li>$\ln(\cfrac{1}{1-z})=\sum_{n\geq 1}\cfrac{1}{n}z^n$.</li>
<li>$\ln(1+z)=\sum_{k\geq 0}(-1)^k\cfrac{z^{k+1}}{k+1}\\$.</li>
</ol>
<p>可以使用积分或泰勒展开证明.</p>
<h3 id="阶乘的扩展定义"><a href="#阶乘的扩展定义" class="headerlink" title="阶乘的扩展定义"></a>阶乘的扩展定义</h3><p>对于复数的阶乘,我们通常定义:</p>
<script type="math/tex; mode=display">
\cfrac{1}{z!}=\lim_{n\rightarrow +\infin}\binom{n+z}{z}n^{-z}</script><p>同时我们定义$\Gamma(z+1)=z!$,有:$(-z)!\Gamma(z)=\cfrac{\pi}{\sin(\pi z)}$.</p>
<p>这样我们还可以定义广义阶乘幂:</p>
<script type="math/tex; mode=display">
z^{\underline{w}}=\cfrac{z!}{(z-w)!}\\
z^{\overline{w}}=\cfrac{\Gamma(z+w)}{\Gamma(z)}</script><p>通过以上我们还可以有二项式系数的定义:</p>
<script type="math/tex; mode=display">
\binom{z}{w}=\lim_{\zeta\rightarrow z,\omega\rightarrow w}\cfrac{\zeta!}{\omega!(\zeta-\omega)!}</script><h3 id="超几何级数"><a href="#超几何级数" class="headerlink" title="超几何级数"></a>超几何级数</h3><h4 id="超几何函数"><a href="#超几何函数" class="headerlink" title="超几何函数"></a>超几何函数</h4><p>我们定义超几何函数$F(a_1,…,a_m;b_1,…b_n;z)=F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>许多生成函数都可以写成超几何函数的形式.</p>
<p>值得一提的是,如果我们直接定义类似$\cfrac{0}{0}=1$之类的式子,可以发现当$z=0$时任意超几何函数总是$=1$.</p>
<p>值得一提的是,我们通常直接忽略超几何函数中的任何特殊情况,例如分母为$0$或者哪里出现了正无穷.如同生成函数中我们不关心式子带入一个数后是否收敛而只关心是否两边存在一种对应的转化.如果你想去探究超几何函数中的各种情况,那请去翻那本巨大的、黑糊糊的、作者默认你精通高等数学的、你在第五章看到的恒等式作者在第七章才给出证明的《具体数学》,而不是看我这个弱智写的笔记.笔者看这一段的时候已经被作者的”严谨”态度整疯了.该证明的一拖再拖不该证明的可以一句话带过的逼逼逼逼.仿佛这本书就是写给那些已经会了所有东西只是来使自己已经学会的东西更加体系化的以及拿来查阅各种恒等式的工具书.</p>
<h4 id="特殊的超几何函数"><a href="#特殊的超几何函数" class="headerlink" title="特殊的超几何函数"></a>特殊的超几何函数</h4><h5 id="合流超几何函数"><a href="#合流超几何函数" class="headerlink" title="合流超几何函数"></a>合流超几何函数</h5><p>我们通常把形如$M(a;b;z)=F\left(\begin{array}{r|}a\\b\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}}{b^{\overline{k}}k!}$的函数称为合流超几何函数.</p>
<p>不难发现我们有:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}1\\1\end{array}z\right)=e^z</script><p>也即常见生成函数中的$(6)$.</p>
<h5 id="高斯超几何函数"><a href="#高斯超几何函数" class="headerlink" title="高斯超几何函数"></a>高斯超几何函数</h5><p>我们把形如$F\left(\begin{array}{r|}a,b\\c\end{array}z\right)=\sum_{k\geq 0}\cfrac{z^ka^{\overline{k}}b^{\overline{k}}}{c^{\overline{k}}k!}$的函数称为高斯超几何函数.</p>
<p>下面是几种常见的高斯超几何函数形式:</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\1\end{array}z\right)=\cfrac{1}{1-z}$.</li>
</ol>
<p>即常见生成函数$(1)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}-a,1\\1\end{array}-z\right)=(1+z)^a$.</li>
</ol>
<p>即常见生成函数$(2)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}a,1\\1\end{array}z\right)=\cfrac{1}{(1-z)^a}$.</li>
</ol>
<p>即常见生成函数$(4)$.</p>
<ol>
<li>$F\left(\begin{array}{r|}1,1\\2\end{array}-z\right)=\cfrac {\ln(1+z)}z$.</li>
</ol>
<p>即常见生成函数$(7)$.</p>
<h4 id="超几何级数的应用"><a href="#超几何级数的应用" class="headerlink" title="超几何级数的应用"></a>超几何级数的应用</h4><p>我们先考虑改写超几何级数的形式:</p>
<p>$F\left(\begin{array}{r|}a_1,…,a_m\\b_1,…,b_n\end{array}z\right)=\sum_{k\geq 0}t_k,t_k=\cfrac{z^k\prod_{i=1}^ma_i^{\overline{k}}}{k!\prod_{i=1}^nb_i^{\overline{k}}}$.</p>
<p>不难发现$t_0=1$,而:</p>
<script type="math/tex; mode=display">
\cfrac{t_{k+1}}{t_k}=\cfrac{z^{k+1}}{z^k}\cfrac{k!}{(k+1)!}\cfrac{\prod_{i=1}^ma_i^{\overline{k+1}}}{\prod_{i=1}^ma_i^{\overline{k}}}\cfrac{\prod_{i=1}^nb_i^{\overline{k}}}{\prod_{i=1}^nb_i^{\overline{k+1}}}\\
=\cfrac{\prod_{i=1}^m(k+a_i)}{\prod_{i=1}^n(k+b_i)}\cfrac{z}{k+1}</script><p>换句话说,$\cfrac{t_{k+1}}{t_k}$是关于$k$的一个有理函数.而根据代数基本定理,任意$k$的有理函数在$\mathbb{C}$内都可以分解为以上的形式(如果缺少$k+1$项则需要上下同时乘以$k+1$以补上).</p>
<p>换句话说,对于一个无穷级数$\sum_{k\geq 0}t_k$,我们先将$\cfrac{t_{k+1}}{t_k}$表示回超几何函数,设为$F$.</p>
<p>那么有:$\sum_{k\geq 0}t_k=t_0F$.</p>
<p>好,接下来请把脑子扔了,不要纠结某一个公式按理来说只能作用于正整数而在这里直接将它套在了复数域上.你只需要知道数学家非常厉害通过扩展一些东西的定义(大部分是阶乘和$\Gamma$函数的定义)来使这些公式全部成立.But who cares,只要我们能用就行了.我又不是数竞人,这些麻烦的要死我直观上根本无法接受的定义交给数竞老哥证明得了.反正信竞更多依赖离散数学,大不了我们直接默认所有的数都是自然数.</p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>求证:$\sum_{k\leq n}\binom{r+k}{k}=\binom{r+n+1}{n}\Leftrightarrow F\left(\begin{array}{r|}1,-n\-n-r\end{array}1\right)=\cfrac{r+n+1}{r+1},n\in\mathbb{N}\\$.</p>
<p>首先考虑:</p>
<script type="math/tex; mode=display">
\sum_{k\leq n}\binom{r+k}{k}=\sum_{k\geq 0}\binom{r+n-k}{n-k}</script><p>有了这个无穷级数,我们可以直接将二项式系数用阶乘形式展开,于是得到:</p>
<script type="math/tex; mode=display">
\binom{r+n}{n}F\left(\begin{array}{r|}1,-n\\-n-r\end{array}1\right)=\binom{r+n+1}{n}</script><p>两边同时除以$\binom{r+n}{n}$得到上式.</p>
<h5 id="二项式系数与超几何函数"><a href="#二项式系数与超几何函数" class="headerlink" title="二项式系数与超几何函数"></a>二项式系数与超几何函数</h5><p>通过范德蒙德卷积,不难验证:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b\\c\end{array}1\right)=\cfrac{\Gamma(c-a-b)\Gamma(c)}{\Gamma(c-a)\Gamma(c-b)},-b\in\mathbb{N}</script><p>这个公式的一个特例是:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,-n\\c\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\
\sum_{k\geq 0}\cfrac{a^{\overline{k}}(-n)^{\overline{k}}}{c^{\overline{k}}k!}=\cfrac{(c-a)^{\overline{n}}}{c^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}}{(-c)^{\underline{n}}},n\in\mathbb{N}\\</script><p>这个公式几乎囊括了所有的基本二项式求和公式:上指标求和,平行求和,范德蒙德卷积……几乎只要是我们推出的由两个及以下项的乘积求和的二项式系数相关的式子都可以使用这个式子.</p>
<p>那么如果我们要三项相乘或更多,我们有Saalschütz恒等式:</p>
<script type="math/tex; mode=display">
F\left(\begin{array}{r|}a,b,-n\\c,a+b-n-c+1\end{array}1\right)=\cfrac{(c-a)^{\overline{n}}(c-b)^{\overline{n}}}{c^{\overline{n}}(c-a-b)^{\overline{n}}}=\cfrac{(a-c)^{\underline{n}}(b-c)^{\underline{n}}}{(-c)^{\underline{n}}(a+b-c)^{\overline{n}}},n\in\mathbb{N}\\</script><p>事实上,《具体数学》上给出了大量的超几何级数的应用以及各种技巧,但是笔者的智商已经理解不了接下来的内容了.考虑到大部分时候上述两个超几何级数恒等式已经足够解决绝大部分问题,如果考到更加困难的求和技巧,笔者相信别人也不会做,于是笔者决定摆烂.</p>
<h3 id="生成函数的应用"><a href="#生成函数的应用" class="headerlink" title="生成函数的应用"></a>生成函数的应用</h3><h4 id="求解递归关系"><a href="#求解递归关系" class="headerlink" title="求解递归关系"></a>求解递归关系</h4><p>我们假设已经有了$R(z)=\sum_{k\geq 0}g_kz^k$,并且$R(z)=\cfrac{P(z)}{Q(z)}$,其中$P(z)$和$Q(z)$都是多项式,我们想要找到一种方式求解$[z^n]R(z)$.</p>
<p>考虑有理函数$S(z)=\sum_{k=1}^m\cfrac{a_k}{1-\rho_kz}\\$,不难发现$[z^n]S(z)=\sum_{k=1}^ma_k\rho_k^n\\$.</p>
<p>那么可以证明,只要$Q(z)=0$无重根并且无零根,那么就存在一组系数满足$S(z)=R(z)$.</p>
<p>我们这么定义”反射”运算,若$Q(z)=\sum_{k=0}^mq_kz^k\\$,则其反射多项式为$Q^R(z)=\sum_{k=0}^mq_kz^{m-k}\\$.</p>
<p>若$Q(z)=q_0\prod_{k=1}^m(1-\rho_kz)$,则显然有$Q^R(z)=q_0\prod_{k=1}^m(z-\rho_k)\\$.</p>
<p>那么显然这里求出来的这组数$\rho$就是$S(z)$中的那组$\rho$.</p>
<p>而我们有$a_k=\cfrac{-\rho_kP(\cfrac{1}{\rho_k})}{Q’(\rho_k)}$.</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>已知$n!=\sum_{k}\binom{n}{k}g_{n-k},n\in\mathbb{N}\\$,求$g_n$.</p>
<p>首先两边同时除以$n!$并将组合数用阶乘形式展开,我们有:</p>
<script type="math/tex; mode=display">
1=\sum_{k}\cfrac{g_{n-k}}{k!(n-k)!}.</script><p>如果我们令$D(z)=\sum_{k\geq 0}\cfrac{g_{k}}{k!}z^k$,则有:</p>
<script type="math/tex; mode=display">
\cfrac{1}{1-z}=e^zD(z)\\
D(z)=\cfrac{1}{1-z}e^{-z}\\
D(z)=(\sum_{k\geq 0}z^k)(\sum_{k\geq 0}(-1)^k\cfrac{z^k}{k!})\\
[z^n]D(z)=\sum_{k=0}^n\cfrac{(-1)^k}{k!}</script><p>于是$g_n=n!\sum_{k=0}^n\cfrac{(-1)^k}{k!}\\$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" data-id="cl81lbtuo0008zovtd4lqgtnm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/09/03/%E6%95%B4%E5%80%BC%E5%87%BD%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/08/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/OI/" rel="tag">OI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/OI/" style="font-size: 10px;">OI</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">数学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/13/%E6%95%B0%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/03/%E9%80%92%E5%BD%92%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/03/%E6%95%B4%E5%80%BC%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/08/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 LWLAymh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>