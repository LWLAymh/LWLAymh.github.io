<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LWLAymh的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一些性质 唯一分解定理（算术基本定理）：任何大于1的正整数都可以唯一分解为几个质数的乘积\\ 素数有无限多个\\ {\lim_{n\rightarrow+\infty}\cfrac{\pi(n)\times \ln n}{n}}&#x3D;1，\pi(n)为[1,n]之间的质数个数\\ 切比雪夫定理:若n&gt;1，\exist p\in prime,p\in(n,2n)\\\\ \sum_{1\leq p\le">
<meta property="og:type" content="article">
<meta property="og:title" content="LWLAymh的博客">
<meta property="og:url" content="http://lwlaymh.github.io/2022/03/09/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="LWLAymh的博客">
<meta property="og:description" content="一些性质 唯一分解定理（算术基本定理）：任何大于1的正整数都可以唯一分解为几个质数的乘积\\ 素数有无限多个\\ {\lim_{n\rightarrow+\infty}\cfrac{\pi(n)\times \ln n}{n}}&#x3D;1，\pi(n)为[1,n]之间的质数个数\\ 切比雪夫定理:若n&gt;1，\exist p\in prime,p\in(n,2n)\\\\ \sum_{1\leq p\le">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-09T10:28:26.919Z">
<meta property="article:modified_time" content="2022-03-09T06:36:28.984Z">
<meta property="article:author" content="LWLAymh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LWLAymh的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LWLAymh的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://LWLAymh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数论基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/09/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2022-03-09T10:28:26.919Z" itemprop="datePublished">2022-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><script type="math/tex; mode=display">
唯一分解定理（算术基本定理）：任何大于1的正整数都可以唯一分解为几个质数的乘积\\
素数有无限多个\\
{\lim_{n\rightarrow+\infty}\cfrac{\pi(n)\times \ln n}{n}}=1，\pi(n)为[1,n]之间的质数个数\\
切比雪夫定理:若n>1，\exist p\in prime,p\in(n,2n)\\\\
\sum_{1\leq p\leq n且p\in prime}\cfrac{1}{p}\approx \log\log n，证明如下\\
\sum_{1\leq p\leq n且p\in prime}\cfrac{1}{p}=\sum^n_{k=1}\cfrac{\pi(k)-\pi(k-1)}{k}=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^n_{k=1}\cfrac{\pi(k-1)}{k}\\
=\sum^n_{k=1}\cfrac{\pi(k)}{k}-\sum^{n-1}_{k=0}\cfrac{\pi(k)}{k+1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k}+\cfrac{\pi(n)}{n}-\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k+1}+\cfrac{\pi(0)}{1}\\
=\sum^{n-1}_{k=1}\cfrac{\pi(k)}{k(k+1)}+\cfrac{\pi(n)}{n}\\
= \sum^{n-1}_{k=1}{(\cfrac{1}{k\log k})}+O(1)= O(\log \log n)+O(1)</script><script type="math/tex; mode=display">
欧几里得引理：\\
若p|ab,则p|a或p|b\\
若a|bc且a\perp b则a|c\\
若a|c,b|c且a\perp b,则ab|c\\
\\
\gcd(a,b)=\gcd(a-b,b)=\gcd(a\mod b,b)\\
\gcd(a,b)\times lcm(a,b)=ab\\
\\
若a\equiv b(\mod m)且a\equiv b(\mod n)，则a\equiv b(\mod lcm(n,m))\\
若\gcd(k,m)=d且ka\equiv kb(\mod m)，则a\equiv b(\mod \cfrac{m}{d})</script><h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><script type="math/tex; mode=display">
(p-1)!\equiv \begin{cases}
-1(\mod p)&p\in prime\\
2(\mod p)&p=4\\
0(\mod p)&other
\end{cases}\\
证明：\\
当p为质数时，考虑对于a和b=a^{-1}(\mod p)，若a=b，此时可证明a=1或p-1\\
如果a\ne b那么一定可以在[1,p-1]找到一对，相乘为1\\
（若a_1\ne a_2，那么a_1^{-1}\ne a_2^{-1}）\\
若p不是质数，则设p=ab，当a\ne b时，由于a,b\leq p，因此(p-1)!一定是p的倍数\\
若a=b，除非p=4，不然一定能在[1,p-1]里找到a和2a，此时(p-1)!也是p的倍数</script><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><script type="math/tex; mode=display">
\forall a,b,m\in\mathbb{Z}，则\exists x,y\in \mathbb{Z}满足ax+by=m，当且仅当\gcd(a,b)|m\\证明如下\\
若a=0或b=0，显然成立\\
不然，设集合A=\{xa+yb|x,y\in\mathbb{Z}\}中的最小正元素d_0=x_0a+y_0b\\（由于该集合中一定有正元素\\
考虑任意d=x_1a+y_1b\in A，设p=qd_0+r，其中0\leq r<d_0\\
可以发现r=p-qd_0=ax_1+by_1-qax_0-qby_0\\=a(x_1-qx_0)+b(y_1-qy_0)，发现r\in A\\
由于d_0是A中最小的正元素，所以r=0，所以p=qd_0\\
由于p可以=a也可以=b，所以d_0|a且d_0|b\\
又因为对于一个数d_1|a且d_1|b\\
则a=k_1d_1，b=k_2d_1,d_0=(x_0k_1+y_0k_2)d_1\\
由于d_0和d_1都是正整数，所以可得到d_1是d_0的约数\\
也就是说d_0=\gcd(a,b)，则原方程化为h_1d_0x+h_2d_0y=m\\
由于x和y都是整数，所以若\gcd(a,b)\nmid m，也就是d_0\nmid m，原方程定无解\\
不然，考虑刚才的过程中的q，显然可以取任意整数，因而必定有解</script><h3 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h3><script type="math/tex; mode=display">
要求\sum^n_{i=0}\lfloor\cfrac{ai+b}{c}\rfloor\\
若c\leq a，原式化为\sum^n_{i=0}{i\times\lfloor\cfrac{(a-c)i+b}{c}\rfloor}\\
若c\leq b，原式化为\sum^n_{i=0}{\lfloor\cfrac{b}{c}\rfloor+\lfloor\cfrac{ai+(b\mod c)}{c}\rfloor}\\
考虑a,b<c的情况，设m=\lfloor\cfrac{an+b}{c}\rfloor，原式化为\sum^n_{i=0}\sum^m_{j=1}[j\leq \lfloor\cfrac{ai+b}{c}\rfloor]\\
=\sum^n_{i=0}\sum^m_{j=1}[cj\leq ai+b]=nm-\sum^n_{i=0}\sum^m_{j=1}[ai\leq cj-b-1]=nm-\sum^m_{i=1}\lfloor\cfrac{ci-b-1}{a}\rfloor</script><h3 id="一种预处理最大公约数的算法"><a href="#一种预处理最大公约数的算法" class="headerlink" title="一种预处理最大公约数的算法"></a>一种预处理最大公约数的算法</h3><script type="math/tex; mode=display">
存在一种O(n)预处理，O(1)求任意两个小于等于n的数的gcd的方法\\
引理：\\
对于任意整数n=abc，那么abc三个数要么是质数，要么\leq \sqrt n\\
证明：\\
如果n存在一个大于等于\sqrt n的质因子，显然成立\\
否则，使用数学归纳，我们考虑n的最小质因子为p，设\frac n p=xyz\\
不妨设x\leq y\leq z\\
如果x=1，显然成立。
不然有p\leq x\leq y\leq z\\
而pxyz=n，那么p^4\leq n\\
p\leq n^{\frac 1 4}\\
现在我们想要证明不存在xp>\sqrt n，yp>\sqrt n，zp>\sqrt n\\
如果存在，我们有xyzp^3>n^{\frac 3 2}\\
np^2>n^{\frac 3 2}\\
p^2>\sqrt n\\
p>n^{\frac 1 4}，与我们前面的结论不符合\\
因而该引理一定成立，并且给出了O(n)预处理所有数abc的方法\\
接下来，设m=\sqrt n，考虑使用O(n)的时间求出每个小于等于m的数对的gcd\\
接下来，如果我们要求\gcd(x,y)，设x=abc\\
显然\gcd(x,y)=\gcd(a,y)\times\gcd(b,\frac{y}{\gcd(a,y)})\times\gcd(c,\frac{y}{\gcd(ab,y)})\\
如果a是质数，只需要判断a是否整除y\\
否则\gcd(a,y)=\gcd(y\mod a,a)，因为a\leq \sqrt n，因而可以直接查表</script><h3 id="exGCD"><a href="#exGCD" class="headerlink" title="exGCD"></a>exGCD</h3><script type="math/tex; mode=display">
求ax+by=\gcd(a,b)的一组特解\\
首先有
\left[\begin{matrix}
a\\
b
\end{matrix}\right]
=\left[\begin{matrix}
a\\
b
\end{matrix}\right]\\
令q=\lfloor\frac a b\rfloor\\
那么我们有
\left[\begin{matrix}
0&1\\
1&-q
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
b\\
a\mod b
\end{matrix}\right]\\
同样我们可以得到：\\
\left[\begin{matrix}
x_1&y_1\\
x_2&y_2
\end{matrix}\right]
\left[\begin{matrix}
a\\
b
\end{matrix}\right]=
\left[\begin{matrix}
\gcd(a,b)\\
0
\end{matrix}\right]\\
即ax_1+by_1=\gcd(a,b)\\
(x_1,y_1)就是一组特解\\</script><h3 id="Miller-Rabin算法"><a href="#Miller-Rabin算法" class="headerlink" title="Miller-Rabin算法"></a>Miller-Rabin算法</h3><script type="math/tex; mode=display">
如果判断n是否是质数，取a<n，设n-1=d\times2^r\\
则要么a^d\equiv 1(\mod n)\\
要么\exists i，使得0\leq i<r，a^{d\times 2^i}\equiv -1(\mod n)\\
若一个都不满足，则n一定不是质数，不然可能是质数\\
但是若取足够多的不同的a（如果选m个），那么n是质数的可能性更大\\
此为Miller-Rabin算法，复杂度O(m\times log_2n)，不保证正确性\\
其中a通常取质数，原因不详\\
（事实上，如果a取前八个小质数，在2^{64}内是不会出错的）</script><h3 id="Pollard-Rho算法"><a href="#Pollard-Rho算法" class="headerlink" title="Pollard-Rho算法"></a>Pollard-Rho算法</h3><script type="math/tex; mode=display">
对n做质因数分解，若能找到a使得a|n，则考虑对\cfrac{n}{a}和a分别进行质因数分解\\
考虑随机a，若n有m个因数，那么显然随机到a使得a|n的概率为\cfrac{m}{n}，显然不太优秀\\
考虑改变随机策略，我们考虑随机一个a使得\gcd(a,n)\ne 1，那么\gcd(a,n)就是n的一个因子\\
这种情况下，随机的概率是\cfrac{\varphi(n)}{n}，仍然很不优秀\\
考虑使用生日悖论优化，随机k个数a，两两匹配得到k^2个值，这些值全都不整除n的概率可以用生日悖论来计算\\
当k=10\sqrt{n}时，错误的概率会很小，但是复杂度仍然很高，无法接受\\
考虑构造a_i=[(a_{i-1})^2+b]\mod n\\
考虑该数列的性值，当b确定时，a一定有循环节\\
显然当x|(a_i-a_j)，则x|[(a_i-a_j)\times(a_i+a_j)-b+b]，x|(a_{i+1}-a_{j+1})\\
因此，我们可以利用floyd判环法（双指针法）找出循环节\\
并且在这个过程中，我们可以预处理出大量的a_{i+len}-a_i\\
复杂度极其玄学，但是实际应用中不差</script><h3 id="欧拉函数与欧拉定理"><a href="#欧拉函数与欧拉定理" class="headerlink" title="欧拉函数与欧拉定理"></a>欧拉函数与欧拉定理</h3><script type="math/tex; mode=display">
定义欧拉函数\varphi(m)为所有满足1\leq n\leq m且n\perp m的n个数\\
\varphi是积性函数\\
若n=\prod^{k}_{i=1}p_i^{a_i}，则\varphi(n)=\prod^k_{i=1}\varphi(p_i^{a_i})=\prod^k_{i=1}{p_i^{a_i}-p_i^{a_i-1}}=\prod^k_{i=1}{p^{a_i-1}(p_i-1)}\\
考虑改变枚举方式，则n=\prod_{p|n}p^{a_p}\\
则\varphi(n)=\prod_{p|n}{p^{a_p-1}(p-1)}=\prod_{p|n}{(p^{a_p}\times \cfrac{p-1}{p})}=n\times\prod_{p|n}\cfrac{p-1}{p}
\\
欧拉定理：\\
当a\perp m时，a^{\varphi(m)}\equiv 1(\mod m)\\</script><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><script type="math/tex; mode=display">
扩展欧拉定理：\\
a^b\equiv a^c(\mod m)\\

其中c=
\begin{cases}
b\mod \varphi(m) &a\perp m\\
b &b<\varphi(m)\\
b\mod \varphi(m)+\varphi(m) &other
\end{cases}\\
证明如下：\\
设m=\prod^k_{i=1}p_i^{e_i}\\
则要证a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod m)\\
即证\forall i都有a^b\equiv a^{(b\mod \varphi(m))+\varphi(m)}(\mod p_i^{e_i})\\
分情况讨论，若p_i^{e_i}\perp a，则为普通欧拉定理情况，即证明b-c是\varphi(p_i^{e_i})的因数\\
由于\varphi(p_i^{e_i})是\varphi(m)的因数，而\varphi(m)是b-c的因数，显然得证\\
不然，发现a_i\leq\varphi(p_i^{e_i})\leq\varphi(m)\leq b且\varphi(m)\leq c\\
又发现p_i^{e_i}|a^{e_i}，所以p_i^{e_i}|a^b，p_i^{e_i}|a^c，左右两边均为0，得证</script><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><script type="math/tex; mode=display">
欧拉定理求逆元：\\
a^{\varphi(p)}\equiv 1(\mod p)，则有a^{-1}\equiv a^{\varphi(p)-1}(\mod p)\\
\\
线性求膜p意义下逆元：\\
考虑1\leq i\leq n，设p=ki+r，则有ki+r\equiv 0(\mod p)，则有kr^{-1}+i^{-1}\equiv 0(\mod p)\\
于是有i^{-1}\equiv -kr^{-1}(\mod p)，即i^{-1}\equiv -\lfloor\cfrac{p}{i}\rfloor\times r^{-1}(\mod p)\\</script><h3 id="原根和阶"><a href="#原根和阶" class="headerlink" title="原根和阶"></a>原根和阶</h3><script type="math/tex; mode=display">
阶：找到一个最小的k使得a^k\equiv1(\mod p)，则称k是a在膜p意义下的阶\\
原根：如果a在膜p意义下的阶是p且a<p，则称a是p的一个原根\\
若m有原根，则m一定是2,4或是p^a，2p^a，其中p\in prime且2\nmid p\\
由于对于大部分m来说，都存在一个很小的原根，所以在实际应用中只需要暴力找就可以了\\
根据阶的定义，我们如果要判断一个a不是p的原根，只需判断是否\exists i使得a^i\equiv 1(\mod p)\\
而由于a^{\varphi(p)}\equiv 1(\mod p)，因此一定有i|\varphi(p)，因此只需判断\varphi(p)的所有因数，复杂度O(\sqrt{\varphi(p)})\\
\\
Problem1：给定k，p，a，求x^k\equiv a(\mod p)的所有解，其中p\in prime，1\leq k \leq 10^5\\
\\
解：考虑求出p的原根g，得到g^r\equiv a(\mod p)，同时由于x\equiv g^y(\mod p)，因此原方程变为：\\
g^{yk}\equiv g^r(\mod p)
于是有：yk\equiv r(\mod p-1)，即可求解</script><h3 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h3><script type="math/tex; mode=display">
求a^x\equiv b(\mod p)的一组解，其中p\in prime且1\leq p\leq 10^9\\
直接枚举显然是O(p)的，非常不合理，考虑如何优化\\
求出s=\lfloor\sqrt{p}\rfloor，并求出所有a^i，其中i\in [0,s-1]\\
若x\leq s-1，则可以直接判断是否被求出来过\\
否则，则将x=x\mod (s-1)，一直操作直到x\leq s-1\\</script><h3 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h3><script type="math/tex; mode=display">
求a^x\equiv b(\mod p)的一组解，其中1\leq p\leq 10^9\\
设g=\gcd(a,p)，那么根据膜的性质，原方程即\frac {a^x} g\equiv \frac b g (\mod \frac p g)\\
显然若g\nmid b并且b\ne 1，方程定无解\\
（若b=1，那么x=0就是一个解）\\
那么现在的方程就是a^{x-1}\frac a g\equiv \frac b g(\mod \frac p g)\\
继续进行这个过程，不断求a和当前模数的gcd，并将当前模数除以该gcd，这样最后我们得到了方程：\\
a^{x-k}\prod_{i=1}^k \frac a {g_i}\equiv \frac b {\prod_{i=1}^k g_i}(\mod \frac p {\prod_{i=1}^k g_i})\\
不妨设A=\prod_{i=1}^k \frac a {g_i},B=\frac b {\prod_{i=1}^k g_i},P=\frac p {\prod_{i=1}^k g_i}\\
那么现在方程就是a^{x-k}\equiv \frac B A(\mod p)\\
可以使用BSGS求解\\
ps：\\
p=1的时候要特判\\</script><h3 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h3><script type="math/tex; mode=display">
对于方程组x\equiv a_i(\mod m_i)，其中m_i两两互质时\\
令m=\prod^k_{i=1}m_i，设M_i=\cfrac{m}{m_i}，N_i是M_i在\mod m_i意义下逆元\\
则x\equiv \sum^k_{i=1}M_iN_ia_i(\mod m)\\
中国剩余定理的证明类似拉格朗日插值\\
由于x在\mod m_i意义下，\sum中枚举的所有不等于i的项都会成0，等于i的项会成a_i</script><h3 id="exCRT"><a href="#exCRT" class="headerlink" title="exCRT"></a>exCRT</h3><script type="math/tex; mode=display">
对于方程组x\equiv a_i(\mod m_i)，若m_i两两不互质\\
我们考虑每次合并两个方程
\begin{cases}
x\equiv a_1(\mod m_1)\\
x\equiv a_2(\mod m_2)
\end{cases}\\
那这个方程组等价于
\begin{cases}
x=k_1m_1+a_1\\
x=k_2m_2+a_2
\end{cases}\\
合并上下方程，有k_1m_1+a_1=k_2m_2+a_2\\
a_2-a_1=k_1m_1-k_2m_2\\
设g=\gcd(m_1,m_2)，显然若g\nmid (a_2-a_1)，方程无解\\
不然，\frac {a_2-a_1}g=k_1\frac {m_1}{g}-k_2\frac{m_2}{g}\\
k_1\frac{m_1}{g}=k_2\frac {m_2}g+\frac {a_2-a_1}g\\
k_1\frac{m_1}g\equiv \frac {a_2-a_1}{g}(\mod \frac {m_2}g)\\
令inv(a,p)表示a在\mod p意义下的逆元\\
k_1\equiv inv(\frac {m_1}{g},\frac {m_2}g)\frac{a_2-a_1}{g}(\mod \frac {m_2}g)\\
k_1=inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g\\
带回第一个方程\\
x=m_1(inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+k_3\frac{m_2}g)+a_1\\
x\equiv m_1inv(\frac{m_1}g,\frac{m_2}g)\frac{a_2-a_1}g+a_1(\mod \frac{m_1m_2}g)</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://lwlaymh.github.io/2022/03/09/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/" data-id="cl0jf7ecn0003d0vtdev15b1d" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/09/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/03/09/%E7%AD%9B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/09/%E5%8F%8D%E6%BC%94/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF%E4%B8%8E%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/09/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 LWLAymh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>